<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fgyong的技术博客</title>
  
  <subtitle>不忘初心 方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fgyong.cn/"/>
  <updated>2020-09-04T04:40:21.665Z</updated>
  <id>http://fgyong.cn/</id>
  
  <author>
    <name>fgyong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS 一款自动上传图床的APP</title>
    <link href="http://fgyong.cn/2019/12/24/macOS%20AUY%E4%B8%80%E6%AC%BE%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85%E6%9F%90%E7%A6%8F%E5%88%A9%E7%9A%84APP/"/>
    <id>http://fgyong.cn/2019/12/24/macOS%20AUY%E4%B8%80%E6%AC%BE%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85%E6%9F%90%E7%A6%8F%E5%88%A9%E7%9A%84APP/</id>
    <published>2019-12-24T03:15:58.000Z</published>
    <updated>2020-09-04T04:40:21.665Z</updated>
    
    <content type="html"><![CDATA[<p>macOS开发和iOS有很多相关之处，也有很多不同之处，今天带你使用最优雅的<code>APP.dmg</code>,一款名叫<code>AUY</code>的自动上传图床的APP，没有服务器，不担心数据被盗，可以上传剪切板中的图片，可以拖动文件上传、智能的APP。</p><h2 id="AUY-传送门"><a href="#AUY-传送门" class="headerlink" title="AUY 传送门"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvQVVZL3JlbGVhc2Vz" title="https://github.com/ifgyong/AUY/releases">AUY 传送门<i class="fa fa-external-link"></i></span></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>更少的操作步骤完成目标。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;macOS开发和iOS有很多相关之处，也有很多不同之处，今天带你使用最优雅的&lt;code&gt;APP.dmg&lt;/code&gt;,一款名叫&lt;code&gt;AUY&lt;/code&gt;的自动上传图床的APP，没有服务器，不担心数据被盗，可以上传剪切板中的图片，可以拖动文件上传、智能的APP。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="macOS" scheme="http://fgyong.cn/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://fgyong.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>APP 资源管理优化</title>
    <link href="http://fgyong.cn/2019/12/05/APP%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <id>http://fgyong.cn/2019/12/05/APP%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</id>
    <published>2019-12-05T03:15:58.000Z</published>
    <updated>2020-09-04T04:40:21.650Z</updated>
    
    <content type="html"><![CDATA[<p>在APP中，使用 X1、X2、X3已经是司空见惯的事情了，网上出了清空不再使用的图片和类，是不是做完这些不能再进一步优化了，答案是否定的，当然可以的，今天再探究一下资源管理优化。</p><p>资源大部分是图片，说到图片必须讲一下位图和矢量图</p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><blockquote><p>位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。</p></blockquote><h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h3><blockquote><p>矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。<br>矢量图是根据几何特性来绘制图形，矢量可以是一个点或一条线，矢量图只能靠软件生成，文件占用内在空间较小，因为这种类型的图像文件包含独立的分离图像，可以自由无限制的重新组合。</p></blockquote><h3 id="说人话"><a href="#说人话" class="headerlink" title="说人话"></a>说人话</h3><blockquote><p>位图就是无数个点组成的图片，基本元素是像素；矢量图有多个图形组成的，基本元素是图像。当相同尺寸的位图和矢量图绘制在大屏幕上，位图的弊端出现了，图像看着像素颗粒很大，而矢量图基本效果还是很好的。</p></blockquote><p>矢量图在绘制到不同的屏幕上有着天然的优势。</p><h2 id="开始使用矢量图"><a href="#开始使用矢量图" class="headerlink" title="开始使用矢量图"></a>开始使用矢量图</h2><p>在Xcdoe 9、iOS11 中已经开始支持了矢量图，只需要设置打钩<code>Preserve Cector Dadta</code>。<br><img src="http://blog.fgyong.cn/FhF6-GTsthDXMlsX9ezQ1PaXalIa.png-a" alt></p><p><strong>前提图片格式是矢量图哦</strong></p><p>矢量图在资源大小中相比和一倍、两倍、三倍图总和，大小下降<strong>60%</strong>，这算是不错的提升了。</p><h2 id="Stretchable-Images"><a href="#Stretchable-Images" class="headerlink" title="Stretchable Images"></a>Stretchable Images</h2><p>从iOS11、Xcode 9就开始支持了该工具，该工具可实现在<code>building</code>中将图片元数据格栅化，儿不是在运行时处理，降低图片在显示时候的CPU压力。<br>当渲染的尺寸大于当前的尺寸的时候才会重新渲染，否则使用优化过的预渲染位图。<br>效果是这样子的</p><p><img src="http://blog.fgyong.cn/FpZhgVvqS711QZZnYYptKr40Pc9U-a" alt></p><h4 id="Slicing"><a href="#Slicing" class="headerlink" title="Slicing"></a>Slicing</h4><h5 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h5><ul><li>None 无</li><li>Horizontal 水平</li><li>Vertical 竖直</li><li>Horizontal and Vertical 水平和竖直 </li></ul><h5 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h5><ul><li>Tiles 平铺</li><li>Streches 拉伸</li></ul><p>使用这两组参数可以达到绝大部分需求了</p><p><img src="http://blog.fgyong.cn/FrtLZrygVGyJAqlV6Q412foMQgRk-a" alt></p><p>当我们使用下图这种图片，提前和UI讲清楚，作出一个小图，在设备上使用<code>Stretchable Images</code>功能，可以达到大图的效果。</p><p><img src="http://blog.fgyong.cn/FvHCZgiiwONF_5Y01HOVP_-d9d3_-a" alt><br>白色部分表示可拉伸和舍弃的<br><img src="http://blog.fgyong.cn/Fh6BK-44VNuB2PDdQUjaA-2iOF_J-a" alt></p><p>最终效果是这样的</p><p><img src="http://blog.fgyong.cn/1.mp4" alt></p><p>👏👏👏👏</p><p>更多用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE4LzIyNw==" title="https://developer.apple.com/videos/play/wwdc2018/227">WWDC2018/227<i class="fa fa-external-link"></i></span></p><h2 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h2><p>大项目可能会有很多框架，当多个框架使用的图片名字发生重复时，使用<code>Bundle</code>是不错的选择，<code>Bundle</code>相当于文件夹，相同<code>Bundle</code>下边没有重复的文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the app&#39;s main bundle</span><br><span class="line">let mainBundle &#x3D; Bundle.main</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取本地Bundle 图片</span><br><span class="line">let me &#x3D; Bundle.init(identifier: &quot;me&quot;)</span><br><span class="line">let path &#x3D; me?.path(forResource: &quot;fgyong.cn 技术博客&quot;, ofType: &quot;png&quot;)</span><br></pre></td></tr></table></figure><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>当APP有50个类似的功能，但是每个功能都用类似的图片，那么他们名字也一致，我们使用<code>Namespace</code>来解决这个问题。<br><img src="http://blog.fgyong.cn/FqvcOJHbjHBdE04jl78PlT3pAA4l-a" alt></p><p>使用起来也是很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let image &#x3D; UIImage(named: &quot;me&#x2F;4.png&quot;)</span><br></pre></td></tr></table></figure><h2 id="APP-Thining"><a href="#APP-Thining" class="headerlink" title="APP Thining"></a>APP Thining</h2><h3 id="Memory-Classes-amp-amp-Graphics-Classes"><a href="#Memory-Classes-amp-amp-Graphics-Classes" class="headerlink" title="Memory Classes &amp;&amp; Graphics Classes"></a>Memory Classes &amp;&amp; Graphics Classes</h3><p>使用内存和Metal来适配不同机型，达到最优性能。</p><p><img src="http://blog.fgyong.cn/FgJGgpqcA-K_kSKY6e9LDZapOiYT-a" alt></p><p>首先机型先去找4GB的资源，4GB没找到，则向下寻找3GB，一直寻找到1GB对应的资源。</p><p>内存和GPU相比，内存有着更高的优先级，我们确定内存是表现设备整体性能的标准。</p><h2 id="NSSData-set"><a href="#NSSData-set" class="headerlink" title="NSSData set"></a>NSSData set</h2><p><code>Data set</code>容器可以放任何东西。<br>可以是<code>plist</code>文件，可以是<code>video</code>、可以是<code>mp3</code>，可以是其他任何格式的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class func preloadTextureAtlasesNamed(_ atlasNames: [String], withCompletionHandler completionHandler: @escaping (Error?, [SKTextureAtlas]) -&gt; Void)</span><br></pre></td></tr></table></figure><p>使用该函数立刻调用大量I/O和内存来解码或读入数据，预先放在内存中，你需要在紧急需要的时候调用该函数。不要随意调用该API，以为它会按照你说的<strong>立马</strong>去做！⚠️⚠️⚠️当你调用该函数，请确保立即使用资源，否则API会消耗大量的I/O和内存来加载所有这些图像。</p><p><code>Sprite Atlases</code>强大之处是会根据不同设备和屏幕来渲染不同的图像，并传送到正确的设备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://blog.fgyong.cn/Fld0tbjb_RgbF9QWnzTXUYrZJzhG-a" alt></p><ul><li>在iOS12上采用最新的算法，这些图像资源会减少10%-20%的空间，</li><li>使用Xcode的资源目录是不错的选择</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在APP中，使用 X1、X2、X3已经是司空见惯的事情了，网上出了清空不再使用的图片和类，是不是做完这些不能再进一步优化了，答案是否定的，当然可以的，今天再探究一下资源管理优化。&lt;/p&gt;
&lt;p&gt;资源大部分是图片，说到图片必须讲一下位图和矢量图&lt;/p&gt;
&lt;h3 id=&quot;位图&quot;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS优化" scheme="http://fgyong.cn/tags/iOS%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片优化</title>
    <link href="http://fgyong.cn/2019/12/03/iOS%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%20/"/>
    <id>http://fgyong.cn/2019/12/03/iOS%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%20/</id>
    <published>2019-12-03T03:15:58.000Z</published>
    <updated>2020-09-04T04:40:21.656Z</updated>
    
    <content type="html"><![CDATA[<p>基于现在iOS11新生成的图片都是<code>HEIF</code>，该图片使用<code>[UIImage image:name]</code>已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。</p><p>既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?</p><p>这就要先了解该图片的编码了。</p><h2 id="HEIC-HEIF"><a href="#HEIC-HEIF" class="headerlink" title="HEIC HEIF"></a>HEIC HEIF</h2><blockquote><p>带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件</p></blockquote><p><code>heic</code>和<code>heif</code>是广色域图片的格式，广色域比<code>sRGB</code>表示范围大25%，在广色域设备中能显示更广的色彩，<code>sRGB 8bit/dept</code>，广色域达到<code>16bit/dept</code>。广色域只是在硬件支持的情况下才能显示的。<br>其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载<code>image</code>，只是把<strong>文件信息</strong>加载到内存中，下一步就是解码。在代码中体现就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let image &#x3D; UIImage(contentsOfFile: url.path)</span><br><span class="line">或 加载图片到内存 会常驻内存</span><br><span class="line">let image &#x3D; UIImage(named: name)!</span><br></pre></td></tr></table></figure></p><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>其实是发生在添加到要显示的view上面才会解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let imageV &#x3D; UIImageView.init(image: image)</span><br><span class="line">imageV.frame &#x3D; CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)</span><br><span class="line">self.view.addSubview(imageV)</span><br></pre></td></tr></table></figure><br>最后一行不写，则不会解码。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>当<code>view</code>显示出来则是渲染。过程是解码的<code>data buffer</code> 复制到<code>frame buffer</code>,硬件从帧缓冲区读取数据显示到屏幕上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.view.addSubview(imageV)</span><br></pre></td></tr></table></figure></p><h2 id="内存暴涨原因"><a href="#内存暴涨原因" class="headerlink" title="内存暴涨原因"></a>内存暴涨原因</h2><p>一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。</p><p>首先有请我们准备的素材和设备(6s 64g版本)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:jpg</span><br><span class="line">20M 12000*12000</span><br><span class="line"></span><br><span class="line">B:jpg</span><br><span class="line">2.8M 3024*4032</span><br><span class="line"></span><br><span class="line">C:HEIC</span><br><span class="line">1.8M 3024*4032</span><br></pre></td></tr></table></figure><br>素材A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.8M</span><br><span class="line">加载Image: 240.3M之后稳定到220M</span><br><span class="line">CPU：峰值5%，随后降低到0%</span><br><span class="line">image占内存：226.5M</span><br></pre></td></tr></table></figure></p><p>素材B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.7M</span><br><span class="line">加载Image: 31.5</span><br><span class="line">CPU：峰值5%，随后降低到0%</span><br><span class="line">image占内存：17.8M</span><br></pre></td></tr></table></figure></p><p>素材C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.8M</span><br><span class="line">加载Image: 32.3</span><br><span class="line">CPU：峰值4%，随后降低到0%</span><br><span class="line">image占内存：18.5M</span><br></pre></td></tr></table></figure></p><p>我们猜测是否是<code>imageView</code>的大小影响内存的呢？<br><code>size</code>改为原来的1/10结果运行内存还是和以前一样。</p><p>为什么呢？</p><blockquote><p>内存大小不是取决于<code>view</code>的<code>size</code>，而是原始文件<strong>image size</strong>。</p></blockquote><p><img src="/images/14-1.png" alt></p><h3 id="渲染格式"><a href="#渲染格式" class="headerlink" title="渲染格式"></a>渲染格式</h3><h4 id="SRGB"><a href="#SRGB" class="headerlink" title="SRGB"></a>SRGB</h4><p>每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。</p><h4 id="display-p3-宽色域"><a href="#display-p3-宽色域" class="headerlink" title="display p3 宽色域"></a>display p3 宽色域</h4><p>每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。</p><h4 id="亮度和透明度"><a href="#亮度和透明度" class="headerlink" title="亮度和透明度"></a>亮度和透明度</h4><p>每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。</p><h4 id="Alpha-8-Format"><a href="#Alpha-8-Format" class="headerlink" title="Alpha 8 Format"></a>Alpha 8 Format</h4><p>每个像素1字节，用来表示透明度，一般用作蒙版和文字。<br>相比sRGB容量小了75%，详细 宽色域 容量小了87.5%</p><h3 id="渲染图片大小计算"><a href="#渲染图片大小计算" class="headerlink" title="渲染图片大小计算"></a>渲染图片大小计算</h3><p>图片大小 = 图片格式容量 <em> 像素个数<br>当我们把大小是20\</em>20使用<code>Alpha 8 format</code>渲染到20*20的view上面，和40*40的image使用<code>p3</code>渲染到20*20的view中，后着占用内存是前者的8倍。</p><p>使用sRGB色域进行渲染所占用的大小为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageWidth*imageHeight*4 字节</span><br></pre></td></tr></table></figure><br>每个像素占用了4字节，每个字节8位，</p><p>使用<code>display p3</code>则每个通道占用16位，那么占用内存大小是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageWidth*imageHeight*8 字节</span><br></pre></td></tr></table></figure></p><h3 id="如何选择正确的图片格式"><a href="#如何选择正确的图片格式" class="headerlink" title="如何选择正确的图片格式"></a>如何选择正确的图片格式</h3><blockquote><p>不要主动选择图片格式，让格式选择你。</p></blockquote><p>不要再使用<code>UIGraphicsBeginImageContextWithOptions</code>,该方法总是使用sRGB格式，你想节约内存是不行的，在支持<code>p3</code>的设备上想绘制出来<code>p3</code>色域的图片也是不行的。那么使用<code>UIGraphicsImageRenderer</code>系统可以自动为你选择格式，如果绘制<code>image</code>，自己再添加单色蒙版，是不需要另外单独分配内存的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if let im &#x3D; imageV &#123;</span><br><span class="line">&#x2F;&#x2F;第二次添加蒙版</span><br><span class="line">im.tintColor &#x3D; UIColor.black</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F;绘制一个红色矩形</span><br><span class="line">let bounds &#x3D; CGRect(x: 0, y: 0, width: width, height: height)</span><br><span class="line">let renderer &#x3D; UIGraphicsImageRenderer(bounds: bounds)</span><br><span class="line"> let image &#x3D; renderer.image &#123; (coxt) in</span><br><span class="line">UIColor.red.setFill()</span><br><span class="line">let path &#x3D; UIBezierPath(roundedRect: bounds,</span><br><span class="line">cornerRadius: 20)</span><br><span class="line">path.addClip()</span><br><span class="line">UIRectFill(bounds)</span><br><span class="line">&#125;</span><br><span class="line">imageV &#x3D; UIImageView(image: image)</span><br><span class="line">imageV?.frame &#x3D; bounds</span><br><span class="line">self.view.addSubview(imageV!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>UIImage</code> 直接读出来需要将所有<code>UIImage</code>的<code>data</code>全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用<strong>下采样</strong>。</p><h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p>当<code>image</code>素材大小是<code>1000*1000</code>，但是在手机上显示出来只有<code>200*200</code>，我们其实是没必要将<code>1000*1000</code>的数据都解码的，只需要缩小成<code>200*200</code>的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。<br>在<code>UIKit</code>中使用<code>UIGraphicsImageRenderer</code>会有瞬间很高的内存和CPU峰值，那么</p><h4 id="1-UIKit-UIGraphicsImageRenderer"><a href="#1-UIKit-UIGraphicsImageRenderer" class="headerlink" title="1.UIKit  UIGraphicsImageRenderer"></a>1.UIKit  UIGraphicsImageRenderer</h4><p>使用素材A下采样技术，使用<code>UIKit</code>中的<code>UIGraphicsImageRenderer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:16.4M</span><br><span class="line">normal:14.8M</span><br><span class="line">CPU:</span><br><span class="line">Hight:29%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</span><br><span class="line">guard let image &#x3D; UIImage(contentsOfFile: url.path) else &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">if #available(iOS 10.0, *) &#123;</span><br><span class="line">let renderer &#x3D; UIGraphicsImageRenderer(size: size)</span><br><span class="line"></span><br><span class="line">return renderer.image &#123; (context) in</span><br><span class="line">image.draw(in: CGRect(origin: .zero, size: size))</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">UIGraphicsBeginImageContext(size)</span><br><span class="line">image.draw(in: CGRect(origin: .zero, size: size))</span><br><span class="line">let image &#x3D; UIGraphicsGetImageFromCurrentImageContext()</span><br><span class="line">UIGraphicsEndImageContext()</span><br><span class="line">return image</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用子线程绘制，会出现CPU略微升高，当<code>image size</code>大很多的时候会出现内存飙升然后慢慢恢复到<code>normal</code>。</p><h4 id="2-CoreGraphics-CGContext上下文绘制缩略图"><a href="#2-CoreGraphics-CGContext上下文绘制缩略图" class="headerlink" title="2.CoreGraphics CGContext上下文绘制缩略图"></a>2.CoreGraphics CGContext上下文绘制缩略图</h4><p>使用上下文绘制 <code>cpu</code> 和内存变化如下,<code>CPU</code>和内存没有大的变动解决了该问题，也做到省电、顺滑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:42.3M</span><br><span class="line">normal:14.1M</span><br><span class="line">CPU:</span><br><span class="line">Hight:6%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage2(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line">guard let imageSource &#x3D; CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">let image &#x3D; CGImageSourceCreateImageAtIndex(imageSource, 0, nil)</span><br><span class="line">else&#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">let cxt &#x3D; CGContext(data: nil,</span><br><span class="line">width: Int(size.width),</span><br><span class="line">height: Int(size.height),</span><br><span class="line">bitsPerComponent: image.bitsPerComponent,</span><br><span class="line">bytesPerRow: image.bytesPerRow,</span><br><span class="line">space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!</span><br><span class="line">,</span><br><span class="line">bitmapInfo: image.bitmapInfo.rawValue)</span><br><span class="line">cxt?.interpolationQuality &#x3D; .high</span><br><span class="line">cxt?.draw(image, in: CGRect(origin: .zero, size: size))</span><br><span class="line">guard let scaledImage &#x3D; cxt?.makeImage() else &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">let ima &#x3D; UIImage(cgImage: scaledImage)</span><br><span class="line">return ima</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-ImageIO-创建缩略图"><a href="#3-ImageIO-创建缩略图" class="headerlink" title="3.ImageIO 创建缩略图"></a>3.ImageIO 创建缩略图</h4><p>使用<code>ImageIO</code> 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:320M</span><br><span class="line">normal:221M</span><br><span class="line">CPU:</span><br><span class="line">Hight:73%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage3(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line"></span><br><span class="line">let ops:[CFString:Any] &#x3D; [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,</span><br><span class="line">  kCGImageSourceCreateThumbnailWithTransform:true,</span><br><span class="line">  kCGImageSourceShouldCacheImmediately:true,</span><br><span class="line">  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]</span><br><span class="line">guard let imageSource &#x3D; CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">let image &#x3D; CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">let ima &#x3D; UIImage(cgImage: image)</span><br><span class="line">printImageCost(image: ima)</span><br><span class="line">return ima</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-CoreImage-滤镜"><a href="#4-CoreImage-滤镜" class="headerlink" title="4.CoreImage 滤镜"></a>4.CoreImage 滤镜</h4><p>使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:1.04G</span><br><span class="line">normal:566M</span><br><span class="line">CPU:</span><br><span class="line">Hight:73%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage4(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line">let shareContext &#x3D; CIContext(options: [.useSoftwareRenderer:false])</span><br><span class="line"></span><br><span class="line"> guard let image &#x3D; CIImage(contentsOf: url) else &#123; return nil &#125;</span><br><span class="line">let fillter &#x3D; CIFilter(name: &quot;CILanczosScaleTransform&quot;)</span><br><span class="line">fillter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">fillter?.setValue(1, forKey: kCIInputScaleKey)</span><br><span class="line">guard let outPutCIImage &#x3D; fillter?.outputImage,let outputCGImage &#x3D; shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">return UIImage(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-使用-vImage-优化图片渲染"><a href="#5-使用-vImage-优化图片渲染" class="headerlink" title="5.使用 vImage 优化图片渲染"></a>5.使用 vImage 优化图片渲染</h4><p>使用<code>vImage</code>创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要<code>crash</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:998.7M</span><br><span class="line">normal:566M</span><br><span class="line">CPU:</span><br><span class="line">Hight:78%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage5(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</span><br><span class="line">    &#x2F;&#x2F; 解码源图像</span><br><span class="line">    guard let imageSource &#x3D; CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">        let image &#x3D; CGImageSourceCreateImageAtIndex(imageSource, 0, nil),</span><br><span class="line">        let properties &#x3D; CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],</span><br><span class="line">        let imageWidth &#x3D; properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,</span><br><span class="line">        let imageHeight &#x3D; properties[kCGImagePropertyPixelHeight] as? vImagePixelCount</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义图像格式</span><br><span class="line">    var format &#x3D; vImage_CGImageFormat(bitsPerComponent: 8,</span><br><span class="line">                                      bitsPerPixel: 32,</span><br><span class="line">                                      colorSpace: nil,</span><br><span class="line">                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),</span><br><span class="line">                                      version: 0,</span><br><span class="line">                                      decode: nil,</span><br><span class="line">                                      renderingIntent: .defaultIntent)</span><br><span class="line"></span><br><span class="line">    var error: vImage_Error</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建并初始化源缓冲区</span><br><span class="line">    var sourceBuffer &#x3D; vImage_Buffer()</span><br><span class="line">    defer &#123; sourceBuffer.data.deallocate() &#125;</span><br><span class="line">    error &#x3D; vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</span><br><span class="line">                                         &amp;format,</span><br><span class="line">                                         nil,</span><br><span class="line">                                         image,</span><br><span class="line">                                         vImage_Flags(kvImageNoFlags))</span><br><span class="line">    guard error &#x3D;&#x3D; kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建并初始化目标缓冲区</span><br><span class="line">    var destinationBuffer &#x3D; vImage_Buffer()</span><br><span class="line">    error &#x3D; vImageBuffer_Init(&amp;destinationBuffer,</span><br><span class="line">                              vImagePixelCount(size.height),</span><br><span class="line">                              vImagePixelCount(size.width),</span><br><span class="line">                              format.bitsPerPixel,</span><br><span class="line">                              vImage_Flags(kvImageNoFlags))</span><br><span class="line">    guard error &#x3D;&#x3D; kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 优化缩放图像</span><br><span class="line">    error &#x3D; vImageScale_ARGB8888(&amp;sourceBuffer,</span><br><span class="line">                                 &amp;destinationBuffer,</span><br><span class="line">                                 nil,</span><br><span class="line">                                 vImage_Flags(kvImageHighQualityResampling))</span><br><span class="line">    guard error &#x3D;&#x3D; kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从目标缓冲区创建一个 CGImage 对象</span><br><span class="line">    guard let resizedImage &#x3D;</span><br><span class="line">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</span><br><span class="line">                                      &amp;format,</span><br><span class="line">                                      nil,</span><br><span class="line">                                      nil,</span><br><span class="line">                                      vImage_Flags(kvImageNoAllocate),</span><br><span class="line">                                      &amp;error)?.takeRetainedValue(),</span><br><span class="line">        error &#x3D;&#x3D; kvImageNoError</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return UIImage(cgImage: resizedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。</p><p>在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,</span><br><span class="line">   object: nil,</span><br><span class="line">   queue: .main)</span><br><span class="line">&#123;[weak self] (note) in</span><br><span class="line">self?.unloadImage()</span><br><span class="line">&#125;</span><br><span class="line">NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,</span><br><span class="line">   object: nil,</span><br><span class="line">   queue: .main)</span><br><span class="line">&#123;[weak self] (note) in</span><br><span class="line">self?.loadImage()</span><br><span class="line">&#125;</span><br><span class="line"># 2</span><br><span class="line"></span><br><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">super.viewWillAppear(animated)</span><br><span class="line">self.loadImage()</span><br><span class="line">&#125;</span><br><span class="line">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class="line">super.viewWillDisappear(animated)</span><br><span class="line">self.unloadImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>基于性能综合考虑方法1是最简单最合适的</li><li>使用滤镜和<code>vImage</code>略微复杂点，平时开发过程中可以不用考虑了。</li><li>图片解码缓存和图片大小有关，适当的下采样是不错的选择。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE4LzQxNg==" title="https://developer.apple.com/videos/play/wwdc2018/416">session 2018 416 iOS Memory Deep Dive<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE4LzIxOQ==" title="https://developer.apple.com/videos/play/wwdc2018/219">219_image_and_graphics_best_practices<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">WWDC 中文字幕下载<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGFhZjhiM2YyNjVkYTViNmYwNzRjOTgjaGVhZGluZy0x" title="https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1">swift gg 图像优化<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></p></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlcg==" title="https://github.com/ifgyong/demo/tree/master">demo code git<i class="fa fa-external-link"></i></span></li></ul><h2 id="唯有实践才是检验真理的唯一标准"><a href="#唯有实践才是检验真理的唯一标准" class="headerlink" title="唯有实践才是检验真理的唯一标准"></a><strong>唯有实践才是检验真理的唯一标准</strong></h2><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于现在iOS11新生成的图片都是&lt;code&gt;HEIF&lt;/code&gt;，该图片使用&lt;code&gt;[UIImage image:name]&lt;/code&gt;已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM、分层设计浅谈 — (13)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20MVC%E3%80%81MVP%E3%80%81MVVM%E3%80%81%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B5%85%E8%B0%88%20%E2%80%94%20(13)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20MVC%E3%80%81MVP%E3%80%81MVVM%E3%80%81%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B5%85%E8%B0%88%20%E2%80%94%20(13)/</id>
    <published>2019-12-01T03:23:58.000Z</published>
    <updated>2020-09-04T04:40:21.657Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到</p><blockquote><ol><li>MVC</li><li>MVC变种</li><li>MVP</li><li>MVVM</li><li>分层设计的优缺点</li></ol></blockquote><p>没有最好的架构，只有最适合业务的架构。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>苹果版本的<code>MVC</code>是<code>Model</code>和<code>VC</code>和交互，<code>VC</code>和<code>View</code>交互</p><ul><li><p>优点：<code>View</code>和<code>Model</code>可以重复利用，可以独立使用</p></li><li><p>缺点：<code>Controller</code>的代码过于臃肿</p></li></ul><p><img src="/images/13-1.png" alt></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self loadData];</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadData&#123;</span><br><span class="line">    self.data&#x3D;[NSMutableArray array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        FYNews *item&#x3D;[FYNews new];</span><br><span class="line">        item.title &#x3D;[NSString stringWithFormat:@&quot;title-%d&quot;,i];</span><br><span class="line">        item.name &#x3D;[NSString stringWithFormat:@&quot;name-%d&quot;,i];</span><br><span class="line">        [self.data addObject:item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">    return self.data.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Configure the cell...</span><br><span class="line">    FYNews *item &#x3D;[self.data objectAtIndex:indexPath.row];</span><br><span class="line">    cell.detailTextLabel.text &#x3D;item.title;</span><br><span class="line">    cell.textLabel.text &#x3D; item.name;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;model</span><br><span class="line"></span><br><span class="line">@interface FYNews : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *title;</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这里是<code>VC</code>中组装了<code>tableview</code>，<code>model</code>的数据在<code>VC</code>中在<code>view</code>中显示出来，当需要另外的数据的时候，只需要将<code>model</code>改成需要的<code>model</code>而无需更改<code>tableview</code>的代码兼容性较好。</p><h3 id="MVC变种"><a href="#MVC变种" class="headerlink" title="MVC变种"></a>MVC变种</h3><p><code>MVC</code>变种，其实就是将<code>model</code>和<code>view</code>建立了联系，<code>view</code>依据<code>Model</code>来展示数据，<code>VC</code>组装<code>Model</code>，组装展示是在<code>view</code>中实现。</p><ul><li><p>优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现</p></li><li><p>缺点：view依赖于Model</p></li></ul><p><img src="/images/13-2.png" alt></p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.m</span><br><span class="line">@interface FYAppleView()</span><br><span class="line">@property (nonatomic,strong) UILabel *nameLabel;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYAppleView</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    if (self &#x3D;[super initWithFrame:frame]) &#123;</span><br><span class="line">        _nameLabel&#x3D;[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</span><br><span class="line">        [self addSubview:_nameLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">  mvc的变种</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)setModel:(FYItemModel *)model&#123;</span><br><span class="line">    _model &#x3D; model;</span><br><span class="line">    _nameLabel.textColor &#x3D; model.bgColor;</span><br><span class="line">    _nameLabel.text &#x3D; model.name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;FYItemModel</span><br><span class="line">@interface FYItemModel : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,strong) UIColor *bgColor;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ViewController</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self loadViewOtherMVC];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;变种MVC 把View和Model建立起连接</span><br><span class="line">&#x2F;&#x2F;等以后更新view数据只需要 view.model &#x3D; item;Controllr少了许多代码</span><br><span class="line">- (void)loadViewOtherMVC&#123;</span><br><span class="line">    FYAppleView * view &#x3D;[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</span><br><span class="line">    FYItemModel *item&#x3D;[[FYItemModel alloc]init];</span><br><span class="line">    item.name &#x3D; @&quot;校长来了&quot;;</span><br><span class="line">    item.bgColor &#x3D; [UIColor redColor];</span><br><span class="line">    view.model &#x3D; item;</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看到<code>model</code>组装到<code>view</code>展示内容是在<code>view</code>实现的，外部不知道细节，只需要将<code>model</code>给<code>view</code>即可，但是只能传输过来<code>model</code>或者他子类，业务更改的话，需要修改<code>view</code>的内部<code>model</code>才能将变更过的数据重新展示出来。</p><p>想要监听view的点击事件来做一些操作，那么我们可以使用代理和<code>block</code>,这里<code>id</code>是实现了<code>FYAppleViewProtocol</code>协议的，<code>weak</code>修饰防止循环引用，使用协议实现了和<code>VC</code>的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@class FYAppleView;</span><br><span class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>稍作更改还是<code>apple-MVC</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .h</span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>将<code>View</code>属性<code>nameLabel</code>暴露出来，但是不允许外界进行更改，去掉<code>model</code>则是<code>MVC</code>。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><code>MVP</code>和<code>MVC</code>很像，只是将<code>VC</code>换成了<code>Presenter</code>，<code>vc</code>和<code>Present</code>做的事情基本一致，将<code>view</code>和<code>Model</code>通信改到了都和<code>Presenter</code>通信。</p><p><img src="/images/13-3.png" alt><br>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MVP</span><br><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@interface FYNewsPresenter : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) UIViewController *vc;</span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">- (void)setup;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">.m</span><br><span class="line">#import &quot;FYNewsPresenter.h&quot;</span><br><span class="line">@interface FYNewsPresenter()&lt;FYAppleViewProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYNewsPresenter</span><br><span class="line">- (void)setup&#123;</span><br><span class="line">FYAppleView * view &#x3D;[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</span><br><span class="line">FYItemModel *item&#x3D;[[FYItemModel alloc]init];</span><br><span class="line">item.name &#x3D; @&quot;校长来了&quot;;</span><br><span class="line">item.bgColor &#x3D; [UIColor redColor];</span><br><span class="line">view.model &#x3D; item;</span><br><span class="line">[self.vc.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</span><br><span class="line">NSLog(@&quot;点击了我&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;VC中</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong) FYNewsPresenter *presenter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">_presenter&#x3D;[FYNewsPresenter new];</span><br><span class="line">_presenter.vc &#x3D; self;</span><br><span class="line">[_presenter setup];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>再次对<code>VC</code>进行了瘦身，将更多的业务逻辑搬到了<code>FYNewsPresenter</code>处理，其实全部搬过去，意义比不大，<code>FYNewsPresenter</code>也会臃肿，也会出现和<code>VC</code>一样的困惑。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>是将<code>FYNewsPresenter</code>都搬到了<code>FYNewsViewModel</code>中，然后对<code>FYNewsViewModel</code>和<code>View</code>进行了一个双向绑定，双向绑定可以使用代理，<code>block</code>或者<code>KVO</code>实现。<br><img src="/images/13-4.png" alt><br>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNewsViewModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,strong) UIColor *bgColor;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) UIViewController *vc;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithController:(UIViewController *)vc;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;FYNewsViewModel.h&quot;</span><br><span class="line">@interface FYNewsViewModel()&lt;FYAppleViewProtocol&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYNewsViewModel</span><br><span class="line">- (instancetype)initWithController:(UIViewController *)vc&#123;</span><br><span class="line">    if (self &#x3D;[super init]) &#123;</span><br><span class="line">        self.vc &#x3D; vc;</span><br><span class="line">        </span><br><span class="line">        FYAppleView * view &#x3D;[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];</span><br><span class="line">        &#x2F;&#x2F;    view.model &#x3D; item;</span><br><span class="line">        view.delegate &#x3D; self;</span><br><span class="line">        view.viewModel &#x3D; self; &#x2F;&#x2F;建立kvo</span><br><span class="line">        </span><br><span class="line">        view.backgroundColor &#x3D; [UIColor lightGrayColor];</span><br><span class="line">        [vc.view addSubview:view];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        FYItemModel *item&#x3D;[[FYItemModel alloc]init];</span><br><span class="line">        item.name &#x3D; @&quot;校长来了&quot;;</span><br><span class="line">        item.bgColor &#x3D; [UIColor redColor];</span><br><span class="line">        </span><br><span class="line">        self.name &#x3D; item.name;</span><br><span class="line">        self.bgColor &#x3D; item.bgColor;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</span><br><span class="line">NSLog(@&quot;点击了我&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在<code>view</code>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@class FYAppleView,FYNewsViewModel;</span><br><span class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@class FYItemModel;</span><br><span class="line"></span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</span><br><span class="line">@property (nonatomic,weak) FYNewsViewModel *viewModel;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface FYAppleView()</span><br><span class="line">@property (nonatomic,strong) UILabel *nameLabel;</span><br><span class="line">@end</span><br><span class="line">@implementation FYAppleView</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    if (self &#x3D;[super initWithFrame:frame]) &#123;</span><br><span class="line">        _nameLabel&#x3D;[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</span><br><span class="line">        [self addSubview:_nameLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">  mvc的变种</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)setModel:(FYItemModel *)model&#123;</span><br><span class="line">    _model &#x3D; model;</span><br><span class="line">    _nameLabel.textColor &#x3D; model.bgColor;</span><br><span class="line">    _nameLabel.text &#x3D; model.name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setViewModel:(FYNewsViewModel *)viewModel&#123;</span><br><span class="line">    _viewModel &#x3D; viewModel;</span><br><span class="line">   [_viewModel addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">   &#x2F;&#x2F;使用FBKVO实现 或者自己使用KVO实现</span><br><span class="line">&#x2F;&#x2F;    __weak typeof(self) waekSelf &#x3D; self;</span><br><span class="line">&#x2F;&#x2F;    [self.KVOController observe:viewModel keyPath:@&quot;name&quot;</span><br><span class="line">&#x2F;&#x2F;                        options:NSKeyValueObservingOptionNew</span><br><span class="line">&#x2F;&#x2F;                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123;</span><br><span class="line">&#x2F;&#x2F;        waekSelf.nameLabel.text &#x3D; change[NSKeyValueChangeNewKey];</span><br><span class="line">&#x2F;&#x2F;    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        self.nameLabel.text &#x3D; change[NSKeyValueChangeNewKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加点击事件</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) &#123;</span><br><span class="line">[self.delegate FYAppleViewDidClick:self];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    [_viewModel removeObserver:self</span><br><span class="line">                    forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>使用<code>KVO</code>或者<code>FBKVO</code>或者<code>RAC</code>都是可以的，本章节例子给出了<code>FBKVO</code>或者自己使用<code>KVO</code>的实现。</p><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>三层架构：</p><blockquote><p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层</p></blockquote><ul><li><p>目的: “高内聚，低耦合”的思想 </p></li><li><p>优点: 降低层与层之间的依赖 标准化 </p></li><li><p>缺点: 系统架构复杂，不适合小型项目</p></li></ul><h4 id="三层原理"><a href="#三层原理" class="headerlink" title="三层原理"></a>三层原理</h4><blockquote><p>3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。<br>所谓三层体系结构，是在客户端与数据库之间加入了一个<code>中间层</code>，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有<code>B/S</code>应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。</p><p>三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过<code>COM/DCOM</code>通讯与中间层建立连接，再经由中间层与数据库进行交互。</p><p>三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用<code>COM/DCOM</code>通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互</p></blockquote><p><code>MVC</code>、<code>MVVM</code>、<code>MVP</code>属于界面层，<br>当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了</p><p>分层之后，得到了一个三层架构或四层架构</p><p><img src="/images/13-5.png" alt="三层架构"></p><p>数据层也可以分为两层，分为网络请求和db层。</p><p><img src="/images/13-6.png" alt="四层架构"></p><p>具体在工程中我们通常这样体现</p><p><img src="/images/13-7.png" alt></p><p>在<code>vc</code>中获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong) FYDBPool *db;</span><br><span class="line">@property (nonatomic,strong) FYHttpPool *http;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当有业务层</span><br><span class="line">[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) &#123;</span><br><span class="line"></span><br><span class="line">&#125; fail:^&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;当没有有业务层</span><br><span class="line">self.db&#x3D;[FYDBPool new];</span><br><span class="line">self.http&#x3D;[FYHttpPool new];</span><br><span class="line">[self.db loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">if ([ret count]) &#123;</span><br><span class="line">NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">&#125; fail:^&#123;</span><br><span class="line">NSLog(@&quot;数据获取失败&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125; fail:^&#123;</span><br><span class="line">[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">&#125; fail:^&#123;</span><br><span class="line">NSLog(@&quot;数据获取失败&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNewsService ()</span><br><span class="line">@property (nonatomic,strong) FYDBPool *db;</span><br><span class="line">@property (nonatomic,strong) FYHttpPool *http;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYNewsService</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">self.db&#x3D;[FYDBPool new];</span><br><span class="line">self.http&#x3D;[FYHttpPool new];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line"> success:(succcessCallback )succblock</span><br><span class="line">fail:(dispatch_block_t)failBlock&#123;</span><br><span class="line">[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">if ([ret count]) &#123;</span><br><span class="line">succblock(ret);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">succblock(ret);</span><br><span class="line">&#125; fail:failBlock];</span><br><span class="line">&#125;</span><br><span class="line">&#125; fail:^&#123;</span><br><span class="line">[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">succblock(ret);</span><br><span class="line">&#125; fail:failBlock];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在db层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^succcessCallback)(NSArray *);</span><br><span class="line">@interface FYDBPool : NSObject</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line"> success:(succcessCallback )succblock</span><br><span class="line">fail:(dispatch_block_t)failBlock;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在网络请求层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^succcessCallback)(NSArray *);</span><br><span class="line">@interface FYHttpPool : NSObject</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line"> success:(succcessCallback )succblock</span><br><span class="line">fail:(dispatch_block_t)failBlock;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或<code>db</code>，当<code>db</code>足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。<br>不同的人来处理不同的分层，相互影响也比较小，降低耦合。</p><p><strong>当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。</strong></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>优雅的代码总是伴随着各种传统设计模式的搭配</p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote><p>设计模式（Design Pattern）<br>是一套被反复使用、代码设计经验的总结<br>使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性<br>一般与编程语言无关，是一套比较成熟的编程思想</p></blockquote><p>设计模式可以分为三大类</p><ol><li><p>创建型模式：对象实例化的模式，用于解耦对象的实例化过程<br>单例模式、工厂方法模式，等等</p></li><li><p>结构型模式：把类或对象结合在一起形成一个更大的结构<br>代理模式、适配器模式、组合模式、装饰模式，等等</p></li><li><p>行为型模式：类或对象之间如何交互，及划分责任和算法<br>观察者模式、命令模式、责任链模式，等等</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>适合项目的才是最好的架构</li></ul><h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglODklRTUlQjElODIlRTYlOUUlQjYlRTYlOUUlODQ=" title="https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84">三层架构<i class="fa fa-external-link"></i></span><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;MVC变种&lt;/li&gt;
&lt;li&gt;MVP&lt;/li&gt;
&lt;li&gt;MVVM&lt;/li&gt;
&lt;li&gt;分层设计的优缺点&lt;/li&gt;
&lt;/ol&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8E%9F%E7%90%86%E6%B1%87%E6%80%BB%20%E2%80%94%20(12)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8E%9F%E7%90%86%E6%B1%87%E6%80%BB%20%E2%80%94%20(12)/</id>
    <published>2019-12-01T03:22:58.000Z</published>
    <updated>2020-09-04T04:40:21.660Z</updated>
    
    <content type="html"><![CDATA[<p>看完本文章你将了解到</p><blockquote><ol><li>DisplayLink和timer的使用和原理</li><li>内存分配和内存管理</li><li>自动释放池原理</li><li>weak指针原理和释放时机</li><li>引用计数原理</li></ol></blockquote><p>/</p><h3 id="DisplayLink"><a href="#DisplayLink" class="headerlink" title="DisplayLink"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</span><br><span class="line">&#x2F;&#x2F;runloop没循环一圈都会调用</span><br><span class="line">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">&#x2F;&#x2F;从runloop中删除</span><br><span class="line">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">&#x2F;&#x2F;取消</span><br><span class="line">- (void)invalidate;</span><br></pre></td></tr></table></figure><p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) CADisplayLink *link;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">self.link &#x3D; [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">NSLog(@&quot;FPS:%d&quot;,fps);</span><br><span class="line">fps &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line">&#x2F;&#x2F;全局变量</span><br><span class="line">dispatch_source_t timer;</span><br><span class="line">static int fps;</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line"></span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">fps +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">[self.link invalidate];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</span><br><span class="line">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</span><br></pre></td></tr></table></figure><p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYTimerTarget : NSObject</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYTimerTarget</span><br><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">return self.target;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYProxy *proxy&#x3D;[FYProxy proxyWithTarget:self];</span><br><span class="line">self.link &#x3D; [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 17:59:04.339934 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.356292 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 17:59:04.371634 -[ViewController dealloc]</span><br></pre></td></tr></table></figure><p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface FYProxy : NSProxy</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line"></span><br><span class="line">+(instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@end</span><br><span class="line">@implementation FYProxy</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</span><br><span class="line">FYProxy *obj&#x3D;[FYProxy alloc];</span><br><span class="line">obj.target &#x3D; target;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line">[invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</span><br><span class="line">return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">return self.target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FYTimerTarget *obj &#x3D;[FYTimerTarget new];</span><br><span class="line">obj.target &#x3D; self;</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; [NSTimer timerWithTimeInterval:1.0f</span><br><span class="line">target:obj</span><br><span class="line">   selector:@selector(test)</span><br><span class="line">   userInfo:nil</span><br><span class="line">repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">[self.timer setFireDate:[NSDate distantPast]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</span><br></pre></td></tr></table></figure><p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.timer&#x3D;[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</span><br></pre></td></tr></table></figure><p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p><h3 id="GCD中timer"><a href="#GCD中timer" class="headerlink" title="GCD中timer"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;timer 需要强引用 或者设置成全局变量</span><br><span class="line">    timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">    &#x2F;&#x2F;设置</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">  &#x2F;&#x2F;code 定时器执行的代码</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;开始定时器</span><br><span class="line">    dispatch_resume(timer);</span><br></pre></td></tr></table></figure><p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler_f(timer, function_t);</span><br><span class="line">void function_t(void * p)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p><p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block</span><br><span class="line">      start:(NSTimeInterval)time</span><br><span class="line">       interval:(NSTimeInterval)interval</span><br><span class="line">     repeat:(BOOL)repeat</span><br><span class="line">      async:(BOOL)async;</span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">  sel:(SEL)aciton</span><br><span class="line">start:(NSTimeInterval)time</span><br><span class="line"> interval:(NSTimeInterval)interval</span><br><span class="line">   repeat:(BOOL)repeat</span><br><span class="line">async:(BOOL)async;</span><br><span class="line">&#x2F;&#x2F;取消</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key;</span><br></pre></td></tr></table></figure><p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</span><br><span class="line">if (block &#x3D;&#x3D; nil) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (repeat &amp;&amp; interval &lt;&#x3D; 0) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *name &#x3D;[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">&#x2F;&#x2F;主队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">if (async) &#123;</span><br><span class="line">queue &#x3D; dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建定时器</span><br><span class="line">dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">&#x2F;&#x2F;设置启动时间</span><br><span class="line">dispatch_source_set_timer(_timer,</span><br><span class="line">  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">&#x2F;&#x2F;设定回调</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">block();</span><br><span class="line">if (repeat &#x3D;&#x3D; NO) &#123;</span><br><span class="line">dispatch_source_cancel(_timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;启动定时器</span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line">&#x2F;&#x2F;存放到字典</span><br><span class="line">if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">timers[name] &#x3D; _timer;</span><br><span class="line">dispatch_semaphore_signal(samephore);</span><br><span class="line">&#125;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">  sel:(SEL)aciton</span><br><span class="line">start:(NSTimeInterval)time</span><br><span class="line"> interval:(NSTimeInterval)interval</span><br><span class="line">   repeat:(BOOL)repeat</span><br><span class="line">async:(BOOL)async&#123;</span><br><span class="line">if (target &#x3D;&#x3D; nil || aciton &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (repeat &amp;&amp; interval &lt;&#x3D; 0) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *name &#x3D;[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">&#x2F;&#x2F;主队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">if (async) &#123;</span><br><span class="line">queue &#x3D; dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建定时器</span><br><span class="line">dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">&#x2F;&#x2F;设置启动时间</span><br><span class="line">dispatch_source_set_timer(_timer,</span><br><span class="line">  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">&#x2F;&#x2F;设定回调</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">&#x2F;&#x2F;这里是会报警告的代码</span><br><span class="line">if ([target respondsToSelector:aciton]) &#123;</span><br><span class="line">[target performSelector:aciton];</span><br><span class="line">&#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">if (repeat &#x3D;&#x3D; NO) &#123;</span><br><span class="line">dispatch_source_cancel(_timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;启动定时器</span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line">&#x2F;&#x2F;存放到字典</span><br><span class="line">if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">timers[name] &#x3D; _timer;</span><br><span class="line">dispatch_semaphore_signal(samephore);</span><br><span class="line">&#125;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key&#123;</span><br><span class="line">if (key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">if ([timers.allKeys containsObject:key]) &#123;</span><br><span class="line">dispatch_source_cancel(timers[key]);</span><br><span class="line">[timers removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_signal(samephore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; [FYTimer exeTask:^&#123;</span><br><span class="line">        NSLog(@&quot;123&quot;);</span><br><span class="line">    &#125; start:1</span><br><span class="line">    interval:1 </span><br><span class="line">    repeat:YES </span><br><span class="line">    async:NO];</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br></pre></td></tr></table></figure><p>取消执行的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FYTimer exeCancelTask:key];</span><br></pre></td></tr></table></figure><p>测试封装的定时器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">key &#x3D; [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">[FYTimer exeCancelTask:key];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</span><br></pre></td></tr></table></figure><p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p><h3 id="NSProxy实战"><a href="#NSProxy实战" class="headerlink" title="NSProxy实战"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p><p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc1 &#x3D;[[ViewController alloc]init];</span><br><span class="line">FYProxy *pro1 &#x3D;[FYProxy proxyWithTarget:vc1];</span><br><span class="line"></span><br><span class="line">FYTimerTarget *tar &#x3D;[FYTimerTarget proxyWithTarget:vc1];</span><br><span class="line">BOOL ret1 &#x3D; [pro1 isKindOfClass:ViewController.class];</span><br><span class="line">BOOL ret2 &#x3D; [tar isKindOfClass:ViewController.class];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,ret1,ret2);</span><br></pre></td></tr></table></figure><p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p><p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p><p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p><p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p><p>数据段包括</p><ul><li>字符串常量：比如NSString * str = @”11”</li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ul><p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p><p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">int b ;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static int c &#x3D; 20;</span><br><span class="line">        static int d;</span><br><span class="line">        int e &#x3D; 10;</span><br><span class="line">        int f;</span><br><span class="line">        NSString * str &#x3D; @&quot;123&quot;;</span><br><span class="line">        NSObject *obj &#x3D;[[NSObject alloc]init];</span><br><span class="line">        NSLog(@&quot;\na:%p \nb:%p \nc:%p \nd:%p \ne:%p \nf:%p \nobj:%p\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">a:0x1063e0d98 </span><br><span class="line">b:0x1063e0e64 </span><br><span class="line">c:0x1063e0d9c </span><br><span class="line">d:0x1063e0e60 </span><br><span class="line">e:0x7ffee9820efc </span><br><span class="line">f:0x7ffee9820ef8 </span><br><span class="line">obj:0x6000013541a0</span><br><span class="line">str:0x1063e0068</span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拿来这个可以判断对象是否使用了优化技术。</p><h4 id="NSNumbe-Tagged-Pointer"><a href="#NSNumbe-Tagged-Pointer" class="headerlink" title="NSNumbe Tagged Pointer"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ &#x2F;&#x2F;mac开发</span><br><span class="line">&#x2F;&#x2F; 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F; Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1&#x2F;&#x2F;iOS开发</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#endif</span><br><span class="line">bool objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSNumber *n1 &#x3D; @2;</span><br><span class="line">        NSNumber *n2 &#x3D; @3;</span><br><span class="line">        NSNumber *n3 &#x3D; @(4);</span><br><span class="line">        NSNumber *n4 &#x3D; @(0x4fffffffff);</span><br><span class="line">        NSLog(@&quot;\n%p \n%p \n%p \n%p&quot;,n1,n2,n3,n4);</span><br><span class="line">        BOOL n1_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</span><br><span class="line">        BOOL n2_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</span><br><span class="line">        BOOL n3_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</span><br><span class="line">        BOOL n4_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;\nn1:%d \nn2:%d \nn3:%d \nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">0xbf4071e2657ccb95 </span><br><span class="line">0xbf4071e2657ccb85 </span><br><span class="line">0xbf4071e2657ccbf5 </span><br><span class="line">0xbf40751d9a833444</span><br><span class="line">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </span><br><span class="line">n1:1 </span><br><span class="line">n2:1 </span><br><span class="line">n3:1 </span><br><span class="line">n4:0</span><br></pre></td></tr></table></figure><p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p><h4 id="NSString-Tagged-Pointer"><a href="#NSString-Tagged-Pointer" class="headerlink" title="NSString Tagged Pointer"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">self.name &#x3D; [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">self.name &#x3D; [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不运行，先分析一下。</p><p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread: EXC_BAD_ACCESS(code &#x3D; 1)</span><br></pre></td></tr></table></figure><p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p><p>验证<code>NSString Tagged Pointer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 1; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">self.name &#x3D; [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">NSLog(@&quot;test1 class:%@&quot;,self.name.class);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 1; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">self.name &#x3D; [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">NSLog(@&quot;test2 class:%@&quot;,self.name.class);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">test1 class:NSTaggedPointerString</span><br><span class="line">test2 class:__NSCFString</span><br></pre></td></tr></table></figure><p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p><p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p><p> iOS提供了2中拷贝方法</p><ol><li>copy 拷贝出来不可变对象</li><li>mutableCopy 拷贝出来可变对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test1()&#123;</span><br><span class="line">NSString *str &#x3D; @&quot;strstrstrstr&quot;;</span><br><span class="line">NSMutableString *mut1 &#x3D;[str mutableCopy];</span><br><span class="line">[mut1 appendFormat:@&quot;123&quot;];</span><br><span class="line">NSString *str2 &#x3D; [str copy];</span><br><span class="line">NSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">str:0x100001040 </span><br><span class="line">mut1:0x1007385f0 </span><br><span class="line">str2:0x100001040</span><br></pre></td></tr></table></figure><p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p><p>我们把字符串换成其他常用的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test2()&#123;</span><br><span class="line">NSArray *array &#x3D; @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</span><br><span class="line">NSMutableArray *mut &#x3D;[array mutableCopy];</span><br><span class="line">NSString *array2 &#x3D; [array copy];</span><br><span class="line">NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x102840800 </span><br><span class="line">0x1028408a0</span><br><span class="line">0x102840800</span><br><span class="line"></span><br><span class="line">void test3()&#123;</span><br><span class="line">NSArray *array &#x3D; [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</span><br><span class="line">NSMutableArray *mut &#x3D;[array mutableCopy];</span><br><span class="line">NSString *array2 &#x3D; [array copy];</span><br><span class="line">NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x102808720 </span><br><span class="line">0x1028088a0</span><br><span class="line">0x1028089a0</span><br></pre></td></tr></table></figure><p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p><p>我们再换成其他的常用的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void test4()&#123;</span><br><span class="line">NSDictionary *item &#x3D; @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</span><br><span class="line">NSMutableDictionary *mut &#x3D;[item mutableCopy];</span><br><span class="line">NSDictionary *item2 &#x3D; [item copy];</span><br><span class="line">NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x1007789c0 </span><br><span class="line">0x100779190</span><br><span class="line">0x1007789c0</span><br><span class="line"></span><br><span class="line">void test5()&#123;</span><br><span class="line">NSDictionary *item &#x3D; [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</span><br><span class="line">NSMutableDictionary *mut &#x3D;[item mutableCopy];</span><br><span class="line">NSDictionary *item2 &#x3D; [item copy];</span><br><span class="line">NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">0x1007041d0 </span><br><span class="line">0x1007042b0</span><br><span class="line">0x1007043a0</span><br></pre></td></tr></table></figure><p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p><p>由这几个看出来，总结出来下表</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">copy</th><th style="text-align:center">mutableCopy</th></tr></thead><tbody><tr><td style="text-align:center">NSString</td><td style="text-align:center">浅拷贝</td><td style="text-align:center">深拷贝</td></tr><tr><td style="text-align:center">NSMutableString</td><td style="text-align:center">浅拷贝</td><td style="text-align:center">深拷贝</td></tr><tr><td style="text-align:center">NSArray</td><td style="text-align:center">浅拷贝</td><td style="text-align:center">深拷贝</td></tr><tr><td style="text-align:center">NSMutableArray</td><td style="text-align:center">深拷贝</td><td style="text-align:center">深拷贝</td></tr><tr><td style="text-align:center">NSDictionary</td><td style="text-align:center">浅拷贝</td><td style="text-align:center">深拷贝</td></tr><tr><td style="text-align:center">NSMutableDictionary</td><td style="text-align:center">深拷贝</td><td style="text-align:center">深拷贝</td></tr></tbody></table><h4 id="自定义对象实现协议NSCoping"><a href="#自定义对象实现协议NSCoping" class="headerlink" title="自定义对象实现协议NSCoping"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCopying</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSMutableCopying</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@property (nonatomic,assign) int level;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FYPerson()&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.age &#x3D; self.age;</span><br><span class="line">p.level &#x3D; self.level;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.age &#x3D; 10;</span><br><span class="line">p.level &#x3D; 11;</span><br><span class="line">FYPerson *p2 &#x3D;[p copy];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">10 11</span><br></pre></td></tr></table></figure><p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p><p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (add)</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    Class cls &#x3D; [self class];</span><br><span class="line">    NSObject * p&#x3D;[cls new];</span><br><span class="line">    &#x2F;&#x2F;成员变量个数</span><br><span class="line">    unsigned int count;</span><br><span class="line">    &#x2F;&#x2F;赋值成员变量数组</span><br><span class="line">    Ivar *ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">    &#x2F;&#x2F;遍历数组</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">        Ivar var &#x3D; ivars[i];</span><br><span class="line">        &#x2F;&#x2F;获取成员变量名字</span><br><span class="line">        const char * name &#x3D; ivar_getName(var);</span><br><span class="line">        if (name !&#x3D; nil) &#123;</span><br><span class="line">            NSString *v &#x3D; [NSString stringWithUTF8String:name];</span><br><span class="line">            id value &#x3D; [self valueForKey:v];</span><br><span class="line">            &#x2F;&#x2F;给新的对象赋值</span><br><span class="line">            if (value !&#x3D; NULL) &#123;</span><br><span class="line">                [p setValue:value forKey:v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.age &#x3D; 10;</span><br><span class="line">p.level &#x3D; 11;</span><br><span class="line">p.name &#x3D; @&quot;xiaowang&quot;;</span><br><span class="line">FYPerson *p2 &#x3D;[p copy];</span><br><span class="line">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">10 </span><br><span class="line">11 </span><br><span class="line">xiaowang</span><br></pre></td></tr></table></figure><p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p><h3 id="引用计数原理"><a href="#引用计数原理" class="headerlink" title="引用计数原理"></a>引用计数原理</h3><p>摘自<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlOTUlRTclOTQlQTglRTglQUUlQTElRTYlOTUlQjAvMTAyMDU1MDc/ZnI9YWxhZGRpbg==" title="https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin">百度百科<i class="fa fa-external-link"></i></span></p><blockquote><p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p></blockquote><p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p><p>在MRC中我们经常都是这样子使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">FYPerson *p2 &#x3D;[p retain];</span><br><span class="line">&#x2F;&#x2F;code here</span><br><span class="line">[p release];</span><br><span class="line">[p2 release];</span><br></pre></td></tr></table></figure><p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p><p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p><p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;大概率x&#x3D;&#x3D;1 提高读取指令的效率</span><br><span class="line">#define fastpath(x) (__builtin_expect(bool(x), 1))</span><br><span class="line">&#x2F;&#x2F;大概率x&#x3D;&#x3D;0 提高读取指令的效率</span><br><span class="line">#define slowpath(x) (__builtin_expect(bool(x), 0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用计数+1</span><br><span class="line">&#x2F;&#x2F;tryRetain 尝试+1</span><br><span class="line">&#x2F;&#x2F;handleOverflow 是否覆盖</span><br><span class="line">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;优化的指针 返回this</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line">    bool transcribeToSideTable &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;old bits</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">&#x2F;&#x2F;使用联合体技术</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);&#x2F;&#x2F;nothing</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();&#x2F;&#x2F;解锁</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">else return sidetable_retain();&#x2F;&#x2F;&#x2F;&#x2F;sidetable 引用计数+1</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">&#x2F;&#x2F;不尝试retain 和 正在销毁 什么都不做 返回 nil</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">&#x2F;&#x2F;引用计数+1 (bits.extra_rc++;)</span><br><span class="line">        newisa.bits &#x3D; addc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc++</span><br><span class="line"></span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; newisa.extra_rc++ 溢出处理</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;为拷贝到side table 做准备</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            transcribeToSideTable &#x3D; true;</span><br><span class="line">            newisa.extra_rc &#x3D; RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">&#x2F;&#x2F;拷贝 平外一半的 引用计数到 side table</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sidetable 引用计数+1</span><br><span class="line">id objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F;取出table key&#x3D;this</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage &#x3D; table.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage +&#x3D; SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p><p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;&#x2F;&#x2F;指针优化的不存在计数器</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;&#x2F;&#x2F;isa</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">&#x2F;&#x2F;side table -1</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits &#x3D; subc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc--</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; don&#39;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    newisa &#x3D; oldisa;</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;side table 引用计数-1</span><br><span class="line">        size_t borrowed &#x3D; sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            newisa.extra_rc &#x3D; borrowed - 1;  &#x2F;&#x2F; redo the original decrement too</span><br><span class="line">            bool stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                isa_t oldisa2 &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 &#x3D; oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits &#x3D; </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed.</span><br><span class="line">                &#x2F;&#x2F; Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;真正的销毁</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        &#x2F;&#x2F; does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;设置正在销毁</span><br><span class="line">    newisa.deallocating &#x3D; true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline uintptr_t  objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;优化指针 直接返回</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line">&#x2F;&#x2F;没优化则 到SideTable 读取</span><br><span class="line">    sidetable_lock();</span><br><span class="line">&#x2F;&#x2F;isa指针</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);&#x2F;&#x2F;啥都没做</span><br><span class="line">    if (bits.nonpointer) &#123;&#x2F;&#x2F;使用联合体存储更多的数据 </span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;&#x2F;&#x2F;计数数量</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;&#x2F;&#x2F;当大过于 联合体存储的值 则另外在SideTable读取数据</span><br><span class="line">&#x2F;&#x2F;读取table的值 相加</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">&#x2F;&#x2F;在sidetable 中存储的count</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDJiY2YzZGYyNjVkYTFiNjcyMTNkNjk=" title="https://juejin.im/post/5d2bcf3df265da1b67213d69">使用联合体存储更多的数据<i class="fa fa-external-link"></i></span>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用联合体</span><br><span class="line">size_t  objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;不是联合体技术 则报错</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">&#x2F;&#x2F;key是 this，存储了每个对象的table</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">&#x2F;&#x2F;找到 it 否则返回0</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有优化的是直接读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未使用联合体的情况，</span><br><span class="line">uintptr_t objc_object::sidetable_retainCount()</span><br><span class="line">&#123;&#x2F;&#x2F;没有联合体存储的计数器则直接在table中取出来</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    size_t refcnt_result &#x3D; 1;</span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it !&#x3D; table.refcnts.end()) &#123;</span><br><span class="line">        refcnt_result +&#x3D; it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak指针原理"><a href="#weak指针原理" class="headerlink" title="weak指针原理"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">&#x2F;&#x2F;c++析构函数</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">&#x2F;&#x2F;关联函数</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正在清除side table 和weakly referenced</span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for raw pointer isa.</span><br><span class="line">&#x2F;&#x2F;释放weak</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for non-pointer isa with weak refs and&#x2F;or side table data.</span><br><span class="line">&#x2F;&#x2F;释放weak 和引用计数</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">&#x2F;&#x2F;清除weak</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">&#x2F;&#x2F;table.weak_table 弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;引用计数</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">&#x2F;&#x2F;擦除 this</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p><h3 id="Autoreleasepool-原理"><a href="#Autoreleasepool-原理" class="headerlink" title="Autoreleasepool 原理"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line"> __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"> FYPerson *p &#x3D; ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__AtAutoreleasePool</code>是一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">__AtAutoreleasePool() &#123;&#x2F;&#x2F;构造函数 生成结构体变量的时候调用</span><br><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">&#125;</span><br><span class="line">~__AtAutoreleasePool() &#123;&#x2F;&#x2F;析构函数 销毁的时候调用</span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br><span class="line">void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后将上边的代码和c++整合到一起就是这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __AtAutoreleasePool pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">    objc_autoreleasePoolPop(pool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p><p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;&#x2F;&#x2F;下一个存放aotoreleass对象的地址</span><br><span class="line">    pthread_t const thread;&#x2F;&#x2F;线程</span><br><span class="line">    AutoreleasePoolPage * const parent; &#x2F;&#x2F;父节点</span><br><span class="line">    AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">    uint32_t const depth;&#x2F;&#x2F;深度</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p><ul><li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li><li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li><li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li><li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li><li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li></ul><p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">_objc_autoreleasePoolPrint();</span><br><span class="line">printf(&quot;\n--------------\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">objc[23958]: ##############</span><br><span class="line">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[23958]: 3 releases pending.</span><br><span class="line">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[23958]: [0x101000038]  ################  POOL 0x101000038</span><br><span class="line">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</span><br><span class="line">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</span><br><span class="line">objc[23958]: ##############</span><br><span class="line"></span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">FYPerson *p2 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line"></span><br><span class="line">FYPerson *p3 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">FYPerson *p4 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line"></span><br><span class="line">_objc_autoreleasePoolPrint();</span><br><span class="line">printf(&quot;\n--------------\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">objc[24025]: ##############</span><br><span class="line">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[24025]: 6 releases pending.</span><br><span class="line">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[24025]: [0x100803038]  ################  POOL 0x100803038</span><br><span class="line">objc[24025]: [0x100803040]       0x100721580  FYPerson</span><br><span class="line">objc[24025]: [0x100803048]       0x100721b10  FYPerson</span><br><span class="line">objc[24025]: [0x100803050]  ################  POOL 0x100803050</span><br><span class="line">objc[24025]: [0x100803058]       0x100721390  FYPerson</span><br><span class="line">objc[24025]: [0x100803060]       0x100717620  FYPerson</span><br><span class="line">objc[24025]: ##############</span><br></pre></td></tr></table></figure><p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p><p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line"> &#123;</span><br><span class="line">     AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">     &#x2F;&#x2F;当有分页而且分页没有满就添加</span><br><span class="line">     if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">         return page-&gt;add(obj);</span><br><span class="line">     &#125; else if (page) &#123;</span><br><span class="line">         &#x2F;&#x2F;满则新建一个page进行添加obj和设置hotpage</span><br><span class="line">         return autoreleaseFullPage(obj, page);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F;没有page则新建page进行添加</span><br><span class="line">         return autoreleaseNoPage(obj);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;activities &#x3D; 0xa0转化成二进制 0b101 0000</span><br><span class="line">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</span><br><span class="line">&#x2F;&#x2F;回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line"></span><br><span class="line">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid &#x3D; Yes, activities &#x3D; 0xa0, </span><br><span class="line">repeats &#x3D; Yes, order &#x3D; 2147483647, </span><br><span class="line">callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </span><br><span class="line">context &#x3D; &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type &#x3D; mutable-small, count &#x3D; 1, </span><br><span class="line">values &#x3D; (\n\t0 : &lt;0x7fb6dc004058&gt;\n)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p><p>在ARC中则执行完毕<code>test()</code>会马上释放。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li><li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li><li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li><li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li><li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Vubnl4eC5jb20vMjAxNC8xMC8xNS9iZWhpbmQtYXV0b3JlbGVhc2Uv" title="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease<i class="fa fa-external-link"></i></span></li><li>小码哥视频</li><li>iOS和OS多线程与内存管理</li><li>iOS和macOS性能优化<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完本文章你将了解到&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DisplayLink和timer的使用和原理&lt;/li&gt;
&lt;li&gt;内存分配和内存管理&lt;/li&gt;
&lt;li&gt;自动释放池原理&lt;/li&gt;
&lt;li&gt;weak指针原理和释放时机&lt;/li&gt;
&lt;li&gt;引用计数原理&lt;/
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%AE%89%E5%85%A8%E9%94%81%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%20--(11)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%AE%89%E5%85%A8%E9%94%81%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%20--(11)/</id>
    <published>2019-12-01T03:21:58.000Z</published>
    <updated>2020-09-04T04:40:21.661Z</updated>
    
    <content type="html"><![CDATA[<p>只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？<br>这篇文章主要讲解线程安全。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是什么呢？摘抄一段<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQkElQkYlRTclQTglOEIlRTUlQUUlODklRTUlODUlQTgvOTc0NzcyND9mcj1hbGFkZGlu" title="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin">百度百科<i class="fa fa-external-link"></i></span>的一段话</p><blockquote><p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p></blockquote><h4 id="为什么需要线程安全"><a href="#为什么需要线程安全" class="headerlink" title="为什么需要线程安全"></a>为什么需要线程安全</h4><p>ATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。</p><p>那么在iOS中，锁是如何使用的呢？</p><h3 id="自旋锁-OS-SPINLOCK"><a href="#自旋锁-OS-SPINLOCK" class="headerlink" title="自旋锁 OS_SPINLOCK"></a>自旋锁 OS_SPINLOCK</h3><h4 id="什么是优先级反转"><a href="#什么是优先级反转" class="headerlink" title="什么是优先级反转"></a>什么是优先级反转</h4><p>简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</p><p>假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</p><p>首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</p><p>其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</p><p>第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</p><p>第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</p><p>第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。</p><p><code>OS_SPINLOCK</code>叫做<code>自旋锁</code>，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。</p><p><code>OS_SPINLOCK</code>API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化 一般是0，或者直接数字0也是ok的。</span><br><span class="line">#defineOS_SPINLOCK_INIT    0</span><br><span class="line">&#x2F;&#x2F;锁的初始化</span><br><span class="line">OSSpinLock lock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">&#x2F;&#x2F;尝试加锁</span><br><span class="line">bool ret &#x3D; OSSpinLockTry(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure><p><code>OSSpinLock</code>简单实现12306如何卖票</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;基类实现的卖票</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    NSInteger oldCount &#x3D; self.ticketsCount;</span><br><span class="line">if (isLog) &#123;</span><br><span class="line">sleep(sleepTime);</span><br><span class="line">&#125;</span><br><span class="line">    oldCount --;</span><br><span class="line">    self.ticketsCount &#x3D; oldCount;</span><br><span class="line">if (isLog) &#123;</span><br><span class="line">printf(&quot;还剩% 2ld 张票 - %s \n&quot;,(long)oldCount,[NSThread currentThread].description.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)ticketTest&#123;</span><br><span class="line">    self.ticketsCount &#x3D; 10000;</span><br><span class="line">NSInteger count &#x3D; self.ticketsCount&#x2F;3;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;tick.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">if (time1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">time1 &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">&#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">if (time1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">time1 &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">&#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">if (time1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">time1 &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">&#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">CFAbsoluteTime time &#x3D; CFAbsoluteTimeGetCurrent() - time1;</span><br><span class="line">printf(&quot;tick cost time:%f&quot;,time);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __getMonery];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __saveMonery];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    NSInteger oldCount &#x3D; self.ticketsCount;</span><br><span class="line">    oldCount --;</span><br><span class="line">    self.ticketsCount &#x3D; oldCount;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h4 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后将睡眠时间设置为600s，方便我们调试。</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);&#x2F;&#x2F;此行打断点</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了断点进入<code>Debug-&gt;Debug WorkFlow -&gt;Always Show Disassembly</code>，到了汇编界面，在<code>LLDB</code>输入<code>stepi</code>，然后一直按<code>enter</code>，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现<code>ja</code>跳转到地址<code>0x103f3d0f9</code>，每次执行到<code>ja</code>总是跳转到<code>0x103f3d0f9</code>，直到线程睡眠结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  0x103f3d0f9 &lt;+241&gt;: movq   %rcx, (%r8)</span><br><span class="line">0x103f3d0fc &lt;+244&gt;: addq   $0x8, %r8</span><br><span class="line">0x103f3d100 &lt;+248&gt;: cmpq   %r8, %r9</span><br><span class="line">0x103f3d103 &lt;+251&gt;: ja     0x103f3d0f9</span><br></pre></td></tr></table></figure><p>可以通过汇编分析了解到<code>自旋锁</code>是真的<code>忙等</code>，闲不住的锁。</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的<code>OSSpinLock</code>，而且必须使用<code>OS_UNFAIR_LOCK_INIT</code>来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在<code>__IOS_AVAILABLE(10.0)</code>，锁的数据结构是一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OS_UNFAIR_LOCK_AVAILABILITY</span><br><span class="line">typedef struct os_unfair_lock_s &#123;</span><br><span class="line">uint32_t _os_unfair_lock_opaque;</span><br><span class="line">&#125; os_unfair_lock, *os_unfair_lock_t;</span><br></pre></td></tr></table></figure><p><code>os_unfair_lock</code>使用非常简单，只需要在任务前加锁，任务后解锁即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface FYOSUnfairLockDemo : FYBaseDemo</span><br><span class="line">@property (nonatomic,assign) os_unfair_lock lock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYOSUnfairLockDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">self.lock &#x3D; OS_UNFAIR_LOCK_INIT;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">[super __saveMonery];</span><br><span class="line">os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">[super __getMonery];</span><br><span class="line">os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">[super __saleTicket];</span><br><span class="line">os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h4 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h4><p><code>LLDB</code> 中命令<code>stepi</code>遇到函数会进入到函数，<code>nexti</code>会跳过函数。我们将断点打到添加锁的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)__saleTicket&#123;</span><br><span class="line"> os_unfair_lock_lock(&amp;_unlock);&#x2F;&#x2F;断点位置</span><br><span class="line">[super __saleTicket];</span><br><span class="line">os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>si</code>,一直<code>enter</code>，最终是停止该位子，模拟器缺跳出来了，再<code>enter</code>也没用了，因为线程在睡眠了。<code>syscall</code>是调用系统函数的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libsystem_kernel.dylib&#96;__ulock_wait:</span><br><span class="line">    0x107a3b9d4 &lt;+0&gt;:  movl   $0x2000203, %eax          ; imm &#x3D; 0x2000203 </span><br><span class="line">    0x107a3b9d9 &lt;+5&gt;:  movq   %rcx, %r10</span><br><span class="line">-&gt;  0x107a3b9dc &lt;+8&gt;:  syscall</span><br></pre></td></tr></table></figure><h3 id="互斥锁-pthread-mutex-t"><a href="#互斥锁-pthread-mutex-t" class="headerlink" title="互斥锁 pthread_mutex_t"></a>互斥锁 pthread_mutex_t</h3><p><code>mutex</code>叫互斥锁，等待锁的线程会处于休眠状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">pthread_mutex_destroy(&amp;_plock);</span><br><span class="line">pthread_mutexattr_destroy(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">if (self &#x3D;[super init]) &#123;</span><br><span class="line">&#x2F;&#x2F;初始化锁的属性 </span><br><span class="line">&#x2F;&#x2F;pthread_mutexattr_init(&amp;t);</span><br><span class="line">&#x2F;&#x2F;pthread_mutexattr_settype(&amp;t, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;初始化锁</span><br><span class="line">&#x2F;&#x2F;pthread_mutex_init(&amp;_plock, &amp;t);</span><br><span class="line"></span><br><span class="line">pthread_mutex_t plock &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">self.plock &#x3D; plock;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">-(void)__saleTicket&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">[super __saleTicket];</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">[super __getMonery];</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">[super __saveMonery];</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><p>互斥锁有三个类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Mutex type attributes</span><br><span class="line"> *&#x2F;</span><br><span class="line"> 普通锁</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL0</span><br><span class="line">&#x2F;&#x2F;检查错误</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK1</span><br><span class="line">&#x2F;&#x2F;递归锁</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE2</span><br><span class="line">&#x2F;&#x2F;普通锁</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL</span><br></pre></td></tr></table></figure><p>当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self otherTest2];</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest2&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">-[FYPthread_mutex2 otherTest]</span><br></pre></td></tr></table></figure><p>上面这个需求需要使用两把锁，或者使用递归锁来解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self otherTest2];</span><br><span class="line">pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest2&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_plock2);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">pthread_mutex_unlock(&amp;_plock2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">-[FYPthread_mutex2 otherTest]</span><br><span class="line">-[FYPthread_mutex2 otherTest2]</span><br></pre></td></tr></table></figure><p>从使用2把锁是可以解决这个问题的。<br>递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。</p><h3 id="NSLock、NSRecursiveLosk"><a href="#NSLock、NSRecursiveLosk" class="headerlink" title="NSLock、NSRecursiveLosk"></a>NSLock、NSRecursiveLosk</h3><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p><p>使用<code>(LLDB) si</code>可以跟踪<code>[myLock lock];</code>的内部函数最终是<code>pthread_mutex_lock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foundation&#96;-[NSLock lock]:</span><br><span class="line">    0x1090dfb5a &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x1090dfb5b &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x1090dfb5e &lt;+4&gt;:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars</span><br><span class="line">    0x1090dfb63 &lt;+9&gt;:  movq   %rax, %rdi</span><br><span class="line">    0x1090dfb66 &lt;+12&gt;: popq   %rbp</span><br><span class="line">-&gt;  0x1090dfb67 &lt;+13&gt;: jmp    0x1092ca596   ;</span><br><span class="line">&#x2F;&#x2F;  symbol stub for: pthread_mutex_lock</span><br></pre></td></tr></table></figure><p><code>NSLock API</code>大全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;协议NSLocking</span><br><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)tryLock;&#x2F;&#x2F;尝试加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;&#x2F;&#x2F;在某个日期前加锁，</span><br><span class="line">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>用法也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNSLock()&#123;</span><br><span class="line">NSLock *_lock;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYNSLock</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">&#x2F;&#x2F;封装了mutex的普通锁</span><br><span class="line">_lock&#x3D;[[NSLock alloc]init];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">[_lock lock];</span><br><span class="line">[super __saveMonery];</span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">[_lock lock];</span><br><span class="line">[super __saleTicket];</span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">[_lock lock];</span><br><span class="line">[super __getMonery];</span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><p><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，<code>API</code>跟<code>NSLock</code>基本一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tryLock;&#x2F;&#x2F;尝试加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;&#x2F;&#x2F;日期前加锁</span><br></pre></td></tr></table></figure><p>递归锁可以对相同的线程进行反复加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@implementation FYRecursiveLockDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">&#x2F;&#x2F;封装了mutex的递归锁</span><br><span class="line">_lock&#x3D;[[NSRecursiveLock alloc]init];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">static int count &#x3D; 10;</span><br><span class="line">[_lock lock];</span><br><span class="line">while (count &gt; 0) &#123;</span><br><span class="line">count -&#x3D; 1;</span><br><span class="line">printf(&quot;循环% 2d次 - %s \n&quot;,count,[NSThread currentThread].description.UTF8String);</span><br><span class="line">[self otherTest];</span><br><span class="line">&#125;</span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">循环 9次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 8次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 7次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 6次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 5次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 4次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 3次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 2次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 1次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">循环 0次 - &lt;NSThread: 0x60000274e900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br></pre></td></tr></table></figure><h3 id="NSCondition-条件"><a href="#NSCondition-条件" class="headerlink" title="NSCondition 条件"></a>NSCondition 条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)wait;&#x2F;&#x2F;等待</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</span><br><span class="line">- (void)signal;&#x2F;&#x2F;唤醒一个线程</span><br><span class="line">- (void)broadcast;&#x2F;&#x2F;唤醒多个线程</span><br></pre></td></tr></table></figure><p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">&#x2F;&#x2F;遵守的 lock协议 的 条件🔐</span><br><span class="line">_lock&#x3D;[[NSCondition alloc]init];</span><br><span class="line">self.array &#x3D;[NSMutableArray array];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__add&#123;</span><br><span class="line">[_lock lock];</span><br><span class="line">[self.array addObject:@&quot;Test&quot;];</span><br><span class="line">NSLog(@&quot;添加成功&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">[_lock signal];&#x2F;&#x2F;唤醒一个线程</span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__remove&#123;</span><br><span class="line">[_lock lock];</span><br><span class="line">if (self.array.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">[_lock wait];</span><br><span class="line">&#125;</span><br><span class="line">[self.array removeLastObject];</span><br><span class="line">NSLog(@&quot;删除成功&quot;);</span><br><span class="line"></span><br><span class="line">[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;Log</span><br><span class="line"></span><br><span class="line">2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功</span><br><span class="line">2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功</span><br></pre></td></tr></table></figure><p>可以看到时间上差了1秒，正好是我们设定的<code>sleep(1);</code>。优点是可以让线程之间形成依赖，缺点是没有明确的条件。</p><h3 id="NSConditionLock-可以实现线程依赖的锁"><a href="#NSConditionLock-可以实现线程依赖的锁" class="headerlink" title="NSConditionLock 可以实现线程依赖的锁"></a>NSConditionLock 可以实现线程依赖的锁</h3><p><code>NSConditionLock</code>是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用<code>NSConditionLock</code>来解决问题。<br>首先看下<code>API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) NSInteger condition;&#x2F;&#x2F;条件值</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;&#x2F;&#x2F;当con为condition进行锁住</span><br><span class="line">&#x2F;&#x2F;尝试加锁</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">&#x2F;&#x2F;当con为condition进行尝试锁住</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">&#x2F;&#x2F;当con为condition进行解锁</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">&#x2F;&#x2F;NSDate 小余 limit进行 加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">&#x2F;&#x2F;条件为condition 在limit之前进行加锁</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br></pre></td></tr></table></figure><p>条件锁的使用，在<code>lockWhenCondition:(NSInteger)condition</code>的条件到达的时候才能进行正常的加锁和<code>unlockWithCondition:(NSInteger)condition</code>解锁，否则会阻塞线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)__test1&#123;</span><br><span class="line">[_lock lockWhenCondition:1];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[_lock unlockWithCondition:2];&#x2F;&#x2F;解锁 并赋值2</span><br><span class="line">&#125;</span><br><span class="line">- (void)__test2&#123;</span><br><span class="line">[_lock lockWhenCondition:2];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[_lock unlockWithCondition:3];&#x2F;&#x2F;解锁 并赋值3</span><br><span class="line">&#125;</span><br><span class="line">- (void)__test3&#123;</span><br><span class="line">[_lock lockWhenCondition:3];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[_lock unlockWithCondition:4];&#x2F;&#x2F;解锁 并赋值4</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">-[FYCondLockDemo2 __test1]</span><br><span class="line">-[FYCondLockDemo2 __test2]</span><br><span class="line">-[FYCondLockDemo2 __test3]</span><br></pre></td></tr></table></figure><p>当<code>con = 1</code>进行<code>test1</code>加锁和执行任务<code>A</code>，任务<code>A</code>执行完毕，进行解锁，并把值2赋值给<code>lock</code>，这是当<code>con = 2</code>的锁开始加锁，进入任务<code>B</code>，开始执行任务<code>B</code>，当任务<code>B</code>执行完毕，进行解锁并赋值为3，然后<code>con=3</code>的锁进行加锁，解锁并赋值4来进行线程之间的依赖。</p><h3 id="dispatch-queue-特殊的锁"><a href="#dispatch-queue-特殊的锁" class="headerlink" title="dispatch_queue 特殊的锁"></a>dispatch_queue 特殊的锁</h3><p>其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface FYSerialQueueDemo()&#123;</span><br><span class="line">dispatch_queue_t _queue;</span><br><span class="line">&#125;@end</span><br><span class="line">@implementation FYSerialQueueDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D;[super init]) &#123;</span><br><span class="line">_queue &#x3D; dispatch_queue_create(&quot;fyserial.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">dispatch_sync(_queue, ^&#123;</span><br><span class="line">[super __saleTicket];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">dispatch_sync(_queue, ^&#123;</span><br><span class="line">[super __getMonery];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">dispatch_sync(_queue, ^&#123;</span><br><span class="line">[super __saveMonery];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch-semaphore-信号量控制并发数量"><a href="#dispatch-semaphore-信号量控制并发数量" class="headerlink" title="dispatch_semaphore 信号量控制并发数量"></a>dispatch_semaphore 信号量控制并发数量</h3><p>当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？<code>dispatch_semaphore</code>信号量正好可以满足我们的需求。<br><code>dispatch_semaphore</code>可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化信号量 值为2，就是最多允许同时2个线程执行</span><br><span class="line">_semaphore &#x3D; dispatch_semaphore_create(2);</span><br><span class="line">&#x2F;&#x2F;生成多个线程进行并发访问test</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i ++) &#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test&#123;</span><br><span class="line">&#x2F;&#x2F;如果信号量&gt;0 ，让信号量-1，继续向下执行。</span><br><span class="line">&#x2F;&#x2F;如果信号量 &lt;&#x3D; 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER</span><br><span class="line">dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">sleep(2);&#x2F;&#x2F;睡眠时间2s</span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#x2F;&#x2F;释放一个信号量</span><br><span class="line">dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] &lt;NSThread: 0x600002c45240&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] &lt;NSThread: 0x600002c45200&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] &lt;NSThread: 0x600002c45540&gt;&#123;number &#x3D; 10, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] &lt;NSThread: 0x600002c45440&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] &lt;NSThread: 0x600002c45480&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] &lt;NSThread: 0x600002c454c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] &lt;NSThread: 0x600002c45500&gt;&#123;number &#x3D; 9, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] &lt;NSThread: 0x600002c45400&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] &lt;NSThread: 0x600002c455c0&gt;&#123;number &#x3D; 12, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] &lt;NSThread: 0x600002c45580&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><p>一次最多2个线程同时执行任务，暂停时间是2s。<br>使用信号量实现线程最大并发锁，<br>同时只有2个线程执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">if (self &#x3D;[super init]) &#123;</span><br><span class="line">_semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">[super __saleTicket];</span><br><span class="line">dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p><code>@synchronized(id obj){}</code>锁的是对象<code>obj</code>，使用该锁的时候，底层是对象计算出来的值作为<code>key</code>，生成一把锁，不同的资源的读写可以使用不同<code>obj</code>作为锁对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[super __saleTicket];</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="atmoic-原子操作"><a href="#atmoic-原子操作" class="headerlink" title="atmoic 原子操作"></a>atmoic 原子操作</h3><p>给属性添加<code>atmoic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证了<code>setter</code>和<code>getter</code>的内部是线程同步的。<br>原子操作是最终调用了<code>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行</code>，我们进入到函数内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置属性原子操作</span><br><span class="line">void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, true, false, false);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;非原子操作设置属性</span><br><span class="line">void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, false, false, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;&#x2F;&#x2F;偏移量等于0则是class指针</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;其他的value</span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果是copy 用copyWithZone:</span><br><span class="line">        newValue &#x3D; [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        &#x2F;&#x2F;mutableCopy则调用mutableCopyWithZone:</span><br><span class="line">        newValue &#x3D; [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;如果赋值和原来的相等 则不操作</span><br><span class="line">        if (*slot &#x3D;&#x3D; newValue) return;</span><br><span class="line">        newValue &#x3D; objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;&#x2F;&#x2F;非原子操作 直接赋值</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;原子操作 加锁</span><br><span class="line">    &#x2F;&#x2F;锁和属性是一一对应的-&gt;自旋锁</span><br><span class="line">        spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue &#x3D; *slot;</span><br><span class="line">        *slot &#x3D; newValue;&#x2F;&#x2F;赋值</span><br><span class="line">        slotlock.unlock();&#x2F;&#x2F;解锁</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Retain release world</span><br><span class="line">    id *slot &#x3D; (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;&#x2F;&#x2F;非原子操作 直接返回值</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; Atomic retain release world</span><br><span class="line">&#x2F;&#x2F;原子操作 加锁-&gt;自旋锁</span><br><span class="line">    spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();&#x2F;&#x2F;加锁</span><br><span class="line">    id value &#x3D; objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();&#x2F;&#x2F;解锁</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以属性的地址为参数计算出key ，锁为value</span><br><span class="line">StripedMap&lt;spinlock_t&gt; PropertyLocks;</span><br></pre></td></tr></table></figure><p>从源码了解到设置属性读取是<code>self</code>+属性的偏移量，当<code>copy</code>或<code>mutableCopy</code>会调用到<code>[newValue copyWithZone:nil]</code>或<code>[newValue mutableCopyWithZone:nil]</code>，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取<code>spinlock_t&amp; slotlock = PropertyLocks[slot]</code>进行加锁、赋值、解锁操作。而且<code>PropertyLocks</code>是一个类，类有一个数组属性，使用<code>*p</code>计算出来的值作为<code>key</code>。</p><p>我们提取出来关键代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原子操作 加锁</span><br><span class="line">spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">slotlock.lock();</span><br><span class="line">oldValue &#x3D; *slot;</span><br><span class="line">*slot &#x3D; newValue;&#x2F;&#x2F;赋值</span><br><span class="line">slotlock.unlock();&#x2F;&#x2F;解锁</span><br></pre></td></tr></table></figure><p>使用自旋锁对赋值操作进行加锁，保证了<code>setter()</code>方法的安全性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原子操作 加锁 -&gt;自旋锁</span><br><span class="line">spinlock_t&amp; slotlock &#x3D; PropertyLocks[slot];</span><br><span class="line">slotlock.lock();&#x2F;&#x2F;加锁</span><br><span class="line">id value &#x3D; objc_retain(*slot);</span><br><span class="line">slotlock.unlock();&#x2F;&#x2F;解锁</span><br></pre></td></tr></table></figure><p>取值之前进行加锁，取值之后进行解锁，保证了<code>getter()</code>方法的安全。</p><p>由上面得知<code>atmoic</code>仅仅是对方法<code>setter()</code>和<code>getter()</code>安全，对成员变量不保证安全，对于属性的读写一般使用<code>nonatomic</code>，性能好，<code>atomic</code>读取频率高的时候会导致线程都在排队，浪费CPU时间。</p><p>大概使用者几种锁分别对卖票功能进行了性能测试，<br>性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)</p><table><thead><tr><th style="text-align:center">锁类型</th><th style="text-align:center">1万次</th><th style="text-align:center">100万次</th><th style="text-align:center">1000万次</th></tr></thead><tbody><tr><td style="text-align:center">pthread_mutex_t</td><td style="text-align:center">0.000309</td><td style="text-align:center">0.027238</td><td style="text-align:center">0.284714</td></tr><tr><td style="text-align:center">os_unfair_lock</td><td style="text-align:center">0.000274</td><td style="text-align:center">0.028266</td><td style="text-align:center">0.285685</td></tr><tr><td style="text-align:center">OSSpinLock</td><td style="text-align:center">0.030688</td><td style="text-align:center">0.410067</td><td style="text-align:center">0.437702</td></tr><tr><td style="text-align:center">NSCondition</td><td style="text-align:center">0.005067</td><td style="text-align:center">0.323492</td><td style="text-align:center">1.078636</td></tr><tr><td style="text-align:center">NSLock</td><td style="text-align:center">0.038692</td><td style="text-align:center">0.151601</td><td style="text-align:center">1.322062</td></tr><tr><td style="text-align:center">NSRecursiveLock</td><td style="text-align:center">0.007973</td><td style="text-align:center">0.151601</td><td style="text-align:center">1.673409</td></tr><tr><td style="text-align:center">@synchronized</td><td style="text-align:center">0.008953</td><td style="text-align:center">0.640234</td><td style="text-align:center">2.790291</td></tr><tr><td style="text-align:center">NSConditionLock</td><td style="text-align:center">0.229148</td><td style="text-align:center">5.325272</td><td style="text-align:center">10.681123</td></tr><tr><td style="text-align:center">semaphore</td><td style="text-align:center">0.094267</td><td style="text-align:center">0.415351</td><td style="text-align:center">24.699100</td></tr><tr><td style="text-align:center">SerialQueue</td><td style="text-align:center">0.213386</td><td style="text-align:center">9.058581</td><td style="text-align:center">50.820202</td></tr></tbody></table><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>平时我们简单使用的话没有很大的区别，还是推荐使用<code>NSLock</code>和信号量,最简单的是<code>@synchronized</code>，不用声明和初始化，直接拿来就用。</p><h3 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h3><p>自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul><li>自旋锁在等待时间比较短的时候比较合适</li><li>临界区代码经常被调用，但竞争很少发生</li><li>CPU不紧张</li><li>多核处理器<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4></li><li>预计线程等待时间比较长</li><li>单核处理器</li><li>临界区IO操作</li><li>临界区代码比较多、复杂，或者循环量大</li><li>临界区竞争非常激烈</li></ul><h2 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h2><h4 id="简单读写锁"><a href="#简单读写锁" class="headerlink" title="简单读写锁"></a>简单读写锁</h4><p>一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">&#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">self.semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 10; i ++) &#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)read&#123;</span><br><span class="line">dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br><span class="line">- (void)write&#123;</span><br><span class="line">dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点</p><ol><li>同一时间，只能有1个线程进行写操作</li><li>同一时间，允许有多个线程进行读的操作</li><li>同一时间，不允许读写操作同时进行</li></ol><p>典型的<code>多读单写</code>，经常用于文件等数据的读写操作，我们实现2种</p><h4 id="读写锁-pthread-rwlock"><a href="#读写锁-pthread-rwlock" class="headerlink" title="读写锁 pthread_rwlock"></a>读写锁 pthread_rwlock</h4><p>这是有c语言封装的读写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化读写锁</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t * __restrict,</span><br><span class="line">const pthread_rwlockattr_t * _Nullable __restrict)</span><br><span class="line">&#x2F;&#x2F;读上锁</span><br><span class="line">pthread_rwlock_rdlock(pthread_rwlock_t *)</span><br><span class="line">&#x2F;&#x2F;尝试加锁读</span><br><span class="line">pthread_rwlock_tryrdlock(pthread_rwlock_t *)</span><br><span class="line">&#x2F;&#x2F;尝试加锁写</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *)</span><br><span class="line">&#x2F;&#x2F;写入加锁</span><br><span class="line">pthread_rwlock_wrlock(pthread_rwlock_t *)</span><br><span class="line">&#x2F;&#x2F;解锁</span><br><span class="line">pthread_rwlock_unlock(pthread_rwlock_t *)</span><br><span class="line">&#x2F;&#x2F;销毁锁属性</span><br><span class="line">pthread_rwlockattr_destroy(pthread_rwlockattr_t *)</span><br><span class="line">&#x2F;&#x2F;销毁锁</span><br><span class="line">pthread_rwlock_destroy(pthread_rwlock_t * )</span><br></pre></td></tr></table></figure><p><code>pthread_rwlock_t</code>使用很简单，只需要在读之前使用<code>pthread_rwlock_rdlock</code>，读完解锁<code>pthread_rwlock_unlock</code>,写入前需要加锁<code>pthread_rwlock_wrlock</code>，写入完成之后解锁<code>pthread_rwlock_unlock</code>，任务都执行完了可以选择销毁<code>pthread_rwlock_destroy</code>或者等待下次使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,assign) pthread_rwlock_t rwlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">pthread_rwlock_destroy(&amp;_rwlock);&#x2F;&#x2F;销毁锁</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;初始化读写锁</span><br><span class="line">pthread_rwlock_init(&amp;_rwlock, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];</span><br><span class="line">[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)readPthreadRWLock&#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_rwlock);</span><br><span class="line">    NSLog(@&quot;读文件&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)writePthreadRWLock&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_rwlock);</span><br><span class="line">    NSLog(@&quot; 写入文件&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 10:47:16 读文件</span><br><span class="line">2019-07-30 10:47:16 读文件</span><br><span class="line">2019-07-30 10:47:17 写入文件</span><br><span class="line">2019-07-30 10:47:18 写入文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:20 写入文件</span><br><span class="line">2019-07-30 10:47:21 写入文件</span><br><span class="line">2019-07-30 10:47:22 写入文件</span><br></pre></td></tr></table></figure><p>读文件会出现同一秒读多次，写文件同一秒只有一个。</p><h4 id="异步栅栏调用-dispatch-barrier-async"><a href="#异步栅栏调用-dispatch-barrier-async" class="headerlink" title="异步栅栏调用 dispatch_barrier_async"></a>异步栅栏调用 dispatch_barrier_async</h4><p>栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">任务</th><th style="text-align:center">任务</th><th style="text-align:center">任务</th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">读</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">写</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">读</td><td style="text-align:center">A</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">读</td><td style="text-align:center">A</td><td style="text-align:center">B</td></tr></tbody></table><p>这个函数传入的并发队列必须是通过<code>dispatch_queue_create</code>创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于<code>dispatch_async</code>的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化 异步队列</span><br><span class="line">self.rwqueue &#x3D; dispatch_queue_create(&quot;rw.thread&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[self readBarryier];</span><br><span class="line">[self readBarryier];</span><br><span class="line">[self readBarryier];</span><br><span class="line">[self writeBarrier];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)readBarryier&#123;</span><br><span class="line">&#x2F;&#x2F;添加任务到rwqueue</span><br><span class="line">dispatch_async(self.rwqueue, ^&#123;</span><br><span class="line">NSLog(@&quot;读文件 %@&quot;,[NSThread currentThread]);</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)writeBarrier&#123;</span><br><span class="line">&#x2F;&#x2F;barrier_async添加任务到self.rwqueue中</span><br><span class="line">dispatch_barrier_async(self.rwqueue, ^&#123;</span><br><span class="line">NSLog(@&quot;写入文件 %@&quot;,[NSThread currentThread]);</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae0740&gt;&#123;number &#x3D; 9, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8500&gt;&#123;number &#x3D; 10, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8040&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ac3a80&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:54 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:55 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 11:16:56 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><p>读文件会出现同一秒读多个，写文件同一秒只有一个。</p><p>读写任务都添加到异步队列<code>rwqueue</code>中，使用栅栏函数<code>dispatch_barrier_async</code>拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>普通线程锁本质就是同步执行</li><li><code>atomic</code>原子操作只限制<code>setter</code>和<code>getter</code>方法，不限制成员变量</li><li>读写锁高性能可以使用<code>pthread_rwlock_t</code>和<code>dispatch_barrier_async</code><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9hc190YWRwb2xlL2FydGljbGUvZGV0YWlscy84NjQzNjE2MQ==" title="https://blog.csdn.net/Fly_as_tadpole/article/details/86436161">优先级反转<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTkwZGU2OGYyNjVkYTRlOWI1OTJiNDAjaGVhZGluZy0xNg==" title="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16">iOS多线程：『GCD』详尽总结<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy41MjBpdC5jb20venQvaW9zX21qLw==" title="http://www.520it.com/zt/ios_mj/">小码哥视频<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2F3YXlxdS4xMDI0dWwuY29tL2lvcy8yMDE4LzA1LzAyL2djZC0zLmh0bWw=" title="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html">任务调度<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=" title="https://opensource.apple.com/tarballs/libdispatch/">libdispatch<i class="fa fa-external-link"></i></span></li><li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？&lt;br&gt;这篇文章主要讲解线程安全。&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  多线程之GCD看我就够了 --(10)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%20%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86%20--(10)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%20%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86%20--(10)/</id>
    <published>2019-12-01T03:20:58.000Z</published>
    <updated>2020-09-04T04:40:21.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>RunLoop</code>和线程的关系，以及<code>Thread</code>如何保活和控制生命周期，今天我们再探究下另外的一个线程<code>GCD</code>，揭开蒙娜丽莎的面纱。</p><h3 id="GCD-基础知识"><a href="#GCD-基础知识" class="headerlink" title="GCD 基础知识"></a>GCD 基础知识</h3><p>GCD是什么呢？我们引用<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9HQ0Q=" title="https://baike.baidu.com/item/GCD">百度百科<i class="fa fa-external-link"></i></span>的一段话。</p><blockquote><p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p></blockquote><p>GCD有哪些优点</p><ul><li>GCD自动管理线程</li><li>开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可</li><li>GCD 自动管理线程，线程创建，挂起，销毁。</li></ul><p>那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发</p><h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。</p><h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><p>并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活</p><p><strong>串行队列</strong>相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。</p><p><strong>并行队列</strong>是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。</p><p><strong>并发</strong>是多个流水线在同时加工产品。</p><h4 id="GCD中的串行队列"><a href="#GCD中的串行队列" class="headerlink" title="GCD中的串行队列()"></a>GCD中的串行队列()</h4><h5 id="串行队列（Serial-Dispatch-Queue）："><a href="#串行队列（Serial-Dispatch-Queue）：" class="headerlink" title="串行队列（Serial Dispatch Queue）："></a>串行队列（Serial Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。</p><p><img src="/images/10-1.png" alt></p><h5 id="并发队列（Concurrent-Dispatch-Queue）："><a href="#并发队列（Concurrent-Dispatch-Queue）：" class="headerlink" title="并发队列（Concurrent Dispatch Queue）："></a>并发队列（Concurrent Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。</p><p><img src="/images/10-2.png" alt></p><h3 id="GCD使用步骤"><a href="#GCD使用步骤" class="headerlink" title="GCD使用步骤"></a>GCD使用步骤</h3><p>GCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。</p><p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p><h4 id="获取主队列"><a href="#获取主队列" class="headerlink" title="获取主队列"></a>获取主队列</h4><p>主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过<code>dispatch_get_main_queue()</code>，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取主队列</span><br><span class="line">dispatch_queue_t main_queue&#x3D; dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><h4 id="获取全局队列"><a href="#获取全局队列" class="headerlink" title="获取全局队列"></a>获取全局队列</h4><p>全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>,第一个参数是<code>identifier</code>，表示队列的优先级，一般传入<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数<code>flags</code>，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=" title="https://opensource.apple.com/tarballs/libdispatch/">libdispatch<i class="fa fa-external-link"></i></span></p><blockquote><p>Use the<br>.Fn dispatch_get_global_queue<br>function to obtain the global queue of given priority. The<br>.Fa flags<br>argument is reserved for future use and must be zero. Passing any value other<br>than zero may result in a NULL return value.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取全局队列</span><br><span class="line">dispatch_queue_t main_queue&#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure><h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法的<code>spatch_async</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F; 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    &#x2F;&#x2F; 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然是只有同步异步但是他们组合的多变的</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">并发队列</th><th style="text-align:center">创建的串行队列</th><th style="text-align:center">主队列</th></tr></thead><tbody><tr><td style="text-align:center">同步(sync)</td><td style="text-align:center">没开启新线程，串行执行</td><td style="text-align:center">没开启新线程，串行执行任务</td><td style="text-align:center">没开启新线程，串行执行任务</td></tr><tr><td style="text-align:center">异步(async)</td><td style="text-align:center">能开启新线程，并发执行</td><td style="text-align:center">能开启新线程，串行执行任务</td><td style="text-align:center">没开启新线程，串行执行任务</td></tr></tbody></table><h3 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h3><h4 id="主队列-同步"><a href="#主队列-同步" class="headerlink" title="主队列+同步"></a>主队列+同步</h4><p>在主队列中执行任务，并同步添加任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主队列+同步</span><br><span class="line">-(void)syn_main&#123;</span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">dispatch_queue_t main_queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">dispatch_sync(main_queue, ^&#123;</span><br><span class="line">NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>看到日志只输出了1就崩溃了提示<code>exc_bad_instuction</code>,为什么出问题呢？<br>主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。<br><strong>what</strong>???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句<code>exc_bad_instuction</code>，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。<br>那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主队列+同步</span><br><span class="line">-(void)syn_main2&#123;</span><br><span class="line">NSLog(@&quot;1任务执行&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;2任务执行&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;3任务执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">1任务执行</span><br><span class="line">2任务执行</span><br><span class="line">3任务执行</span><br></pre></td></tr></table></figure><p>没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。</p><h4 id="主队列-异步"><a href="#主队列-异步" class="headerlink" title="主队列+异步"></a>主队列+异步</h4><p>在主队列中异步添加任务并执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主队列+异步</span><br><span class="line">NSLog(@&quot;start&quot;);</span><br><span class="line">dispatch_queue_t main_queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">dispatch_async(main_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(main_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(main_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-24 15:12:24.73 start</span><br><span class="line">2019-07-24 15:12:24.73 end</span><br><span class="line"></span><br><span class="line">&lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 0</span><br><span class="line">2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 1</span><br><span class="line">2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 2</span><br><span class="line">2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 3</span><br><span class="line">2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 4</span><br><span class="line">2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 5</span><br><span class="line">2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 7</span><br><span class="line">2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 8</span><br><span class="line">2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 9</span><br></pre></td></tr></table></figure><p>在主队列异步执行任务，从日志看出来<code>end</code>早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到</p><ul><li>主线程多个任务异步不能创建新线程</li><li>主线程异步也是串行执行</li></ul><h4 id="全局队列-同步"><a href="#全局队列-同步" class="headerlink" title="全局队列+同步"></a>全局队列+同步</h4><p>全局队列是并行队列，和同步配合就是串行执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局队列+同步</span><br><span class="line">-(void)sync_global&#123;</span><br><span class="line">printf(&quot;\n start&quot;);</span><br><span class="line">dispatch_queue_t global_queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_sync(global_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(global_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(global_queue, ^&#123;</span><br><span class="line">NSThread *thread &#x3D; [NSThread currentThread];</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">start</span><br><span class="line"> 2019-07-24 15:35:36 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 0</span><br><span class="line"> 2019-07-24 15:35:37 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 1</span><br><span class="line"> 2019-07-24 15:35:38 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 2</span><br><span class="line"> 2019-07-24 15:35:39 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 3</span><br><span class="line"> 2019-07-24 15:35:40 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 4</span><br><span class="line"> 2019-07-24 15:35:41 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 5</span><br><span class="line"> 2019-07-24 15:35:42 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 7</span><br><span class="line"> 2019-07-24 15:35:43 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 8</span><br><span class="line"> 2019-07-24 15:35:44 &lt;NSThread: 0x600000592900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 9</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p>在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。</p><h4 id="全局队列-异步"><a href="#全局队列-异步" class="headerlink" title="全局队列+异步"></a>全局队列+异步</h4><p>全局队列有创建子线程的能力，但是需要异步<code>async</code>去执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局队列+异步</span><br><span class="line">-(void)async_global&#123;</span><br><span class="line">printf(&quot;\n start&quot;);</span><br><span class="line">dispatch_queue_t global_queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(global_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(global_queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(global_queue, ^&#123;</span><br><span class="line">NSThread *thread &#x3D; [NSThread currentThread];</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(NSString *)currentDateString&#123;</span><br><span class="line">NSDate *date&#x3D;[NSDate new];</span><br><span class="line">NSDateFormatter *format &#x3D; [[NSDateFormatter alloc]init];</span><br><span class="line">[format setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">return [format stringFromDate:date];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line"> start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b43dc0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 3</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b44e80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 0</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b45880&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 7</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b44e80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 1</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b45880&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 8</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b43dc0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 4</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b45880&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 9</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b44e80&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 2</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b43dc0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 5</span><br></pre></td></tr></table></figure><p>全局队列当搭配<code>async</code>的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。</p><h4 id="创建串行队列-同步"><a href="#创建串行队列-同步" class="headerlink" title="创建串行队列+同步"></a>创建串行队列+同步</h4><p>开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建串行队列+同步</span><br><span class="line">-(void)sync_cust_queue&#123;</span><br><span class="line">printf(&quot;\n start&quot;);</span><br><span class="line">dispatch_queue_t custQueue &#x3D; dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(custQueue, ^&#123;</span><br><span class="line">NSThread *thread &#x3D; [NSThread currentThread];</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"> 2019-07-24 15:53:15 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 0</span><br><span class="line"> 2019-07-24 15:53:16 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 1</span><br><span class="line"> 2019-07-24 15:53:17 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 2</span><br><span class="line"> 2019-07-24 15:53:18 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 3</span><br><span class="line"> 2019-07-24 15:53:19 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 4</span><br><span class="line"> 2019-07-24 15:53:20 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 5</span><br><span class="line"> 2019-07-24 15:53:21 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 7</span><br><span class="line"> 2019-07-24 15:53:22 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 8</span><br><span class="line"> 2019-07-24 15:53:23 &lt;NSThread: 0x6000017ea940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 9</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p>同步向串行队列添加任务并没有死锁！原因是添加任务是在<code>main_queue</code>执行的，添加的任务是在<code>cust-queue</code>中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在<code>main</code>线程中。</p><h4 id="创建串行队列-异步"><a href="#创建串行队列-异步" class="headerlink" title="创建串行队列+异步"></a>创建串行队列+异步</h4><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建串行队列+异步</span><br><span class="line">-(void)async_cust_queue&#123;</span><br><span class="line">printf(&quot;\n start&quot;);</span><br><span class="line">dispatch_queue_t custQueue &#x3D; dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">NSThread *thread &#x3D; [NSThread currentThread];</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line"> start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 16:12:57 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:12:58 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:12:59 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:13:00 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:13:01 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:13:02 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 5</span><br><span class="line"> 2019-07-24 16:13:03 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 7</span><br><span class="line"> 2019-07-24 16:13:04 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 8</span><br><span class="line"> 2019-07-24 16:13:05 &lt;NSThread: 0x600002b346c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 9</span><br></pre></td></tr></table></figure><p>在<code>异步 + 串行队列</code>可以看到：</p><p>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。<br>所有任务是在打印的<code>end</code>之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</p><h4 id="创建并行队列-同步"><a href="#创建并行队列-同步" class="headerlink" title="创建并行队列+同步"></a>创建并行队列+同步</h4><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">2019-07-24 16:21:24 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 0</span><br><span class="line">2019-07-24 16:21:25 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 1</span><br><span class="line">2019-07-24 16:21:26 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 2</span><br><span class="line">2019-07-24 16:21:27 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 3</span><br><span class="line">2019-07-24 16:21:28 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 4</span><br><span class="line">2019-07-24 16:21:29 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 5</span><br><span class="line">2019-07-24 16:21:30 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 7</span><br><span class="line">2019-07-24 16:21:31 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 8</span><br><span class="line">2019-07-24 16:21:32 &lt;NSThread: 0x6000031d1380&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 9</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>全局队列其实就是特殊的并行队列，这里结果和<code>全局队列+同步</code>一致。</p><h4 id="创建并行队列-异步"><a href="#创建并行队列-异步" class="headerlink" title="创建并行队列+异步"></a>创建并行队列+异步</h4><p>在当前线程中执行任务，会开启新线程，可以同时执行多个任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建并行队列+异步</span><br><span class="line">-(void)async_queue&#123;</span><br><span class="line">printf(&quot;\n start&quot;);</span><br><span class="line">dispatch_queue_t custQueue &#x3D; dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(custQueue, ^&#123;</span><br><span class="line">NSThread *thread &#x3D; [NSThread currentThread];</span><br><span class="line">for (int i &#x3D; 7; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004280c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 7</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004104c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x600000422300&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004104c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004280c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 8</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x600000422300&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004280c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 9</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004104c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x600000422300&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 5</span><br></pre></td></tr></table></figure><p><code>并行队列+异步</code>和<code>全局队列+异步</code>一致，也会新建线程执行任务，且是并发执行。</p><h3 id="GCD其他高级用法"><a href="#GCD其他高级用法" class="headerlink" title="GCD其他高级用法"></a>GCD其他高级用法</h3><h4 id="子线程执行任务-主线程刷新UI"><a href="#子线程执行任务-主线程刷新UI" class="headerlink" title="子线程执行任务 主线程刷新UI"></a>子线程执行任务 主线程刷新UI</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)backToMain&#123;</span><br><span class="line">dispatch_queue_t main &#x3D; dispatch_get_main_queue();</span><br><span class="line">dispatch_queue_t glo &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(glo, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_sync(main, ^&#123;</span><br><span class="line">printf(&quot;\n %s %s 我在刷新UI&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"> 2019-07-24 16:45:07 &lt;NSThread: 0x600001e84380&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:45:08 &lt;NSThread: 0x600001e84380&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001e84380&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001ef2940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 我在刷新UI</span><br></pre></td></tr></table></figure><h4 id="队列分组-dispatch-group-t"><a href="#队列分组-dispatch-group-t" class="headerlink" title="队列分组 dispatch_group_t"></a>队列分组 dispatch_group_t</h4><h5 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h5><p>GCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过<code>dispatch_group_notify</code>完成回调，第一个参数<code>group</code>是某个分组的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(void)group&#123;</span><br><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue&#x3D; dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t queue2&#x3D; dispatch_queue_create(&quot;cust2.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">for (int i &#x3D; 4; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">printf(&quot;\n %s %s ---end1----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 6; i &lt; 8; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">for (int i &#x3D; 8; i &lt; 10; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave"><a href="#dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave" class="headerlink" title="dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave"></a>dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave</h5><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>需要成对使用，否则<code>dispatch_group_wait</code>在缺少<code>leave</code>的情况下会等待到死，造成线程阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">staticdispatch_group_t group ;</span><br><span class="line">if (group &#x3D;&#x3D; nil) &#123;</span><br><span class="line">group &#x3D; dispatch_group_create();</span><br><span class="line">&#125;</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">&#x2F;&#x2F;dispatch_group_enter(group);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[self print];</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">&#x2F;&#x2F;dispatch_group_leave(group);&#x2F;&#x2F;当注释掉  阻塞在wait不继续向下执行</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[self print];</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-25 10:58:50 &lt;NSThread: 0x600002d84180&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">2019-07-25 10:58:52 &lt;NSThread: 0x600002d84180&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h4 id="栅栏函数-dispatch-barrier-sync"><a href="#栅栏函数-dispatch-barrier-sync" class="headerlink" title="栅栏函数 dispatch_barrier_sync"></a>栅栏函数 dispatch_barrier_sync</h4><p>栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)barry&#123;</span><br><span class="line">dispatch_queue_t queue&#x3D; dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">printf(&quot;\n %s %s ---中间暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i &#x3D; 3; i &lt; 6; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">printf(&quot;\n %s %s ---中间第二次暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"> 2019-07-24 16:52:33 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:52:34 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x6000031293c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; ---中间暂停一下----</span><br><span class="line"> 2019-07-24 16:52:36 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:52:37 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 5</span><br><span class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; ---中间第二次暂停一下----</span><br></pre></td></tr></table></figure><h4 id="单例-执行一次的函数-dispatch-once-t"><a href="#单例-执行一次的函数-dispatch-once-t" class="headerlink" title="单例-执行一次的函数 dispatch_once_t"></a>单例-执行一次的函数 dispatch_once_t</h4><p>单例可以通过这个函数实现，只执行一次的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只执行一次的dispatch_once</span><br><span class="line">-(void)exc_once&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static NSObject *obj;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">obj&#x3D;[NSObject new];</span><br><span class="line">printf(&quot;\n just once %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line">调用4次</span><br><span class="line">dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">[self exc_once];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">just once 2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br></pre></td></tr></table></figure><p>当调用4次的时候，日志打印的四次<code>obj</code>均为同一个地址，证明<code>block</code>回调四次但是只执行了一次。</p><h4 id="延迟执行-dispatch-after"><a href="#延迟执行-dispatch-after" class="headerlink" title="延迟执行 dispatch_after"></a>延迟执行 dispatch_after</h4><p>当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;延迟执行</span><br><span class="line">-(void)delayTimeExc&#123;</span><br><span class="line">printf(&quot;\n %s %s begin&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n %s %s&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">printf(&quot;\n %s %s end&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; begin</span><br><span class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; end</span><br><span class="line">2019-07-24 17:07:50 &lt;NSThread: 0x600003cc6940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量-dispatch-semaphore-t"><a href="#信号量-dispatch-semaphore-t" class="headerlink" title="信号量  dispatch_semaphore_t"></a>信号量  dispatch_semaphore_t</h4><p>信号量为1可以作为线程锁来用，当N&gt;1的时候，同时执行的有N个任务。<br><code>dispatch_apply</code>可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;信号量 当信号量为1 可以未做锁来用，当N&gt;1，t通知执行的数量则是数字N。</span><br><span class="line">- (void)semaphore&#123;</span><br><span class="line">static dispatch_semaphore_t sem;</span><br><span class="line">if (sem &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">sem &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">static int i &#x3D; 0;</span><br><span class="line">int currentI &#x3D; i +2;</span><br><span class="line">for (; i &lt; currentI; i ++) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_signal(sem);</span><br><span class="line">&#125;</span><br><span class="line">-(void)asyn_semaphore&#123;</span><br><span class="line">dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">[self semaphore];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">2019-07-24 17:25:04 &lt;NSThread: 0x6000002a2940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 0</span><br><span class="line">2019-07-24 17:25:05 &lt;NSThread: 0x6000002a2940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 1</span><br><span class="line">2019-07-24 17:25:06 &lt;NSThread: 0x6000002e2b40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 2</span><br><span class="line">2019-07-24 17:25:07 &lt;NSThread: 0x6000002e2b40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 3</span><br><span class="line">2019-07-24 17:25:08 &lt;NSThread: 0x6000002d4740&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 4</span><br><span class="line">2019-07-24 17:25:09 &lt;NSThread: 0x6000002d4740&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 5</span><br></pre></td></tr></table></figure><p>设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-(void)muchQueueBuyTick&#123;</span><br><span class="line">dispatch_queue_t queue&#x3D; dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">[self semaphore_buy_ticks:4];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_queue_t queue2&#x3D; dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">[self semaphore_buy_ticks:2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)semaphore_buy_ticks:(NSInteger)windowsCount&#123;</span><br><span class="line">static dispatch_semaphore_t sem;</span><br><span class="line">if (sem &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">sem &#x3D; dispatch_semaphore_create(windowsCount);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;信号量-1</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">self.count--;</span><br><span class="line">if (self.count &gt; 0) &#123;</span><br><span class="line">printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;信号量+1</span><br><span class="line">dispatch_semaphore_signal(sem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">2019-07-24 18:01:44 &lt;NSThread: 0x600003935e00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:01:44 &lt;NSThread: 0x600003904c40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第0个人买到票了</span><br></pre></td></tr></table></figure><p>两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。<br>当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)muchQueueBuyTick&#123;</span><br><span class="line">dispatch_queue_t queue&#x3D; dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">[self semaphore_buy_ticks:1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_queue_t queue2&#x3D; dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">[self semaphore_buy_ticks:1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-24 18:03:56 &lt;NSThread: 0x600000e1cac0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第9个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第7个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第5个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第3个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; 第1个人买到票了</span><br></pre></td></tr></table></figure><p>顺序是对了，数量也对了。</p><p>再换一种思路实现锁住窗口，我们使用串行队列也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用同步队列卖票</span><br><span class="line">- (void)sync_buy_tick&#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">self.count--;</span><br><span class="line">if (self.count &gt; 0) &#123;</span><br><span class="line">printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</span><br><span class="line">[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第9个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第7个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第5个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第3个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; 第1个人买到票了</span><br></pre></td></tr></table></figure><p>串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。</p><h4 id="快速迭代方法：dispatch-apply"><a href="#快速迭代方法：dispatch-apply" class="headerlink" title="快速迭代方法：dispatch_apply"></a>快速迭代方法：dispatch_apply</h4><p>快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">同时新建了多条线程来做任务</span><br><span class="line">*&#x2F;</span><br><span class="line">dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">printf(&quot;\n %s %s &quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000979dc0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000090d3c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000095cfc0&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000950140&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000095d0c0&gt;&#123;number &#x3D; 9, name &#x3D; (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a400&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><p>可以看到新建了<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>、<code>main</code>来执行任务。</p><h3 id="多线程RunLoop实战"><a href="#多线程RunLoop实战" class="headerlink" title="多线程RunLoop实战"></a>多线程RunLoop实战</h3><p>问题一：请问下边代码输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    dispatch_queue_t  que&#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>猜想1：结果是<code>123</code></li><li>猜想2：结果是<code>132</code></li></ul><p>有没有第三种结果呢？</p><p>猜想1分析：<br>因为是延迟<code>0</code>s执行，当然是先执行<code>2</code>，再执行<code>3</code>了。</p><p>猜想2分析：</p><p>我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出<code>1</code>，然后输出<code>3</code>，最后输出<code>2</code>.</p><p>最后验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在<code>runloop.h</code>文件中，我们猜测延迟执行是<code>timer</code>添加到<code>runloop</code>中了，添加进去也应该输出<code>132</code>的。因为在子线程中，没有主动调用不会有<code>runloop</code>的，及时调用了也需要保活技术，那么代码改进一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t  que&#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        &#x2F;&#x2F; 相当于[self test];</span><br><span class="line">&#x2F;&#x2F;       [self performSelector:@selector(test) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>经测试输出了<code>12</code>，这和我们猜想的还是不对，原来输出<code>3</code>放在了最后，导致的问题，<code>RunLoop</code>运行起来，进入了循环，则后面的就不会执行了，除非停止当前<code>RunLoop</code>，我们再改进一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t  que&#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        &#x2F;&#x2F; 相当于[self test];</span><br><span class="line">&#x2F;&#x2F;       [self performSelector:@selector(test) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">         NSLog(@&quot;3&quot;);</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>最后终于输出了<code>132</code>。缺点是子线程成了<strong>死待</strong>，不死之身，关于怎么杀死<strong>死待</strong>请看<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDM1YjM0N2YyNjVkYTFiODYwOGM0OWI=" title="https://juejin.im/post/5d35b347f265da1b8608c49b">上篇优雅控制RunLoop生命周期<i class="fa fa-external-link"></i></span>。<br>关于<code>performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>中有延迟的，都是添加到当前你线程的<code>RunLoop</code>，如果没有启动<code>RunLoop</code>和保活恐怕也不能一直执行。<code>[self performSelector:@selector(test) withObject:nil]</code>是在<code>Foudation</code>中，源码是直接<code>objc_msgSend()</code>，相当于直接<code>[self test]</code>，不会有延迟。</p><p>问题2：请问输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread&#x3D;[[NSThread alloc]initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self performSelector:@selector(test)</span><br><span class="line">             onThread:thread</span><br><span class="line">           withObject:nil</span><br><span class="line">        waitUntilDone:YES];</span><br></pre></td></tr></table></figure><p>这个和上面的类似，结果是打印了<code>1</code>就崩溃了，原因是<code>thread start</code>之后执行完<code>block</code>就结束了，没有<code>runloop</code>的支撑。当执行<code>performSelector</code>的时候，线程已经死掉。解决这个问题只需要向子线程中添加<code>RunLoop</code>，而且保证<code>RunLoop</code>不停止就行了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI</li><li>队列多任务异步执行最后全局执行完毕可以使用<code>group_notify</code>来监听执行完毕时间</li><li>队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用<code>dispatch_barrier_sync</code></li><li>当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTkwZGU2OGYyNjVkYTRlOWI1OTJiNDAjaGVhZGluZy0xNg==" title="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16">iOS多线程：『GCD』详尽总结<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy41MjBpdC5jb20venQvaW9zX21qLw==" title="http://www.520it.com/zt/ios_mj/">小码哥视频<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2F3YXlxdS4xMDI0dWwuY29tL2lvcy8yMDE4LzA1LzAyL2djZC0zLmh0bWw=" title="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html">任务调度<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=" title="https://opensource.apple.com/tarballs/libdispatch/">libdispatch<i class="fa fa-external-link"></i></span></li><li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;RunLoop&lt;/code&gt;和线程的关系，以及&lt;code&gt;Thread&lt;/code&gt;如何保活和控制生命周期，今天我们再探究下另外的一个线程&lt;code&gt;GCD&lt;/code&gt;，揭开蒙娜丽莎的面纱。&lt;/p&gt;
&lt;h3 id=&quot;GCD-基础知识&quot;&gt;&lt;a href=&quot;#GC
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20RunLoop%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%92%8C%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2%E6%8E%8C%E6%8F%A1%E5%AD%90%E7%BA%BF%E7%A8%8BRunLoop%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%20--(9)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20RunLoop%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%92%8C%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2%E6%8E%8C%E6%8F%A1%E5%AD%90%E7%BA%BF%E7%A8%8BRunLoop%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%20--(9)/</id>
    <published>2019-12-01T03:19:58.000Z</published>
    <updated>2020-09-04T04:40:21.658Z</updated>
    
    <content type="html"><![CDATA[<p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p><h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ret &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">    &#x2F;&#x2F;睡眠中等待消息</span><br><span class="line">    int messgae &#x3D; sleep_and_wait();</span><br><span class="line">    &#x2F;&#x2F;处理消息</span><br><span class="line">    ret &#x3D; process_message(messgae);</span><br><span class="line">&#125; while (ret &#x3D;&#x3D; 0);</span><br></pre></td></tr></table></figure><h3 id="获取runloop"><a href="#获取runloop" class="headerlink" title="获取runloop"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop * runloop1 &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">NSRunLoop *mainloop1 &#x3D; [NSRunLoop mainRunLoop];</span><br><span class="line"></span><br><span class="line">CFRunLoopRef runloop2&#x3D; CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopRef mainloop2 &#x3D; CFRunLoopGetMain();</span><br><span class="line">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</span><br><span class="line">NSLog(@&quot;%@&quot;,runloop1);</span><br><span class="line">&#x2F;&#x2F;打印</span><br><span class="line">runlopp1:0x600001bc58c0 </span><br><span class="line">mainloop1:0x600001bc58c0 </span><br><span class="line">runloop2:0x6000003cc300 </span><br><span class="line">mainloop1:0x6000003cc300</span><br><span class="line"></span><br><span class="line">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</span><br></pre></td></tr></table></figure><p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p><p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9DRi8=" title="https://opensource.apple.com/tarballs/CF/">源码(可以下载最新的源码)<i class="fa fa-external-link"></i></span>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;&#x2F;* model list 锁 *&#x2F;</span><br><span class="line">    __CFPort _wakeUpPort;&#x2F;&#x2F; 接受 CFRunLoopWakeUp的端口</span><br><span class="line">    Boolean _unused;&#x2F;&#x2F;是否使用</span><br><span class="line">    volatile _per_run_data *_perRunData;              &#x2F;&#x2F; reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread; &#x2F;&#x2F;线程</span><br><span class="line">    uint32_t _winthread;&#x2F;&#x2F;win线程</span><br><span class="line">    CFMutableSetRef _commonModes; &#x2F;&#x2F;modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F;modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; &#x2F;&#x2F;当前的mode</span><br><span class="line">    CFMutableSetRef _modes; &#x2F;&#x2F;所有的modes</span><br><span class="line">    struct _block_item *_blocks_head; &#x2F;&#x2F;待执行的block列表头部</span><br><span class="line">    struct _block_item *_blocks_tail; &#x2F;&#x2F;待执行的block 尾部</span><br><span class="line">    CFAbsoluteTime _runTime; &#x2F;&#x2F;runtime</span><br><span class="line">    CFAbsoluteTime _sleepTime; &#x2F;&#x2F;sleeptime</span><br><span class="line">    CFTypeRef _counterpart; &#x2F;&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过简化之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread; &#x2F;&#x2F;线程</span><br><span class="line">    CFMutableSetRef _commonModes; &#x2F;&#x2F;modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F;modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; &#x2F;&#x2F;当前的mode</span><br><span class="line">    CFMutableSetRef _modes; &#x2F;&#x2F;所有的modes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li><li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li><li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li></ol><p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;&#x2F;* must have the run loop locked before locking this *&#x2F;</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; &#x2F;&#x2F; set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; &#x2F;* TSR *&#x2F;</span><br><span class="line">    uint64_t _timerHardDeadline; &#x2F;* TSR *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过简化之后是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;&#x2F;&#x2F;当前mode的名字</span><br><span class="line">    CFMutableSetRef _sources0;&#x2F;&#x2F;souces0</span><br><span class="line">    CFMutableSetRef _sources1;&#x2F;&#x2F;sources1</span><br><span class="line">    CFMutableArrayRef _observers;&#x2F;&#x2F;observers</span><br><span class="line">    CFMutableArrayRef _timers;&#x2F;&#x2F;timers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p><p><img src="/images/9-1.png" alt></p><p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p><h4 id="souces0"><a href="#souces0" class="headerlink" title="souces0"></a>souces0</h4><ul><li>触摸事件</li><li>performSelector:onThread:</li></ul><p>测试下点击事件处理源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);&#x2F;&#x2F;此处断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(LLDB) bt &#x2F;&#x2F;输出当前调用栈</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">  * frame #0: 0x000000010c5bb66d CFRunloop&#96;::-[ViewController touchesBegan:withEvent:](self&#x3D;0x00007fc69ec087e0, _cmd&#x3D;&quot;touchesBegan:withEvent:&quot;, touches&#x3D;1 element, event&#x3D;0x00006000012a01b0) at ViewController.mm:22:2</span><br><span class="line">    frame #1: 0x0000000110685a09 UIKitCore&#96;forwardTouchMethod + 353</span><br><span class="line">    frame #2: 0x0000000110685897 UIKitCore&#96;-[UIResponder touchesBegan:withEvent:] + 49</span><br><span class="line">    frame #3: 0x0000000110694c48 UIKitCore&#96;-[UIWindow _sendTouchesForEvent:] + 1869</span><br><span class="line">    frame #4: 0x00000001106965d2 UIKitCore&#96;-[UIWindow sendEvent:] + 4079</span><br><span class="line">    frame #5: 0x0000000110674d16 UIKitCore&#96;-[UIApplication sendEvent:] + 356</span><br><span class="line">    frame #6: 0x0000000110745293 UIKitCore&#96;__dispatchPreprocessedEventFromEventQueue + 3232</span><br><span class="line">    frame #7: 0x0000000110747bb9 UIKitCore&#96;__handleEventQueueInternal + 5911</span><br><span class="line">    frame #8: 0x000000010d8eabe1 CoreFoundation&#96;__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</span><br><span class="line">    frame #9: 0x000000010d8ea463 CoreFoundation&#96;__CFRunLoopDoSources0 + 243</span><br><span class="line">    frame #10: 0x000000010d8e4b1f CoreFoundation&#96;__CFRunLoopRun + 1231</span><br><span class="line">    frame #11: 0x000000010d8e4302 CoreFoundation&#96;CFRunLoopRunSpecific + 626</span><br><span class="line">    frame #12: 0x0000000115ddc2fe GraphicsServices&#96;GSEventRunModal + 65</span><br><span class="line">    frame #13: 0x000000011065aba2 UIKitCore&#96;UIApplicationMain + 140</span><br><span class="line">    frame #14: 0x000000010c5bb760 CFRunloop&#96;main(argc&#x3D;1, argv&#x3D;0x00007ffee3643f68) at main.m:14:13</span><br><span class="line">    frame #15: 0x000000010f1cb541 libdyld.dylib&#96;start + 1</span><br><span class="line">    frame #16: 0x000000010f1cb541 libdyld.dylib&#96;start + 1</span><br></pre></td></tr></table></figure><p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p><h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul><li>基于Port的线程间通信</li><li>系统事件捕捉</li></ul><h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul><li>NSTimer</li><li>performSelector:withObject:afterDelay:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">static int count &#x3D; 5;</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">NSLog(@&quot;-------：%d \n&quot;,count++);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">  * frame #0: 0x0000000101f26457 CFRunloop&#96;::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor&#x3D;0x0000000101f28100) at ViewController.mm:72:33</span><br><span class="line">    frame #1: 0x0000000104ac2db5 libdispatch.dylib&#96;_dispatch_client_callout + 8</span><br><span class="line">    frame #2: 0x0000000104ac5c95 libdispatch.dylib&#96;_dispatch_continuation_pop + 552</span><br><span class="line">    frame #3: 0x0000000104ad7e93 libdispatch.dylib&#96;_dispatch_source_invoke + 2249</span><br><span class="line">    frame #4: 0x0000000104acfead libdispatch.dylib&#96;_dispatch_main_queue_callback_4CF + 1073</span><br><span class="line">    frame #5: 0x00000001032568a9 CoreFoundation&#96;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</span><br><span class="line">    frame #6: 0x0000000103250f56 CoreFoundation&#96;__CFRunLoopRun + 2310</span><br><span class="line">    frame #7: 0x0000000103250302 CoreFoundation&#96;CFRunLoopRunSpecific + 626</span><br></pre></td></tr></table></figure><p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=" title="https://opensource.apple.com/tarballs/libdispatch/">libdispatch<i class="fa fa-external-link"></i></span>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p><h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul><li>用于监听RunLoop的状态</li><li>UI刷新（BeforeWaiting）</li><li>Autorelease pool（BeforeWaiting）</li></ul><p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</span><br><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</span><br></pre></td></tr></table></figure><p>那么这两个Mode都是在什么情况下运行的呢？</p><ol><li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li><li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li></ol><p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F;即将进入loop</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),&#x2F;&#x2F;即将处理timers</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F;即将处理sourcs</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),&#x2F;&#x2F;即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),&#x2F;&#x2F;即将从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),&#x2F;&#x2F;即将退出</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU&#x2F;&#x2F;所有状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDJiY2YzZGYyNjVkYTFiNjcyMTNkNjk=" title="https://juejin.im/post/5d2bcf3df265da1b67213d69">位域或者联合体<i class="fa fa-external-link"></i></span>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p><p>现在我们了解到：</p><ol><li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li><li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li><li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li><li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li><li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li><li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li></ol><h5 id="runloop切换Mode"><a href="#runloop切换Mode" class="headerlink" title="runloop切换Mode"></a>runloop切换Mode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverRef obs&#x3D; CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">    case kCFRunLoopEntry:&#123;</span><br><span class="line">    CFRunLoopMode m &#x3D; CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;即将进入 mode:%@&quot;,m);</span><br><span class="line">    CFRelease(m);</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    case kCFRunLoopExit:</span><br><span class="line">    &#123;</span><br><span class="line">    CFRunLoopMode m &#x3D; CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;即将退出 mode:%@&quot;,m);</span><br><span class="line">    CFRelease(m);</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</span><br><span class="line">CFRelease(obs);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当滑动tb的时候log</span><br><span class="line"></span><br><span class="line">即将退出 mode:kCFRunLoopDefaultMode</span><br><span class="line">即将进入 mode:UITrackingRunLoopMode</span><br><span class="line">即将退出 mode:UITrackingRunLoopMode</span><br><span class="line">即将进入 mode:kCFRunLoopDefaultMode</span><br></pre></td></tr></table></figure><p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p><p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;获取loop</span><br><span class="line">CFRunLoopRef ref &#x3D; CFRunLoopGetMain();</span><br><span class="line">&#x2F;&#x2F;获取obs</span><br><span class="line">CFRunLoopObserverRef obs &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</span><br><span class="line">&#x2F;&#x2F;添加监听</span><br><span class="line">CFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</span><br><span class="line">CFRelease(obs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int count &#x3D; 0;&#x2F;&#x2F;定义全局变量来计算一个mode中状态切换的统计数据</span><br><span class="line">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line">printf(&quot;- &quot;);</span><br><span class="line">count ++;</span><br><span class="line">printf(&quot;%d&quot;,count);</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry:</span><br><span class="line">printf(&quot;即将进入 \n&quot;);</span><br><span class="line">count &#x3D; 0;</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopExit:</span><br><span class="line">printf(&quot;即将退出 \n&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">printf(&quot;即将从休眠中唤醒 \n&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeTimers:</span><br><span class="line">printf(&quot;即将进入处理 timers \n&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeSources:</span><br><span class="line">printf(&quot;即将进入 sources \n&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeWaiting:</span><br><span class="line">printf(&quot;即将进入 休眠 \n&quot;);</span><br><span class="line">count &#x3D; 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击的时候 会出发loop来处理触摸事件</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入处理 timers </span><br><span class="line">- 7即将进入 sources </span><br><span class="line">- 8即将进入处理 timers </span><br><span class="line">- 9即将进入 sources </span><br><span class="line">- 10即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入 休眠</span><br></pre></td></tr></table></figure><p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p><h5 id="RunLoop在不获取的时候不存在-获取才生成"><a href="#RunLoop在不获取的时候不存在-获取才生成" class="headerlink" title="RunLoop在不获取的时候不存在,获取才生成"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl &#x3D; (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p><p>首先看官方给的图：</p><p><img src="/images/9-2.png" alt><br>那我又整理了一个表格来更直观的了解状态运转</p><table><thead><tr><th style="text-align:center">步骤</th><th style="text-align:center">任务</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">通知Observers:进入Loop</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">通知Observers:即将处理Timers</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">通知Observers:即将处理Sources</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">处理blocks</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">处理Source0(可能再处理Blocks)</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">如果存在Source1，跳转第8步</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">通知Observers:开始休眠</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">处理Blocks</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">根据前面的执行结果，决定如何操作1.返回第2步，2退出loop</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">通知Observers:退出Loop</td></tr></tbody></table><p>查看<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9DRi8=" title="https://opensource.apple.com/tarballs/CF/">runloop源码<i class="fa fa-external-link"></i></span>中<code>runloop.c</code>2333行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR &#x3D; mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort &#x3D; MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe &#x3D; pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL &#x3D;&#x3D; previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 &#x3D;&#x3D; _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() &#x3D;&#x3D; rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort &#x3D; _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    mach_port_name_t modeQueuePort &#x3D; MACH_PORT_NULL;</span><br><span class="line">    if (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort &#x3D; _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        if (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer &#x3D; NULL;</span><br><span class="line">    struct __timeout_context *timeout_context &#x3D; (struct __timeout_context *)malloc(sizeof(*timeout_context));</span><br><span class="line">    if (seconds &lt;&#x3D; 0.0) &#123; &#x2F;&#x2F; instant timeout</span><br><span class="line">        seconds &#x3D; 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR &#x3D; 0ULL;</span><br><span class="line">    &#125; else if (seconds &lt;&#x3D; TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">dispatch_queue_t queue &#x3D; pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">timeout_timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">timeout_context-&gt;ds &#x3D; timeout_timer;</span><br><span class="line">timeout_context-&gt;rl &#x3D; (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">timeout_context-&gt;termTSR &#x3D; startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">dispatch_set_context(timeout_timer, timeout_context); &#x2F;&#x2F; source gets ownership of context</span><br><span class="line">dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at &#x3D; (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; infinite timeout</span><br><span class="line">        seconds &#x3D; 9999999999.0;</span><br><span class="line">        timeout_context-&gt;termTSR &#x3D; UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean didDispatchPortLastTime &#x3D; true;</span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    do &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_state_t voucherState &#x3D; VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy &#x3D; NULL;</span><br><span class="line">#endif</span><br><span class="line">        uint8_t msg_buffer[3 * 1024];</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        mach_msg_header_t *msg &#x3D; NULL;</span><br><span class="line">        mach_port_t livePort &#x3D; MACH_PORT_NULL;</span><br><span class="line">#endif</span><br><span class="line">__CFPortSet waitSet &#x3D; rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">&#x2F;&#x2F;通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">&#x2F;&#x2F;通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">&#x2F;&#x2F;处理Blocks</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#x2F;&#x2F;处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">&#x2F;&#x2F;处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#125;</span><br><span class="line">        Boolean poll &#x3D; sourceHandledThisLoop || (0ULL &#x3D;&#x3D; timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL !&#x3D; dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            msg &#x3D; (mach_msg_header_t *)msg_buffer;</span><br><span class="line">&#x2F;&#x2F;y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">&#x2F;&#x2F;有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        didDispatchPortLastTime &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;即将进入休眠</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#x2F;&#x2F;开始休眠</span><br><span class="line">__CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">    __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">__CFRunLoopModeUnlock(rlm);</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart &#x3D; poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line"></span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg &#x3D; (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            &#x2F;&#x2F;等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">            if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;</span><br><span class="line"></span><br><span class="line">                    rlm-&gt;_timerFired &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (msg &amp;&amp; msg !&#x3D; (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">        if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg &#x3D; (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        rl-&gt;_sleepTime +&#x3D; (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; user callouts now OK again</span><br><span class="line">__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">&#x2F;&#x2F;结束休眠</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">&#x2F;&#x2F;标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL &#x3D;&#x3D; livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            &#x2F;&#x2F; handle nothing</span><br><span class="line">        &#125; else if (livePort &#x3D;&#x3D; rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        else if (modeQueuePort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; modeQueuePort) &#123;</span><br><span class="line">&#x2F;&#x2F;被timer唤醒</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F;被GCD换醒</span><br><span class="line">        else if (livePort &#x3D;&#x3D; dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</span><br><span class="line">&#x2F;&#x2F;处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop &#x3D; true;</span><br><span class="line">            didDispatchPortLastTime &#x3D; true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;处理Source1</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line"></span><br><span class="line">            voucher_t previousVoucher &#x3D; _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">mach_msg_header_t *reply &#x3D; NULL;</span><br><span class="line">sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">if (NULL !&#x3D; reply) &#123;</span><br><span class="line">    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;处理bBlock</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;设置返回值</span><br><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">    &#125; while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过及进一步精简</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR &#x3D; mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime &#x3D; true;</span><br><span class="line">    int32_t retVal &#x3D; 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">&#x2F;&#x2F;通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">&#x2F;&#x2F;通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">&#x2F;&#x2F;处理Blocks</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#x2F;&#x2F;处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">&#x2F;&#x2F;处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#125;</span><br><span class="line">            msg &#x3D; (mach_msg_header_t *)msg_buffer;</span><br><span class="line">&#x2F;&#x2F;y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">&#x2F;&#x2F;有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;即将进入休眠</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#x2F;&#x2F;开始休眠</span><br><span class="line">__CFRunLoopSetSleeping(rl);</span><br><span class="line">        do &#123;</span><br><span class="line">    &#x2F;&#x2F;等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">&#x2F;&#x2F;结束休眠</span><br><span class="line">__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">&#x2F;&#x2F;标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">&#x2F;&#x2F;被timer唤醒</span><br><span class="line">CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort !&#x3D; MACH_PORT_NULL &amp;&amp; livePort &#x3D;&#x3D; rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F;被GCD换醒</span><br><span class="line">        else if (livePort &#x3D;&#x3D; dispatchPort) &#123;</span><br><span class="line">&#x2F;&#x2F;处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            CFRunLoopSourceRef rls &#x3D; __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">&#x2F;&#x2F;处理Source1</span><br><span class="line">sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            &#x2F;&#x2F; Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;处理bBlock</span><br><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F;设置返回值</span><br><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped &#x3D; false;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">    retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line">    &#125; while (0 &#x3D;&#x3D; retVal);</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<span class="exturl" data-url="aHR0cDovL3dlYi5taXQuZWR1L2Rhcndpbi9zcmMvbW9kdWxlcy94bnUvb3NmbWsvbWFuL21hY2hfbXNnLmh0bWw=" title="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html">mach_msg()<i class="fa fa-external-link"></i></span>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p><h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p><h5 id="timer保活和多mode运行"><a href="#timer保活和多mode运行" class="headerlink" title="timer保活和多mode运行"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int i &#x3D; 0;</span><br><span class="line">NSTimer *timer&#x3D;[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">NSLog(@&quot;%d&quot;,++i);</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</span><br><span class="line">&#x2F;&#x2F;timer在设置为common模式下能运行</span><br><span class="line">&#x2F;&#x2F;NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</span><br><span class="line">&#x2F;&#x2F;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];&#x2F;&#x2F;默认的模式</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</span><br><span class="line">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</span><br><span class="line">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</span><br><span class="line">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</span><br><span class="line">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</span><br><span class="line">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</span><br><span class="line">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</span><br><span class="line">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</span><br></pre></td></tr></table></figure><p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</span><br><span class="line">dispatch_source_cancel(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p><p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p><p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (CFStringGetTypeID() &#x3D;&#x3D; CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">    doit &#x3D; CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    doit &#x3D; CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p><h5 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </span><br><span class="line">                            forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p><p>验证线程保活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) FYThread *thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">self.thread&#x3D;[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">_thread.name &#x3D; @&quot;test thread&quot;;</span><br><span class="line">[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">&#x2F;&#x2F;添加端口</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">NSLog(@&quot;--start--&quot;);</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">NSLog(@&quot;执行完毕了子线程&quot;);&#x2F;&#x2F;不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">&#x2F;&#x2F;注释掉添加端口代码</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number &#x3D; 3, name &#x3D; test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">--end--</span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注释放开的时候点击触发log</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number &#x3D; 3, name &#x3D; test thread&#125;</span><br><span class="line">--start--</span><br><span class="line"></span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number &#x3D; 3, name &#x3D; test thread&#125;</span><br></pre></td></tr></table></figure><p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p><p>那我们测试下该线程声明周期多长？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">self.thread&#x3D;[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">_thread.name &#x3D; @&quot;test thread&quot;;</span><br><span class="line">[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#x2F;&#x2F;获取obs</span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">NSLog(@&quot;--start--&quot;);</span><br><span class="line">&#x2F;*</span><br><span class="line"> If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</span><br><span class="line"> *&#x2F;</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">NSLog(@&quot;执行完毕了子线程&quot;);&#x2F;&#x2F;不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600003394780&gt;&#123;number &#x3D; 3, name &#x3D; test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController stop]</span><br></pre></td></tr></table></figure><p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p><p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p><blockquote><p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p></blockquote><p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL shouldKeepRunning &#x3D; YES; &#x2F;&#x2F; global</span><br><span class="line">NSRunLoop *theRL &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br></pre></td></tr></table></figure><p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#x2F;&#x2F;获取obs</span><br><span class="line">NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">NSLog(@&quot;--start--&quot;);</span><br><span class="line">self.shouldKeepRunning &#x3D; YES;&#x2F;&#x2F;默认运行</span><br><span class="line">NSRunLoop *theRL &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">while (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line">NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">NSLog(@&quot;执行完毕了子线程&quot;);&#x2F;&#x2F;不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">self.shouldKeepRunning &#x3D; NO;</span><br><span class="line">[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)pop&#123;</span><br><span class="line">[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600002699fc0&gt;&#123;number &#x3D; 3, name &#x3D; test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">--end--</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure><p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    if (self.thread &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)stopThread&#123;</span><br><span class="line">    self.shouldKeepRunning &#x3D; NO;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self stop];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) __weakSelf &#x3D; self;</span><br><span class="line">self.thread &#x3D; [[FYThread alloc]initWithBlock:^&#123;</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;--start--&quot;);</span><br><span class="line">    __weakSelf.shouldKeepRunning &#x3D; YES;&#x2F;&#x2F;默认运行</span><br><span class="line">    NSRunLoop *theRL &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>测试下崩溃了，崩溃到了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (__weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#x2F;&#x2F;崩溃的地方</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">--end--</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure><p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p><h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9DRi8=" title="https://opensource.apple.com/tarballs/CF/">runloop源码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy41MjBpdC5jb20venQvaW9zX21qLw==" title="http://www.520it.com/zt/ios_mj/">小码哥视频<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2F3YXlxdS4xMDI0dWwuY29tL2lvcy8yMDE4LzA1LzAyL2djZC0zLmh0bWw=" title="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html">任务调度<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=" title="https://opensource.apple.com/tarballs/libdispatch/">libdispatch<i class="fa fa-external-link"></i></span><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9PQyVFNiU5QyVBQyVFOCVCNCVBOC9kYXkxNC1DRlJ1bmxvb3AlRTclQkElQkYlRTclQTglOEIlRTQlQkYlOUQlRTYlQjQlQkIlRTUlQjAlODElRTglQTMlODUlRTclOUElODRjJUU4JUFGJUFEJUU4JUE4JTgw" title="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80">thread保活c语言版本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9PQyVFNiU5QyVBQyVFOCVCNCVBOC9kYXkxNC1DRlJ1bmxvb3AlRTclQkElQkYlRTclQTglOEIlRTQlQkYlOUQlRTYlQjQlQkIlRTUlQjAlODElRTglQTMlODU=" title="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85">thread 保活<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的&lt;code&gt;jsonToModel&lt;/code&gt;,&lt;code&gt;iOS&lt;/code&gt;除了&lt;code&gt;runtime&lt;/code&gt;还有一个东西的叫做&lt;code&gt;runloop&lt;/code&gt;，各位看官老爷一定都有了解，
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理 runtime - super、hook、以及简单应用--(8)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime%20-%20super%E3%80%81hook%E3%80%81%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8--(8)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime%20-%20super%E3%80%81hook%E3%80%81%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8--(8)/</id>
    <published>2019-12-01T03:18:58.000Z</published>
    <updated>2020-09-04T04:40:21.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h3><p>关键字<code>super</code>,在调用<code>[super init]</code>的时候，<code>super</code>会转化成结构体<code>__rw_objc_super</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __rw_objc_super &#123; </span><br><span class="line">struct objc_object *object; &#x2F;&#x2F;消息接受者</span><br><span class="line">struct objc_object *superClass; &#x2F;&#x2F;父类</span><br><span class="line">__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>[super init]</code>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m</code>转化成<code>cpp</code><br>打开<code>cpp</code>大概在底部的位置找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</span><br></pre></td></tr></table></figure><p>简化之后是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void *)objc_msgSendSuper((__rw_objc_super)&#123;self, class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</span><br></pre></td></tr></table></figure><p><code>voidobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )</code><br>    其实是向父类发送消息，参数是<code>struct objc_super *super, SEL op, ...</code>，我们源码中找到了该函数的实现在<code>objc-msg-arm64.s</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line">UNWIND _objc_msgSendSuper, NoFrame</span><br><span class="line">&#x2F;&#x2F;根据结构体struct __rw_objc_super </span><br><span class="line">&#123; </span><br><span class="line">&#x2F;&#x2F;struct objc_object *object; &#x2F;&#x2F;消息接受者</span><br><span class="line">&#x2F;&#x2F;struct objc_object *superClass; &#x2F;&#x2F;父类</span><br><span class="line">&#125;占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，</span><br><span class="line">&#x2F;&#x2F;使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</span><br><span class="line">ldpp0, p16, [x0]&#x2F;&#x2F; p0 &#x3D; self , p16 &#x3D; superclass</span><br><span class="line"></span><br><span class="line">CacheLookup NORMAL&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure><p>将<code>self</code>和<code>superclass</code>赋值给 <code>p0, p16</code>调用<code>CacheLookup NORMAL</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup &#x2F;&#x2F;.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</span><br><span class="line">&#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa</span><br><span class="line">ldpp10, p11, [x16, #CACHE]&#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">andw11, w11, 0xffff&#x2F;&#x2F; p11 &#x3D; mask</span><br><span class="line">#endif</span><br><span class="line">andw12, w1, w11&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">addp12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">             &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:cmpp9, p1&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">b.ne2f&#x2F;&#x2F;     scan more</span><br><span class="line">CacheHit $0&#x2F;&#x2F; call or return imp 命中 调用或者返回imp</span><br><span class="line"></span><br><span class="line">2:&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket 没有命中</span><br><span class="line">CheckMiss $0&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">cmpp12, p10&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">b1b&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:&#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask</span><br><span class="line">addp12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">                        &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">&#x2F;&#x2F; The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:cmpp9, p1&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">b.ne2f&#x2F;&#x2F;     scan more</span><br><span class="line">CacheHit $0&#x2F;&#x2F; call or return imp</span><br><span class="line"></span><br><span class="line">2:&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket</span><br><span class="line">CheckMiss $0&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">cmpp12, p10&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">b1b&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:&#x2F;&#x2F; double wrap</span><br><span class="line">JumpMiss $0</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>汇编比较多，只看到第二行<code>p1 = SEL, p16 = isa</code>，查找缓存是从<code>p16</code>,也就是<code>superclass</code>开始查找，后边的都和<code>objc_msgSend</code>一样。<br>大致上比较清楚了，<code>super</code>本质上调用了<code>objc_msgSendSuper</code>，<code>objc_msgSendSuper</code>是查找从父类开始查找方法。</p><p><code>[super init]</code>就是<code>self</code>直接调用父类<code>init</code>的方法，但是<code>objc_msgSend</code>接受者是<code>self</code>，假如是<code>[self init]</code>则会产生死循环。<code>[super test]</code>则是执行父类的<code>test</code>。<br>使用<code>Debug Workflow-&gt;Always Show Disassemdly</code>发现<code>super</code>其实调用了汇编的<code>objc_msgSendSuper2</code>，进入<code>objc_msgSendSuper2 objc-msg-arm64.s 422 行</code>发现和<code>objc_msgSendSuper</code>其实基本一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;_objc_msgSendSuper 开始</span><br><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line">UNWIND _objc_msgSendSuper, NoFrame</span><br><span class="line">&#x2F;&#x2F;x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</span><br><span class="line">ldpp0, p16, [x0]&#x2F;&#x2F; p0 &#x3D; self , p16 &#x3D; superclass</span><br><span class="line">CacheLookup NORMAL&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line">END_ENTRY _objc_msgSendSuper  &#x2F;&#x2F;_objc_msgSendSuper 结束</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;objc_msgLookupSuper2 开始</span><br><span class="line">ENTRY _objc_msgSendSuper2 </span><br><span class="line">UNWIND _objc_msgSendSuper2, NoFrame</span><br><span class="line"></span><br><span class="line">ldpp0, p16, [x0]&#x2F;&#x2F; p0 &#x3D; real receiver, p16 &#x3D; class</span><br><span class="line">&#x2F;&#x2F;将存储器地址为x16+8的字数据读入寄存器p16。</span><br><span class="line">ldrp16, [x16, #SUPERCLASS]&#x2F;&#x2F; p16 &#x3D; class-&gt;superclass</span><br><span class="line">CacheLookup NORMAL</span><br><span class="line">END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure><p>也可以使用<code>LLVM</code>转化成中间代码来查看，<code>clang -emit-llvm -S FYCat.m</code>查看关键函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define internal void @&quot;\01-[FYCat forwardInvocation:]&quot;(%1*, i8*, %2*) #1 &#123;</span><br><span class="line">    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>forwardInvocation</code>函数的调用代码，简化之后是<code>objc_msgSendSuper2(self,struct._objc_super i8*,%2*)</code>，就是<code>objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)</code>。</p><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (int)age;</span><br><span class="line">-(void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    ;    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (int)age&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">    return [_name stringByAppendingString:@&quot; eat apple&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface FYStudent : FYPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYStudent</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    [super test]; &#x2F;&#x2F;执行父类的test</span><br><span class="line">    int age &#x3D; [super age]; &#x2F;&#x2F;获取父类的方法 返回值</span><br><span class="line">    NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">    NSString * name &#x3D; [self name]; &#x2F;&#x2F;从父类开始寻找name的值，但返回的是self.name的值</span><br><span class="line">    NSLog(@&quot;%@&quot;,name);</span><br><span class="line">&#125;</span><br><span class="line">-(int)age&#123;</span><br><span class="line">    return 12;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[FYPerson test]</span><br><span class="line">-[FYPerson age]</span><br><span class="line">age is 10</span><br><span class="line">小李子 eat apple</span><br></pre></td></tr></table></figure><p><code>test</code>是执行父类的方法，<code>[super age]</code>获取父类中固定的<code>age</code>,<br><code>[self name]</code>从父类开始寻找<code>name</code>的值，但返回的是<code>self.name</code>的值。</p><h3 id="isMemberOfClass-amp-isKindOfClass"><a href="#isMemberOfClass-amp-isKindOfClass" class="headerlink" title="isMemberOfClass &amp;  isKindOfClass"></a>isMemberOfClass &amp;  isKindOfClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return object_getClass((id)self) &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; object_getClass((id)self); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        printf(&quot;%s %s\n&quot;,class_getName(tcls),class_getName(cls));</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls)</span><br><span class="line">        &#123;return YES;&#125;else&#123;</span><br><span class="line">            printf(&quot;%s&quot;,class_getName(tcls));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot; %s %s\n&quot;,class_getName(tcls),class_getName(cls));</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isSubclassOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; self; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>- (BOOL)isMemberOfClass</code>和<code>- (BOOL)isKindOfClass:(Class)cls</code>比较简单，都是判断<code>self.class</code> 和<code>cls</code>，<code>+ (BOOL)isMemberOfClass:(Class)cls</code>是判断<code>self.class-&gt;isa</code>是否和<code>cls</code>相等，<code>+ (BOOL)isKindOfClass:(Class)cls</code>判断<code>cls-&gt;isa</code>和<code>cls-&gt;isa-&gt;isa</code>有没有可能和<code>cls</code>相等？只有基类是，其他的都不是。</p><h4 id="验证-实例方法"><a href="#验证-实例方法" class="headerlink" title="验证 实例方法"></a>验证 实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class cls &#x3D; NSObject.class;</span><br><span class="line">Class pcls &#x3D; FYPerson.class;</span><br><span class="line">FYPerson *p&#x3D;[FYPerson new];</span><br><span class="line">NSObject *obj&#x3D;[NSObject new];</span><br><span class="line">BOOL res11 &#x3D;[p isKindOfClass:pcls];</span><br><span class="line">BOOL res12 &#x3D;[p isMemberOfClass:pcls];</span><br><span class="line">BOOL res13 &#x3D;[obj isKindOfClass:cls];</span><br><span class="line">BOOL res14 &#x3D;[obj isMemberOfClass:cls];</span><br><span class="line">NSLog(@&quot;instance:%d %d %d %d&quot;,res11,res12,res13,res14);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">&#x2F;&#x2F;instance:1 1 1 1</span><br></pre></td></tr></table></figure><p><code>p</code>是<code>pcls</code>的子类，<code>obj</code> 是<code>cls</code>的子类，在明显不过了。</p><h4 id="验证-类方法"><a href="#验证-类方法" class="headerlink" title="验证 类方法"></a>验证 类方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;isKindOfClass cls-&gt;isa 和cls&#x2F;cls-&gt;superclass相等吗?</span><br><span class="line">&#x2F;&#x2F;元类对象和类对象不相等，但是最后一个元类的isa-&gt;superclass是指向NSObject的class 所以res1 &#x3D; YES;</span><br><span class="line">&#x2F;&#x2F;cls-&gt;isa:元类对象 cls-&gt;isa-&gt;superclass: NSObject类对象</span><br><span class="line">&#x2F;&#x2F;cls:类对象</span><br><span class="line">BOOL res1 &#x3D;[cls isKindOfClass:cls];</span><br><span class="line">&#x2F;&#x2F;cls-&gt;isa 和cls相等吗？ 不相等 cls-&gt;isa是元类对象,cls是类对象，不可能相等。</span><br><span class="line">BOOL res2 &#x3D;[cls isMemberOfClass:cls];</span><br><span class="line">&#x2F;&#x2F;pcls-&gt;isa:person的元类对象 cls-&gt;isa-&gt;superclass: NSObject元类类对象 -&gt;superclass:NSObject类对象 -&gt;superclass:nil</span><br><span class="line">&#x2F;&#x2F;pcls:person类对象</span><br><span class="line">BOOL res3 &#x3D;[pcls isKindOfClass:pcls];</span><br><span class="line">&#x2F;&#x2F;pcls-&gt;isa:person的元类对象</span><br><span class="line">&#x2F;&#x2F;pcls:person类对象</span><br><span class="line">BOOL res4 &#x3D;[pcls isMemberOfClass:pcls];</span><br><span class="line">NSLog(@&quot;%d %d %d %d&quot;,res1,res2,res3,res4);</span><br><span class="line">结果：</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure><h3 id="堆栈-对象本质-class本质实战"><a href="#堆栈-对象本质-class本质实战" class="headerlink" title="堆栈 对象本质 class本质实战"></a>堆栈 对象本质 class本质实战</h3><p>网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。<br>其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDJkMjAwYmU1MWQ0NTEwYTczMjgxNjE=" title="https://juejin.im/post/5d2d200be51d4510a7328161">obj_msgsend基础<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDE5YzU5ZTZmYjlhMDdmMDQyMDVmOTU=" title="https://juejin.im/post/5d19c59e6fb9a07f04205f95">类的本质<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDE1ODg3ZWU1MWQ0NTEwODEyNmQyOGQ=" title="https://juejin.im/post/5d15887ee51d45108126d28d">对象的本质<i class="fa fa-external-link"></i></span>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)print&#123;</span><br><span class="line">    NSLog(@&quot;my name is %@&quot;,self.name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSObject *fix &#x3D;[NSObject new]; &#x2F;&#x2F; 16字节 0x60000219b030</span><br><span class="line">    id cls  &#x3D; [FYPerson class];针</span><br><span class="line">    void * obj &#x3D; &amp;cls; </span><br><span class="line">    [(__bridge id)obj print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题一-能否编译成功？"><a href="#问题一-能否编译成功？" class="headerlink" title="问题一 能否编译成功？"></a>问题一 能否编译成功？</h4><p>当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有<code>id self</code>和<code>SEL sel</code>，现在<code>cls</code>和<code>obj</code>都在栈区，<code>obj</code> 指针指向<code>cls</code>的内存地址，访问<code>obj</code>相当于直接访问<code>cls</code>内存存储的值，<code>cls</code>存储的是<code>Person.class</code>,<code>[obj print]</code> 相当于<code>objc_msgSend(cls,@selector(print))</code>,<code>cls</code>是有<code>print</code>方法的，所以会编译成功。</p><h4 id="输出什么？"><a href="#输出什么？" class="headerlink" title="输出什么？"></a>输出什么？</h4><p><code>fix/cls/obj</code>这三个对象都是存储在栈上，<code>fix/cls/obj</code>地址是连续从高到低的，而且他们地址相差都是<code>8</code>字节，一个指针大小是<code>8</code>字节。他们三个地址如下所示：</p><p>使用图来表示<code>fix</code>和<code>obj</code>：</p><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">地址</th><th style="text-align:center">地址高低</th></tr></thead><tbody><tr><td style="text-align:center">fix</td><td style="text-align:center">0x7ffeec3df920</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">cls</td><td style="text-align:center">0x7ffeec3df918</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">obj</td><td style="text-align:center">0x7ffeec3df910</td><td style="text-align:center">低</td></tr></tbody></table><p>寻找属性先是寻找<code>isa</code>，然后再在<code>isa</code>地址上+<code>8</code>则是属性的值，所以根据<code>obj</code>寻找<code>cls</code>地址是<code>0x7ffeec3df918</code>,然后<code>cls</code>地址+8字节则是<code>_name</code>的地址，<code>cls</code>地址是<code>0x7ffeec3df918</code>，加上<code>8</code>字节正好是<code>fix</code>的地址<code>0x7ffeec3df920</code>，因为都是指针，所以都是<code>8</code>字节,所以最后输出是结果是<code>fix</code>对象的地址的数据。</p><p>情况再复杂一点，<code>FYPerson</code>结构改动一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,copy) NSString *name2;</span><br><span class="line">@property (nonatomic,copy) NSString *name3;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>则他们的<code>_name</code>、<code>_name2</code>、<code>_name3</code>则在<code>cls</code>的地址基础上再向上寻找<code>8*1=8/8*2=16/8*3=24</code>字节，就是向上寻找第1个，第2个，第3个指向对象的指针。</p><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,copy) NSString *name2;</span><br><span class="line">@property (nonatomic,copy) NSString *name3;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)print&#123;</span><br><span class="line">    NSLog(@&quot;name1:%@ name2:%@ name3:%@&quot;,self.name1,self.name2,self.name3);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主函数</span><br><span class="line"></span><br><span class="line">NSObject *fix &#x3D;[NSObject new];</span><br><span class="line">FYPerson *fix2 &#x3D;[FYPerson new];</span><br><span class="line"></span><br><span class="line">id cls  &#x3D; [FYPerson class];</span><br><span class="line">void * obj &#x3D; &amp;cls; </span><br><span class="line">[(__bridge id)obj print];&#x2F;&#x2F;objc_msgSend(self,sel);</span><br><span class="line">NSLog(@&quot;fix:%p fix2:%p cls:%p obj:%p&quot;,&amp;fix,&amp;fix2,&amp;cls,&amp;obj);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">name1:&lt;FYPerson: 0x6000033a38a0&gt; </span><br><span class="line">name2:&lt;NSObject: 0x6000031f5380&gt; </span><br><span class="line">name3:&lt;ViewController: 0x7f8307505580&gt;</span><br><span class="line"></span><br><span class="line">fix: 0x7ffeec3d f9 28 </span><br><span class="line">fix2:0x7ffeec3d f9 20 </span><br><span class="line">cls: 0x7ffeec3d f9 18 </span><br><span class="line">obj: 0x7ffeec3d f9 10</span><br></pre></td></tr></table></figure><p>再变形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#x2F;*</span><br><span class="line"> objc_msgSuperSend(self,ViewController,sel)</span><br><span class="line"> *&#x2F;</span><br><span class="line">NSLog(@&quot;self:%p ViewController.class:%p SEL:%p&quot;,self,ViewController.class,@selector(viewDidLoad));</span><br><span class="line">    id cls  &#x3D; [FYPerson class];&#x2F;&#x2F;cls 是类指针</span><br><span class="line">    void * obj &#x3D; &amp;cls; &#x2F;&#x2F;obj </span><br><span class="line">    [(__bridge id)obj print];&#x2F;&#x2F;objc_msgSend(self,sel);</span><br><span class="line">    </span><br><span class="line"> NSLog(@&quot;cls:%p obj:%p&quot;,&amp;cls,&amp;obj);</span><br><span class="line"> &#x2F;&#x2F;log</span><br><span class="line"> </span><br><span class="line"> name1:&lt;ViewController: 0x7fad03e04ea0&gt; </span><br><span class="line"> name2:ViewController</span><br><span class="line"> </span><br><span class="line"> self:                  0x7fad03e04ea0 </span><br><span class="line"> ViewController.class:  0x10d0edf00 </span><br><span class="line"> SEL:                   0x1117d5687</span><br><span class="line"> </span><br><span class="line"> cls:0x7ffee2b11908 </span><br><span class="line"> obj:0x7ffee2b11900</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_name1</code>是<code>cls</code>地址向上+8字节，<code>_name2</code>是向上移动16字节，<code>[super viewDidLoad]</code>本质上是<code>objc_msgSuperSend(self,ViewController.class,sel)</code>，<code>self</code>、<code>ViewController.class</code>、<code>SEL</code>是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，<br>结构体如下图所示：</p><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">地址高低</th></tr></thead><tbody><tr><td style="text-align:center">self</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">ViewController.class</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">SEL</td><td style="text-align:center">高</td></tr></tbody></table><h3 id="常用的runtimeAPI"><a href="#常用的runtimeAPI" class="headerlink" title="常用的runtimeAPI"></a>常用的runtimeAPI</h3><table><thead><tr><th style="text-align:center">method</th><th style="text-align:center">desc</th></tr></thead><tbody><tr><td style="text-align:center">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</td><td style="text-align:center">动态创建一个类（参数：父类，类名，额外的内存空间</td></tr><tr><td style="text-align:center">void objc_registerClassPair(Class cls))</td><td style="text-align:center">注册一个类</td></tr><tr><td style="text-align:center">void objc_disposeClassPair(Class cls)</td><td style="text-align:center">销毁一个类</td></tr><tr><td style="text-align:center">Class objcect_getClass(id obj)</td><td style="text-align:center">获取isa指向的class</td></tr><tr><td style="text-align:center">Class object_setClass (id obj,Class cls)</td><td style="text-align:center">设置isa指向的class</td></tr><tr><td style="text-align:center">BOOL object_isClass(id class)</td><td style="text-align:center">判断oc对象是否为Class</td></tr><tr><td style="text-align:center">BOOL class_isMetaClass(Class cls)</td><td style="text-align:center">是否是元类</td></tr><tr><td style="text-align:center">Class class_getSuperclass(Class cls)</td><td style="text-align:center">获取父类</td></tr><tr><td style="text-align:center">Ivar class_getInstanceVariable(Class cls ,const char * name</td><td style="text-align:center">获取一个实例变量信息</td></tr><tr><td style="text-align:center">Ivar <em> class_copyIvarList(Class cls,unsigned int </em> outCount)</td><td style="text-align:center">拷贝实例变量列表，需要free</td></tr><tr><td style="text-align:center">void object_setIvar(id obj,Ivar ivar,id value</td><td style="text-align:center">设置获取实例变量的值</td></tr><tr><td style="text-align:center">id object_getIvar(id obj,Ivar ivar)</td><td style="text-align:center">获取实例变量的值</td></tr><tr><td style="text-align:center">BOOL class_addIvar(Class cls,const cahr <em> name ,size_t size,uint_t alignment,const char </em> types)</td><td style="text-align:center">动态添加成员变量（已注册的类不能动态添加成员变量）</td></tr><tr><td style="text-align:center">const char * ivar_getName（Ivar v)</td><td style="text-align:center">获取变量名字</td></tr><tr><td style="text-align:center">const char * ivar_getTypeEncoding(Ivar v)</td><td style="text-align:center">变量的encode</td></tr><tr><td style="text-align:center">objc_property_t class_getProperty(Class cls,const char* name)</td><td style="text-align:center">获取一个属性</td></tr><tr><td style="text-align:center">objc_property_t _Nonnull <em> _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)</td><td style="text-align:center">拷贝属性列表</td></tr><tr><td style="text-align:center">objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)</td><td style="text-align:center">获取属性列表</td></tr><tr><td style="text-align:center">BOOL class_addProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes,unsigned int attributeCount)</td><td style="text-align:center">添加属性</td></tr><tr><td style="text-align:center">void class_replaceProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes, unsigned int attributeCount)</td><td style="text-align:center">替换属性</td></tr><tr><td style="text-align:center">void class_replaceProperty(Class cls, const char <em>name, const objc_property_attribute_t </em>attributes,unsigned int attributeCount)</td><td style="text-align:center">动态替换属性</td></tr><tr><td style="text-align:center">const char * _Nonnull property_getName(objc_property_t _Nonnull property)</td><td style="text-align:center">获取name</td></tr><tr><td style="text-align:center">const char * _Nullable property_getAttributes(objc_property_t _Nonnull property)</td><td style="text-align:center">获取属性的属性</td></tr><tr><td style="text-align:center">IMP imp_implementationWithBlock(id block)</td><td style="text-align:center">获取block的IMP</td></tr><tr><td style="text-align:center">id imp_getBlock(IMP anIMP)</td><td style="text-align:center">通过imp 获取block</td></tr><tr><td style="text-align:center">BOOL imp_removeBlock(IMP anIMP)</td><td style="text-align:center">IMP是否被删除</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们<br>获取<code>class</code>的所有成员变量,可以获取<code>Ivar</code>查看是否有该变量，然后可以通过<code>KVC</code>来赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface FYCat : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@property (nonatomic,assign) int  age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FYCat *cat&#x3D;[FYCat new];</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar *vars&#x3D; class_copyIvarList(cat.class, &amp;count);</span><br><span class="line">for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">Ivar item &#x3D; vars[i];</span><br><span class="line">const char *name &#x3D; ivar_getName(item);</span><br><span class="line">NSLog(@&quot;%s&quot;,name);</span><br><span class="line">&#125;</span><br><span class="line">free(vars);</span><br><span class="line"></span><br><span class="line">Method *m1&#x3D; class_copyMethodList(cat.class, &amp;count);</span><br><span class="line">for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">Method item &#x3D; m1[i];</span><br><span class="line">SEL name &#x3D; method_getName(item);</span><br><span class="line">printf(&quot;method:%s \n&quot;,NSStringFromSelector(name).UTF8String);</span><br><span class="line">&#125;</span><br><span class="line">free(m1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">_age</span><br><span class="line">_name</span><br><span class="line"></span><br><span class="line">method:.cxx_destruct </span><br><span class="line">method:name </span><br><span class="line">method:setName: </span><br><span class="line">method:methodSignatureForSelector: </span><br><span class="line">method:forwardInvocation: </span><br><span class="line">method:age </span><br><span class="line">method:setAge:</span><br></pre></td></tr></table></figure><p>大家常用的一个功能是<code>JsonToModel</code>，那么我们已经了解到了<code>runtime</code>的基础知识，现在可以自己撸一个<code>JsonToModel</code>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Json)</span><br><span class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json;</span><br><span class="line">@end</span><br><span class="line">@implementation NSObject (Json)</span><br><span class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json&#123;</span><br><span class="line">id obj &#x3D; [[self alloc]init];</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar *vars&#x3D; class_copyIvarList(self, &amp;count);</span><br><span class="line">for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">Ivar item &#x3D; vars[i];</span><br><span class="line">const char *name &#x3D; ivar_getName(item);</span><br><span class="line">NSString * nameOC&#x3D; [NSString stringWithUTF8String:name];</span><br><span class="line">if (nameOC.length&gt;1) &#123;</span><br><span class="line">nameOC &#x3D; [nameOC substringFromIndex:1];</span><br><span class="line">NSString * value &#x3D; json[nameOC];</span><br><span class="line">if ([value isKindOfClass:NSString.class] &amp;&amp; value.length) &#123;</span><br><span class="line">[obj setValue:value forKey:nameOC];</span><br><span class="line">&#125;else if ([value isKindOfClass:NSArray.class])&#123;</span><br><span class="line">[obj setValue:value forKey:nameOC];</span><br><span class="line">&#125;else if ([value isKindOfClass:NSDictionary.class])&#123;</span><br><span class="line">[obj setValue:value forKey:nameOC];</span><br><span class="line">&#125;else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s value is nil or null \n&quot;,name);</span><br><span class="line">&#125;else if ([value integerValue] &gt; 0)&#123;</span><br><span class="line">[obj setValue:value forKey:nameOC];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;未知错误 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">free(vars);</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后自己定义一个字典，来测试一下这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface FYCat : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@property (nonatomic,assign) int  age;</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSDictionary * info &#x3D; @&#123;@&quot;age&quot;:@&quot;10&quot;,@&quot;value&quot;:@10,@&quot;name&quot;:@&quot;小明&quot;&#125;;</span><br><span class="line">FYCat *cat&#x3D;[FYCat fy_objectWithJson:info];</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">age:10 name:小明</span><br></pre></td></tr></table></figure><h4 id="hook钩子-method-exchangeImplementations"><a href="#hook钩子-method-exchangeImplementations" class="headerlink" title="hook钩子(method_exchangeImplementations)"></a>hook钩子(method_exchangeImplementations)</h4><p>由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIButton (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">Method m1&#x3D; class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));</span><br><span class="line">Method m2&#x3D; class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</span><br><span class="line">NSLog(@&quot;%@ &quot;,NSStringFromSelector(action));</span><br><span class="line">&#x2F;*</span><br><span class="line"> code here</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;sel IMP 已经交换过了，所以不会死循环</span><br><span class="line">[self fy_sendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以在<code>code here</code>添加需要处理的代码，一般记录日志和延迟触发都可以处理。<code>[self fy_sendAction:action to:target forEvent:event];</code>不会产生死循环，原因是在<code>+load</code>中已经将<code>m1</code>和<code>m2</code>已经交换过了<code>IMP</code>。我们进入到<code>method_exchangeImplementations</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line">&#123;</span><br><span class="line">    if (!m1  ||  !m2) return;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;交换IMP</span><br><span class="line">    IMP m1_imp &#x3D; m1-&gt;imp;</span><br><span class="line">    m1-&gt;imp &#x3D; m2-&gt;imp;</span><br><span class="line">    m2-&gt;imp &#x3D; m1_imp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;刷新缓存</span><br><span class="line">    flushCaches(nil);</span><br><span class="line"></span><br><span class="line">    updateCustomRR_AWZ(nil, m1);</span><br><span class="line">    updateCustomRR_AWZ(nil, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;;</span><br><span class="line">using MethodListIMP &#x3D; IMP;</span><br></pre></td></tr></table></figure><p><code>m1</code>和<code>m2</code>交换了<code>IMP</code>，交换的是<code>method_t-&gt;imp</code>，然后刷新缓存(清空缓存)，等下次调用<code>IMP</code>则需要在<code>cls-&gt;rw-&gt;data-&gt;method</code>中去寻找。</p><h4 id="数组越界和nil处理"><a href="#数组越界和nil处理" class="headerlink" title="数组越界和nil处理"></a>数组越界和nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSMutableArray (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">Class cls&#x3D; NSClassFromString(@&quot;__NSArrayM&quot;);</span><br><span class="line">Method m1&#x3D; class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</span><br><span class="line">SEL sel &#x3D; @selector(fy_insertObject:atIndex:);</span><br><span class="line">Method m2&#x3D; class_getInstanceMethod(cls, sel);</span><br><span class="line"></span><br><span class="line">Method m3&#x3D; class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));</span><br><span class="line">Method m4&#x3D; class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));</span><br><span class="line"></span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">method_exchangeImplementations(m1, m2);</span><br><span class="line">method_exchangeImplementations(m3, m4);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index&#123;</span><br><span class="line">if (anObject !&#x3D; nil) &#123;</span><br><span class="line">[self fy_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot; anObject is nil \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx&#123;</span><br><span class="line">if (self.count &gt; idx) &#123;</span><br><span class="line">return [self fy_objectAtIndexedSubscript:idx];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot; %ld is outof rang \n&quot;,(long)idx);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSMutableArray *array&#x3D;[NSMutableArray array];</span><br><span class="line">id obj &#x3D; nil;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">array[1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"> anObject is nil </span><br><span class="line"> 1 is outof rang</span><br></pre></td></tr></table></figure><p><code>NSMutableArray</code>是类簇，使用工厂模式，<code>NSMutableArray</code>不是数组实例，而是生产数组对象的工厂。<br>真实的数组对象是<code>__NSArrayM</code>,然后给<code>__NSArrayM</code>钩子，交换<code>objectAtIndexedSubscript:(NSUInteger)idx</code>和<code>insertObject:(id)anObject atIndex:(NSUInteger)index</code>方法，实现崩溃避免。</p><h4 id="字典nil处理"><a href="#字典nil处理" class="headerlink" title="字典nil处理"></a>字典nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface NSMutableDictionary (add)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSMutableDictionary (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    Class cls&#x3D; NSClassFromString(@&quot;__NSDictionaryM&quot;);</span><br><span class="line">    Method m1&#x3D; class_getInstanceMethod(cls, @selector(setObject:forKey:));</span><br><span class="line">&#x2F;&#x2F;    __NSDictionaryM</span><br><span class="line">    SEL sel &#x3D; @selector(fy_setObject:forKey:);</span><br><span class="line">    Method m2&#x3D; class_getInstanceMethod(cls, sel);</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        method_exchangeImplementations(m1, m2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)fy_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey&#123;</span><br><span class="line">    if (anObject) &#123;</span><br><span class="line">        [self fy_setObject:anObject forKey:aKey];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSString * key &#x3D; (NSString *)aKey;</span><br><span class="line">        printf(&quot;key:%s anobj is nil \n&quot;,key.UTF8String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>利用类别<code>+load</code>给<code>__NSDictionaryM</code>添加方法，然后交换<code>IMP</code>，实现给<code>NSMutableDictionary setObject:Key:</code>的时候进行<code>nil</code>校验,<code>+load</code>虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成<code>IMP</code>和<code>SEL</code>混乱，使用<code>dispatch_once</code>进行单次运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>super</code>本质上是<code>self</code>调用函数，不过查找函数是从<code>sueprclass</code>开始查找的</li><li><code>+isKandOfClass</code>是判断<code>self</code>是否是<code>cls</code>的子类，<code>+isMemberOfClass:</code>是判断<code>self</code>是否和<code>cls</code>相同。</li><li>了解<code>+load</code>在<code>Category</code>是启动的时候使用运行时编译的，而且只会加载一次,然后利用<code>objc/runtime.h</code>中<code>method_exchangeImplementations</code>实现交换两个函数的<code>IMP</code>，可以实现拦截<code>nil</code>，降低崩溃率。</li><li><code>NSMutableDictionary</code>、<code>NSMutableArray</code>是类簇，先找到他们的类然后再交换该类的函数的<code>IMP</code>。</li></ol><h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy41MjBpdC5jb20venQvaW9zX21qLw==" title="http://www.520it.com/zt/ios_mj/">小码哥视频<i class="fa fa-external-link"></i></span></li></ul><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关键字-super&quot;&gt;&lt;a href=&quot;#关键字-super&quot; class=&quot;headerlink&quot; title=&quot;关键字 super&quot;&gt;&lt;/a&gt;关键字 super&lt;/h3&gt;&lt;p&gt;关键字&lt;code&gt;super&lt;/code&gt;,在调用&lt;code&gt;[super init
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime-%20objc_msgSend%E6%8B%BE%E9%81%97%E5%9F%BA%E7%A1%80%E7%AF%87--(7)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime-%20objc_msgSend%E6%8B%BE%E9%81%97%E5%9F%BA%E7%A1%80%E7%AF%87--(7)/</id>
    <published>2019-12-01T03:17:58.000Z</published>
    <updated>2020-09-04T04:40:21.659Z</updated>
    
    <content type="html"><![CDATA[<p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p><p>objc_msgSend的执行流程可以分为3大阶段</p><ol><li>消息发送</li><li>动态方法解析</li><li>消息转发</li></ol><p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">objc-msg-arm64.s</span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">b.leLNilOrTagged &#x2F;&#x2F;&lt;0则返回</span><br><span class="line">CacheLookup NORMAL &#x2F;&#x2F;缓存查找 未命中则继续查找</span><br><span class="line">.macro CacheLookup&#x2F;&#x2F; 通过宏 查找cache，命中直接call or return imp</span><br><span class="line">.macro CheckMiss &#x2F;&#x2F;miss 则跳转__objc_msgSend_uncached</span><br><span class="line">STATIC_ENTRY __objc_msgSend_uncached </span><br><span class="line">.macro MethodTableLookup&#x2F;&#x2F;方法中查找</span><br><span class="line">__class_lookupMethodAndLoadCache3&#x2F;&#x2F;跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-runtime-new.mm</span><br><span class="line">_class_lookupMethodAndLoadCache3</span><br><span class="line">lookUpImpOrForward</span><br><span class="line">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</span><br><span class="line">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</span><br><span class="line">_class_resolveInstanceMethod</span><br><span class="line">_objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-msg-arm64.s</span><br><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line">__forwarding__（不开源）</span><br></pre></td></tr></table></figure><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSend &#x2F;&#x2F; _objc_msgSend 开始</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">cmpp0, #0&#x2F;&#x2F; 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">b.leLNilOrTagged&#x2F;&#x2F; if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</span><br><span class="line">#else</span><br><span class="line">b.eqLReturnZero &#x2F;&#x2F; if le &#x3D;&#x3D; 0 -&gt;  跳转到标签  LReturnZero</span><br><span class="line">#endif</span><br><span class="line">ldrp13, [x0]&#x2F;&#x2F; p13 &#x3D; isa</span><br><span class="line">GetClassFromIsa_p16 p13&#x2F;&#x2F; p16 &#x3D; class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">LNilOrTagged:</span><br><span class="line">b.eqLReturnZero&#x2F;&#x2F; 如果&#x3D;&#x3D;0 -&gt; LReturnZero</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tagged</span><br><span class="line">adrpx10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">ubfxx11, x0, #60, #4</span><br><span class="line">ldrx16, [x10, x11, LSL #3]</span><br><span class="line">adrpx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</span><br><span class="line">addx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</span><br><span class="line">cmpx10, x16</span><br><span class="line">b.neLGetIsaDone</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ext tagged</span><br><span class="line">adrpx10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">ubfxx11, x0, #52, #8</span><br><span class="line">ldrx16, [x10, x11, LSL #3]</span><br><span class="line">bLGetIsaDone</span><br><span class="line">&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">&#x2F;&#x2F; x0 is already zero</span><br><span class="line">movx1, #0</span><br><span class="line">movid0, #0</span><br><span class="line">movid1, #0</span><br><span class="line">movid2, #0</span><br><span class="line">movid3, #0</span><br><span class="line">ret &#x2F;&#x2F;return 返回结束掉</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSend &#x2F;&#x2F; _objc_msgSend 结束</span><br></pre></td></tr></table></figure><p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup &#x2F;&#x2F;.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</span><br><span class="line">&#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa</span><br><span class="line">ldpp10, p11, [x16, #CACHE]&#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">andw11, w11, 0xffff&#x2F;&#x2F; p11 &#x3D; mask</span><br><span class="line">#endif</span><br><span class="line">andw12, w1, w11&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">addp12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">             &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:cmpp9, p1&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">b.ne2f&#x2F;&#x2F;     scan more</span><br><span class="line">CacheHit $0&#x2F;&#x2F; call or return imp 命中 调用或者返回imp</span><br><span class="line"></span><br><span class="line">2:&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket 没有命中</span><br><span class="line">CheckMiss $0&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">cmpp12, p10&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">b1b&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:&#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask</span><br><span class="line">addp12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">                        &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">&#x2F;&#x2F; The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:cmpp9, p1&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">b.ne2f&#x2F;&#x2F;     scan more</span><br><span class="line">CacheHit $0&#x2F;&#x2F; call or return imp</span><br><span class="line"></span><br><span class="line">2:&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket</span><br><span class="line">CheckMiss $0&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">cmpp12, p10&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">b1b&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:&#x2F;&#x2F; double wrap</span><br><span class="line">JumpMiss $0</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">&#x2F;&#x2F; push frame</span><br><span class="line">SignLR</span><br><span class="line">stpfp, lr, [sp, #-16]!</span><br><span class="line">movfp, sp</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; save parameter registers: x0..x8, q0..q7</span><br><span class="line">subsp, sp, #(10*8 + 8*16)</span><br><span class="line">stpq0, q1, [sp, #(0*16)]</span><br><span class="line">stpq2, q3, [sp, #(2*16)]</span><br><span class="line">stpq4, q5, [sp, #(4*16)]</span><br><span class="line">stpq6, q7, [sp, #(6*16)]</span><br><span class="line">stpx0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">stpx2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">stpx4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">stpx6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">strx8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">movx2, x16</span><br><span class="line">bl__class_lookupMethodAndLoadCache3&#x2F;&#x2F;跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IMP in x0</span><br><span class="line">movx17, x0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; restore registers and return</span><br><span class="line">ldpq0, q1, [sp, #(0*16)]</span><br><span class="line">ldpq2, q3, [sp, #(2*16)]</span><br><span class="line">ldpq4, q5, [sp, #(4*16)]</span><br><span class="line">ldpq6, q7, [sp, #(6*16)]</span><br><span class="line">ldpx0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">ldpx2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">ldpx4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">ldpx6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">ldrx8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">movsp, fp</span><br><span class="line">ldpfp, lr, [sp], #16</span><br><span class="line">AuthenticateLR</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj,                               YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* initialize&#x3D;&#x3D;NO 尽量避免调用，有时可能也会调用。</span><br><span class="line">* cache&#x3D;&#x3D;NO 跳过缓存查找，其他地方可能会不调过</span><br><span class="line">* 大多数人会传值 initialize&#x3D;&#x3D;YES and cache&#x3D;&#x3D;YES</span><br><span class="line">*   如果cls是非初始化的元类，则非Non-nil会快点</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    bool triedResolver &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (cache) &#123; &#x2F;&#x2F;从汇编过来是NO</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">&#x2F;&#x2F;当cls需要初始化和没有初始化的时候 进行cls初始化，</span><br><span class="line">&#x2F;&#x2F;初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</span><br><span class="line">&#x2F;&#x2F;数据的大小最小是4，扩容规则是：n*2+1;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再次获取imp</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;尝试在本类中查找method</span><br><span class="line">    &#123;&#x2F;&#x2F;从cls-&gt;data()-&gt;methods查找method</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;&#x2F;&#x2F;找到添加到cache中</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">&#x2F;&#x2F;从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">        for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">             curClass !&#x3D; nil;</span><br><span class="line">             curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass cache.</span><br><span class="line">            imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">&#x2F;&#x2F;将父类添加到 子类的缓存中</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                    &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                    &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass method list.</span><br><span class="line">            Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp &#x3D; meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果还没有找到imp，进入动态方法解析阶段</span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        triedResolver &#x3D; YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="line">&#x2F;&#x2F;进行消息转发 阶段</span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">&#x2F;&#x2F;填充 cache</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Define SUPPORT_INDEXED_ISA&#x3D;1 on platforms that store the class in the isa </span><br><span class="line">&#x2F;&#x2F; field as an index into a class table.</span><br><span class="line">&#x2F;&#x2F; Note, keep this in sync with any .s files which also define it.</span><br><span class="line">&#x2F;&#x2F; Be sure to edit objc-abi.h as well.</span><br><span class="line">&#x2F;&#x2F; __ARM_ARCH_7K__ 处理器架构指令集版本</span><br><span class="line">&#x2F;&#x2F;__arm64__ 架构</span><br><span class="line">&#x2F;&#x2F;__LP64__ uinx 和uinx  mac os</span><br><span class="line">#if __ARM_ARCH_7K__ &gt;&#x3D; 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 1</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p><p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p><p>借用网上找一个图， 可以更直观的看出流程运转。</p><p><img src="/images/7-1.png" alt></p><h4 id="realizeClass-解析"><a href="#realizeClass-解析" class="headerlink" title="realizeClass()解析"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* realizeClass</span><br><span class="line"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</span><br><span class="line"> runtimelock 必须有调用者把写入锁锁起来</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls &#x3D;&#x3D; remapClass(cls));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">&#x2F;&#x2F;首先将tw赋值给to，因为数据结构一样可以直接强制转化</span><br><span class="line">    ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;&#x2F;&#x2F;是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br><span class="line">        rw &#x3D; cls-&gt;data();</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 正常情况下 申请class_rw_t空间</span><br><span class="line">        rw &#x3D; (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro &#x3D; ro;&#x2F;&#x2F;cls-&gt;rw-&gt;ro 指向现在的ro</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING;&#x2F;&#x2F;realized &#x3D; 1 and  realizing &#x3D; 1</span><br><span class="line">        cls-&gt;setData(rw);&#x2F;&#x2F;赋值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta &#x3D; ro-&gt;flags &amp; RO_META;&#x2F;&#x2F;是否是元类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rw-&gt;version &#x3D; isMeta ? 7 : 0;  &#x2F;&#x2F; 元类版本是7，旧版的6，否就是0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Choose an index for this class.</span><br><span class="line">&#x2F;&#x2F;设置cls的索引</span><br><span class="line">cls-&gt;chooseClassArrayIndex();</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: realizing class &#39;%s&#39;%s %p %p #%u&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </span><br><span class="line">                     (void*)cls, ro, cls-&gt;classArrayIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果父类没有初始化则进行初始化</span><br><span class="line">    &#x2F;&#x2F; root_class 做完需要设置RW_REALIZED&#x3D;1，</span><br><span class="line">    &#x2F;&#x2F; root metaclasses 需要执行完.</span><br><span class="line">&#x2F;&#x2F;从NXMapTable 获取cls ，然后进行初始化</span><br><span class="line">&#x2F;&#x2F;从NXMapTable 获取cls-&gt;isa ，然后进行初始化</span><br><span class="line">    supercls &#x3D; realizeClass(remapClass(cls-&gt;superclass));</span><br><span class="line">    metacls &#x3D; realizeClass(remapClass(cls-&gt;ISA()));</span><br><span class="line">&#x2F;&#x2F;没有经过优化的isa执行的，现在已经是version&#x3D;7，在arm64上是优化过的，这个先不看了。</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    &#x2F;&#x2F; Disable non-pointer isa for some classes and&#x2F;or platforms.</span><br><span class="line">    &#x2F;&#x2F; Set instancesRequireRawIsa.</span><br><span class="line">    bool instancesRequireRawIsa &#x3D; cls-&gt;instancesRequireRawIsa();</span><br><span class="line">    bool rawIsaIsInherited &#x3D; false;</span><br><span class="line">    static bool hackedDispatch &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (DisableNonpointerIsa) &#123;</span><br><span class="line">        &#x2F;&#x2F; Non-pointer isa disabled by environment or app SDK version</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </span><br><span class="line">             0 &#x3D;&#x3D; strcmp(ro-&gt;name, &quot;OS_object&quot;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; hack for libdispatch et al - isa also acts as vtable pointer</span><br><span class="line">        hackedDispatch &#x3D; true;</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </span><br><span class="line">             supercls-&gt;instancesRequireRawIsa()) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; This is also propagated by addSubclass() </span><br><span class="line">        &#x2F;&#x2F; but nonpointer isa setup needs it earlier.</span><br><span class="line">        &#x2F;&#x2F; Special case: instancesRequireRawIsa does not propagate </span><br><span class="line">        &#x2F;&#x2F; from root class to root metaclass</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">        rawIsaIsInherited &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (instancesRequireRawIsa) &#123;</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; SUPPORT_NONPOINTER_ISA</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Update superclass and metaclass in case of remapping</span><br><span class="line">    cls-&gt;superclass &#x3D; supercls;</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 协调实例变量偏移&#x2F;布局</span><br><span class="line">&#x2F;&#x2F;可能重新申请空间 class_ro_t,更新我们的class_ro_t</span><br><span class="line">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置setInstanceSize 从ro-&gt;instanceSize</span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拷贝flags 从ro到rw中</span><br><span class="line">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;添加superclass指针</span><br><span class="line">    if (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories</span><br><span class="line">&#x2F;&#x2F;类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* methodizeClass</span><br><span class="line"> 修复cls方法列表想，协议列表和属性列表</span><br><span class="line">* 加锁</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line">    auto ro &#x3D; rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Methodizing for the first time</span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法列表</span><br><span class="line">    method_list_t *list &#x3D; ro-&gt;baseMethods();</span><br><span class="line">    if (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</span><br><span class="line">&#x2F;&#x2F;将对象的方法追加到cls-&gt;rw-&gt;methods后面</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist &#x3D; ro-&gt;baseProperties;</span><br><span class="line">    if (proplist) &#123;</span><br><span class="line">&#x2F;&#x2F;将对象的属性追加到rw-&gt;properties后面</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist &#x3D; ro-&gt;baseProtocols;</span><br><span class="line">    if (protolist) &#123;</span><br><span class="line">&#x2F;&#x2F;将对象的协议追加到rw-&gt;protocols后面</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Root classes get bonus method implementations if they don&#39;t have </span><br><span class="line">    &#x2F;&#x2F; them already. These apply before category replacements.</span><br><span class="line">    if (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; root metaclass</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories.</span><br><span class="line">&#x2F;&#x2F;类别 从全局NXMapTable *category_map 已经加载过了。</span><br><span class="line">    category_list *cats &#x3D; unattachedCategoriesForClass(cls, true &#x2F;*realizing*&#x2F;);</span><br><span class="line">&#x2F;&#x2F;收集所有的cats到cls -&gt; rw中</span><br><span class="line">    attachCategories(cls, cats, false &#x2F;*don&#39;t flush caches*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        if (cats) &#123;</span><br><span class="line">            for (uint32_t i &#x3D; 0; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </span><br><span class="line">                             isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cats) free(cats);&#x2F;&#x2F;释放cats</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; Debug: sanity-check all SELs; log method list contents</span><br><span class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</span><br><span class="line">        &#125;</span><br><span class="line">        assert(sel_registerName(sel_getName(meth.name)) &#x3D;&#x3D; meth.name); </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="attachCategories-解析"><a href="#attachCategories-解析" class="headerlink" title="attachCategories()解析"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme rearrange to remove these intermediate allocations</span><br><span class="line">&#x2F;&#x2F;方法数组[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">    method_list_t **mlists &#x3D; (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">&#x2F;&#x2F;属性数组</span><br><span class="line">    property_list_t **proplists &#x3D; (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">&#x2F;&#x2F;协议数组</span><br><span class="line">    protocol_list_t **protolists &#x3D; (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount &#x3D; 0;</span><br><span class="line">    int propcount &#x3D; 0;</span><br><span class="line">    int protocount &#x3D; 0;</span><br><span class="line">    int i &#x3D; cats-&gt;count;</span><br><span class="line">    bool fromBundle &#x3D; NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">&#x2F;&#x2F;取出某个分类</span><br><span class="line">        auto&amp; entry &#x3D; cats-&gt;list[i];</span><br><span class="line">&#x2F;&#x2F;取出分类 的 instance方法或者class方法</span><br><span class="line">        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] &#x3D; mlist; &#x2F;&#x2F;mlists 接受所有分类方法</span><br><span class="line">            fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有分类属性</span><br><span class="line">        property_list_t *proplist &#x3D; </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] &#x3D; proplist;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有协议方法</span><br><span class="line">        protocol_list_t *protolist &#x3D; entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] &#x3D; protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;收集了所有协议 分类方法</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">&#x2F;&#x2F;追加所有分类方法</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">&#x2F;&#x2F;释放数组</span><br><span class="line">    free(mlists);</span><br><span class="line">&#x2F;&#x2F;刷新该类的缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">&#x2F;&#x2F;追加所有分类属性</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#x2F;&#x2F;追加所有分类协议</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rw-gt-list-gt-attachLists-解析"><a href="#rw-gt-list-gt-attachLists-解析" class="headerlink" title="rw-&gt;list-&gt;attachLists()解析"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           &#x2F;&#x2F; many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">&#x2F;&#x2F;一共需要的数量</span><br><span class="line">           uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">&#x2F;&#x2F;分配内存 内存不够用了，需要扩容</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">&#x2F;&#x2F;赋值count</span><br><span class="line">           array()-&gt;count &#x3D; newCount;</span><br><span class="line">&#x2F;&#x2F; array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br><span class="line">           memmove(array()-&gt;lists + addedCount&#x2F;*数组末尾*&#x2F;, array()-&gt;lists&#x2F;*数组*&#x2F;,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0])&#x2F;*移动的大小*&#x2F;);</span><br><span class="line">&#x2F;&#x2F;空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#x2F;*</span><br><span class="line">图示讲解：</span><br><span class="line">array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">addedCount:3</span><br><span class="line">addedLists:P-&gt;L-&gt;V</span><br><span class="line">memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</span><br><span class="line">P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line"> *&#x2F;</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">           &#x2F;&#x2F; 0 lists -&gt; 1 list</span><br><span class="line">           list &#x3D; addedLists[0];</span><br><span class="line">       &#125; </span><br><span class="line">       else &#123;</span><br><span class="line">           &#x2F;&#x2F; 1 list -&gt; many lists</span><br><span class="line">           List* oldList &#x3D; list;</span><br><span class="line">           uint32_t oldCount &#x3D; oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count &#x3D; newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p><h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_resolveMethod</span><br><span class="line">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</span><br><span class="line">* 如果存在了则不检查</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;&#x2F;&#x2F;不是元类则调用 实例的</span><br><span class="line">&#x2F;&#x2F;首先调用</span><br><span class="line">_class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">&#x2F;&#x2F;寻找classMethod</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_resolveInstanceMethod</span><br><span class="line">* 调用 class添加的函数 +resolveInstanceMethod</span><br><span class="line">* 有可能是元类</span><br><span class="line">* 如果方法存在则不检查</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态解析至此完成。</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache &#x2F;&#x2F;开始__objc_msgForward_impcache</span><br><span class="line">&#x2F;&#x2F; No stret specialization.</span><br><span class="line">b__objc_msgForward&#x2F;&#x2F;跳转-&gt;__objc_msgForward</span><br><span class="line">END_ENTRY __objc_msgForward_impcache &#x2F;&#x2F; 结束__objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward &#x2F;&#x2F; 开始 __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrpx17, __objc_forward_handler@PAGE</span><br><span class="line">ldrp17, [x17, __objc_forward_handler@PAGEOFF]&#x2F;&#x2F;p17&#x3D; x17 和 __objc_forward_handler@PAGEOFF的和</span><br><span class="line">TailCallFunctionPointer x17 &#x2F;&#x2F;跳转-&gt; TailCallFunctionPointer</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward&#x2F;&#x2F;结束 __objc_msgForward</span><br></pre></td></tr></table></figure><p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure><p>网上有大神总结的点我们先参考下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</span><br><span class="line">    id receiver &#x3D; *(id *)frameStackPointer;</span><br><span class="line">    SEL sel &#x3D; *(SEL *)(frameStackPointer + 8);</span><br><span class="line">    const char *selName &#x3D; sel_getName(sel);</span><br><span class="line">    Class receiverClass &#x3D; object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 forwardingTargetForSelector:</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget &#x3D; [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        if (forwardingTarget &amp;&amp; forwardingTarget !&#x3D; receiver) &#123;</span><br><span class="line">            if (isStret &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                int ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;</span><br><span class="line">            return objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 僵尸对象</span><br><span class="line">    const char *className &#x3D; class_getName(receiverClass);</span><br><span class="line">    const char *zombiePrefix &#x3D; &quot;_NSZombie_&quot;;</span><br><span class="line">    size_t prefixLen &#x3D; strlen(zombiePrefix); &#x2F;&#x2F; 0xa</span><br><span class="line">    if (strncmp(className, zombiePrefix, prefixLen) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        CFLog(kCFLogLevelError,</span><br><span class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature &#x3D; [receiver methodSignatureForSelector:sel];</span><br><span class="line">        if (methodSignature) &#123;</span><br><span class="line">            BOOL signatureIsStret &#x3D; [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            if (signatureIsStret !&#x3D; isStret) &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#39;%s&#39;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">                      isStret ? &quot;&quot; : not);</span><br><span class="line">            &#125;</span><br><span class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">                NSInvocation *invocation &#x3D; [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                void *returnValue &#x3D; NULL;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                return returnValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: object %p of class &#39;%s&#39; does not implement forwardInvocation: -- dropping message&quot;,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel &#x3D; sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; selector 是否已经在 Runtime 注册过</span><br><span class="line">    if (sel !&#x3D; registeredSel) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &#39;%s&#39; does not match selector known to Objective C runtime (%p)-- abort&quot;,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; &#x2F;&#x2F; doesNotRecognizeSelector</span><br><span class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: object %p of class &#39;%s&#39; does not implement doesNotRecognizeSelector: -- abort&quot;,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The point of no return.</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证动态解析"><a href="#验证动态解析" class="headerlink" title="验证动态解析"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">Method me &#x3D; class_getInstanceMethod(self, @selector(test2));</span><br><span class="line">class_addMethod(self, sel,</span><br><span class="line">method_getImplementation(me),</span><br><span class="line">method_getTypeEncoding(me));</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test2&#123;</span><br><span class="line">NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *p &#x3D; [[Person alloc]init];</span><br><span class="line">[p test];</span><br><span class="line">[p test];</span><br><span class="line"> &#x2F;&#x2F;输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line"> -[FYPerson test3]</span><br><span class="line"> -[FYPerson test3]</span><br></pre></td></tr></table></figure><p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p><p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">+ (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">Method me &#x3D; class_getClassMethod(self, @selector(test3));&#x2F;&#x2F;获取method</span><br><span class="line">&#x2F;&#x2F;给sel 添加方法实现 @selecter(test3)</span><br><span class="line">class_addMethod(object_getClass(self), sel,</span><br><span class="line">method_getImplementation(me),</span><br><span class="line">method_getTypeEncoding(me));</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Person test];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[Person resolveClassMethod:]</span><br><span class="line">来了，老弟</span><br></pre></td></tr></table></figure><p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">&#x2F;&#x2F;        Method me &#x3D; class_getInstanceMethod(self, @selector(test3));</span><br><span class="line">&#x2F;&#x2F;        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</span><br><span class="line">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">void test3(id self,SEL sel)&#123;</span><br><span class="line">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line">test3:test</span><br><span class="line">test3:test</span><br></pre></td></tr></table></figure><p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p><h3 id="验证消息转发"><a href="#验证消息转发" class="headerlink" title="验证消息转发"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">if (aSelector &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">return [[Struent alloc]init];</span><br><span class="line">&#125;</span><br><span class="line">return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Student test]</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p><p>第一步没拦截，可以在第二步拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消息转发第二步 没有对象来处理方法，那将函数签名来实现</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">if (aSelector &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">NSMethodSignature *sign &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">return sign;</span><br><span class="line">&#125;</span><br><span class="line">return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数签名已返回，到了函数调用的地方</span><br><span class="line">&#x2F;&#x2F;selector 函数的sel</span><br><span class="line">&#x2F;&#x2F;target   函数调用者</span><br><span class="line">&#x2F;&#x2F;methodSignature 函数签名</span><br><span class="line">&#x2F;&#x2F;NSInvocation  封装数据的对象</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Person forwardInvocation:]</span><br></pre></td></tr></table></figure></p><p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, retain) NSMethodSignature *methodSignature;&#x2F;&#x2F;只读</span><br><span class="line">- (void)retainArguments;</span><br><span class="line">@property (readonly) BOOL argumentsRetained;</span><br><span class="line">@property (nullable, assign) id target;&#x2F;&#x2F;读写</span><br><span class="line">@property SEL selector;&#x2F;&#x2F;读写</span><br></pre></td></tr></table></figure><p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;class 转发</span><br><span class="line">&#x2F;&#x2F; 消息转发第一步 拦截是否有转发的class对象处理方法</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">return [Student class];</span><br><span class="line">&#125;</span><br><span class="line">return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">&#x2F;&#x2F;NSLog(@&quot;+[Student test3]&quot;);</span><br><span class="line">&#x2F;&#x2F;当[Person test3]上一行写这么一行，Person *p &#x3D; [[Person alloc]init] 这句报错</span><br><span class="line">&#x2F;&#x2F;暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</span><br><span class="line">&#x2F;&#x2F;注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">-[Student test2]</span><br></pre></td></tr></table></figure><p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">return [[Student alloc]init];</span><br><span class="line">&#125;</span><br><span class="line">return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Student test3]</span><br></pre></td></tr></table></figure><p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消息转发第二步 没有class来处理方法，那将函数签名来实现</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">NSMethodSignature *sign &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">return sign;</span><br><span class="line">&#125;</span><br><span class="line">return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数签名已返回，到了函数调用的地方</span><br><span class="line">&#x2F;&#x2F;selector 函数的sel</span><br><span class="line">&#x2F;&#x2F;target   函数调用者</span><br><span class="line">&#x2F;&#x2F;methodSignature 函数签名</span><br><span class="line">&#x2F;&#x2F;NSInvocation  封装数据的对象</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">&#x2F;&#x2F;anInvocation.selector &#x3D; @selector(test2);</span><br><span class="line">&#x2F;&#x2F;此处换成[Student class]同样可以</span><br><span class="line">&#x2F;&#x2F;anInvocation.target &#x3D; (id)[[Student alloc]init];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[anInvocation invoke];</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[Person forwardInvocation:]</span><br></pre></td></tr></table></figure><p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li><li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li><li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li><li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li><li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li></ul><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></li></ul><p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，&lt;code&gt;objc_class-&amp;gt;cache_t cache&lt;/code&gt;是一个是缓存最近调用&lt;code&gt;class&lt;/code&gt;的方法，当缓存剩余空间小余1/4则进行扩容，扩
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理 runtime-object_class拾遗基础篇--(6)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime-object_class%E6%8B%BE%E9%81%97%E5%9F%BA%E7%A1%80%E7%AF%87--(6)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20runtime-object_class%E6%8B%BE%E9%81%97%E5%9F%BA%E7%A1%80%E7%AF%87--(6)/</id>
    <published>2019-12-01T03:16:58.000Z</published>
    <updated>2020-09-04T04:40:21.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runtime-基础知识"><a href="#runtime-基础知识" class="headerlink" title="runtime 基础知识"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    &#x2F;&#x2F;****</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;isa.h&quot;</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                         </span><br><span class="line">      uintptr_t nonpointer        : 1;                              </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                 </span><br><span class="line">      uintptr_t nonpointer        : 1;                                  </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span><br><span class="line"># else</span><br><span class="line">#   error unknown architecture for packed isa</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure><p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    struct &#123;</span><br><span class="line">      uintptr_t nonpointer        : 1;                                </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p><h4 id="共用体基础知识"><a href="#共用体基础知识" class="headerlink" title="共用体基础知识"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) BOOL rich;</span><br><span class="line">@property (nonatomic,assign) BOOL tell;</span><br><span class="line">@property (nonatomic,assign) BOOL handsome;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后查看该类的实例占用空间大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.handsome &#x3D; YES;</span><br><span class="line">p.rich &#x3D; NO;</span><br><span class="line">NSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</span><br><span class="line">&#x2F;&#x2F;16</span><br></pre></td></tr></table></figure><p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现：</span><br><span class="line">&#x2F;&#x2F;使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</span><br><span class="line">&#x2F;&#x2F;#define FYHandsomeMask 0b00000001</span><br><span class="line">&#x2F;&#x2F;#define FYTallMask 0b00000010</span><br><span class="line">&#x2F;&#x2F;#define FYRichMask 0b00000001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FYHandsomeMask (1&lt;&lt;0)</span><br><span class="line">#define FYTallMask (1&lt;&lt;1)</span><br><span class="line">#define FYRichMask (1&lt;&lt;2)</span><br><span class="line"></span><br><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">char _richTellHandsome;&#x2F;&#x2F;0000 0000 rich tall handsome</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome|FYRichMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome&amp;~FYRichMask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome|FYTallMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome&amp;~FYTallMask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome|FYHandsomeMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome&amp;~FYHandsomeMask;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">return !!(_richTellHandsome&amp;FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">return !!(_richTellHandsome&amp;FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">return !!(_richTellHandsome&amp;FYHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;char _richTellHandsome;&#x2F;&#x2F;0000 0000 rich tall handsome</span><br><span class="line">&#x2F;&#x2F;位域</span><br><span class="line">struct&#123;</span><br><span class="line">char tall : 1;&#x2F;&#x2F;高度</span><br><span class="line">char rich : 1;&#x2F;&#x2F;富有</span><br><span class="line">char handsome : 1; &#x2F;&#x2F;帅</span><br><span class="line">&#125; _richTellHandsome; &#x2F;&#x2F; 0b0000 0000</span><br><span class="line">&#x2F;&#x2F;使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</span><br><span class="line">&#x2F;&#x2F;使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">_richTellHandsome.rich &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">_richTellHandsome.tall &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">_richTellHandsome.handsome &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">return !!_richTellHandsome.rich;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">return !!_richTellHandsome.tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">return !!_richTellHandsome.handsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome|FYHandsomeMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome &#x3D; _richTellHandsome&amp;~FYHandsomeMask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">union &#123;</span><br><span class="line">char bits; &#x2F;&#x2F;一个字节8位 ricH &#x2F;tall&#x2F;handsome都是占用的bits的内存空间</span><br><span class="line">struct&#123;</span><br><span class="line">char tall : 1;&#x2F;&#x2F;高度</span><br><span class="line">char rich : 1;&#x2F;&#x2F;富有</span><br><span class="line">char handsome : 1; &#x2F;&#x2F;帅</span><br><span class="line">&#125;; &#x2F;&#x2F; 0b0000 0000</span><br><span class="line">&#125;_richTellHandsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome.bits |&#x3D; FYRichMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome.bits &amp;&#x3D; ~FYRichMask;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome.bits |&#x3D; FYTallMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome.bits &amp;&#x3D; ~FYTallMask;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">if (tall) &#123;</span><br><span class="line">_richTellHandsome.bits |&#x3D; FYHandsomeMask;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">_richTellHandsome.bits &amp;&#x3D; ~FYHandsomeMask;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">return !!(_richTellHandsome.bits &amp; FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">return !!(_richTellHandsome.bits &amp; FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">return (_richTellHandsome.bits &amp; FYHandsomeMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</span><br><span class="line">        NSKeyValueObservingOptionNew &#x3D; 0x01,</span><br><span class="line">    NSKeyValueObservingOptionOld &#x3D; 0x02,</span><br><span class="line">    NSKeyValueObservingOptionInitial &#x3D; 0x04,</span><br><span class="line">    NSKeyValueObservingOptionPrior &#x3D; 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">FYOne &#x3D; 1,&#x2F;&#x2F;  0b 0001</span><br><span class="line">FYTwo &#x3D; 2,&#x2F;&#x2F;  0b 0010</span><br><span class="line">FYTHree &#x3D; 4,&#x2F;&#x2F;0b 0100</span><br><span class="line">FYFour &#x3D; 8,&#x2F;&#x2F; 0b 1000</span><br><span class="line">&#125;FYOptions;</span><br><span class="line"></span><br><span class="line">- (void)setOptions:(FYOptions )ops&#123;</span><br><span class="line">if (ops &amp;FYOne) &#123;</span><br><span class="line">NSLog(@&quot;FYOne is show&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (ops &amp;FYTwo) &#123;</span><br><span class="line">NSLog(@&quot;FYTwo is show&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (ops &amp;FYTHree) &#123;</span><br><span class="line">NSLog(@&quot;FYTHree is show&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (ops &amp;FYFour) &#123;</span><br><span class="line">NSLog(@&quot;FYFour is show&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self setOptions:FYOne|FYTwo|FYTHree];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出是：</span><br><span class="line">FYOne is show</span><br><span class="line">FYTwo is show</span><br><span class="line">FYTHree is show</span><br></pre></td></tr></table></figure><p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p><h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>nonpointer</td><td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td></tr><tr><td>has_assoc</td><td>是否有设置过关联对象，如果没有，释放时会更快</td></tr><tr><td>has_cxx_dtor</td><td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td></tr><tr><td>shiftcls</td><td>存储着Class、Meta-Class对象的内存地址信息</td></tr><tr><td>magic</td><td>用于在调试时分辨对象是否未完成初始化</td></tr><tr><td>weakly_referenced</td><td>是否有被弱引用指向过，如果没有，释放时会更快</td></tr><tr><td>deallocating</td><td>对象是否正在释放</td></tr><tr><td>extra_rc</td><td>里面存储的值是引用计数器减1</td></tr><tr><td>has_sidetable_rc</td><td>引用计数器是否过大无法存储在isa中</td></tr></tbody></table><p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p><p>class结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct fy_objc_class : xx_objc_object &#123;</span><br><span class="line">Class superclass;</span><br><span class="line">cache_t cache;</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fy_objc_class* metaClass() &#123; &#x2F;&#x2F; 提供metaClass函数，获取元类对象</span><br><span class="line">&#x2F;&#x2F; 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span><br><span class="line">return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t version;</span><br><span class="line">const class_ro_t *ro;&#x2F;&#x2F;只读 数据</span><br><span class="line">method_list_t * methods;    &#x2F;&#x2F; 方法列表</span><br><span class="line">property_list_t *properties;    &#x2F;&#x2F; 属性列表</span><br><span class="line">const protocol_list_t * protocols;  &#x2F;&#x2F; 协议列表</span><br><span class="line">Class firstSubclass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t instanceStart;</span><br><span class="line">uint32_t instanceSize;  &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">const uint8_t * ivarLayout;</span><br><span class="line">const char * name;  &#x2F;&#x2F; 类名</span><br><span class="line">method_list_t * baseMethodList;</span><br><span class="line">protocol_list_t * baseProtocols;</span><br><span class="line">const ivar_list_t * ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">const uint8_t * weakIvarLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    &#x2F;&#x2F;如果已注册 就返回</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls &#x3D;&#x3D; remapClass(cls));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">&#x2F;&#x2F;只读ro</span><br><span class="line">    ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        &#x2F;&#x2F; This was a future class. rw data is already allocated.</span><br><span class="line">        rw &#x3D; cls-&gt;data();&#x2F;&#x2F;初始化ro</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Normal class. Allocate writeable class data.</span><br><span class="line">        &#x2F;&#x2F;初始化 rw </span><br><span class="line">        rw &#x3D; (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro &#x3D; ro;</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING;</span><br><span class="line">        &#x2F;&#x2F;指针指向rw 一开始是指向ro的</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta &#x3D; ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version &#x3D; isMeta ? 7 : 0;  &#x2F;&#x2F; old runtime went up to 6</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_list_t **beginCategoryMethodLists() &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    method_list_t **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    method_array_t duplicate() &#123;</span><br><span class="line">        return Super::duplicate&lt;method_array_t&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p><h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><ul><li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似</li><li>可以通过@selector()和sel_registerName()获得</li><li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul><h5 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9BcnRpY2xlcy9vY3J0VHlwZUVuY29kaW5ncy5odG1s" title="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">官方网站插件encodeing<i class="fa fa-external-link"></i></span></p><table><thead><tr><th>code</th><th>Meaning</th></tr></thead><tbody><tr><td>c</td><td>A char</td></tr><tr><td>i</td><td>An int</td></tr><tr><td>s</td><td>A short</td></tr><tr><td>l</td><td>A long</td></tr><tr><td>l</td><td>is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td>q</td><td>A long long</td></tr><tr><td>C</td><td>An unsigned char</td></tr><tr><td>I</td><td>An unsigned int</td></tr><tr><td>S</td><td>An unsigned short</td></tr><tr><td>L</td><td>An unsigned long</td></tr><tr><td>Q</td><td>An unsigned long long</td></tr><tr><td>f</td><td>A float</td></tr><tr><td>d</td><td>A double</td></tr><tr><td>B</td><td>A C++ bool or a C99 _Bool</td></tr><tr><td>v</td><td>A void</td></tr><tr><td>*</td><td>A character string (char *)</td></tr><tr><td>@</td><td>An object (whether statically typed or typed id)</td></tr><tr><td>#</td><td>A class object (Class)</td></tr><tr><td>:</td><td>A method selector (SEL)</td></tr><tr><td>[array type]</td><td>An array</td></tr><tr><td>{name=type…}</td><td>A structure</td></tr><tr><td>(name=type…)</td><td>A union</td></tr><tr><td>bnum</td><td>A bit field of num bits</td></tr><tr><td>^type</td><td>A pointer to type</td></tr><tr><td>?</td><td>An unknown type (among other things, this code is used for function pointers)</td></tr></tbody></table><p>我们通过一个例子来了解encode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)test:(int)age heiht:(float)height&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">SEL sel &#x3D; @selector(test:heiht:);</span><br><span class="line">Method m1&#x3D; class_getInstanceMethod(p.class, sel);</span><br><span class="line">const char *type &#x3D; method_getTypeEncoding(m1);</span><br><span class="line">NSLog(@&quot;%s&quot;,type);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">v24@0:8i16f20</span><br><span class="line">&#x2F;&#x2F;0id 8 SEL 16 int 20 float &#x3D; 24</span><br></pre></td></tr></table></figure><p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p><h4 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;&#x2F;&#x2F;散列表</span><br><span class="line">    mask_t _mask;&#x2F;&#x2F;散列表长度-1</span><br><span class="line">    mask_t _occupied;&#x2F;&#x2F;已经存储的方法数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">#if __arm64__</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">#else</span><br><span class="line">    cache_key_t _key;&#x2F;&#x2F;SEL作为key </span><br><span class="line">    MethodCacheIMP _imp; &#x2F;&#x2F;函数地址</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>散列表的数据结构表格所示</p><table><thead><tr><th>索引</th><th>bucket_t</th></tr></thead><tbody><tr><td>0</td><td>bucket_t(_key,_imp)</td></tr><tr><td>1</td><td>bucket_t(_key,_imp)</td></tr><tr><td>2</td><td>bucket_t(_key,_imp)</td></tr><tr><td>3</td><td>bucket_t(_key,_imp)</td></tr><tr><td>4</td><td>bucket_t(_key,_imp)</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; mask();</span><br><span class="line">&#x2F;&#x2F;key&amp;mask 得到索引</span><br><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hack</span><br><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span><br><span class="line">&#x2F;&#x2F; Caches are never built in the dyld shared cache.</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef MJClassInfo_h</span><br><span class="line">#define MJClassInfo_h</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">#if __arm__  ||  __x86_64__  ||  __i386__</span><br><span class="line">&#x2F;&#x2F; objc_msgSend has few registers available.</span><br><span class="line">&#x2F;&#x2F; Cache scan increments and wraps at special end-marking bucket.</span><br><span class="line">#define CACHE_END_MARKER 1</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif __arm64__</span><br><span class="line">&#x2F;&#x2F; objc_msgSend has lots of registers available.</span><br><span class="line">&#x2F;&#x2F; Cache scan decrements. No end marker needed.</span><br><span class="line">#define CACHE_END_MARKER 0</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#error unknown architecture</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">    </span><br><span class="line">    IMP imp(SEL selector)</span><br><span class="line">    &#123;</span><br><span class="line">        mask_t begin &#x3D; _mask &amp; (long long)selector;</span><br><span class="line">        mask_t i &#x3D; begin;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (_buckets[i]._key &#x3D;&#x3D; 0  ||  _buckets[i]._key &#x3D;&#x3D; (long long)selector) &#123;</span><br><span class="line">                return _buckets[i]._imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ((i &#x3D; cache_next(i, _mask)) !&#x3D; begin);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">    method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *type;</span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">    ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">    property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">    chained_property_list *next;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  &#x2F;&#x2F; 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    &#x2F;&#x2F; 方法列表</span><br><span class="line">    property_list_t *properties;    &#x2F;&#x2F; 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  &#x2F;&#x2F; 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* OC对象 *&#x2F;</span><br><span class="line">struct mj_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 类对象 *&#x2F;</span><br><span class="line">struct mj_objc_class : mj_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mj_objc_class* metaClass() &#123;</span><br><span class="line">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>测试代码是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">Method test1Method &#x3D; class_getInstanceMethod(p.class, @selector(test));</span><br><span class="line">Method test2Method &#x3D; class_getInstanceMethod(p.class, @selector(test2));</span><br><span class="line">IMP imp1&#x3D; method_getImplementation(test1Method);</span><br><span class="line">IMP imp2&#x3D; method_getImplementation(test2Method);</span><br><span class="line"></span><br><span class="line">mj_objc_class *cls &#x3D; (__bridge mj_objc_class *)p.class;</span><br><span class="line">NSLog(@&quot;-----&quot;);</span><br><span class="line">[p test];</span><br><span class="line">[p test2];</span><br><span class="line">cache_t cache &#x3D; cls-&gt;cache;</span><br><span class="line">bucket_t *buck &#x3D; cache._buckets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; cache._mask; i ++) &#123;</span><br><span class="line">bucket_t item &#x3D; buck[i];</span><br><span class="line">if (item._key !&#x3D; 0) &#123;</span><br><span class="line">NSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">p imp1</span><br><span class="line">(IMP) $0 &#x3D; 0x0000000100000df0 (day11-runtime1&#96;-[FYPerson test] at FYPerson.m:12)</span><br><span class="line">(lldb) p imp2</span><br><span class="line">(IMP) $1 &#x3D; 0x0000000100000e20 (day11-runtime1&#96;-[FYPerson test2] at FYPerson.m:15)</span><br><span class="line">p&#x2F;d @selector(test)             &#x2F;&#x2F;输出 test方法的sel地址</span><br><span class="line">(SEL) $6 &#x3D; 140734025103231 &quot;test&quot;</span><br><span class="line">(lldb) p&#x2F;d @selector(test2)     &#x2F;&#x2F;输出 test2方法的sel地址</span><br><span class="line">(SEL) $7 &#x3D; 4294971267 &quot;test2&quot;</span><br><span class="line"></span><br><span class="line">key1:140733954181041 imp1:0x7fff59fc4cd1</span><br><span class="line">key2:4294971267 imp2:0x100000e20         &#x2F;&#x2F;对应test2</span><br><span class="line">key3:140734025103231 imp3:0x100000df0    &#x2F;&#x2F;对应test1</span><br></pre></td></tr></table></figure><p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当initialized 没有执行完毕的时候不缓存</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache &lt;&#x3D; 3&#x2F;4 </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        扩容 之后，缓存清空</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;bucket_t 最小是4，当&gt;3&#x2F;4时候，扩容，空间扩容之后是之前的2️倍。</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">mj_objc_class *cls &#x3D; (__bridge mj_objc_class *)p.class;</span><br><span class="line">NSLog(@&quot;-----&quot;);</span><br><span class="line">[p test];</span><br><span class="line">&#x2F;*</span><br><span class="line"> key:init imp:0x7fff58807c2d</span><br><span class="line"> key:class imp:0x7fff588084b7</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test imp:0x100000bf0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> *&#x2F;</span><br><span class="line">[p test2]; &#x2F;&#x2F;当执行该函数的时候</span><br><span class="line">&#x2F;*</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test2 imp:0x100000c20</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">cache_t cache &#x3D; cls-&gt;cache;</span><br><span class="line">bucket_t *buck &#x3D; cache._buckets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; cache._mask; i ++) &#123;</span><br><span class="line">bucket_t item &#x3D; buck[i];</span><br><span class="line">&#x2F;&#x2F;            if (item._key !&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;                printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">    printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li><li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li><li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li><li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li><li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li></ul><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></p><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p></li></ul><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;runtime-基础知识&quot;&gt;&lt;a href=&quot;#runtime-基础知识&quot; class=&quot;headerlink&quot; title=&quot;runtime 基础知识&quot;&gt;&lt;/a&gt;runtime 基础知识&lt;/h3&gt;&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt;是运行时，在运行的时
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  block本质 --(5)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%20block%E6%9C%AC%E8%B4%A8%20--(5)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%20block%E6%9C%AC%E8%B4%A8%20--(5)/</id>
    <published>2019-12-01T03:15:58.000Z</published>
    <updated>2020-09-04T04:40:21.656Z</updated>
    
    <content type="html"><![CDATA[<p>本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。</p><h3 id="block本质"><a href="#block本质" class="headerlink" title="block本质"></a>block本质</h3><p>前几篇文章讲过了，<code>class</code>是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？<code>block</code>具有这几个特点：/</p><ul><li>block本质上也是一个OC对象，它内部也有isa指针</li><li>block是封装了函数调用以及函数调用环境的oc对象</li></ul><p>先简单来看一下<code>block</code>编译之后的样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (^block)(void) &#x3D; ^(void)&#123;</span><br><span class="line">            NSLog(@&quot;hello word&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp</code>,来到<code>main.cpp</code>内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">    &#x2F;&#x2F;构造函数 类似OC init函数</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;&#x2F;&#x2F;block类型</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;&#x2F;&#x2F; 执行函数的地址</span><br><span class="line">    Desc &#x3D; desc;&#x2F;&#x2F;desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    &#x2F;&#x2F;block 内部代码封装成函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;&#x2F;&#x2F;存储结构体占用空间的大小</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">&#x2F;&#x2F;定义block</span><br><span class="line">        void (*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">        &#x2F;&#x2F;执行block</span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终<code>block</code>转化成<code>__main_block_impl_0</code>结构体，赋值给变量<code>block</code>，传入参数是<code>__main_block_func_0</code>和<code>__main_block_desc_0_DATA</code>来执行<code>__main_block_impl_0</code>的构造函数，<code>__main_block_desc_0_DATA</code>函数赋值给<code>__main_block_impl_0-&gt;FuncPtr</code>，执行函数是<code>block-&gt;FuncPtr(block)</code>，删除冗余代码之前是<code>((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code>，那么为什么<code>block</code>可以直接强制转化成<code>__block_impl</code>呢？因为<code>__main_block_impl_0</code>结构体的第一行变量是<code>__block_impl</code>，相当于<code>__main_block_impl_0</code>的内存地址和<code>__block_impl</code>的内存地址一样，强制转化也不会有问题。</p><h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>变量捕获分为3种：</p><table><thead><tr><th>变量类型</th><th>是否会捕获到block内部</th><th>访问方式</th><th>内部变量假定是a</th></tr></thead><tbody><tr><td>局部变量 auto</td><td>会</td><td>值传递</td><td>a</td></tr><tr><td>局部变量 static</td><td>会</td><td>指针传递</td><td>*a</td></tr><tr><td>全局变量</td><td>不会</td><td>直接访问</td><td>空</td></tr></tbody></table><h4 id="auto变量捕获"><a href="#auto变量捕获" class="headerlink" title="auto变量捕获"></a>auto变量捕获</h4><p><code>auto</code> 变量，一般<code>auto</code>是省略不写的，访问方式是值传递，关于值传递不懂的话可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lRTUlODAlQkMlRTQlQkMlQTAlRTklODAlOTImYW1wO29xPSVFNSU4MCVCQyVFNCVCQyVBMCVFOSU4MCU5MiZhbXA7YXFzPWNocm9tZS4uNjlpNTcuNTE2OWowajQmYW1wO3NvdXJjZWlkPWNocm9tZSZhbXA7aWU9VVRGLTg=" title="https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&amp;oq=%E5%80%BC%E4%BC%A0%E9%80%92&amp;aqs=chrome..69i57.5169j0j4&amp;sourceid=chrome&amp;ie=UTF-8">这篇博客<i class="fa fa-external-link"></i></span>，<br>看下这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void (^block)(void) &#x3D; ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block();</span><br><span class="line">&#x2F;&#x2F;实际输出是 age is 10</span><br></pre></td></tr></table></figure><p>有没有疑问呢？在<code>block</code>执行之前<code>age =20</code>，为什么输出是10呢？<br>将这段代码转化成<code>c/c++</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;&#x2F;&#x2F;多了一个变量age,存储值是10</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        int age &#x3D; 10;</span><br><span class="line">        void (*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">        age &#x3D; 20;</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体<code>__main_block_impl_0</code>多了一个变量<code>age</code>，在<code>block</code>转化成<code>c</code>函数的时候<code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)</code>直接将age的值存储在<code>__main_block_impl_0.age</code>中，此时<code>__main_block_impl_0.age</code>是存储在堆上的，之前的<code>age</code>是存储在数据段的，执行<code>block</code>访问的变量是堆上的<code>`__main_block_impl_0.age</code>,所以最终输出来<code>age is 10</code>。</p><h4 id="static变量捕获"><a href="#static变量捕获" class="headerlink" title="static变量捕获"></a>static变量捕获</h4><p>我们通过一个例子来讲解static和auto区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void);</span><br><span class="line">void test()&#123;</span><br><span class="line">    int age &#x3D; 10;</span><br><span class="line">    static int level &#x3D; 12;</span><br><span class="line">    block &#x3D; ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;age is %d,level is %d&quot;,age,level);</span><br><span class="line">    &#125;;</span><br><span class="line">    age &#x3D; 20;</span><br><span class="line">    level &#x3D; 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        test();</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出：age is 10,level is 13</span><br></pre></td></tr></table></figure><p>转化成源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void);</span><br><span class="line"></span><br><span class="line">struct __test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __test_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  int *level;</span><br><span class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags&#x3D;0) : age(_age), level(_level) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">  int *level &#x3D; __cself-&gt;level; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __test_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">    int age &#x3D; 10;</span><br><span class="line">    static int level &#x3D; 12;</span><br><span class="line">    block &#x3D; ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, age, &amp;level));</span><br><span class="line">    age &#x3D; 20;</span><br><span class="line">    level &#x3D; 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        test();</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行完<code>test()</code>函数，<code>age</code>变量已经被收回，但是<code>age</code>的值存储在<code>block</code>结构体中，<code>level</code>的地址存储在<code>__test_block_impl_0.level</code>,可以看到<code>level</code>类型是指针类型，读取值的时候也是<code>*level</code>，则不管什么时间改动<code>level</code>的值，读<code>level</code>的值都是最新的，因为它是从地址直接读的。所以结果是<code>age is 10,level is 13</code>。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局不用捕获的，访问的时候直接访问。我们来测试下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">static int level &#x3D; 12;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        void(^block)(void) &#x3D; ^(void)&#123;</span><br><span class="line">            NSLog(@&quot;age is %d,level is %d&quot;,age,level);</span><br><span class="line">        &#125;;</span><br><span class="line">        age &#x3D; 20;</span><br><span class="line">        level &#x3D; 13;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化成<code>c/c++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">static int level &#x3D; 12;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        void(*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">        age &#x3D; 20;</span><br><span class="line">        level &#x3D; 13;</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来编译之后仅仅是多了两行<code>int age = 10;static int level = 12;</code>，结构体<code>__main_block_impl_0</code>内部和构造函数并没有专门来存储值或者指针，原因是当执行<code>__main_block_func_0</code>，可以直接访问变量<code>age</code>和 <code>level</code>，因为全局变量有效区域是全局，不会出了<code>main</code>函数就消失。<br><strong>基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。</strong></p><p>我们再看下更复杂的情况，对象类型的引用是如何处理的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;person is %@&quot;,self);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    void (^block2)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;name is %@&quot;,_name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __FYPerson__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __FYPerson__test_block_desc_0* Desc;</span><br><span class="line">  FYPerson *self;</span><br><span class="line">  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags&#x3D;0) : self(_self) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  FYPerson *self &#x3D; __cself-&gt;self; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);</span><br><span class="line">    &#125;</span><br><span class="line">static void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __FYPerson__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __FYPerson__test_block_impl_0*);</span><br><span class="line">&#125; __FYPerson__test_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">struct __FYPerson__test_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __FYPerson__test_block_desc_1* Desc;</span><br><span class="line">  FYPerson *self;</span><br><span class="line">  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags&#x3D;0) : self(_self) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) &#123;</span><br><span class="line">  FYPerson *self &#x3D; __cself-&gt;self; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));</span><br><span class="line">    &#125;</span><br><span class="line">static void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __FYPerson__test_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __FYPerson__test_block_impl_1*);</span><br><span class="line">&#125; __FYPerson__test_block_desc_1_DATA &#x3D; &#123; 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_FYPerson_test(FYPerson * self, SEL _cmd) &#123;</span><br><span class="line">    void (*block)(void) &#x3D; ((void (*)())&amp;__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &amp;__FYPerson__test_block_desc_0_DATA, self, 570425344));</span><br><span class="line"></span><br><span class="line">    void (*block2)(void) &#x3D; ((void (*)())&amp;__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &amp;__FYPerson__test_block_desc_1_DATA, self, 570425344));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>block</code>和<code>block2</code>都是结构体<code>__FYPerson__test_block_impl_1</code>内部引用了一个<code>FYPerson</code>对象指针，<code>FYPerson</code>对象属于局部变量，需要捕获。第2个<code>block</code>访问<code>_name</code>捕捉的也是<code>FYPerson</code>对象，访问<code>_name</code>，需要先访问<code>FYPerson</code>对象，然后再访问<code>_name</code>，本质上是访问<code>person.name</code>,所以捕捉的是<code>FYPerson</code>对象。</p><h4 id="验证block是对象类型："><a href="#验证block是对象类型：" class="headerlink" title="验证block是对象类型："></a>验证block是对象类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ARC环境下</span><br><span class="line">void(^block)(void)&#x3D;^&#123;</span><br><span class="line">NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@&quot;,[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);</span><br><span class="line">&#x2F;&#x2F;输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject</span><br></pre></td></tr></table></figure><p>可以了解到<code>block</code>是继承与基类的，所以<code>block</code>也是OC对象。</p><h4 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h4><p><code>block</code>有3种类型，如下所示，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承来自<code>NSBlock</code>类型。</p><ul><li><strong>NSGlobalBLock</strong>（_NSConcreteGLobalBlock）</li><li><strong>NSStackBlock</strong>（_NSConcreteStackBlock）</li><li><strong>NSMallocBLock</strong>（_NSConcreteMallocBlock）</li></ul><p>在应用程序中内存分配是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">程序区域 .text区</span><br><span class="line">---------------</span><br><span class="line">数据区域 .data区     &lt;--------- _NSConcreteGlobalBlock(存储全局变量)</span><br><span class="line">---------------</span><br><span class="line">堆                  &lt;--------- _NSConcreteMallocBlock(动态申请释放内存区域)</span><br><span class="line">---------------</span><br><span class="line">栈                  &lt;--------- _NSConcreteStackBlock(存储存局部变量)</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure><table><thead><tr><th>block类型</th><th>环境</th></tr></thead><tbody><tr><td><strong>NSGlobalBLock</strong></td><td>没有访问auto变量</td></tr><tr><td><strong>NSStackBlock</strong></td><td>访问auto变量</td></tr><tr><td><strong>NSMallocBLock</strong></td><td><strong>NSStackBlock</strong> 调用copy</td></tr></tbody></table><p>验证需要设置成MRC，找到工程文件，设置<code>project-&gt;Object-C Automatic Reference Counting=</code>为<code>NO</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line"></span><br><span class="line">void(^block1)(void)&#x3D;^&#123;</span><br><span class="line">NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">void(^block2)(void)&#x3D;^&#123;</span><br><span class="line">NSLog(@&quot;block2 %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">void(^block3)(void)&#x3D;[block2 copy];</span><br><span class="line">NSLog(@&quot;block1:%@   block2:%@ block3:%@ &quot;,[block1 class],[block2 class],[block3 class]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">block1:__NSGlobalBlock__   </span><br><span class="line">block2:__NSStackBlock__ </span><br><span class="line">block3:__NSMallocBlock__</span><br></pre></td></tr></table></figure><p>没有访问<code>auto</code>变量的<code>block</code>属于<code>__NSGlobalBlock__</code>，访问了auto变量的是<code>__NSStackBlock__</code>，手动调用了<code>copy</code>的<code>block</code>属于<code>__NSMallocBlock__</code>。<code>__NSMallocBlock__</code>是在堆上，需要程序员手动释放<code>[block3 release];</code>，不释放会造成内存泄露。</p><p>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下</p><table><thead><tr><th>block类型</th><th>副本源的配置存储域</th><th>复制效果</th></tr></thead><tbody><tr><td><strong>NSGlobalBLock</strong></td><td>堆</td><td>从栈复制到堆</td></tr><tr><td><strong>NSStackBlock</strong></td><td>程序的数据区域</td><td>什么也不做</td></tr><tr><td><strong>NSMallocBLock</strong></td><td>堆</td><td>引用计数+1</td></tr></tbody></table><h4 id="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"><a href="#在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况" class="headerlink" title="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"></a>在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况</h4><ul><li>block作为函数返回值时</li><li>将block赋值给__strong指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul><p>在ARC环境下测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^FYBlock)(void);</span><br><span class="line">typedef void (^FYBlockInt)(int);</span><br><span class="line">FYBlock myBlock()&#123;</span><br><span class="line">return ^&#123;</span><br><span class="line">NSLog(@&quot;哈哈&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">FYBlock myBlock2()&#123;</span><br><span class="line">int age &#x3D; 10;</span><br><span class="line">return ^&#123;</span><br><span class="line">NSLog(@&quot;哈哈 %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">FYBlock block &#x3D; myBlock();</span><br><span class="line">FYBlock block2 &#x3D; myBlock2();</span><br><span class="line">int age &#x3D; 10;</span><br><span class="line">FYBlock block3&#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot;强指针block %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;没访问变量:%@ 访问布局变量：%@ 强指针:%@&quot;,[block class],[block2 class],[block3 class]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">没访问变量:__NSGlobalBlock__ </span><br><span class="line">访问局部变量：__NSMallocBlock__ </span><br><span class="line">强指针:__NSMallocBlock__</span><br></pre></td></tr></table></figure><p><code>arc</code>环境下，没访问变量的<code>block</code>是<code>__NSGlobalBlock__</code>，访问了局部变量是<code>__NSMallocBlock__</code>,有强指针引用的是<code>__NSMallocBlock__</code>,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。</p><p><strong>所以有以下建议：</strong></p><p>MRC下block属性的建议写法</p><ul><li>@property (copy, nonatomic) void (^block)(void);</li></ul><p>ARC下block属性的建议写法</p><ul><li>@property (strong, nonatomic) void (^block)(void);</li><li>@property (copy, nonatomic) void (^block)(void);</li></ul><h3 id="对象类型数据和block交互"><a href="#对象类型数据和block交互" class="headerlink" title="对象类型数据和block交互"></a>对象类型数据和block交互</h3><p>平时我们使用<code>block</code>，对象类型来传递数据的比较多，对象类型读取到<code>block</code>中用<code>__block</code>修饰符，会把对象地址直接读取到<code>block</code>结构体内，<code>__weak</code>修饰的对象是弱引用，默认是强引用，我们看下这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;FYPerson.h</span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;FYPerson.m</span><br><span class="line">@implementation FYPerson</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;main.m</span><br><span class="line">typedef void (^FYBlock)(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">FYBlock block ;</span><br><span class="line">FYPerson *person &#x3D; [[FYPerson alloc]init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">__weak typeof(person) __weakPerson &#x3D; person;</span><br><span class="line">block &#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot; %d&quot;,__weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面该命令转化成<code>cpp</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>摘取关键结构体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  FYPerson *__weak __weakPerson;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags&#x3D;0) : __weakPerson(___weakPerson) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  FYPerson *__weak __weakPerson &#x3D; __cself-&gt;__weakPerson; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(&quot;age&quot;)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>FYPerson *__weak __weakPerson</code>是<code>__weak</code>修饰的对象<br>当block内部换成<code>block = ^{                NSLog(@&quot; %d&quot;,person.age);            };</code>，转换源码之后是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  FYPerson *__strong person;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags&#x3D;0) : person(_person) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>person</code>默认是使用<code>__storng</code>来修饰的，<code>arc</code>中，<code>block</code>引用外界变量，系统执行了<code>copy</code>操作，将<code>block</code> <code>copy</code>到堆上，由开发者自己管理，转<code>c/c++</code>中结构体描述为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;__weakPerson, (void*)src-&gt;__weakPerson, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;__weakPerson, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);&#125;</span><br></pre></td></tr></table></figure><p>有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数<code>void (*copy)</code>和<code>void (*dispose)</code>就是对block的引用计数的<code>+1</code>和<code>-1</code>。</p><p>如果block被拷贝到堆上</p><ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li></ul><p>如果block从堆上移除</p><ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）</li></ul><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">调用时机</th></tr></thead><tbody><tr><td style="text-align:center">copy函数</td><td style="text-align:center">栈上的Block复制到堆时</td></tr><tr><td style="text-align:center">dispose函数</td><td style="text-align:center">堆上的Block被废弃时</td></tr></tbody></table><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>person什么时间释放？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">FYPerson *person &#x3D; [[FYPerson alloc]init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3s后释放，<code>dispatch</code>对<code>block</code>强引用，<code>block</code>强引用<code>person</code>，在<code>block</code>释放的时候，<code>person</code>没其他的引用，就释放掉了。</p><p>变换1：<code>person</code>什么时间释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person &#x3D; [[FYPerson alloc]init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">__weak FYPerson *__weakPerosn &#x3D; person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,__weakPerosn.age);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>__weak</code>没有对<code>perosn</code>进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。<br>变换2：<code>person</code>什么时间释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person &#x3D; [[FYPerson alloc]init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">__weak typeof(person) __weakPerson &#x3D; person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,__weakPerson.age);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>person</code>被内部<code>block</code>强引用，则<code>block</code>销毁之前<code>person</code>不会释放，<code>__weakPerson</code>执行完<code>person</code>不会销毁，<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。答案是4秒之后<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。</p><p>变换3：<code>person</code>什么时间释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person &#x3D; [[FYPerson alloc]init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">__weak typeof(person) __weakPerson &#x3D; person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;---%d&quot;,__weakPerson.age);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>person</code>被强引用于第一层<code>block</code>，第二层弱引用<code>person</code>，仅仅当第一层block执行完毕的时候，<code>person</code>释放。</p><h4 id="修改block外部变量"><a href="#修改block外部变量" class="headerlink" title="修改block外部变量"></a>修改block外部变量</h4><p>想要修改变量，首先要变量的有效区域，或者block持有变量的地址。<br>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">FYBlock block &#x3D; ^&#123;</span><br><span class="line">    age &#x3D; 20;&#x2F;&#x2F;会报错</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报错的原因是<code>age</code>是值传递，想要不报错只需要将<code>int age = 10</code>改成<code>static int age = 10</code>，就由值传递变成地址传递，有了<code>age</code>的地址，在<code>block</code>的内部就可以更改<code>age</code>的值了。或者将<code>int age = 10</code>改成全局变量，全局变量在<code>block</code>中不用捕获，<code>block</code>本质会编译成<code>c</code>函数，<code>c</code>函数访问全局变量在任意地方都可以直接访问。</p><h4 id="block本质-1"><a href="#block本质-1" class="headerlink" title="__block本质"></a>__block本质</h4><p><code>__block</code>本质上是修饰的对象或基本类型，编译之后会生成一个结构体<code>__Block_byref_age_0</code>,结构体中<code>*__forwarding</code>指向结构体自己，通过<br><code>(age-&gt;__forwarding-&gt;age) = 20</code>来修改变量的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;&#x2F;&#x2F;10</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags&#x3D;0) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by ref</span><br><span class="line">            (age-&gt;__forwarding-&gt;age) &#x3D; 20;</span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>age</code>在<code>block</code>外部有一个，在<code>block</code>内部有一个，他们是同一个吗？我们来探究一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef   void (^FYBlock)(void);</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    struct __Block_byref_age_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int age;&#x2F;&#x2F;10</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    struct __Block_byref_age_0 *age; &#x2F;&#x2F; by ref</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    &#x2F;&#x2F; insert code here...</span><br><span class="line">__blockint age &#x3D; 10;</span><br><span class="line">        NSLog(@&quot; age1:%p&quot;,&amp;age);</span><br><span class="line">        FYBlock block &#x3D; ^&#123;</span><br><span class="line">            age &#x3D; 20;</span><br><span class="line">            NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">        &#125;;</span><br><span class="line">        struct __main_block_impl_0 *main&#x3D; (__bridge struct __main_block_impl_0 *)block;</span><br><span class="line">        NSLog(@&quot; age1:%p age2:%p&quot;,&amp;age,&amp;(main-&gt;age-&gt;__forwarding-&gt;age));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">age1:0x7ffeefbff548</span><br><span class="line">age1:0x100605358 age2:0x100605358</span><br></pre></td></tr></table></figure><p>经过<code>__block</code>修饰之后，之后访问的<code>age</code>和结构体<code>__Block_byref_age_0</code>中的<code>age</code>地址是一样的，可以判定<code>age</code>被系统<code>copy</code>了一份。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__blockint age &#x3D; 10;</span><br><span class="line">       NSLog(@&quot; age1:%p&quot;,&amp;age);</span><br><span class="line">       NSObject *obj&#x3D;[[NSObject alloc]init];</span><br><span class="line">       FYBlock block &#x3D; ^&#123;</span><br><span class="line">           </span><br><span class="line">           NSLog(@&quot;age is %d,obj is %p&quot;,age,&amp;obj);</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><p>使用命令编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 main.m</span><br></pre></td></tr></table></figure><p>摘录主要函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *__strong obj;</span><br><span class="line">  __Block_byref_age_0 *age; &#x2F;&#x2F; by ref</span><br><span class="line">&#125;;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">&#96;__main_block_impl_0&#96;结构体对&#96;age&#96;进行了一个强引用并持有该结构体的地址，将&#96;age&#96;复制到了堆上，&#96;age&#96;转化成&#96;__Block_byref_age_0&#96;对象，&#96;__main_block_impl_0&#96;可以对&#96;__Block_byref_age_0-&gt;__forwarding-&gt;age&#96;进行赋值。&#96;__Block_byref_age_0&#96;既然是对象，就需要内存管理，&#96;__main_block_copy_0&#96;出现了&#96;_Block_object_assign&#96;和&#96;_Block_object_dispose&#96;对&#96;__Block_byref_age_0&#96;进行内存管理的代码。</span><br></pre></td></tr></table></figure><p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {<br>    _Block_object_assign((void<em>)&amp;dst-&gt;age, (void</em>)src-&gt;age, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>    _Block_object_assign((void<em>)&amp;dst-&gt;obj, (void</em>)src-&gt;obj, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/);}</p><pre><code>static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;age&#96;和&#96;obj&#96;是一个对象结构体，&#96;obj&#96;只是一个强引用而没有地址变换原因是&#96;obj&#96;本身就在堆上，&#96;block&#96;也在堆上，故无需复制出新的&#96;obj&#96;来进行管理。</span><br><span class="line"></span><br><span class="line">看一下循环引用是反面教材</span><br></pre></td></tr></table></figure><p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject</p><p>@property (nonatomic,copy) FYBlock blcok;<br>@end</p><p>@implementation FYPerson</p><ul><li>(void)dealloc{<br>  NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end</li></ul><p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSLog(@” age1:%p”,&amp;age);<br>        FYPerson </em>obj=[[FYPerson alloc]init];<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;obj);<br>        }];<br>        NSLog(@”————–”);<br>    }<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出是：</span><br></pre></td></tr></table></figure><br>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;obj&#96;通过&#96;copy&#96;操作强引用&#96;block&#96;,&#96;block&#96;通过默认&#96;__strong&#96;强制引用&#96;obj&#96;,这就是&#96;A&lt;----&gt;B&#96;，相互引用导致执行结束应该释放的时候无法释放。</span><br><span class="line">将&#96;main&#96;改成</span><br></pre></td></tr></table></figure><br>FYPerson <em>obj=[[FYPerson alloc]init];<br>        <strong>weak typeof(obj) weakObj = obj;<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;weakObj);<br>        }];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果是</span><br></pre></td></tr></table></figure><br>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br>-[FYPerson dealloc]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用&#96;__weak&#96;或&#96;__unsafe__unretain&#96;弱引用&#96;obj&#96;,在&#96;block&#96;执行完毕的时候，&#96;obj&#96;释放，&#96;block&#96;释放，无相互强引用，正常释放。</span><br><span class="line">#### &#96;__weak&#96;和&#96;__unsafe__unretain&#96;</span><br><span class="line">&#96;__weak&#96;和&#96;__unsafe__unretain&#96;都是弱引用&#96;obj&#96;,都是不影响&#96;obj&#96;正常释放，区别是&#96;__weak&#96;在释放之后会将值为nil，&#96;__unsafe__unretain&#96;不对该内存处理。</span><br><span class="line">下面我们来具体验证一下该结论：</span><br></pre></td></tr></table></figure><br>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject<br>@property (nonatomic,assign) int age ;<br>@end<br>@implementation FYPerson<br>-(void)dealloc{<br>    NSLog(@”%s”,</strong>func<strong>);<br>}<br>@end<br>struct </strong>Block_byref_age_0 {<br>    void </em><strong>isa;<br>    struct </strong>Block_byref_age_0 <em><strong>forwarding;<br>    int </strong>flags;<br>    int <strong>size;<br>    int age;<br>};<br>struct </strong>block_impl {<br>    void </em>isa;<br>    int Flags;<br>    int Reserved;<br>    void <em>FuncPtr;<br>};<br>struct __main_block_desc_0 {<br>    size_t reserved;<br>    size_t Block_size;<br>    void (</em>copy)(void);<br>    void (<em>dispose)(void);<br>};<br>struct <strong>main_block_impl_0 {<br>    struct </strong>block_impl impl;<br>    struct __main_block_desc_0</em> Desc;<br>    FYPerson *<strong>unsafe_unretained </strong>unsafe_obj;<br>};</p><p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        // insert code here…<br>        FYBlock block;<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            obj.age = 5;<br>            <strong>weak typeof(obj) </strong>unsafe_obj = obj;<br>            block = ^{</p><pre><code>            NSLog(@&quot;obj-&gt;age is %d obj:%p&quot;,__unsafe_obj.age,&amp;__unsafe_obj);        };        struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;        NSLog(@&quot;inside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点1    }    struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;    NSLog(@&quot;outside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点2    block();    NSLog(@&quot;----end------&quot;);}return 0;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据文中提示断点1处使用&#96;lldb&#96;打印&#96;obj&#96;命令</span><br></pre></td></tr></table></figure><br>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5 //年龄5还是存储在这里的<br>inside struct-&gt;obj:0x102929d80</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在断点2处再次查看&#96;obj&#96;的值，报错不可读取该内存</span><br></pre></td></tr></table></figure><p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x0<br>p suct-&gt;<strong>unsafe_obj-&gt;_age<br>error: Couldn’t apply expression side effects : Couldn’t dematerialize a result variable: couldn’t read its memory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">已经超出了&#96;obj&#96;的有效范围，&#96;obj&#96;已经重置为nil，也就是&#96;0x0000000000000000&#96;。</span><br><span class="line">上文代码&#96;__weak&#96;改为&#96;__unsafe_unretained&#96;再次在&#96;obj&#96;断点1查看地址：</span><br></pre></td></tr></table></figure><br>(lldb) p suct-&gt;</strong>unsafe_obj-&gt;_age<br>(int) $0 = 5<br>inside struct-&gt;obj:0x10078c0c0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在断点2出再次查看地址并查看&#96;age&#96;的值</span><br></pre></td></tr></table></figure><p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x10078c0c0<br>(lldb) p suct-&gt;<strong>unsafe_obj-&gt;_age<br>(int) $1 = 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;__unsafe_unretained&#96;在&#96;obj&#96;销毁之后内存并没有及时重置为空。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们离开某个页面需要再执行的操作，那么我们改怎么办？</span><br><span class="line">实际应用A:</span><br></pre></td></tr></table></figure><br>-(void)test{    </strong>weak typeof(self) <strong>weakself = self;<br>    [self setBlcok:^{<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>            NSLog(@”perosn :%p”,</strong>weakself);<br>        });<br>    }];<br>    self.blcok();<br>}</p><p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            [obj test];<br>            NSLog(@”block 执行完毕————–”);<br>        }<br>        NSLog(@”person 死了”);<br>    }<br>    return 0;<br>}<br>输出：<br>block 执行完毕————–<br>-[FYPerson dealloc]<br>person 死了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">猛的一看，哪里都对！使用&#96;__weak&#96;对&#96;self&#96;进行弱引用，不会导致死循环，在&#96;self&#96;死的时候，&#96;block&#96;也会死，就会导致一个问题，&#96;self&#96;和&#96;block&#96;共存亡，但是这个需要3秒后再执行，3秒后，&#96;self&#96;已经死了，&#96;block&#96;也死了，显然不符合我们的业务需求。</span><br><span class="line">那么我们剥离&#96;block&#96;和&#96;self&#96;的关系，让&#96;block&#96;强引用&#96;self&#96;,&#96;self&#96;不持有&#96;block&#96;就能满足业务了。如下所示：</span><br></pre></td></tr></table></figure><br>    <strong>block typeof(self) </strong>weakSelf = self;//<strong>block或者没有修饰符<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        sleep(2);<br>        NSLog(@”obj:%@”,</strong>weakSelf-&gt;_obj);<br>    });<br>//perosn :0x0<br>```</p><p>当<code>self</code>不持用<code>block</code>的时候，<code>block</code>可以强引用<code>self</code>,<code>block</code>执行完毕自己释放，也会释放<code>self</code>，当<code>self</code>持有<code>block</code>，<code>block</code>必须弱引用<code>self</code>,则释放<code>self</code>,<code>block</code>也会释放，否则会循环引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>block</code>本质是一个封装了函数调用以及调用环境的<code>结构体</code>对象</li><li><code>__block</code>修饰的变量会被封装成<code>结构体</code>对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决<code>auto</code>对象在<code>block</code>内部无法修改的问题，在<code>MRC</code>环境下,<code>__block</code>不会对变量产生强引用.</li><li><code>block</code>不使用<code>copy</code>则不会从全局或者栈区域移动到堆上，使用<code>copy</code>之后有由发者管理</li><li>使用<code>block</code>要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。</li><li><code>__weak</code>修饰的对象，<code>block</code>不会对对象强引用，在执行<code>block</code>的时候有可能会值已经被系统置为<code>nil</code>,<code>__unsafe_unretained</code>修饰的销毁之后内存不会及时重置为空。</li></ul><p>我们看的<code>cpp</code>是编译之后的代码，<code>runtime</code>是否和我们看到的一致呢？请听下回分解。</p><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></p><p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p></li></ul><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。&lt;/p&gt;
&lt;h3 id=&quot;block本质&quot;&gt;&lt;a href=&quot;#block本质&quot; class=&quot;headerlink&quot; title=&quot;block本质&quot;&gt;&lt;/a&gt;block本质&lt;/h3&gt;&lt;p&gt;前几篇文章讲过了
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理 Category与关联对象本质--(4)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20Category%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8--(4)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20Category%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8--(4)/</id>
    <published>2019-12-01T03:14:58.000Z</published>
    <updated>2020-09-04T04:40:21.656Z</updated>
    
    <content type="html"><![CDATA[<p> 今天我们再看一下<code>Category</code>的底层原理。<br> 先看一下<code>Category</code>的简单使用，首先新增一个类的<code>Category</code>，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">- (void)run;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(void)run&#123;</span><br><span class="line">NSLog(@&quot;run is run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类别</span><br><span class="line">@interface FYPerson (test)</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson (test)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">NSLog(@&quot;test is run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">#import &quot;FYPerson.h&quot;</span><br><span class="line">#import &quot;FYPerson+test.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *person&#x3D;[[FYPerson alloc]init];</span><br><span class="line">[person test];</span><br><span class="line">[person run];</span><br></pre></td></tr></table></figure><p>  类别使用就是这么简单。<br>  那么类别的本质是什么呢？类的方法是存储在什么地方呢？<br>  第一篇<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDE1ODg3ZWU1MWQ0NTEwODEyNmQyOGQ=" title="https://juejin.im/post/5d15887ee51d45108126d28d">类的本质<i class="fa fa-external-link"></i></span>已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体<code>fy_objc_class</code>中的<code>class_data_bits_t-&gt;data()-&gt;method_list_t</code>中的，那么类别方法也是存储在<code>method_list_t</code>和取元类对象的<code>method_list_t</code>中的。编译的时候类别编译成结构体<code>_category_t</code>,然后<code>runtime</code>在运行时动态将方法添加到<code>method_list_t</code>中。运行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp</code>进入到<code>FYPerson+test.cpp</code>内部查看编译之后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  struct _category_t &#123;</span><br><span class="line">const char *name; &#x2F;&#x2F;&quot;FYPerson&quot;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;存储 test方法</span><br><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_FYPerson_test_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;_category_t 存储FYPerson的分类的数据</span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">&quot;FYPerson&quot;,</span><br><span class="line">0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_FYPerson,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,&#x2F;&#x2F;instace方法</span><br><span class="line">0,&#x2F;&#x2F;类方法</span><br><span class="line">0,&#x2F;&#x2F;协议方法</span><br><span class="line">0,&#x2F;&#x2F;属性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>存储在<code>_category_t</code>中的数据是什么时间加载到<code>FYPerson</code>的<code>class_data_bits_t.data</code>呢？我们探究一下，打开<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9vYmpjNC8=" title="https://opensource.apple.com/tarballs/objc4/">源码<i class="fa fa-external-link"></i></span>下载打开工程阅读源码找到<code>objc-os.mm</code>,通过查找函数运行顺序得到<code>_objec_init-&gt;map_images-&gt;map_images_noljock-&gt;_read_images-&gt;remethodizeClass(cls)-&gt;attachCategories(cls, cats, true /*flush caches*/)</code>，最终进入到<code>attachCategories</code>关键函数内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Attach method lists and properties and protocols from categories to a class.</span><br><span class="line">&#x2F;&#x2F; Assumes the categories in cats are all loaded and sorted by load order, </span><br><span class="line">&#x2F;&#x2F; oldest categories first.</span><br><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme rearrange to remove these intermediate allocations</span><br><span class="line">&#x2F;&#x2F;方法数组[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">    method_list_t **mlists &#x3D; (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">&#x2F;&#x2F;属性数组</span><br><span class="line">    property_list_t **proplists &#x3D; (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">&#x2F;&#x2F;协议数组</span><br><span class="line">    protocol_list_t **protolists &#x3D; (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount &#x3D; 0;</span><br><span class="line">    int propcount &#x3D; 0;</span><br><span class="line">    int protocount &#x3D; 0;</span><br><span class="line">    int i &#x3D; cats-&gt;count;</span><br><span class="line">    bool fromBundle &#x3D; NO;</span><br><span class="line">    &#x2F;&#x2F;最后的编译文件放到最前边</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">&#x2F;&#x2F;取出某个分类</span><br><span class="line">        auto&amp; entry &#x3D; cats-&gt;list[i];</span><br><span class="line">&#x2F;&#x2F;取出分类 的 instance方法或者class方法</span><br><span class="line">        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] &#x3D; mlist; &#x2F;&#x2F;mlists 接受所有分类方法</span><br><span class="line">            fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有分类属性</span><br><span class="line">        property_list_t *proplist &#x3D; </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] &#x3D; proplist;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有协议方法</span><br><span class="line">        protocol_list_t *protolist &#x3D; entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] &#x3D; protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;收集了所有协议 分类方法</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">&#x2F;&#x2F;追加所有分类方法</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">&#x2F;&#x2F;释放数组</span><br><span class="line">    free(mlists);</span><br><span class="line">&#x2F;&#x2F;刷新该类的缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">&#x2F;&#x2F;追加所有分类属性</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#x2F;&#x2F;追加所有分类协议</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attachCategories</code>是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到<code>rw-&gt;protocols.attachLists</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">        if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line">        if (hasArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; many lists -&gt; many lists</span><br><span class="line">            uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">&#x2F;&#x2F;一共需要的数量</span><br><span class="line">            uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">&#x2F;&#x2F;分配内存 内存不够用了，需要扩容</span><br><span class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">&#x2F;&#x2F;赋值count</span><br><span class="line">            array()-&gt;count &#x3D; newCount;</span><br><span class="line">&#x2F;&#x2F; array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br><span class="line">            memmove(array()-&gt;lists + addedCount&#x2F;*指针移动到数组末尾*&#x2F;, array()-&gt;lists&#x2F;*数组*&#x2F;,</span><br><span class="line">                    oldCount * sizeof(array()-&gt;lists[0])&#x2F;*移动数据的大小*&#x2F;);</span><br><span class="line">&#x2F;&#x2F;空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#x2F;*</span><br><span class="line">图示讲解：</span><br><span class="line">array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">addedCount:3</span><br><span class="line">addedLists:P-&gt;L-&gt;V</span><br><span class="line">memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</span><br><span class="line">P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line"> *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 0 lists -&gt; 1 list</span><br><span class="line">            list &#x3D; addedLists[0];</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 1 list -&gt; many lists</span><br><span class="line">            List* oldList &#x3D; list;</span><br><span class="line">            uint32_t oldCount &#x3D; oldList ? 1 : 0;</span><br><span class="line">            uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count &#x3D; newCount;</span><br><span class="line">            if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出来：</p><ol><li>首先通过<code>runtime</code>加载某个类的所有Category数据</li><li>把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边</li><li>将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。</li></ol><p>具体的编译顺序是project文件中-&gt;Build Phases-&gt;Complile Sources的顺序。</p><h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><h4 id="load加载顺序"><a href="#load加载顺序" class="headerlink" title="+load加载顺序"></a>+load加载顺序</h4><p>每个类和分类都会加载的时候调用<code>+load</code>方法，具体是怎么调用呢？我们查看源码<code>_objc_init-&gt;load_images-&gt;call_load_methods</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading &#x3D; NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        &#x2F;&#x2F;执行class+load直到完成</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;执行Category +load 一次</span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类<code>+load</code>在<code>Category+load</code>前边执行，当类的<code>+load</code>执行完毕然后再去执行<code>Category+load</code>,而且只有一次。<br>当class有子类的时候加载顺序呢？其实所有类都是基于<code>NSObject</code>，那么我们假设按照编译顺序加载<code>Class+load</code>，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类<code>+load</code>中的操作是第一个执行的，其他子类是按照<code>superclass-&gt;class-&gt;sonclass</code>的顺序执行的。<br>查看源码<code>_objc_init-&gt;load_images-&gt;prepare_load_methods((const headerType *)mh)-&gt;schedule_class_load</code>在<code>objc-runtime-new.mm</code>2856行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    &#x2F;&#x2F;递归调用自己直到调用clas-&gt;self</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">&#x2F;&#x2F;添加class</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以了解到该函数递归调用自己，直到<code>+load</code>方法已经调用过为止，所以不管编译顺序是高低，<code>+load</code>的加载顺序始终是<code>NSObject-&gt;FYPrson-&gt;FYStudent</code>。多个类平行关系的话，按照编译顺序加载。<br>下边是稍微复杂点的类关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSObject</span><br><span class="line">    Person</span><br><span class="line">        Student</span><br><span class="line">NSObjet</span><br><span class="line">    Car</span><br><span class="line">        BigCar</span><br><span class="line">            BigOrSmallCar</span><br></pre></td></tr></table></figure><p>编译顺序是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">Student</span><br><span class="line">Car</span><br><span class="line">BigOrSmallCar</span><br></pre></td></tr></table></figure><p>那么他们<code>+load</code>的加载顺序是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSobject-&gt;Person-&gt;Student-&gt;Car-&gt;BigCar-&gt;BigOrSmallCar</span><br></pre></td></tr></table></figure><p>看着不是很明白的 可以再看一下刚才的<code>schedule_class_load</code>函数。<br>加载成功之后，是按照<code>objc_msgsend()</code>流程发送的吗？我们进入到<code>call_class_loads</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以找到<code>(*load_method)(cls, SEL_load);</code>该函数，该函数是直接使用<code>IMP</code>执行的，<code>IMP</code>就是函数地址，可以直接访问函数而不用消息的转发流程。</p><h4 id="initialize调用"><a href="#initialize调用" class="headerlink" title="+initialize调用"></a>+initialize调用</h4><ul><li>+initialize方法会在类第一次接收到消息时调用</li><li>先调用父类的+initialize，再调用子类的+initialize</li><li>先初始化父类，再初始化子类，每个类只会初始化1次</li></ul><p><code>objc</code>源码解读过程<code>objc-msg-arm64.x-&gt;objc_msgSend-&gt;objc-&gt;runtime-new-&gt;class_getinstanceMethod-&gt;lookUpImpOrNil-&gt;lookUpImpOrForward-&gt;_clas_initialize-&gt;callInitialize-&gt;objc_msgSend(cls,SEL_Initialize)</code><br>在<code>runtime-new.h</code>4819行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                   NO&#x2F;*initialize*&#x2F;, NO&#x2F;*cache*&#x2F;, YES&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>lookUpImpOrNil</code>查看4916行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    bool triedResolver &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (cache) &#123;</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">      &#x2F;&#x2F;当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化</span><br><span class="line">      &#125;</span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line">   &#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line">    &#x2F;&#x2F;在本类中查找method</span><br><span class="line">    &#123;</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">        for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">             curClass !&#x3D; nil;</span><br><span class="line">             curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass cache.</span><br><span class="line">            imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                    &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                    &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass method list.</span><br><span class="line">            Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp &#x3D; meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t cache the result; we don&#39;t hold the lock so it may have </span><br><span class="line">        &#x2F;&#x2F; changed already. Re-do the search from scratch instead.</span><br><span class="line">        triedResolver &#x3D; YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help. </span><br><span class="line">    &#x2F;&#x2F; Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次收到消息，cls没有初始化，则调用<code>_class_initialize</code>进行初始化<br>我们进入到<code>_class_initialize</code>内部<code>objc-initialize.mm</code>484行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    &#x2F;&#x2F; See note about deadlock above.</span><br><span class="line">    &#x2F;&#x2F;递归调用父类是否有初始化和是否有父类</span><br><span class="line">    supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        &#x2F;&#x2F; We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Record that we&#39;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            &#x2F;&#x2F; LOL JK we don&#39;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Send the +initialize message.</span><br><span class="line">        &#x2F;&#x2F; Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        &#x2F;&#x2F; this class doesn&#39;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exceptions: A +initialize call that throws an exception </span><br><span class="line">        &#x2F;&#x2F; is deemed to be a complete and successful +initialize.</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        &#x2F;&#x2F; bootstrapping problem of this versus CF&#39;s call to</span><br><span class="line">        &#x2F;&#x2F; objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitializing()) &#123;</span><br><span class="line">        &#x2F;&#x2F; We couldn&#39;t set INITIALIZING because INITIALIZING was already set.</span><br><span class="line">        &#x2F;&#x2F; If this thread set it earlier, continue normally.</span><br><span class="line">        &#x2F;&#x2F; If some other thread set it, block until initialize is done.</span><br><span class="line">        &#x2F;&#x2F; It&#39;s ok if INITIALIZING changes to INITIALIZED while we&#39;re here, </span><br><span class="line">        &#x2F;&#x2F;   because we safely check for INITIALIZED inside the lock </span><br><span class="line">        &#x2F;&#x2F;   before blocking.</span><br><span class="line">        if (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (!MultithreadedForkChild) &#123;</span><br><span class="line">            waitForInitializeToComplete(cls);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; We&#39;re on the child side of fork(), facing a class that</span><br><span class="line">            &#x2F;&#x2F; was initializing by some other thread when fork() was called.</span><br><span class="line">            _setThisThreadIsInitializingClass(cls);</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Set CLS_INITIALIZING failed because someone else already </span><br><span class="line">        &#x2F;&#x2F;   initialized the class. Continue normally.</span><br><span class="line">        &#x2F;&#x2F; NOTE this check must come AFTER the ISINITIALIZING case.</span><br><span class="line">        &#x2F;&#x2F; Otherwise: Another thread is initializing this class. ISINITIALIZED </span><br><span class="line">        &#x2F;&#x2F;   is false. Skip this clause. Then the other thread finishes </span><br><span class="line">        &#x2F;&#x2F;   initialization and sets INITIALIZING&#x3D;no and INITIALIZED&#x3D;yes. </span><br><span class="line">        &#x2F;&#x2F;   Skip the ISINITIALIZING clause. Die horribly.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; We shouldn&#39;t be here. </span><br><span class="line">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，和<code>+load</code>方法一样，先父类后子类。然后赋值<code>reallyInitialize = YES;</code>，后边使用<code>try</code>主动调用<code>callInitialize(cls);</code>，来到<code>callInitialize(cls);</code>内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终还是使用<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</code>主动调用了该函数。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点<br>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>可能会被调用多次）<br>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用</p><p>用伪代码实现以下思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(class 没有初始化)&#123;</span><br><span class="line">    父类初始化</span><br><span class="line">    子类初始化</span><br><span class="line">    调用initialize</span><br><span class="line">&#125;</span><br><span class="line">如果子类没有实现initialize，则去调用父类initialize。</span><br></pre></td></tr></table></figure><p>至于子类没有实现的话是直接调用父类的<code>initialize</code>，是使用<code>objc-msgsend</code>的原因。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">+(void)initialize&#123;</span><br><span class="line">printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+(void)load&#123;</span><br><span class="line">printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@interface FYPerson (test1)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+(void)initialize&#123;</span><br><span class="line">printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+(void)load&#123;</span><br><span class="line">printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[FYPerson load]</span><br><span class="line">+[FYPerson(test2) load]</span><br><span class="line">+[FYPerson(test1) load]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>+load</code>是根据函数地址直接调用，<code>initialize</code>是通过<code>objc_msgSend</code>调用</li><li><code>+load</code>是runtime加载类、分类时候调用（只会调用一次）</li><li><code>initialize</code>是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）</li><li><code>+load</code>调用优先于<code>initialize</code>,子类调用<code>+load</code>之前会调用父类的<code>+load</code>，再调用分类的<code>+load</code>,分类之间先编译，先调用。</li><li><code>initialize</code>先初始化父类，再初始化子类（可能最终调用父类的<code>initialize</code>）</li></ul><h3 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h3><h4 id="关联对象的本质-结构体"><a href="#关联对象的本质-结构体" class="headerlink" title="关联对象的本质-结构体"></a>关联对象的本质-结构体</h4><p>继承<code>NSObject</code>是可以可以直接使用<code>@property (nonatomic,assign) int age;</code>，但是在<code>Category</code>中会报错，那么怎么实现和继承基类一样的效果呢？<br>我们查看<code>Category</code>结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  struct _category_t &#123;</span><br><span class="line">const char *name; &#x2F;&#x2F;&quot;FYPerson&quot;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>const struct _prop_list_t *properties;</code>是存储属性的，但是缺少成员变量，而我们也不能主动在<code>_category_t</code>插入<code>ivar</code>，那么我们可以使用<code>objc_setAssociatedObject</code>将属性的值存储全局的<code>AssociationsHashMap</code>中，使用的时候<code>objc_getAssociatedObject(id object, const void *key)</code>,不使用的时候删除使用<code>objc_removeAssociatedObjects</code>删除。</p><p>我们进入到<code>objc_setAssociatedObject</code>内部,<code>objc-references.mm</code>275行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    &#x2F;&#x2F; retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">&#x2F;&#x2F;根据key value 处理</span><br><span class="line">    id new_value &#x3D; value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">&#x2F;&#x2F;生成一个全局的 HashMap</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">&#x2F;&#x2F;有value 就处理</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            &#x2F;&#x2F; break any existing association.</span><br><span class="line">&#x2F;&#x2F;遍历 hashMap是否有该obj</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; secondary table exists</span><br><span class="line">&#x2F;&#x2F;有的话 更新其 value</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    j-&gt;second &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; create the new association (first time).</span><br><span class="line">&#x2F;&#x2F;没有的话 赋值给 refs</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] &#x3D; refs;</span><br><span class="line">                (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D;  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    &#x2F;&#x2F;删除refs </span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过该函数我们了解到</p><ul><li>关联对象并不是存储在关联对象的本身内存中</li><li>关联对象是存储在全局统一的<code>AssociationsManager</code>管理的<code>AssociationsHashMap</code>中</li><li>传入value =nil，会移除该关联对线<br><code>AssociationsManager</code>其实是管理了已<code>key为id object</code>对应的<code>AssociationsHashMap</code>，<code>AssociationsHashMap</code>存储了<code>key</code>对应的<code>ObjcAssociation</code>，<code>ObjcAssociation</code>是存储了<code>value</code> 和<code>policy</code>，<code>ObjcAssociation</code>的数据结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">        uintptr_t _policy;</span><br><span class="line">        id _value;</span><br><span class="line">        *****</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>具体抽象关系见下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager --&gt; AssociationsHashMap --&gt; ObjectAssociationMap</span><br><span class="line">--&gt;void * ObjectAssociation --&gt;uintprt_t _policy ,id _value;</span><br></pre></td></tr></table></figure><p>简单来讲就是一个全局变量保存了以<code>class</code>为<code>key</code>对应的<code>AssociationsHashMap</code>，这个<code>AssociationsHashMap</code>存储了一个<code>key</code>对应的<code>ObjectAssociation</code>，<code>ObjectAssociation</code>包含了<code>value</code>和<code>_policy</code>。通过2层map保存了数据。</p><h4 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h4><table><thead><tr><th>objc_setAssociatedObject</th><th>obj,key,value,policy</th></tr></thead><tbody><tr><td>objc_getAssociatedObject</td><td>根据 obj 和 key获取值</td></tr><tr><td>void objc_removeAssociatedObjects(id object)</td><td>根据obj 删除关联函数</td></tr></tbody></table><p><code>objc_AssociationPolicy</code>的类型：</p><table><thead><tr><th>OBJC_ASSOCIATION_ASSIGN</th><th>weak 引用</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>非原子强引用</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>非原子相当于copy</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>强引用</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>原子操作，相当于copy</td></tr></tbody></table><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (test)</span><br><span class="line">@property (nonatomic,assign) NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+test.h&quot;</span><br><span class="line">#import &quot;objc&#x2F;runtime.h&quot;</span><br><span class="line">@implementation NSObject (test)</span><br><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">return  objc_getAssociatedObject(self, @selector(name));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSObject *obj &#x3D;[[NSObject alloc]init];</span><br><span class="line">obj.name &#x3D; @&quot;老弟来了&quot;;</span><br><span class="line">printf(&quot;%s&quot;,obj.name.UTF8String);</span><br><span class="line">&#x2F;&#x2F;老弟来了</span><br></pre></td></tr></table></figure><p>这段代码我们实现了给基类添加一个成员变量<code>name</code>，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Category <code>+load</code>在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。</li><li>Category <code>+initialize</code>在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用<code>objc-msgsend</code>机制调用。</li><li>Category 可以利用<code>Associative</code>添加和读取属性的值</li></ul><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></p><p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>广告时间</p></li></ul><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 今天我们再看一下&lt;code&gt;Category&lt;/code&gt;的底层原理。&lt;br&gt; 先看一下&lt;code&gt;Category&lt;/code&gt;的简单使用，首先新增一个类的&lt;code&gt;Category&lt;/code&gt;，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  KVO和KVC本质与联系 --(3)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20KVO%E5%92%8CKVC%E6%9C%AC%E8%B4%A8%E4%B8%8E%E8%81%94%E7%B3%BB%20--(3)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20KVO%E5%92%8CKVC%E6%9C%AC%E8%B4%A8%E4%B8%8E%E8%81%94%E7%B3%BB%20--(3)/</id>
    <published>2019-12-01T03:13:58.000Z</published>
    <updated>2020-09-04T04:40:21.657Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道实例实际是存储了成员变量的值和指向类的<code>isa</code>指针，<code>class</code>对象和<code>meta-class</code>对象包含 <code>isa</code>、<code>superclass</code>和<code>class_rw_t</code>这几种结构体，只是数据不一样，<code>isa</code>需要<code>ISA_MASK</code>&amp;之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。</p><h3 id="KVO本质"><a href="#KVO本质" class="headerlink" title="KVO本质"></a>KVO本质</h3><p> 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;FYPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)FYPerson *person;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">&#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">self.person&#x3D;[FYPerson new];</span><br><span class="line">self.person.age &#x3D; 10;</span><br><span class="line">[self.person addObserver:self</span><br><span class="line">      forKeyPath:@&quot;age&quot;</span><br><span class="line">     options:NSKeyValueObservingOptionNew</span><br><span class="line">     context:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.person.age +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">NSLog(@&quot;监听到了age变化： %@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">[self.person removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下边是输出结果</span><br><span class="line">监听到了age变化： &#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 12;</span><br><span class="line">    old &#x3D; 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从上述代码可以看出，添加监听之后，当值改变时，会触发函数<code>observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</code>。</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">&#x2F;&#x2F;self.person.age +&#x3D; 1;</span><br><span class="line">[self.person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">[self.person didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当把<code>age</code>具体值的改变，变成手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>的时候，结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  监听到了age变化： &#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 10;</span><br><span class="line">    old &#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>new</code>和<code>old</code>的值竟然一样，经测试只有同时先后调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>，会触发回调函数<code>observeValueForKeyPath</code>，由此可知触发条件是<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>配合使用。</p><h4 id="探寻KVO底层实现原理"><a href="#探寻KVO底层实现原理" class="headerlink" title="探寻KVO底层实现原理"></a>探寻KVO底层实现原理</h4><p>通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。<br>我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。<br>说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。<br>KVO底层实现分析<br>首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)FYPerson *person;</span><br><span class="line">@property (nonatomic,strong)FYPerson *person2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">&#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">self.person&#x3D;[FYPerson new];</span><br><span class="line">self.person2 &#x3D;[FYPerson new];</span><br><span class="line">self.person.age &#x3D; 10;</span><br><span class="line">[self.person addObserver:self</span><br><span class="line">  forKeyPath:@&quot;age&quot;</span><br><span class="line"> options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</span><br><span class="line"> context:nil];</span><br><span class="line"> Class superclass &#x3D; NSStringFromClass( class_getSuperclass(NSClassFromString(@&quot;NSKVONotifying_FYPerson&quot;)));</span><br><span class="line">Class NSKVONotifying_FYPerson &#x3D; objc_getClass(&quot;NSKVONotifying_FYPerson&quot;);</span><br><span class="line">    fy_objc_class* NSKVONotifying_FYPerson_class &#x3D; (__bridge fy_objc_class *)NSKVONotifying_FYPerson;</span><br><span class="line"> &#x2F;&#x2F;此处打断点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;p 命令输出isa指针 </span><br><span class="line">(lldb) p self.person2-&gt;isa</span><br><span class="line">(Class) $0 &#x3D; FYPerson</span><br><span class="line">(lldb) p self.person-&gt;isa</span><br><span class="line">(Class) $1 &#x3D; NSKVONotifying_FYPerson</span><br><span class="line"></span><br><span class="line">(lldb) p superclass</span><br><span class="line">(Class) $0 &#x3D; FYPerson</span><br><span class="line"></span><br><span class="line">(lldb) p NSKVONotifying_FYPerson_class-&gt;superclass</span><br><span class="line">(Class) $4 &#x3D; FYPerson</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出的isa指针看来，经过<code>【person addObserver】</code>之后，<code>person</code>的<code>isa</code>指针指向了<code>NSKVONotifying_FYPerson</code>,而<code>person2</code>的<code>isa</code>是<code>FYPerson</code>，可以看出系统是对<code>instance</code>对象的<code>isa</code>进行了赋值操作。通过<code>p NSKVONotifying_FYPerson_class-&gt;superclass==FYPerson</code>可以看出isa是指向了子类，那么子类<code>NSKVONotifying_FYPerson</code>到底做了那些事情呢？</p><p>看下边代码查看函数isa改变过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">self.person&#x3D;[FYPerson new];</span><br><span class="line">self.person2 &#x3D;[FYPerson new];</span><br><span class="line">self.person.age &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;打断点 输出 po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">[self.person addObserver:self</span><br><span class="line">  forKeyPath:@&quot;age&quot;</span><br><span class="line"> options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</span><br><span class="line"> context:nil];</span><br><span class="line">&#x2F;&#x2F;打断点 输出 po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x000000010666b720</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x00000001069c63d2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看IMP指针对应地址和内容</span><br><span class="line">(lldb) p (IMP)0x000000010666b720</span><br><span class="line">(IMP) $2 &#x3D; 0x000000010666b720 (day03-KVO本质&#96;::-[FYPerson setAge:](int) at FYPerson.h:14)</span><br><span class="line">(lldb) p (IMP)0x00000001069c63d2</span><br><span class="line">(IMP) $3 &#x3D; 0x00000001069c63d2 (Foundation&#96;_NSSetIntValueAndNotify)</span><br></pre></td></tr></table></figure><p>可以看出来两次的函数地址不一致，添加KVO之前是<code>[FYPerson setAge:]</code>,添加之后是<code>(Foundation_NSSetIntValueAndNotify)</code>。我们将<code>age</code>的类型改成<code>double</code>，再看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x00000001080c4710</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x000000010841f18c</span><br><span class="line"></span><br><span class="line">(lldb) p (IMP)0x00000001080c4710</span><br><span class="line">(IMP) $2 &#x3D; 0x00000001080c4710 (day03-KVO本质&#96;::-[FYPerson setAge:](double) at FYPerson.h:14)</span><br><span class="line">(lldb) p (IMP)0x000000010841f18c</span><br><span class="line">(IMP) $3 &#x3D; 0x000000010841f18c (Foundation&#96;_NSSetDoubleValueAndNotify)</span><br></pre></td></tr></table></figure><p><code>age</code>是<code>int</code>的时候添加之后是<code>Foundation _NSSetIntValueAndNotify</code>,改成<code>double</code>之后，是<code>Foundation _NSSetDoubleValueAndNotify</code>。那么我们可以推测<code>Foundation</code>框架中还有很多例如<code>_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify</code>等等函数。<br>运行<code>nm Foundation | grep ValueAndNotify</code>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation  | grep ValueAndNotify</span><br><span class="line">__NSSetBoolValueAndNotify</span><br><span class="line">__NSSetCharValueAndNotify</span><br><span class="line">__NSSetDoubleValueAndNotify</span><br><span class="line">__NSSetFloatValueAndNotify</span><br><span class="line">__NSSetIntValueAndNotify</span><br><span class="line">__NSSetLongLongValueAndNotify</span><br><span class="line">__NSSetLongValueAndNotify</span><br><span class="line">__NSSetObjectValueAndNotify</span><br><span class="line">__NSSetPointValueAndNotify</span><br><span class="line">__NSSetRangeValueAndNotify</span><br><span class="line">__NSSetRectValueAndNotify</span><br><span class="line">__NSSetShortValueAndNotify</span><br><span class="line">__NSSetSizeValueAndNotify</span><br></pre></td></tr></table></figure><h4 id="另外一种验证方法"><a href="#另外一种验证方法" class="headerlink" title="另外一种验证方法"></a>另外一种验证方法</h4><p>在macOS中可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;开始记录日志</span><br><span class="line">instrumentObjcMessageSends(YES);</span><br><span class="line">    &#x2F;&#x2F; Do stuff.</span><br><span class="line">instrumentObjcMessageSends(NO);&#x2F;&#x2F;结束记录日志</span><br></pre></td></tr></table></figure><p>如果将<code>NSObjCMessageLoggingEnabled</code>环境变量设置为<code>YES</code>，则<code>Objective-C</code>运行时会将所有已分派的<code>Objective-C</code>消息记录到名为<code>/tmp/msgSends-&lt;pid&gt;</code>的文件中。每一次运行会生成一个文件，我们进入到该文件内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">+ FYPerson NSObject initialize</span><br><span class="line">+ FYPerson NSObject new</span><br><span class="line">- FYPerson NSObject init</span><br><span class="line">- FYPerson NSObject addObserver:forKeyPath:options:context:</span><br><span class="line">- FYPerson NSObject _isKVOA</span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类设置age [NSKVONotifying_FYPerson setAge:]</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:</span><br><span class="line">- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:</span><br><span class="line">- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:</span><br><span class="line"></span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;will changeValueForKey</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;FYPerson 设置age</span><br><span class="line">- FYPerson FYPerson setAge:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; didChangeValueForKeyOrKeys</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找到key 发送 具体的key对应的value 到observe</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject valueForKeyPath:</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject valueForKey:</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:</span><br><span class="line">-</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">- NSKVONotifying_FYPerson FYPerson age</span><br><span class="line">+ NSKeyValueMethodGetter NSObject alloc</span><br><span class="line">- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:</span><br><span class="line">- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject respondsToSelector:</span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class</span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA</span><br><span class="line">+ FYPerson NSObject class</span><br><span class="line">+ FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">+ FYPerson NSObject resolveInstanceMethod:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数据字典</span><br><span class="line">+ NSDictionary NSObject self</span><br><span class="line">+ NSMutableDictionary NSObject self</span><br><span class="line">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:</span><br><span class="line">- NSDictionary NSObject init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行观察者回调函数</span><br><span class="line">- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Student NSObject alloc</span><br><span class="line">- Student NSObject init</span><br><span class="line">- Student NSObject dealloc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***&#x2F;&#x2F;省略一部分代码</span><br><span class="line"> NSKVONotifying_FYPerson NSObject release</span><br><span class="line">- NSKeyValueChangeDictionary NSObject release</span><br><span class="line">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc</span><br><span class="line">- NSDictionary NSObject dealloc</span><br><span class="line">- NSKeyValueObservationInfo NSObject release</span><br><span class="line">- NSKVONotifying_FYPerson NSObject release</span><br></pre></td></tr></table></figure><p>经过仔细把重要的函数过滤出来，我们可以了解到<code>person.age = 12</code>的执行过程是<code>NSKVONotifying_FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues</code>-&gt;<code>FYPerson FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</code>-&gt;<code>NSKVONotifying_FYPerson NSObject valueForKeyPath:</code>-&gt;<code>NSMutableDictionary NSObject self</code>-&gt;<code>- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</code>，我们来用伪代码实现一遍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;person.age &#x3D; 12</span><br><span class="line">[NSKVONotifying_FYPerson setAge:12];</span><br><span class="line">willChangeValueForKey@&quot;age&quot;;</span><br><span class="line">[FYPerson setAge:12];</span><br><span class="line">didChangeValueForKey@&quot;age&quot;;</span><br><span class="line">[[NSMutableDictionary alloc] init];</span><br><span class="line">[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];</span><br></pre></td></tr></table></figure><p>NSKVONotifyin_Person内部结构是怎样的？<br>首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。<br>我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    p1.age &#x3D; 1.0;</span><br><span class="line">    Person *p2 &#x3D; [[Person alloc] init];</span><br><span class="line">    p1.age &#x3D; 2.0;</span><br><span class="line">    &#x2F;&#x2F; self 监听 p1的 age属性</span><br><span class="line">    NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">    [self printMethods: object_getClass(p2)];</span><br><span class="line">    [self printMethods: object_getClass(p1)];</span><br><span class="line"></span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) printMethods:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count ;</span><br><span class="line">    Method *methods &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    NSMutableString *methodNames &#x3D; [NSMutableString string];</span><br><span class="line">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methods[i];</span><br><span class="line">        NSString *methodName  &#x3D; NSStringFromSelector(method_getName(method));</span><br><span class="line">        </span><br><span class="line">        [methodNames appendString: methodName];</span><br><span class="line">        [methodNames appendString:@&quot; &quot;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果如下：</span><br><span class="line">NSKVONotifying_FYPerson - setAge: class dealloc _isKVOA</span><br><span class="line">FYPerson - setAge: age</span><br></pre></td></tr></table></figure><p> 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。</p><p><img src="/images/3-1.png" alt></p><p>这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。</p><p>如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。</p><p>那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (Class) class &#123;</span><br><span class="line">     &#x2F;&#x2F; 得到类对象，在找到类对象父类</span><br><span class="line">     return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后自己写代码验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(void)willChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">NSLog(@&quot;%s 开始&quot;,__func__);</span><br><span class="line">[super didChangeValueForKey:key];</span><br><span class="line">NSLog(@&quot;%s 结束&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">NSLog(@&quot;%s 开始&quot;,__func__);</span><br><span class="line">[super didChangeValueForKey:key];</span><br><span class="line">NSLog(@&quot;%s 结束&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setAge:(double)age&#123;</span><br><span class="line">_age &#x3D; age;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>执行之后结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-[FYPerson willChangeValueForKey:] 开始</span><br><span class="line">-[FYPerson willChangeValueForKey:] 结束</span><br><span class="line">-[FYPerson setAge:]</span><br><span class="line">-[FYPerson didChangeValueForKey:] 开始</span><br><span class="line"> 监听到了age变化： &#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 11;</span><br><span class="line">    old &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">-[FYPerson didChangeValueForKey:] 结束</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>KVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p><h3 id="KVC的本质"><a href="#KVC的本质" class="headerlink" title="KVC的本质"></a>KVC的本质</h3><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。<br>常用的API有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure><p>其实当Obj调用<code>(void)setValue:(id)value forKey:(NSString *)key</code>的时候，<code>obj</code>会主动寻找方法<code>setKey</code>和<code>_setKey</code>两个方法，没有找到这两个方法会再去寻找<code>accessInstanceVariablesDirectly</code>，返回值为<code>NO</code>则抛出异常，返回<code>YES</code>则去按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。<br>我们使用这段代码来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()&#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">&#x2F;&#x2F;code1</span><br><span class="line">- (void)setAge:(NSInteger)age&#123;</span><br><span class="line">NSLog(@&quot;%s %ld&quot;,__func__,(long)age);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;code2</span><br><span class="line">- (void)_setAge:(NSInteger)age&#123;</span><br><span class="line">NSLog(@&quot;%s %ld&quot;,__func__,(long)age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">[p setValue:@(2) forKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure><p>当执行<code>code1</code>和<code>code2</code>都有的时候，输出<code>-[FYPerson setAge:] 2</code>，当<code>code1</code>注释掉，输出<code>-[FYPerson _setAge:] 2</code>，可以看出执行顺序是<code>setAge</code>，没有<code>setAge</code>的时候再去执行<code>_setAge</code>。</p><p>现在新增<code>FYPerson</code>4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">NSInteger _age;</span><br><span class="line">NSInteger _isAge;</span><br><span class="line">NSInteger age;</span><br><span class="line">NSInteger isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">[p setValue:@(2) forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;age:%d _age:%d isAge:%d _isAge:%d&quot;,(int)p-&gt;age,(int)p-&gt;_age,(int)p-&gt;isAge,(int)p-&gt;_isAge);</span><br></pre></td></tr></table></figure></p><ul><li>没注释输出 <code>age:0 _age:2 isAge:0 _isAge:0</code></li><li>注释<code>_age</code>输出 <code>age:0 isAge:0 _isAge:2</code></li><li>注释<code>_isAge</code>输出 <code>age:2 isAge:0</code></li><li>注释<code>age</code>输出 <code>isAge:2</code></li></ul><h4 id="KVC和KVO联系"><a href="#KVC和KVO联系" class="headerlink" title="KVC和KVO联系"></a>KVC和KVO联系</h4><p>我们知道KVC本质也是调用setter方法，那么会出发KVO吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">[p addObserver:p</span><br><span class="line">forKeyPath:@&quot;age&quot;</span><br><span class="line">   options:NSKeyValueChangeNewKey</span><br><span class="line">   context:nil];</span><br><span class="line">[p setValue:@2 forKey:@&quot;age&quot;];</span><br><span class="line">[p removeObserver:p forKeyPath:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">@interface FYPerson()&#123;</span><br><span class="line">@public</span><br><span class="line">NSInteger _age;</span><br><span class="line">NSInteger _isAge;</span><br><span class="line">NSInteger age;</span><br><span class="line">NSInteger isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">&#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 2;</span><br><span class="line">    old &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试，可以看出KVC能触发KVO的。那么<code>valueForKey:key</code>底层是怎么运行的呢？其实底层是按照顺序查找四个方法<code>_age</code>-&gt;<code>_isAge</code>-&gt;<code>age</code>-&gt;<code>isAge</code>。我们测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">p-&gt;_age &#x3D; 1;</span><br><span class="line">p-&gt;_isAge &#x3D; 2;</span><br><span class="line">p-&gt;age &#x3D; 3;</span><br><span class="line">p-&gt;isAge &#x3D; 4;</span><br><span class="line">NSLog(@&quot;value:%@&quot;,[p valueForKey:@&quot;age&quot;]);</span><br><span class="line">&#x2F;&#x2F;依次注释1,2,3，依次输出是1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>KVC其实本质是执行4个set方法和4个get方法，当使用<code>setValue:forKey:key</code>会触发KVO，找不到4个方法的时候会抛出异常。</p><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li></ul><p>之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何<code>hook objc_msgsend</code>,感觉这个挺好玩的。</p><p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p> 广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道实例实际是存储了成员变量的值和指向类的&lt;code&gt;isa&lt;/code&gt;指针，&lt;code&gt;class&lt;/code&gt;对象和&lt;code&gt;meta-class&lt;/code&gt;对象包含 &lt;code&gt;isa&lt;/code&gt;、&lt;code&gt;superclass&lt;/code&gt;和&lt;code
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  类的本质 --(2)</title>
    <link href="http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8--(2)/"/>
    <id>http://fgyong.cn/2019/12/01/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8--(2)/</id>
    <published>2019-12-01T03:12:58.000Z</published>
    <updated>2020-09-04T04:40:21.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="底层原理-类的本质"><a href="#底层原理-类的本质" class="headerlink" title="底层原理 类的本质"></a>底层原理 类的本质</h3><p>复习一下<a href>IOS 底层原理 对象的本质–(1)</a>，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Person</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _age;&#x2F;&#x2F;4bytes</span><br><span class="line">int _level;&#x2F;&#x2F;4bytes</span><br><span class="line">int _code;&#x2F;&#x2F;4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>经过<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后其实<code>Person</code>对象是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">int _age;</span><br><span class="line">int _level;</span><br><span class="line">int _code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NSObject_IMPL</code>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么<code>NSObject</code>在内存中包括</p><ul><li><code>isa</code>指针</li><li>其他成员变量</li></ul><p><img src="/images/2-1.png" alt></p><p><code>isa</code>地址就是<code>instance</code>的地址，其他成员变量排在后边，也就是<code>instance</code>的地址就是<code>isa</code>的地址。</p><p>那么这个<code>isa</code>指向的到底是什么呢？<br>请往下继续看：<br>先看下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSObject *ob1&#x3D;[[NSObject alloc]init];</span><br><span class="line">NSObject *ob2&#x3D;[[NSObject alloc]init];</span><br><span class="line"></span><br><span class="line">Class cl1 &#x3D; object_getClass([ob1 class]);</span><br><span class="line">Class cl2 &#x3D; object_getClass([ob2 class]);</span><br><span class="line"></span><br><span class="line">Class cl3 &#x3D; ob1.class;</span><br><span class="line">Class cl4 &#x3D; ob2.class;</span><br><span class="line"></span><br><span class="line">Class cl5 &#x3D; NSObject.class;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot; %p %p %p %p %p&quot;,cl1,cl2,cl3,cl4,cl5);</span><br><span class="line">&#x2F;&#x2F;0x7fff8e3ba0f0 0x7fff8e3ba0f0 </span><br><span class="line">&#x2F;&#x2F;0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140</span><br></pre></td></tr></table></figure><p>这代码是输出了几个<code>NSObject</code>的对象的类和<code>NSObject</code>的类对象的地址，可以看到<code>cl1==cl2</code>、<code>cl3==cl4==cl5</code>。</p><h4 id="Class的本质"><a href="#Class的本质" class="headerlink" title="Class的本质"></a>Class的本质</h4><p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass &#x3D; [NSObject class];        </span><br><span class="line">Class objectMetaClass &#x3D; object_getClass([NSObject class]);</span><br></pre></td></tr></table></figure><p>点击class来到内部，可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p><code>class</code>对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p><p>来到<code>objc_class</code>内部，在源码中经常看到这段源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;&#x2F;&#x2F;isa</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                    &#x2F;&#x2F;父类          OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                              &#x2F;&#x2F;obj名字 OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                            &#x2F;&#x2F;版本 OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                               &#x2F;&#x2F;info OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                      &#x2F;&#x2F; OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars             &#x2F;&#x2F;成员变量链表     OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;&#x2F;&#x2F;方法链表</span><br><span class="line">    struct objc_cache * _Nonnull cache      &#x2F;&#x2F;缓存链表                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols         &#x2F;&#x2F;协议链表 OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">&#x2F;* Use &#96;Class&#96; instead of &#96;struct objc_class *&#96; *&#x2F;</span><br></pre></td></tr></table></figure><p>这段代码明显是 已经<code>OBJC2_UNAVAILABLE</code>，说明代码已经不在使用了。那么<code>objc_class</code>结构体内部结构到底是什么呢？通过objc搜寻<code>runtime</code>的内容可以看到<code>objc_class</code>内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setInfo(uint32_t set) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;setFlags(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void clearInfo(uint32_t clear) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;clearFlags(clear);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;**后边省略</span><br></pre></td></tr></table></figure><p>我们发现这个结构体继承 <code>objc_object</code> 并且结构体内有一些函数，因为这是<code>c++</code>结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到<code>objc_object</code>内，截取部分代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    &#x2F;&#x2F; If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    &#x2F;&#x2F; initInstanceIsa(): objects with no custom RR&#x2F;AWZ</span><br><span class="line">    &#x2F;&#x2F; initClassIsa(): class objects</span><br><span class="line">    &#x2F;&#x2F; initProtocolIsa(): protocol objects</span><br><span class="line">    &#x2F;&#x2F; initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls &#x2F;*nonpointer&#x3D;false*&#x2F;);</span><br><span class="line">    void initClassIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initProtocolIsa(Class cls &#x2F;*nonpointer&#x3D;maybe*&#x2F;);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br></pre></td></tr></table></figure><p>那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取<code>class_rw_t</code>内部实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    &#x2F;&#x2F; Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;&#x2F;&#x2F;方法列表</span><br><span class="line">    property_array_t properties;&#x2F;&#x2F;属性列表</span><br><span class="line">    protocol_array_t protocols;&#x2F;&#x2F;协议列表</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">**</span><br><span class="line">&#x2F;&#x2F;后边省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>class_rw_t</code>是通过<code>bits.data()</code>获取的，截取<code>bits.data()</code>查看内部实现,而仅仅是<code>bits&amp;FAST_DATA_MASK</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而成员变量则是存储在<code>class_ro_t</code>内部中的，我们来到<code>class_ro_t</code>内部查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;&#x2F;&#x2F;方法列表</span><br><span class="line">    protocol_list_t * baseProtocols;&#x2F;&#x2F;协议列表</span><br><span class="line">    const ivar_list_t * ivars;&#x2F;&#x2F;成员变量列表</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;&#x2F;&#x2F;属性列表</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后通过一张图总结一下：</p><p><img src="/images/2-2.png" alt></p><p>那么我们来证明一下：<br>我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。<br>下边代码是我们自定义的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Header.h</span><br><span class="line">&#x2F;&#x2F;  day02-类的本质1</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by Charlie on 2019&#x2F;7&#x2F;2.</span><br><span class="line">&#x2F;&#x2F;  Copyright © 2019 www.fgyong.cn. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">#ifndef Header_h</span><br><span class="line">#define Header_h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">cache_key_t _key;</span><br><span class="line">IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">bucket_t *_buckets;</span><br><span class="line">mask_t _mask;</span><br><span class="line">mask_t _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">uint32_t entsizeAndFlags;</span><br><span class="line">uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">SEL name;</span><br><span class="line">const char *types;</span><br><span class="line">IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">int32_t *offset;</span><br><span class="line">const char *name;</span><br><span class="line">const char *type;</span><br><span class="line">uint32_t alignment_raw;</span><br><span class="line">uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">chained_property_list *next;</span><br><span class="line">uint32_t count;</span><br><span class="line">property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">uintptr_t count;</span><br><span class="line">protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t instanceStart;</span><br><span class="line">uint32_t instanceSize;  &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">const uint8_t * ivarLayout;</span><br><span class="line">const char * name;  &#x2F;&#x2F; 类名</span><br><span class="line">method_list_t * baseMethodList;</span><br><span class="line">protocol_list_t * baseProtocols;</span><br><span class="line">const ivar_list_t * ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">const uint8_t * weakIvarLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t version;</span><br><span class="line">const class_ro_t *ro;</span><br><span class="line">method_list_t * methods;    &#x2F;&#x2F; 方法列表</span><br><span class="line">property_list_t *properties;    &#x2F;&#x2F; 属性列表</span><br><span class="line">const protocol_list_t * protocols;  &#x2F;&#x2F; 协议列表</span><br><span class="line">Class firstSubclass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">class_rw_t* data() &#123; &#x2F;&#x2F; 提供data()方法进行 &amp; FAST_DATA_MASK 操作</span><br><span class="line">return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* OC对象 *&#x2F;</span><br><span class="line">struct xx_objc_object &#123;</span><br><span class="line">void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 类对象 *&#x2F;</span><br><span class="line">struct fy_objc_class : xx_objc_object &#123;</span><br><span class="line">Class superclass;</span><br><span class="line">cache_t cache;</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fy_objc_class* metaClass() &#123; &#x2F;&#x2F; 提供metaClass函数，获取元类对象</span><br><span class="line">&#x2F;&#x2F; 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span><br><span class="line">return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif &#x2F;* Header_h *&#x2F;</span><br></pre></td></tr></table></figure><p>这段代码亲测可用，直接复制自己新建<code>.h</code>文件导入’main.m’即可，将<code>main.m</code>改成<code>main.mm</code>或者将其他某一个<code>.m</code>改成<code>.mm</code>运行就可以运行了。</p><p>那么我们再拿出来经典的那张图挨着分析<code>isa</code> 和<code>superclass</code>的指向</p><p><img src="/images/2-2.png" alt></p><h4 id="instance-对象验证"><a href="#instance-对象验证" class="headerlink" title="instance 对象验证"></a>instance 对象验证</h4><p>使用 <code>p/x</code>输出<code>obj</code>16进制的地址，然后<strong>isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</strong>。实施之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;object</span><br><span class="line"></span><br><span class="line">Printing description of student:</span><br><span class="line">&lt;Student: 0x1021729c0&gt;</span><br><span class="line">(lldb) p&#x2F;x object-&gt;isa &#x2F;&#x2F;查看isa指针地址</span><br><span class="line">(Class) $0 &#x3D; 0x001dffff8e3ba141 NSObject </span><br><span class="line">(lldb) p&#x2F;x objectClass&#x2F;&#x2F;输出 objectClass的地址</span><br><span class="line">(fy_objc_class *) $1 &#x3D; 0x00007fff8e3ba140</span><br><span class="line">(lldb) p&#x2F;x 0x001dffff8e3ba141&amp;0x00007ffffffffff8&#x2F;&#x2F;计算得出object-&gt;isa真正的地址</span><br><span class="line">(long) $2 &#x3D; 0x00007fff8e3ba140 &#x2F;&#x2F;0x00007fff8e3ba140是 objectClass地址和object-&gt;isa地址一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;person</span><br><span class="line"></span><br><span class="line">Printing description of person: &lt;Person: 0x102175300&gt;</span><br><span class="line">(lldb) p&#x2F;x person-&gt;isa</span><br><span class="line">(Class) $3 &#x3D; 0x001d800100002469 Person</span><br><span class="line">(lldb) p&#x2F;x 0x001d800100002469&amp;0x00007ffffffffff8</span><br><span class="line">(long) $4 &#x3D; 0x0000000100002468</span><br><span class="line">(lldb) p&#x2F;x personClass</span><br><span class="line">(fy_objc_class *) $5 &#x3D; 0x0000000100002468&#x2F;&#x2F;isa 和personclass地址都是0x0000000100002468</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;student</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x student-&gt;isa</span><br><span class="line">(Class) $6 &#x3D; 0x001d8001000024b9 Student</span><br><span class="line">(lldb) p&#x2F;x 0x001d8001000024b9&amp;0x00007ffffffffff8</span><br><span class="line">(long) $7 &#x3D; 0x00000001000024b8</span><br><span class="line">(lldb) p&#x2F;x studentClass</span><br><span class="line">(fy_objc_class *) $8 &#x3D; 0x00000001000024b8&#x2F;&#x2F;studentclass 和isa地址都是0x00000001000024b8</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。</p><h4 id="class-对象验证"><a href="#class-对象验证" class="headerlink" title="class 对象验证"></a>class 对象验证</h4><p>接着我们来看<code>class</code>对象，同样通过上一篇文章，我们明确<code>class</code>对象中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对<code>object</code>源码的分析，我们知道这些信息存储在<code>class</code>对象的<code>class_rw_t</code>中，我们通过强制转化来窥探其中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;objectClass and objectMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x objectClass-&gt;isa</span><br><span class="line">(__NSAtom *) $6 &#x3D; 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p&#x2F;x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</span><br><span class="line">(long) $7 &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p&#x2F;x objectMetaClass</span><br><span class="line">(fy_objc_class *) $8 &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;personClass and personMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x personClass-&gt;isa</span><br><span class="line">(__NSAtom *) $9 &#x3D; 0x001d800100002441</span><br><span class="line">(lldb) p&#x2F;x personMetaClass</span><br><span class="line">(fy_objc_class *) $10 &#x3D; 0x0000000100002440</span><br><span class="line">(lldb) p&#x2F;x 0x001d800100002441&amp;0x00007ffffffffff8</span><br><span class="line">(long) $11 &#x3D; 0x0000000100002440</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sutdentClass and studentMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x studentClass-&gt;isa</span><br><span class="line">(__NSAtom *) $12 &#x3D; 0x001d800100002491</span><br><span class="line">(lldb) p&#x2F;x 0x001d800100002491&amp;0x00007ffffffffff8</span><br><span class="line">(long) $13 &#x3D; 0x0000000100002490</span><br><span class="line">(lldb) p&#x2F;x studentMetaClass</span><br><span class="line">(fy_objc_class *) $14 &#x3D; 0x0000000100002490</span><br></pre></td></tr></table></figure><p>有此结果得知<code>objectMetaClass==objectClass-&gt;isa==0x00007fff8e3ba0f0</code>,<code>personClass-&gt;isa==personMetaClass==0x0000000100002440</code>,<code>studentClass-&gt;isa==studentMetaClass==0x0000000100002490</code>。<br>由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。</p><h4 id="meta-class对象验证"><a href="#meta-class对象验证" class="headerlink" title="meta-class对象验证"></a>meta-class对象验证</h4><p>最后我们来看<code>meta-class</code>元类对象，上文提到<code>meta-class</code>中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的类方法信息。同时我们知道<code>meta-class</code>元类对象与<code>class</code>类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的<code>isa</code>指针指向基类的元类对象，基类的元类对象的<code>isa</code>指针指向自己。元类对象的<code>superclass</code>指针指向其父类的元类对象，基类的元类对象的<code>superclass</code>指针指向其类对象。<br>与<code>class</code>对象相同，我们同样通过模拟对<code>person</code>元类对象调用<code>.data</code>函数，即对<code>bits</code>进行<code>&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)</code>运算，并转化为<code>class_rw_t</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objectMetaClass-&gt;superclass &#x3D; 0x00007fff8e3ba140  NSObject</span><br><span class="line">&#x2F;&#x2F;objectMetaClass-&gt;isa &#x3D;   0x00007fff8e3ba0f0</span><br><span class="line">&#x2F;&#x2F;objectMetaClass &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x objectMetaClass-&gt;superclass</span><br><span class="line">(Class) $20 &#x3D; 0x00007fff8e3ba140 NSObject</span><br><span class="line">(lldb) p&#x2F;x objectMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $21 &#x3D; 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p&#x2F;x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</span><br><span class="line">(long) $22 &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p&#x2F;x objectMetaClass</span><br><span class="line">(fy_objc_class *) $23 &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; personMetaClass-&gt;superclas&#x3D;0x00007fff8e3ba0f0</span><br><span class="line">&#x2F;&#x2F;personMetaClass-&gt;isa&#x3D;0x00007fff8e3ba0f0</span><br><span class="line">&#x2F;&#x2F;personMetaClass &#x3D; 0x0000000100002440</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x personMetaClass-&gt;superclass</span><br><span class="line">(Class) $25 &#x3D; 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p&#x2F;x personMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $26 &#x3D; 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p&#x2F;x personMetaClass</span><br><span class="line">(fy_objc_class *) $30 &#x3D; 0x0000000100002440</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; studentMetaClass-&gt;superclas&#x3D;0x0000000100002440</span><br><span class="line">&#x2F;&#x2F;studentMetaClass-&gt;isa&#x3D;0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x studentMetaClass-&gt;superclass</span><br><span class="line">(Class) $27 &#x3D; 0x0000000100002440</span><br><span class="line">(lldb) p&#x2F;x studentMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $28 &#x3D; 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p&#x2F;x 0x001dffff8e3ba0f1 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $29 &#x3D; 0x00007fff8e3ba0f0</span><br></pre></td></tr></table></figure><p>由上面可以看出，<code>studentMetaClass-&gt;isa</code>,<code>personMetaClass-&gt;isa</code>,<code>objectMetaClass-&gt;isa</code>结果<code>mask</code>之后都是<code>0x00007fff8e3ba0f0</code>，与<code>p/x objectMetaClass</code>结果一致，则验证了13，14，15号线，<code>studentMetaClass-&gt;superclass =0x0000000100002440</code>,<code>personMetaClass = 0x0000000100002440</code>验证12号线，<code>personMetaClass-&gt;isa=0x00007fff8e3ba0f0</code>和<code>objectMetaClass = 0x00007fff8e3ba0f0</code>验证了11号线，<code>objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</code>验证10号线。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对象的isa指向哪里？</p><ul><li>instance对象的isa指向class对象</li><li>class对象的isa指向meta-class对象</li><li>meta-class对象的isa指向基类的meta-class对象</li><li>class和meta-class的内存结构一样的，只是值不一样</li></ul><p>OC的类信息存放在哪里？</p><ul><li>对象方法、属性、成员变量、协议信息存放在class对象中</li><li>类方法存放在meta-class对象中</li><li>成员变量具体值存放在instance对象中</li></ul><h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li></ul><hr><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p><p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p><p><img src="/images/0.png" alt></p><p>/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;底层原理-类的本质&quot;&gt;&lt;a href=&quot;#底层原理-类的本质&quot; class=&quot;headerlink&quot; title=&quot;底层原理 类的本质&quot;&gt;&lt;/a&gt;底层原理 类的本质&lt;/h3&gt;&lt;p&gt;复习一下&lt;a href&gt;IOS 底层原理 对象的本质–(1)&lt;/a&gt;，可以看出来实例
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS底层原理  对象的本质 --(1)</title>
    <link href="http://fgyong.cn/2019/12/01/IOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8--(1)/"/>
    <id>http://fgyong.cn/2019/12/01/IOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8--(1)/</id>
    <published>2019-12-01T03:11:58.000Z</published>
    <updated>2020-09-04T04:40:21.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h3><p>探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。<br>那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC/对象的内存布局和内存分配机制。</p><p>使用的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">代码下载<i class="fa fa-external-link"></i></span><br>要用的工具:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2NuL3N1cHBvcnQveGNvZGUv" title="https://developer.apple.com/cn/support/xcode/">Xcode 10.2<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aXB6YXBtYWMuY29tL0dvMlNoZWxs" title="https://zipzapmac.com/Go2Shell">gotoShell<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3JnL2dudS9nbGliYy8=" title="http://ftp.gnu.org/gnu/glibc/">linux-glibc-2.29源码<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJtYWxsb2Mv" title="https://opensource.apple.com/tarballs/libmalloc/">libmalloc源码<i class="fa fa-external-link"></i></span></li></ul><p>首先我们使用最基本的代码验证对象是什么?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    &#x2F;&#x2F; insert code here...</span><br><span class="line">NSObject *obj&#x3D;[[NSObject alloc]init];</span><br><span class="line">    NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>clang</code>编译器编译成<code>cpp</code>，<br>执行<code>clang -rewrite-objc main.m -o main.cpp</code>之后生成的<code>cpp</code>，这个生成的<code>cpp</code>我们不知道是跑在哪个平台的，现在我们指定<code>iphoeos</code>和<code>arm64</code>重新编译一下。<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>，将<code>main64.cpp</code>拖拽到Xcode中并打开。<br>|clang|编译器|<br>|————–|——-|<br>|xcrun|命令|<br>|sdk|指定编译的平台|<br>|arch|arm64架构|<br>|-rewrite-objc|重写|<br>|main.m|重写的文件|<br>|main64.cpp|导出的文件|<br>|-o|导出|</p><p><code>command + F</code>查找<code>int main</code>,找到关键代码，这就是<code>main</code>函数的转化成<code>c/c++</code>的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">  NSObject *obj&#x3D;((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">     NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个结构体是什么呢？<br>其实我们<code>Object-C</code>编译之后对象会编译成结构体，如图所示：<br><img src="/images/1-1.png" alt><br>那么<code>isa</code>是什么吗？通过查看源码得知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p><code>class</code>其实是一个指向结构体的指针，然后<code>com+点击class</code>得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p><code>class</code>是一个指针，那么占用多少内存呢？大家都知道<strong>指针在32位是4字节，在64位是8字节。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj&#x3D;[[NSObject alloc]init];</span><br></pre></td></tr></table></figure><p>可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。<br><code>obj</code>就是指向结构体<code>class</code>的一个指针。<br>那么我们来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    &#x2F;&#x2F; insert code here...</span><br><span class="line">NSObject *obj&#x3D;[[NSObject alloc]init];</span><br><span class="line">&#x2F;&#x2F;获得NSobject对象实例大小</span><br><span class="line">size_t size &#x3D; class_getInstanceSize(obj.class);</span><br><span class="line">&#x2F;&#x2F;获取NSObjet指针的指向的内存大小</span><br><span class="line">&#x2F;&#x2F;需要导入：#import &lt;malloc&#x2F;malloc.h&gt;</span><br><span class="line">size_t size2 &#x3D; malloc_size((__bridge const void *)(obj));</span><br><span class="line">NSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:8 size2:16</span><br></pre></td></tr></table></figure><p>结论是：<strong>指针是8字节，指针指向的的内存大小为16字节。</strong><br>查看源码得知<code>[[NSObject alloc]init]</code>的函数运行顺序是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_createInstance</span><br><span class="line">    -_class_createInstanceFromZone</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct &#x3D; true, </span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    **</span><br><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    **</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数前边后边省略，取出关键代码，其实<code>size</code>是<code>cls-&gt;instanceSize(extraBytes)</code>执行的结果。那么我们再看下<code>cls-&gt;instanceSize</code>的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成员变量大小 8bytes</span><br><span class="line">    uint32_t alignedInstanceSize() &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">        size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">        if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过源码注释得知：CF要求所有的objects 最小是16bytes。</p><p><code>class_getInstanceSize</code>函数的内部执行顺序是<code>class_getInstanceSize-&gt;cls-&gt;alignedInstanceSize()</code><br>查阅源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成员变量大小 8bytes</span><br><span class="line">    uint32_t alignedInstanceSize() &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>所以最终结论是：<strong>对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes</strong>。</p><p>验证：<br>在刚才 的代码打断点和设置<code>Debug-&gt;Debug Workflow-&gt;View Memory</code>,然后运行程序，</p><p><img src="/images/1-2.png" alt></p><p><img src="/images/1-3.png" alt><br>点击<code>obj-&gt;view *objc</code>得到上图所示的内存布局，从<code>address</code>看出和<code>obj</code>内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.</p><p>使用lldb命令<code>memory read 0x100601f30</code>输出内存布局，如下图：<br><img src="/images/1-4.png" alt><br>或者使用<code>x/4xg 0x100601f30</code>输出：</p><p><img src="/images/1-5.png" alt><br><code>x/4xg 0x100601f30</code>中<code>4</code>是输出<code>4</code>个数据,<code>x</code> 是16进制,后边<code>g</code>是8字节为单位。可以验证刚才的出的结论。</p><p>那么我们再使用复杂的一个对象来验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">int _age;</span><br><span class="line">int _no;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后对应的源码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line"> Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;&#x2F;&#x2F; 8 bytes</span><br><span class="line">int _age;&#x2F;&#x2F;4 bytes</span><br><span class="line">int _no;&#x2F;&#x2F;4 bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Person——IMPL</code><strong>结构体占用16bytes</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *obj&#x3D;[[Person alloc]init];</span><br><span class="line">obj-&gt;_age &#x3D; 15;</span><br><span class="line">obj-&gt;_no &#x3D; 14;</span><br></pre></td></tr></table></figure><p>使用代码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *obj&#x3D;[[Person alloc]init];</span><br><span class="line">obj-&gt;_age &#x3D; 15;</span><br><span class="line">obj-&gt;_no &#x3D; 14;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL *p &#x3D;(__bridge struct Person_IMPL*)obj;</span><br><span class="line">NSLog(@&quot;age:%d no:%d&quot;,p-&gt;_age,p-&gt;_no);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;age:15 no:14</span><br></pre></td></tr></table></figure><p>使用内存布局验证：</p><p><img src="/images/1-6.png" alt><br>以十进制输出每个4字节<br><img src="/images/1-7.png" alt><br>使用内存布局查看数据验证，<code>Person</code>占用16 bytes。</p><p>下边是一个直观的内存布局图：</p><p><img src="/images/1-8.png" alt></p><h4 id="再看一下更复杂的继承关系的内存布局："><a href="#再看一下更复杂的继承关系的内存布局：" class="headerlink" title="再看一下更复杂的继承关系的内存布局："></a>再看一下更复杂的继承关系的内存布局：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _age;&#x2F;&#x2F;4bytes </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Student</span><br><span class="line">@interface Student : Person</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _no;&#x2F;&#x2F;4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>那小伙伴可能要说这一定是32字节，因为<code>Person</code>上边已经证明是16字节，<code>Student</code>又多了个成员变量<code>_no</code>，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。<br>其实不然，<code>Person</code>是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，<code>Student</code>是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以<code>Student</code>是占用了16字节。</p><p>那么我们来证明一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student *obj&#x3D;[[Student alloc]init];</span><br><span class="line">obj-&gt;_age &#x3D; 6;</span><br><span class="line">obj-&gt;_no &#x3D; 7;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得NSobject对象实例成员变量占用的大小 -&gt;8</span><br><span class="line">size_t size &#x3D; class_getInstanceSize(obj.class);</span><br><span class="line">&#x2F;&#x2F;获取NSObjet指针的指向的内存大小 -&gt;16</span><br><span class="line">size_t size2 &#x3D; malloc_size((__bridge const void *)(obj));</span><br><span class="line">NSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</span><br><span class="line">&#x2F;&#x2F;size:16 size2:16</span><br></pre></td></tr></table></figure><p>再看一下LLDB查看的内存布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8xw 0x10071ae30</span><br><span class="line">0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007</span><br><span class="line">0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff</span><br><span class="line"></span><br><span class="line">(lldb) memory read 0x10071ae30</span><br><span class="line">0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................</span><br><span class="line">0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....</span><br><span class="line"></span><br><span class="line">(lldb) x&#x2F;4xg 0x10071ae30</span><br><span class="line">0x10071ae30: 0x001d800100001299 0x0000000700000006</span><br><span class="line">0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0</span><br></pre></td></tr></table></figure><p>可以看出来<code>0x00000006</code>和<code>0x00000007</code>就是两个成员变量的值，占用内存是16字节。</p><p>我们将<code>Student</code>新增一个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Student</span><br><span class="line">@interface Student : Person</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _no;&#x2F;&#x2F;4bytes</span><br><span class="line">int _no2;&#x2F;&#x2F;4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>然后查看内存布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x&#x2F;8xg 0x102825db0</span><br><span class="line">0x102825db0: 0x001d8001000012c1 0x0000000700000006</span><br><span class="line">0x102825dc0: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80</span><br><span class="line">0x102825de0: 0x0000000102825c60 0x0000000102825890</span><br></pre></td></tr></table></figure><br>从<code>LLDB</code>可以看出来，<strong>内存变成了32字节。(0x102825dd0-0x102825db0=0x20)</strong></p><p>我们再增加一个属性看下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _age;&#x2F;&#x2F;4bytes </span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,assign) int level; &#x2F;&#x2F;4字节</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;InstanceSize:16 malloc_size:16</span><br></pre></td></tr></table></figure><br>为什么新增了一个属性，内存还是和没有新增的时候一样呢？<br>因为<code>property</code>=<code>setter</code>+<code>getter</code>+<code>ivar</code>,<code>method</code>是存在类对象中的，所以实例<code>Person</code>占用的内存还是<code>_age</code>,<code>_level</code>和一个指向类的指针，最后结果是<code>4+4+8=16bytes</code>。</p><p>再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个<code>int</code>成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">int _age;&#x2F;&#x2F;4bytes</span><br><span class="line">int _level;&#x2F;&#x2F;4bytes</span><br><span class="line">int _code;&#x2F;&#x2F;4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *obj&#x3D;[[Person alloc]init];</span><br><span class="line">obj-&gt;_age &#x3D; 6;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得NSobject对象实例成员变量占用的大小 -&gt;24</span><br><span class="line">Class ocl &#x3D; obj.class;</span><br><span class="line">size_t size &#x3D; class_getInstanceSize(ocl);</span><br><span class="line">&#x2F;&#x2F;获取NSObjet指针的指向的内存大小 -&gt;32</span><br><span class="line">size_t size2 &#x3D; malloc_size((__bridge const void *)(obj));</span><br><span class="line">printf(&quot;InstanceSize:%zu malloc_size:%zu \n&quot;,size,size2);</span><br><span class="line"></span><br><span class="line">InstanceSize:24 malloc_size:32</span><br></pre></td></tr></table></figure><p>为什么和我们猜测的不一样呢？<br>那么我们再探究一下：<br>实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码<code>NSObject.mm 2306行</code>得到创建对象函数调用顺序<code>allocWithZone-&gt;_objc_rootAllocWithZone-&gt;_objc_rootAllocWithZone-&gt;class_createInstance-&gt;_class_createInstanceFromZone-&gt;_class_createInstanceFromZone</code>最后查看下<code>_class_createInstanceFromZone</code>的源码，其他已省略，只留关键代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct &#x3D; true, </span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">**</span><br><span class="line">    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line">    **</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">   **</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在看一下<code>instanceSize</code>中的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对象指针的大小</span><br><span class="line">   uint32_t alignedInstanceSize() &#123;</span><br><span class="line">       return word_align(unalignedInstanceSize());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">       size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">       &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">       if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">       return size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后调用的<code>obj = (id)calloc(1, size);</code>传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？<br>因为这是<code>c</code>函数，我们去<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJtYWxsb2Mv" title="https://opensource.apple.com/tarballs/libmalloc/">苹果开源官网下载源码看下<i class="fa fa-external-link"></i></span>,可以找到这句代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define NANO_MAX_SIZE256 &#x2F;* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; *&#x2F;</span><br></pre></td></tr></table></figure><p>看来<code>NANO_MAX_SIZE</code>在申请空间的时候做完优化就是16的倍数,并且最大是256。所以<code>size = 24 ;obj = (id)calloc(1, size);</code>申请的结果是32字节。<br>然后再看下<code>Linux</code>空间申请的机制是什么？<br><span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3JnL2dudS9nbGliYy8=" title="http://ftp.gnu.org/gnu/glibc/">下载gnu资料<i class="fa fa-external-link"></i></span>，<br>得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _I386_MALLOC_ALIGNMENT_H</span><br><span class="line">#define _I386_MALLOC_ALIGNMENT_H</span><br><span class="line"></span><br><span class="line">#define MALLOC_ALIGNMENT 16</span><br><span class="line"></span><br><span class="line">#endif &#x2F;* !defined(_I386_MALLOC_ALIGNMENT_H) *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* MALLOC_ALIGNMENT is the minimum alignment for malloc&#39;ed chunks.  It</span><br><span class="line">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span><br><span class="line">   which smaller alignments would suffice. It may be defined as larger</span><br><span class="line">   than this though. Note however that code and data structures are</span><br><span class="line">   optimized for the case of 8-byte alignment.  *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;最少是2倍的SIZE_SZ 或者是__alignof__(long double)</span><br><span class="line">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span><br><span class="line">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#x2F;* The corresponding word size.  *&#x2F;</span><br><span class="line">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span><br><span class="line"></span><br><span class="line">#ifndef INTERNAL_SIZE_T</span><br><span class="line"># define INTERNAL_SIZE_T size_t</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在i386中是16，在其他系统中按照宏定义计算，<br><code>__alignof__ (long double)</code>在iOS中是16,<code>size_t</code>是8，则上面的代码简写为<code>#define MALLOC_ALIGNMENT (2*8 &lt; 16 ? 16:2*8)</code>最终是16字节。</p><p>总结：</p><blockquote><p>实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo 查看<i class="fa fa-external-link"></i></span></li></ul><hr><p>广告时间</p><p><img src="/images/0.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象的本质&quot;&gt;&lt;a href=&quot;#对象的本质&quot; class=&quot;headerlink&quot; title=&quot;对象的本质&quot;&gt;&lt;/a&gt;对象的本质&lt;/h3&gt;&lt;p&gt;探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。&lt;br&gt;那么一个OC对
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 手动做一个自动打包部署神器</title>
    <link href="http://fgyong.cn/2019/06/25/iOS%20%E6%89%8B%E5%8A%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E7%A5%9E%E5%99%A8/"/>
    <id>http://fgyong.cn/2019/06/25/iOS%20%E6%89%8B%E5%8A%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E7%A5%9E%E5%99%A8/</id>
    <published>2019-06-25T08:39:24.000Z</published>
    <updated>2020-09-04T04:40:21.654Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。</p><ul><li>打包</li><li>导出ipa</li><li>上传pgyer</li></ul><h4 id="打包自动上传pgyer"><a href="#打包自动上传pgyer" class="headerlink" title="打包自动上传pgyer"></a>打包自动上传pgyer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#xcodebuild archive -project &#39;test.xcodeproj&#39; -configuration &#39;Debug&#39; -scheme &#39;BLTSZY&#39; -archivePath &#39;.&#x2F;app.xcarchive&#39; LIBRARY_SEARCH_PATHS&#x3D;&quot;.&#x2F;Pods&#x2F;..&#x2F;build&#x2F;**  .&#x2F;BLTSZY&#x2F;**&quot;</span><br><span class="line">proName&#x3D;&#39;your project name&#39;</span><br><span class="line">proURL&#x3D;&quot;your project path&quot;#like &#x2F;Users&#x2F;Jerry&#x2F;Desktop&#x2F;ios_afu</span><br><span class="line">api_key&#x3D;&#39;&#39;#pgyer api_key</span><br><span class="line">configuration&#x3D;&#39;Debug&#39; #Release </span><br><span class="line">autoPlus()&#123;</span><br><span class="line">path&#x3D;$&#123;proURL&#125;&#x2F;$&#123;proName&#125;&#x2F;$&#123;proName&#125;&#x2F;Info.plist</span><br><span class="line">number&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;path&#125;&quot;)</span><br><span class="line">BundleVersion&#x3D;$(( $number + 1 ))</span><br><span class="line">&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Set CFBundleVersion $BundleVersion&quot; &quot;$&#123;path&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">#打包</span><br><span class="line">arch()&#123;</span><br><span class="line">    echo &#39;开始编译Pods&#39;</span><br><span class="line">    xcodebuild -project Pods&#x2F;Pods.xcodeproj build</span><br><span class="line">    echo &#39;开始编译project&#39;</span><br><span class="line"></span><br><span class="line">xcodebuild -archivePath &quot;.&#x2F;build&#x2F;$&#123;proName&#125;.xcarchive&quot; -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive</span><br><span class="line">autoPlus</span><br><span class="line">&#125;</span><br><span class="line">#导出ipa</span><br><span class="line">exportIPA()&#123;</span><br><span class="line">    echo &#39;开始导出ipa&#39;</span><br><span class="line">    xcodebuild -exportArchive -archivePath &quot;.&#x2F;build&#x2F;$&#123;proName&#125;.xcarchive&quot; -exportPath &#39;.&#x2F;app&#39; -exportOptionsPlist &#39;.&#x2F;ExportOptions.plist&#39;</span><br><span class="line">&#125;</span><br><span class="line">#上传ipa到蒲公英</span><br><span class="line">upload()&#123;</span><br><span class="line">if [ -e &quot;$&#123;proURL&#125;&#x2F;app&#x2F;$&#123;proName&#125;.ipa&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &#39;开始上传ipa&#x2F;apk到蒲公英&#39;</span><br><span class="line">    curl -F &quot;file&#x3D;@$&#123;proURL&#125;&#x2F;app&#x2F;$&#123;proName&#125;.ipa&quot; -F &quot;_api_key&#x3D;$&#123;api_key&#125;&quot; &#39;http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv2&#x2F;app&#x2F;upload&#39;</span><br><span class="line">else</span><br><span class="line">    echo &quot;在目录：$&#123;proURL&#125;&#x2F;app&#x2F;$&#123;proName&#125;.ipa 不存在&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">startarch()&#123;</span><br><span class="line">    arch</span><br><span class="line">    if (($? &#x3D;&#x3D; 0))</span><br><span class="line">    then</span><br><span class="line">        echo &#39;archive success🍺&#39;</span><br><span class="line">        startExportIPA</span><br><span class="line">    else</span><br><span class="line">        echo &#39;archive faild❌&#39;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">startExportIPA()&#123;</span><br><span class="line">    exportIPA</span><br><span class="line">    if(($? &#x3D;&#x3D; 0))</span><br><span class="line">    then</span><br><span class="line">        echo &#39;exportIPA success🍺🍺&#39;</span><br><span class="line">        startUPLoadIPA</span><br><span class="line">    else</span><br><span class="line">        echo &#39;exportIPA faild ❌&#39;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">startUPLoadIPA()&#123;</span><br><span class="line">    upload</span><br><span class="line">    if(($? &#x3D;&#x3D; 0))</span><br><span class="line">    then</span><br><span class="line">        echo &#39;uploadIPA success&#39;</span><br><span class="line">    else</span><br><span class="line">        echo &#39;uploadIPA faild ❌&#39;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (($# &#x3D;&#x3D; 0))</span><br><span class="line">#then</span><br><span class="line">#    startarch</span><br><span class="line">#elif (($# &#x3D;&#x3D; 1))</span><br><span class="line">then</span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">        echo &#39;🍺🍺🍺***********************🍺🍺🍺&#39;</span><br><span class="line">        echo  &quot;输入 1 到 4 之间的数字:&quot;</span><br><span class="line">        echo  &quot;输入 1:从编译打包开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 2:从导出IPA开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 3:从上传ipa开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 4:退出&quot;</span><br><span class="line">        read a</span><br><span class="line">        case $a in</span><br><span class="line">            1)startarch</span><br><span class="line">            break;;</span><br><span class="line">            2)startExportIPA</span><br><span class="line">            break;;</span><br><span class="line">            3)startUPLoadIPA</span><br><span class="line">            break;;</span><br><span class="line">            4) break;;</span><br><span class="line">        esac</span><br><span class="line">        done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>将该文件和plis拖到project目录下，然后配置<br>plis文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;&#x2F;key&gt;</span><br><span class="line">&lt;false&#x2F;&gt;</span><br><span class="line">&lt;key&gt;method&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ad-hoc&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;your bundle id&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;your .mobileprovsion&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;key&gt;signingCertificate&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;iPhone Distribution&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;signingStyle&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;manual&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;stripSwiftSymbols&lt;&#x2F;key&gt;</span><br><span class="line">&lt;true&#x2F;&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;your_team_id&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;thinning&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;&lt;none&gt;&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure><br>下载<code>setup.sh</code>拖到项目文件夹内，然后<br>运行<code>./setup.sh</code>，即可完成上传到pgyer网站。<br>具体的配置属性见源码下载页面。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvYXV0b0FFVQ==" title="https://github.com/ifgyong/autoAEU">查看源码<i class="fa fa-external-link"></i></span></p><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;li&gt;导出ipa&lt;/li&gt;
&lt;li&gt;上传pgyer&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
      <category term="自动打包" scheme="http://fgyong.cn/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 浅析指针、函数、typedef</title>
    <link href="http://fgyong.cn/2019/06/24/iOS%20%E6%B5%85%E6%9E%90%E6%8C%87%E9%92%88%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81typedef/"/>
    <id>http://fgyong.cn/2019/06/24/iOS%20%E6%B5%85%E6%9E%90%E6%8C%87%E9%92%88%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81typedef/</id>
    <published>2019-06-24T08:39:24.000Z</published>
    <updated>2020-09-04T04:40:21.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h4><p>顾名思义，指针函数即返回指针的函数。其一般定义形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 *函数名(函数参数表列);</span><br></pre></td></tr></table></figure><p>其中，后缀运算符括号<code>“()”</code>表示这是一个函数，其前缀运算符星号<code>“*”</code>表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。</p><p><code>“(函数参数表列)”</code>中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pfun(int, int);</span><br></pre></td></tr></table></figure><p>由于<code>“*”</code>的优先级低于<code>“()”</code>的优先级，因而pfun首先和后面的<code>“()”</code>结合，也就意味着，pfun是一个函数。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *(pfun(int, int));</span><br></pre></td></tr></table></figure><p>接着再和前面的<code>“*”</code>结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。<br>我们不妨来再看一看，指针函数与函数指针有什么区别？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*pfun)(int, int);</span><br></pre></td></tr></table></figure><p>通过括号强行将pfun首先与<code>“*”</code>结合，也就意味着，pfun是一个指针，接着与后面的<code>“()”</code>结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。</p><p>虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。</p><p>用函数指针作为指针函数的返回值<br>在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*ff(int))(int *, int);</span><br></pre></td></tr></table></figure><p>我们用上面介绍的方法分析一下，ff首先与后面的<code>“()”</code>结合，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*(ff(int)))(int *, int);</span><br></pre></td></tr></table></figure><p>用括号将<code>ff(int)</code>再括起来也就意味着，<code>ff</code>是一个函数。<br>接着与前面的<code>“*”</code>结合，说明<code>ff</code>函数的返回值是一个指针。然后再与后面的<code>“()”</code>结合，也就是说，该指针指向的是一个函数。</p><p>这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*PF)(int *, int);</span><br></pre></td></tr></table></figure><p>也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针<code>“类型”</code>，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*PF)(int *, int);</span><br></pre></td></tr></table></figure><p>这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PF ff(int);</span><br></pre></td></tr></table></figure><h4 id="深入理解-typedef"><a href="#深入理解-typedef" class="headerlink" title="深入理解 typedef"></a>深入理解 typedef</h4><p>平时我们在OC中的使用写法，但是对<code>typedef</code>困惑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);&#x2F;&#x2F;typedefBlock Code Snippets</span><br><span class="line"></span><br><span class="line">typedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);</span><br></pre></td></tr></table></figure><br>然后可以通过<code>RWAlertViewCompletionBlock</code>当成block类型直接使用了。<br>然后看下<code>libffi</code>的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">  FFI_OK &#x3D; 0,</span><br><span class="line">  FFI_BAD_TYPEDEF,</span><br><span class="line">  FFI_BAD_ABI</span><br><span class="line">&#125; ffi_status;</span><br><span class="line">typedef int INT64;&#x2F;&#x2F;INT64 其实是int</span><br></pre></td></tr></table></figure><br>使用起来的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffi_status status;&#x2F;&#x2F;声明一个类型是ffi_status的参数</span><br><span class="line">INT64 age;&#x2F;&#x2F;声明一个age 类型是INT64</span><br></pre></td></tr></table></figure><br>现在block也可以是函数指针了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*PF)(int *, int);</span><br><span class="line">&#x2F;&#x2F;也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：</span><br><span class="line">typedef int (*PF)(int *, int);</span><br></pre></td></tr></table></figure><br><strong>typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。</strong><br>针对经典的const来个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef char * pStr;</span><br><span class="line">char string[4] &#x3D; &quot;abc&quot;;</span><br><span class="line">const char *p1 &#x3D; string;</span><br><span class="line">const pStr p2 &#x3D; string;</span><br><span class="line">p1++;</span><br><span class="line">p2++;&#x2F;&#x2F;error</span><br></pre></td></tr></table></figure><br>那么为什么<code>p2++</code>为什么会报错呢？<br>我们来分析一下，<code>const char *p1 = string;</code>是声明了一个<code>const char</code>的指针，不可变的是<code>char</code>,相当于<code>(const char)*p=string</code>,所以<code>p1++</code>不会报错。<code>p2++</code>报错根本原因是<code>p2</code>是不可变的，<code>const pStr p2 = string</code>相当于<code>const (char *) p2 = string</code>,<code>const</code>修饰的是<code>char *</code>，所以<code>p2</code>不可改变。<code>p1</code>是数组，<code>p2</code>是固定的值。</p><h4 id="typedef如何使用呢？"><a href="#typedef如何使用呢？" class="headerlink" title="typedef如何使用呢？"></a><code>typedef</code>如何使用呢？</h4><p>我们具体看几个案例分析一下。</p><p>案例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*b) (void (*)());</span><br></pre></td></tr></table></figure><br>简化一下是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef  void (*func)()</span><br><span class="line">typedef  int (*ifunc)(func)</span><br></pre></td></tr></table></figure><br>最终简化成<code>ifunc b;</code>。可以理解成<code>(void (*)())</code>是一个<code>func</code>,然后替换<code>func</code>成了最终的形参是<code>func</code>，返回值是<code>int</code>。</p><p>案例2分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*func)(int *p);</span><br></pre></td></tr></table></figure><br>首先找到<code>func</code>，<code>func</code>左边是<code>*</code>，说明<code>func</code>是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<br>func是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p><p>综合案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL didload &#x3D; @selector(viewDidLoad);</span><br><span class="line">Method md &#x3D; class_getInstanceMethod(aclass, didload);</span><br><span class="line">IMP load &#x3D; method_getImplementation(md);</span><br><span class="line">void(*loadFunc)(id,SEL) &#x3D; (void *)load;</span><br></pre></td></tr></table></figure><br>这是将SEL获取了Method之后将IMP转化成<code>void(*loadFunc)(id,SEL)</code>，调用的时候可以直接调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行ViewDidLoad IMP</span><br><span class="line"> loadFunc(aclass,NULL);</span><br></pre></td></tr></table></figure><br>Method可以这样使用，block同样也可以这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (^block)(id _self) &#x3D; ^(id _self)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here</span><br><span class="line">&#125;;</span><br><span class="line">void(*func)(id,SEL) &#x3D; (void*)imp_implementationWithBlock(block);</span><br><span class="line">class_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));</span><br></pre></td></tr></table></figure><br>这可以直接使用<code>runtime/message.h</code>函数<code>imp_implementationWithBlock</code>将<code>block</code>转化成<code>IMP</code>,使用<code>class_replaceMethod</code>替换某个函数的<code>IMP</code>。那么再调用该函数的时候，则是调用的<code>block</code>的<code>IMP</code>。获取<code>method</code>和<code>block</code>参数后续再分析。</p><p>资料参考：</p><p><span class="exturl" data-url="aHR0cDovL3l1bGluZ3RpYW54aWEuY29tL2Jsb2cvMjAxNC8wNC8xNy9oYW4tc2h1LXpoaS16aGVuLXl1LXpoaS16aGVuLWhhbi1zaHUv" title="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/">玉令天下博客地址<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;指针函数和函数指针&quot;&gt;&lt;a href=&quot;#指针函数和函数指针&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针&quot;&gt;&lt;/a&gt;指针函数和函数指针&lt;/h4&gt;&lt;p&gt;顾名思义，指针函数即返回指针的函数。其一般定义形式如下：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://fgyong.cn/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://fgyong.cn/tags/iOS/"/>
    
      <category term="指针" scheme="http://fgyong.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Python3 Flask bootstrap教程(2)</title>
    <link href="http://fgyong.cn/2018/05/28/Python3%20Flask%20bootstrap%E6%95%99%E7%A8%8B(2)/"/>
    <id>http://fgyong.cn/2018/05/28/Python3%20Flask%20bootstrap%E6%95%99%E7%A8%8B(2)/</id>
    <published>2018-05-28T04:02:22.000Z</published>
    <updated>2020-09-04T04:40:21.652Z</updated>
    
    <content type="html"><![CDATA[<p>1.蓝图<br>2.Nav的使用<br>3.mysql使用<br>4.模板的使用</p><h3 id="蓝图使用"><a href="#蓝图使用" class="headerlink" title="蓝图使用"></a>蓝图使用</h3><p>新建user文件夹,在user文件夹下变新建tamplates，还有<strong>init</strong>.py和views.py<br><strong>init.py</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">&#x2F;&#x2F;声明蓝图</span><br><span class="line">user &#x3D; Blueprint(&#39;user&#39;, __name__,template_folder&#x3D;&#39;templates&#39;)</span><br><span class="line"></span><br><span class="line">from api.v1.user import views</span><br></pre></td></tr></table></figure><br>然后在run.py中注册蓝图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先导入</span><br><span class="line">from api.v1.user import user</span><br><span class="line"></span><br><span class="line">app.register_blueprint(user,url_prefix&#x3D;&#39;&#x2F;user&#39;) 后边的是路径</span><br></pre></td></tr></table></figure><br>然后在user的views中就可以写方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, jsonify,render_template</span><br><span class="line">from flask.json import tojson_filter</span><br><span class="line">from api.v1.user import user</span><br><span class="line">from api.v1 import first</span><br><span class="line">import pymysql</span><br><span class="line">import sys</span><br><span class="line">import json</span><br><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line">&#x2F;&#x2F;路由</span><br><span class="line">@user.route(&#39;&#x2F;&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;])</span><br><span class="line">&#x2F;&#x2F;方法</span><br><span class="line">def my_index():</span><br><span class="line">    args &#x3D; request.args;</span><br><span class="line">    age &#x3D; &#39;&#39;</span><br><span class="line">    name &#x3D; &#39;&#39;</span><br><span class="line">    if args.__contains__(&#39;name&#39;):</span><br><span class="line">        name &#x3D; request.args.getlist(key&#x3D;&#39;name&#39;)</span><br><span class="line">    if args.__contains__(&#39;age&#39;):</span><br><span class="line">        age &#x3D; request.args.__getitem__(&#39;age&#39;)</span><br><span class="line">&#x2F;&#x2F;返回数据是json</span><br><span class="line">    return jsonify(&#123;&#39;method&#39;:sys._getframe().f_code.co_name,</span><br><span class="line">                    &#39;name&#39;:str(name),</span><br><span class="line">                    &#39;age&#39;:age&#125;)</span><br></pre></td></tr></table></figure><br>现在我们想返回一个html，那么就在tamplates中新建一个index.html<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;结果&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;helloword&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><br>然后在views中增加路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@user.route(&#39;&#x2F;helloword&#39;)</span><br><span class="line">def helloword():</span><br><span class="line">    return render_template(&#39;helloword.html&#39;)</span><br></pre></td></tr></table></figure><br>运行程序,输入地址<code>127.0.0.1：5000/helloword</code>，出现helloword，就算我们的程序跑起来了。</p><h3 id="Nav的使用"><a href="#Nav的使用" class="headerlink" title="Nav的使用"></a>Nav的使用</h3><p>nav就是html的头部或者banner，我们写一个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li role&#x3D;&quot;presentation&quot; class&#x3D;&quot;dropdown&quot; id&#x3D;&quot;myDropdown&quot;&gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;dropdown&quot;  data-target&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot;</span><br><span class="line">           aria-expanded&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            主页 &lt;span class&#x3D;&quot;caret&quot; id&#x3D;&quot;page1&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;dropdown-menu&quot; role&#x3D;&quot;menu&quot; aria-labelledby&#x3D;&quot;page1&quot;&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;add&quot;&gt;添加&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;dropdown&quot;  &gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; id&#x3D;&quot;group2&quot; data-toggle&#x3D;&quot;dropdown&quot; href&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot;&gt;</span><br><span class="line">            文章 &lt;span class&#x3D;&quot;caret&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;dropdown-menu&quot; role&#x3D;&quot;menu&quot; aria-labelledby&#x3D;&quot;group2&quot;&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;add&quot;&gt;添加&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class&#x3D;&quot;active&quot; role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;&quot; href&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot; aria-expanded&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            关于</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><br>这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。</p><h3 id="mysql使用"><a href="#mysql使用" class="headerlink" title="mysql使用"></a>mysql使用</h3><p>本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def userList():</span><br><span class="line">    con &#x3D; pymysql.connect(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;test&#39;, charset&#x3D;&#39;utf8&#39;)  # 添加utf8 否则中文乱码</span><br><span class="line">    cur &#x3D; con.cursor()</span><br><span class="line">    cur.execute(&#39;select * from user&#39;)</span><br><span class="line">    nums &#x3D; cur.rownumber</span><br><span class="line">    all &#x3D; cur.fetchall()</span><br><span class="line">    data &#x3D; []</span><br><span class="line">    for i in range(len(all)):</span><br><span class="line">        one &#x3D; all[i]</span><br><span class="line">        data.append(&#123;&#39;name&#39;: str(one[1]),</span><br><span class="line">                     &#39;age&#39;: one[2]&#125;)</span><br><span class="line"></span><br><span class="line">    con.close()</span><br><span class="line">    return data</span><br></pre></td></tr></table></figure></p><h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br><span class="line">    &lt;title&gt;Bootstrap 101 Template&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;1.12.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Bootstrap --&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</span><br><span class="line">    &lt;!-- 警告：通过 file:&#x2F;&#x2F; 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</span><br><span class="line">    &lt;!--[if lt IE 9]&gt;</span><br><span class="line">      &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;html5shiv&#x2F;3.7.3&#x2F;html5shiv.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">      &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;respond.js&#x2F;1.4.2&#x2F;respond.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;ul class&#x3D;&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li role&#x3D;&quot;presentation&quot; class&#x3D;&quot;dropdown&quot; id&#x3D;&quot;myDropdown&quot;&gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;dropdown&quot;  data-target&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot;</span><br><span class="line">           aria-expanded&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            主页 &lt;span class&#x3D;&quot;caret&quot; id&#x3D;&quot;page1&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;dropdown-menu&quot; role&#x3D;&quot;menu&quot; aria-labelledby&#x3D;&quot;page1&quot;&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;add&quot;&gt;添加&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li class&#x3D;&quot;dropdown&quot;  &gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; id&#x3D;&quot;group2&quot; data-toggle&#x3D;&quot;dropdown&quot; href&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot;&gt;</span><br><span class="line">            文章 &lt;span class&#x3D;&quot;caret&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;dropdown-menu&quot; role&#x3D;&quot;menu&quot; aria-labelledby&#x3D;&quot;group2&quot;&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;add&quot;&gt;添加&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role&#x3D;&quot;menuitem&quot; href&#x3D;&quot;list&quot;&gt;列表&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class&#x3D;&quot;active&quot; role&#x3D;&quot;presentation&quot;&gt;</span><br><span class="line">        &lt;a class&#x3D;&quot;dropdown-toggle&quot; data-toggle&#x3D;&quot;&quot; href&#x3D;&quot;#&quot; role&#x3D;&quot;button&quot; aria-haspopup&#x3D;&quot;true&quot; aria-expanded&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            关于</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">这下边就是定义的缺少的block</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><br>然后我们在子网页中继承这个模板并且添加上去block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;继承刚才的网页</span><br><span class="line">&#123;% extends &#39;base.html&#39; %&#125;</span><br><span class="line">&#x2F;&#x2F;下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;pager&quot;&gt;</span><br><span class="line">    &lt;h1 align&#x3D;&quot;center&quot;&gt;用户列表&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;table class&#x3D;&quot;table nav-tabs&quot;&gt;</span><br><span class="line">        &#123;% for i in data %&#125;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;名字：&#123;&#123; i.name &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;td&gt;年龄：&#123;&#123; i.age &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">                &lt;a href&#x3D;&quot;add&quot;&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加用户&quot;  align&#x3D;&quot;center&quot; style&#x3D;&quot;width: 200px&quot;&gt;</span><br><span class="line">                &lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">                &lt;a href&#x3D;&quot;list&quot; &gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;button&quot;  value&#x3D;&quot;用户列表&quot; style&#x3D;&quot;width: 200px&quot;&gt;</span><br><span class="line">                &lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.蓝图&lt;br&gt;2.Nav的使用&lt;br&gt;3.mysql使用&lt;br&gt;4.模板的使用&lt;/p&gt;
&lt;h3 id=&quot;蓝图使用&quot;&gt;&lt;a href=&quot;#蓝图使用&quot; class=&quot;headerlink&quot; title=&quot;蓝图使用&quot;&gt;&lt;/a&gt;蓝图使用&lt;/h3&gt;&lt;p&gt;新建user文件夹,在use
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://fgyong.cn/categories/Python3/"/>
    
    
      <category term="Flask" scheme="http://fgyong.cn/tags/Flask/"/>
    
      <category term="Python3" scheme="http://fgyong.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 Flask bootstrap教程(1)</title>
    <link href="http://fgyong.cn/2018/05/27/Python3%20Flask%20bootstrap%E6%95%99%E7%A8%8B(1)/"/>
    <id>http://fgyong.cn/2018/05/27/Python3%20Flask%20bootstrap%E6%95%99%E7%A8%8B(1)/</id>
    <published>2018-05-27T04:02:22.000Z</published>
    <updated>2020-09-04T04:40:21.652Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装Flask<br>2.安装bootstrap<br>3.HelloWord</p><h3 id="安装Flask"><a href="#安装Flask" class="headerlink" title="安装Flask"></a>安装Flask</h3><p>我用的py3，所以安装命令是：<br><code>pip3 install Flask</code>，安装之后，在Pycharm里边看到是这样子的，<br><img src="https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="py3第三方库列表"></p><h3 id="安装bootstrap"><a href="#安装bootstrap" class="headerlink" title="安装bootstrap"></a>安装bootstrap</h3><p>安装bootstrap，看这里<span class="exturl" data-url="aHR0cHM6Ly92Mi5ib290Y3NzLmNvbS9pbmRleC5odG1s" title="https://v2.bootcss.com/index.html">官方教程<i class="fa fa-external-link"></i></span>,<br>或者<span class="exturl" data-url="aHR0cDovL2dldGJvb3RzdHJhcC5jb20vMi4zLjIvYXNzZXRzL2Jvb3RzdHJhcC56aXA=" title="http://getbootstrap.com/2.3.2/assets/bootstrap.zip">下载<i class="fa fa-external-link"></i></span>，然后解压，放到Flask的目录下边。我的目录是这样子的<br><img src="https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"></p><h3 id="HelloWord"><a href="#HelloWord" class="headerlink" title="HelloWord"></a>HelloWord</h3><p>初始化Flask，<br>新建app.py<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, jsonify</span><br><span class="line">import os</span><br><span class="line">from api.v1 import config</span><br><span class="line">from api.v1.user import user</span><br><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">Bootstrap(app)</span><br><span class="line">app.config.from_object(config)</span><br><span class="line">app.register_blueprint(user,url_prefix&#x3D;&#39;&#x2F;user&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><br>选中文件，右键-&gt;run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.<br>完整代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">Bootstrap(app)</span><br><span class="line">app.config.from_object(config)</span><br><span class="line">app.register_blueprint(user,url_prefix&#x3D;&#39;&#x2F;user&#39;)</span><br><span class="line">@app.route(&#39;&#x2F;index&#39;)&#x2F;&#x2F;添加路由</span><br><span class="line">def my_index():&#x2F;&#x2F;路由执行的函数</span><br><span class="line">    return jsonify(&#123;&quot;key&quot;:&#39;helloWord&#39;&#125;)&#x2F;&#x2F;返回数据</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()&#x2F;&#x2F;app运行</span><br></pre></td></tr></table></figure><br><img src="https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="helloword"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装Flask&lt;br&gt;2.安装bootstrap&lt;br&gt;3.HelloWord&lt;/p&gt;
&lt;h3 id=&quot;安装Flask&quot;&gt;&lt;a href=&quot;#安装Flask&quot; class=&quot;headerlink&quot; title=&quot;安装Flask&quot;&gt;&lt;/a&gt;安装Flask&lt;/h3&gt;&lt;p&gt;我
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://fgyong.cn/categories/Python3/"/>
    
    
      <category term="Flask" scheme="http://fgyong.cn/tags/Flask/"/>
    
      <category term="Python3" scheme="http://fgyong.cn/tags/Python3/"/>
    
  </entry>
  
</feed>
