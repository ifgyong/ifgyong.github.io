<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:type" content="website">
<meta property="og:title" content="兜兜转转的技术博客">
<meta property="og:url" content="http://fgyong.cn/index.html">
<meta property="og:site_name" content="兜兜转转的技术博客">
<meta property="og:description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兜兜转转的技术博客">
<meta name="twitter:description" content="在学习的路上，不忘初心 方得始终">





  
  
  <link rel="canonical" href="http://fgyong.cn/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>兜兜转转的技术博客 – 不忘初心 方得始终</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">兜兜转转的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/ifgyong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/13/iOS图片优化 /"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/13/iOS图片优化 /" class="post-title-link" itemprop="url">iOS图片优化</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-13 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-13T11:15:58+08:00">2019-12-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 14:44:16" itemprop="dateModified" datetime="2019-12-03T14:44:16+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基于现在iOS11新生成的图片都是<code>HEIF</code>，该图片使用<code>[UIImage image:name]</code>已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。</p>
<p>既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?</p>
<p>这就要先了解该图片的编码了。</p>
<h2 id="HEIC-HEIF"><a href="#HEIC-HEIF" class="headerlink" title="HEIC HEIF"></a>HEIC HEIF</h2><blockquote>
<p>带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件</p>
</blockquote>
<p><code>heic</code>和<code>heif</code>是广色域图片的格式，广色域比<code>sRGB</code>表示范围大25%，在广色域设备中能显示更广的色彩，<code>sRGB 8bit/dept</code>，广色域达到<code>16bit/dept</code>。广色域只是在硬件支持的情况下才能显示的。<br>其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载<code>image</code>，只是把<strong>文件信息</strong>加载到内存中，下一步就是解码。在代码中体现就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let image = UIImage(contentsOfFile: url.path)</div><div class="line">或 加载图片到内存 会常驻内存</div><div class="line">let image = UIImage(named: name)!</div></pre></td></tr></table></figure></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>其实是发生在添加到要显示的view上面才会解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let imageV = UIImageView.init(image: image)</div><div class="line">imageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)</div><div class="line">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>
<p>最后一行不写，则不会解码。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>当<code>view</code>显示出来则是渲染。过程是解码的<code>data buffer</code> 复制到<code>frame buffer</code>,硬件从帧缓冲区读取数据显示到屏幕上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>
<h2 id="内存暴涨原因"><a href="#内存暴涨原因" class="headerlink" title="内存暴涨原因"></a>内存暴涨原因</h2><p>一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。</p>
<p>首先有请我们准备的素材和设备(6s 64g版本)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A:jpg</div><div class="line">20M 12000*12000</div><div class="line"></div><div class="line">B:jpg</div><div class="line">2.8M 3024*4032</div><div class="line"></div><div class="line">C:HEIC</div><div class="line">1.8M 3024*4032</div></pre></td></tr></table></figure></p>
<p>素材A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">APP运行内存：13.8M</div><div class="line">加载Image: 240.3M之后稳定到220M</div><div class="line">CPU：峰值5%，随后降低到0%</div><div class="line">image占内存：226.5M</div></pre></td></tr></table></figure></p>
<p>素材B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">APP运行内存：13.7M</div><div class="line">加载Image: 31.5</div><div class="line">CPU：峰值5%，随后降低到0%</div><div class="line">image占内存：17.8M</div></pre></td></tr></table></figure></p>
<p>素材C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">APP运行内存：13.8M</div><div class="line">加载Image: 32.3</div><div class="line">CPU：峰值4%，随后降低到0%</div><div class="line">image占内存：18.5M</div></pre></td></tr></table></figure></p>
<p>我们猜测是否是<code>imageView</code>的大小影响内存的呢？<br><code>size</code>改为原来的1/10结果运行内存还是和以前一样。</p>
<p>为什么呢？</p>
<blockquote>
<p>内存大小不是取决于<code>view</code>的<code>size</code>，而是原始文件<strong>image size</strong>。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/29/16eb5cff5d35a254?w=1016&amp;h=542&amp;f=png&amp;s=54318" alt=""></p>
<h3 id="渲染格式"><a href="#渲染格式" class="headerlink" title="渲染格式"></a>渲染格式</h3><h4 id="SRGB"><a href="#SRGB" class="headerlink" title="SRGB"></a>SRGB</h4><p>每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。</p>
<h4 id="display-p3-宽色域"><a href="#display-p3-宽色域" class="headerlink" title="display p3 宽色域"></a>display p3 宽色域</h4><p>每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。</p>
<h4 id="亮度和透明度"><a href="#亮度和透明度" class="headerlink" title="亮度和透明度"></a>亮度和透明度</h4><p>每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。</p>
<h4 id="Alpha-8-Format"><a href="#Alpha-8-Format" class="headerlink" title="Alpha 8 Format"></a>Alpha 8 Format</h4><p>每个像素1字节，用来表示透明度，一般用作蒙版和文字。<br>相比sRGB容量小了75%，详细 宽色域 容量小了87.5%</p>
<h3 id="渲染图片大小计算"><a href="#渲染图片大小计算" class="headerlink" title="渲染图片大小计算"></a>渲染图片大小计算</h3><p>图片大小 = 图片格式容量 <em> 像素个数<br>当我们把大小是20\</em>20使用<code>Alpha 8 format</code>渲染到20*20的view上面，和40*40的image使用<code>p3</code>渲染到20*20的view中，后着占用内存是前者的8倍。</p>
<p>使用sRGB色域进行渲染所占用的大小为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imageWidth*imageHeight*4 字节</div></pre></td></tr></table></figure></p>
<p>每个像素占用了4字节，每个字节8位，</p>
<p>使用<code>display p3</code>则每个通道占用16位，那么占用内存大小是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imageWidth*imageHeight*8 字节</div></pre></td></tr></table></figure></p>
<h3 id="如何选择正确的图片格式"><a href="#如何选择正确的图片格式" class="headerlink" title="如何选择正确的图片格式"></a>如何选择正确的图片格式</h3><blockquote>
<p>不要主动选择图片格式，让格式选择你。</p>
</blockquote>
<p>不要再使用<code>UIGraphicsBeginImageContextWithOptions</code>,该方法总是使用sRGB格式，你想节约内存是不行的，在支持<code>p3</code>的设备上想绘制出来<code>p3</code>色域的图片也是不行的。那么使用<code>UIGraphicsImageRenderer</code>系统可以自动为你选择格式，如果绘制<code>image</code>，自己再添加单色蒙版，是不需要另外单独分配内存的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">if let im = imageV &#123;</div><div class="line">//第二次添加蒙版</div><div class="line">	im.tintColor = UIColor.black</div><div class="line">&#125;else&#123;</div><div class="line">//绘制一个红色矩形</div><div class="line">	let bounds = CGRect(x: 0, y: 0, width: width, height: height)</div><div class="line">	let renderer = UIGraphicsImageRenderer(bounds: bounds)</div><div class="line">	 let image = renderer.image &#123; (coxt) in</div><div class="line">		UIColor.red.setFill()</div><div class="line">		let path = UIBezierPath(roundedRect: bounds,</div><div class="line">								cornerRadius: 20)</div><div class="line">		path.addClip()</div><div class="line">		UIRectFill(bounds)</div><div class="line">	&#125;</div><div class="line">	imageV = UIImageView(image: image)</div><div class="line">	imageV?.frame = bounds</div><div class="line">	self.view.addSubview(imageV!)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>UIImage</code> 直接读出来需要将所有<code>UIImage</code>的<code>data</code>全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用<strong>下采样</strong>。</p>
<h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p>当<code>image</code>素材大小是<code>1000*1000</code>，但是在手机上显示出来只有<code>200*200</code>，我们其实是没必要将<code>1000*1000</code>的数据都解码的，只需要缩小成<code>200*200</code>的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。<br>在<code>UIKit</code>中使用<code>UIGraphicsImageRenderer</code>会有瞬间很高的内存和CPU峰值，那么</p>
<h4 id="1-UIKit-UIGraphicsImageRenderer"><a href="#1-UIKit-UIGraphicsImageRenderer" class="headerlink" title="1.UIKit  UIGraphicsImageRenderer"></a>1.UIKit  UIGraphicsImageRenderer</h4><p>使用素材A下采样技术，使用<code>UIKit</code>中的<code>UIGraphicsImageRenderer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Memory </div><div class="line">High:16.4M</div><div class="line">normal:14.8M</div><div class="line">CPU:</div><div class="line">Hight:29%</div><div class="line">normal:0%</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class="line">	guard let image = UIImage(contentsOfFile: url.path) else &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if #available(iOS 10.0, *) &#123;</div><div class="line">		let renderer = UIGraphicsImageRenderer(size: size)</div><div class="line">	</div><div class="line">		return renderer.image &#123; (context) in</div><div class="line">			image.draw(in: CGRect(origin: .zero, size: size))</div><div class="line">		&#125;</div><div class="line">	&#125;else&#123;</div><div class="line">		UIGraphicsBeginImageContext(size)</div><div class="line">		image.draw(in: CGRect(origin: .zero, size: size))</div><div class="line">		let image = UIGraphicsGetImageFromCurrentImageContext()</div><div class="line">		UIGraphicsEndImageContext()</div><div class="line">		return image</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用子线程绘制，会出现CPU略微升高，当<code>image size</code>大很多的时候会出现内存飙升然后慢慢恢复到<code>normal</code>。</p>
<h4 id="2-CoreGraphics-CGContext上下文绘制缩略图"><a href="#2-CoreGraphics-CGContext上下文绘制缩略图" class="headerlink" title="2.CoreGraphics CGContext上下文绘制缩略图"></a>2.CoreGraphics CGContext上下文绘制缩略图</h4><p>使用上下文绘制 <code>cpu</code> 和内存变化如下,<code>CPU</code>和内存没有大的变动解决了该问题，也做到省电、顺滑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Memory </div><div class="line">High:42.3M</div><div class="line">normal:14.1M</div><div class="line">CPU:</div><div class="line">Hight:6%</div><div class="line">normal:0%</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func resizedImage2(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class="line">	guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class="line">		let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)</div><div class="line">	else&#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	let cxt = CGContext(data: nil,</div><div class="line">						width: Int(size.width),</div><div class="line">						height: Int(size.height),</div><div class="line">						bitsPerComponent: image.bitsPerComponent,</div><div class="line">						bytesPerRow: image.bytesPerRow,</div><div class="line">						space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!</div><div class="line">		,</div><div class="line">						bitmapInfo: image.bitmapInfo.rawValue)</div><div class="line">	cxt?.interpolationQuality = .high</div><div class="line">	cxt?.draw(image, in: CGRect(origin: .zero, size: size))</div><div class="line">	guard let scaledImage = cxt?.makeImage() else &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	let ima = UIImage(cgImage: scaledImage)</div><div class="line">	return ima</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-ImageIO-创建缩略图"><a href="#3-ImageIO-创建缩略图" class="headerlink" title="3.ImageIO 创建缩略图"></a>3.ImageIO 创建缩略图</h4><p>使用<code>ImageIO</code> 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Memory </div><div class="line">High:320M</div><div class="line">normal:221M</div><div class="line">CPU:</div><div class="line">Hight:73%</div><div class="line">normal:0%</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func resizedImage3(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class="line">	</div><div class="line">	let ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,</div><div class="line">							  kCGImageSourceCreateThumbnailWithTransform:true,</div><div class="line">							  kCGImageSourceShouldCacheImmediately:true,</div><div class="line">							  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]</div><div class="line">	guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class="line">		let image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else &#123;</div><div class="line">			return nil;</div><div class="line">	&#125;</div><div class="line">	let ima = UIImage(cgImage: image)</div><div class="line">	printImageCost(image: ima)</div><div class="line">	return ima</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-CoreImage-滤镜"><a href="#4-CoreImage-滤镜" class="headerlink" title="4.CoreImage 滤镜"></a>4.CoreImage 滤镜</h4><p>使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Memory </div><div class="line">High:1.04G</div><div class="line">normal:566M</div><div class="line">CPU:</div><div class="line">Hight:73%</div><div class="line">normal:0%</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func resizedImage4(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class="line">	let shareContext = CIContext(options: [.useSoftwareRenderer:false])</div><div class="line">	</div><div class="line">	 guard let image = CIImage(contentsOf: url) else &#123; return nil &#125;</div><div class="line">	let fillter = CIFilter(name: &quot;CILanczosScaleTransform&quot;)</div><div class="line">	fillter?.setValue(image, forKey: kCIInputImageKey)</div><div class="line">	fillter?.setValue(1, forKey: kCIInputScaleKey)</div><div class="line">	guard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else &#123; return nil &#125;</div><div class="line">	</div><div class="line">	return UIImage(cgImage: outputCGImage)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-使用-vImage-优化图片渲染"><a href="#5-使用-vImage-优化图片渲染" class="headerlink" title="5.使用 vImage 优化图片渲染"></a>5.使用 vImage 优化图片渲染</h4><p>使用<code>vImage</code>创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要<code>crash</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Memory </div><div class="line">High:998.7M</div><div class="line">normal:566M</div><div class="line">CPU:</div><div class="line">Hight:78%</div><div class="line">normal:0%</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">func resizedImage5(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class="line">    // 解码源图像</div><div class="line">    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class="line">        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),</div><div class="line">        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],</div><div class="line">        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,</div><div class="line">        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount</div><div class="line">    else &#123;</div><div class="line">        return nil</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 定义图像格式</div><div class="line">    var format = vImage_CGImageFormat(bitsPerComponent: 8,</div><div class="line">                                      bitsPerPixel: 32,</div><div class="line">                                      colorSpace: nil,</div><div class="line">                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),</div><div class="line">                                      version: 0,</div><div class="line">                                      decode: nil,</div><div class="line">                                      renderingIntent: .defaultIntent)</div><div class="line"></div><div class="line">    var error: vImage_Error</div><div class="line"></div><div class="line">    // 创建并初始化源缓冲区</div><div class="line">    var sourceBuffer = vImage_Buffer()</div><div class="line">    defer &#123; sourceBuffer.data.deallocate() &#125;</div><div class="line">    error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</div><div class="line">                                         &amp;format,</div><div class="line">                                         nil,</div><div class="line">                                         image,</div><div class="line">                                         vImage_Flags(kvImageNoFlags))</div><div class="line">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class="line"></div><div class="line">    // 创建并初始化目标缓冲区</div><div class="line">    var destinationBuffer = vImage_Buffer()</div><div class="line">    error = vImageBuffer_Init(&amp;destinationBuffer,</div><div class="line">                              vImagePixelCount(size.height),</div><div class="line">                              vImagePixelCount(size.width),</div><div class="line">                              format.bitsPerPixel,</div><div class="line">                              vImage_Flags(kvImageNoFlags))</div><div class="line">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class="line"></div><div class="line">    // 优化缩放图像</div><div class="line">    error = vImageScale_ARGB8888(&amp;sourceBuffer,</div><div class="line">                                 &amp;destinationBuffer,</div><div class="line">                                 nil,</div><div class="line">                                 vImage_Flags(kvImageHighQualityResampling))</div><div class="line">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class="line"></div><div class="line">    // 从目标缓冲区创建一个 CGImage 对象</div><div class="line">    guard let resizedImage =</div><div class="line">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</div><div class="line">                                      &amp;format,</div><div class="line">                                      nil,</div><div class="line">                                      nil,</div><div class="line">                                      vImage_Flags(kvImageNoAllocate),</div><div class="line">                                      &amp;error)?.takeRetainedValue(),</div><div class="line">        error == kvImageNoError</div><div class="line">    else &#123;</div><div class="line">        return nil</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return UIImage(cgImage: resizedImage)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。</p>
<p>在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># 1</div><div class="line">NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,</div><div class="line">									   object: nil,</div><div class="line">									   queue: .main)</div><div class="line">&#123;[weak self] (note) in</div><div class="line">	self?.unloadImage()</div><div class="line">&#125;</div><div class="line">NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,</div><div class="line">									   object: nil,</div><div class="line">									   queue: .main)</div><div class="line">&#123;[weak self] (note) in</div><div class="line">	self?.loadImage()</div><div class="line">&#125;</div><div class="line"># 2</div><div class="line"></div><div class="line">override func viewWillAppear(_ animated: Bool) &#123;</div><div class="line">	super.viewWillAppear(animated)</div><div class="line">	self.loadImage()</div><div class="line">&#125;</div><div class="line">override func viewWillDisappear(_ animated: Bool) &#123;</div><div class="line">	super.viewWillDisappear(animated)</div><div class="line">	self.unloadImage()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>基于性能综合考虑方法1是最简单最合适的</li>
<li>使用滤镜和<code>vImage</code>略微复杂点，平时开发过程中可以不用考虑了。</li>
<li>图片解码缓存和图片大小有关，适当的下采样是不错的选择。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416" target="_blank" rel="external">session 2018 416 iOS Memory Deep Dive</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/219" target="_blank" rel="external">219_image_and_graphics_best_practices</a></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">WWDC 中文字幕下载</a></li>
<li><p><a href="https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1" target="_blank" rel="external">swift gg 图像优化</a></p>
</li>
<li><p><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></p>
</li>
<li><a href="https://github.com/ifgyong/demo/tree/master" target="_blank" rel="external">demo code git</a></li>
</ul>
<h2 id="唯有实践才是检验真理的唯一标准"><a href="#唯有实践才是检验真理的唯一标准" class="headerlink" title="唯有实践才是检验真理的唯一标准"></a><strong>唯有实践才是检验真理的唯一标准</strong></h2><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/" class="post-title-link" itemprop="url">MVC、MVP、MVVM、分层设计浅谈 — (13)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:23:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:23:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 11:15:52" itemprop="dateModified" datetime="2019-12-03T11:15:52+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到</p>
<blockquote>
<ol>
<li>MVC</li>
<li>MVC变种</li>
<li>MVP</li>
<li>MVVM</li>
<li>分层设计的优缺点</li>
</ol>
</blockquote>
<p>没有最好的架构，只有最适合业务的架构。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>苹果版本的<code>MVC</code>是<code>Model</code>和<code>VC</code>和交互，<code>VC</code>和<code>View</code>交互</p>
<ul>
<li><p>优点：<code>View</code>和<code>Model</code>可以重复利用，可以独立使用</p>
</li>
<li><p>缺点：<code>Controller</code>的代码过于臃肿</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c65c373454277a?w=801&amp;h=274&amp;f=png&amp;s=17358" alt=""></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self loadData];</div><div class="line">&#125;</div><div class="line">- (void)loadData&#123;</div><div class="line">    self.data=[NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</div><div class="line">        FYNews *item=[FYNews new];</div><div class="line">        item.title =[NSString stringWithFormat:@&quot;title-%d&quot;,i];</div><div class="line">        item.name =[NSString stringWithFormat:@&quot;name-%d&quot;,i];</div><div class="line">        [self.data addObject:item];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return self.data.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    // Configure the cell...</div><div class="line">    FYNews *item =[self.data objectAtIndex:indexPath.row];</div><div class="line">    cell.detailTextLabel.text =item.title;</div><div class="line">    cell.textLabel.text = item.name;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//model</div><div class="line"></div><div class="line">@interface FYNews : NSObject</div><div class="line">@property (nonatomic,copy) NSString *title;</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里是<code>VC</code>中组装了<code>tableview</code>，<code>model</code>的数据在<code>VC</code>中在<code>view</code>中显示出来，当需要另外的数据的时候，只需要将<code>model</code>改成需要的<code>model</code>而无需更改<code>tableview</code>的代码兼容性较好。</p>
<h3 id="MVC变种"><a href="#MVC变种" class="headerlink" title="MVC变种"></a>MVC变种</h3><p><code>MVC</code>变种，其实就是将<code>model</code>和<code>view</code>建立了联系，<code>view</code>依据<code>Model</code>来展示数据，<code>VC</code>组装<code>Model</code>，组装展示是在<code>view</code>中实现。</p>
<ul>
<li><p>优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现</p>
</li>
<li><p>缺点：view依赖于Model</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c65cb8ad888abf?w=735&amp;h=364&amp;f=png&amp;s=25874" alt=""></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">//.h</div><div class="line">@class FYItemModel;</div><div class="line">@interface FYAppleView : UIView</div><div class="line">@property (nonatomic,strong) FYItemModel *model;</div><div class="line">@end</div><div class="line"></div><div class="line">//.m</div><div class="line">@interface FYAppleView()</div><div class="line">@property (nonatomic,strong) UILabel *nameLabel;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYAppleView</div><div class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class="line">    if (self =[super initWithFrame:frame]) &#123;</div><div class="line">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class="line">        [self addSubview:_nameLabel];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">  mvc的变种</div><div class="line"> */</div><div class="line">- (void)setModel:(FYItemModel *)model&#123;</div><div class="line">    _model = model;</div><div class="line">    _nameLabel.textColor = model.bgColor;</div><div class="line">    _nameLabel.text = model.name;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">//FYItemModel</div><div class="line">@interface FYItemModel : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic,strong) UIColor *bgColor;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//ViewController</div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self loadViewOtherMVC];</div><div class="line">&#125;</div><div class="line">//变种MVC 把View和Model建立起连接</div><div class="line">//等以后更新view数据只需要 view.model = item;Controllr少了许多代码</div><div class="line">- (void)loadViewOtherMVC&#123;</div><div class="line">    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class="line">    FYItemModel *item=[[FYItemModel alloc]init];</div><div class="line">    item.name = @&quot;校长来了&quot;;</div><div class="line">    item.bgColor = [UIColor redColor];</div><div class="line">    view.model = item;</div><div class="line">    [self.view addSubview:view];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可以看到<code>model</code>组装到<code>view</code>展示内容是在<code>view</code>实现的，外部不知道细节，只需要将<code>model</code>给<code>view</code>即可，但是只能传输过来<code>model</code>或者他子类，业务更改的话，需要修改<code>view</code>的内部<code>model</code>才能将变更过的数据重新展示出来。</p>
<p>想要监听view的点击事件来做一些操作，那么我们可以使用代理和<code>block</code>,这里<code>id</code>是实现了<code>FYAppleViewProtocol</code>协议的，<code>weak</code>修饰防止循环引用，使用协议实现了和<code>VC</code>的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@class FYAppleView;</div><div class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class="line">@end</div><div class="line"></div><div class="line">@class FYItemModel;</div><div class="line">@interface FYAppleView : UIView</div><div class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class="line">@property (nonatomic,strong) FYItemModel *model;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>稍作更改还是<code>apple-MVC</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// .h</div><div class="line">@class FYItemModel;</div><div class="line">@interface FYAppleView : UIView</div><div class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>将<code>View</code>属性<code>nameLabel</code>暴露出来，但是不允许外界进行更改，去掉<code>model</code>则是<code>MVC</code>。</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><code>MVP</code>和<code>MVC</code>很像，只是将<code>VC</code>换成了<code>Presenter</code>，<code>vc</code>和<code>Present</code>做的事情基本一致，将<code>view</code>和<code>Model</code>通信改到了都和<code>Presenter</code>通信。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c65f39c348e3e9?w=610&amp;h=215&amp;f=png&amp;s=12793" alt=""><br>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//MVP</div><div class="line">//.h</div><div class="line">@interface FYNewsPresenter : NSObject</div><div class="line"></div><div class="line">@property (nonatomic,weak) UIViewController *vc;</div><div class="line">//初始化</div><div class="line">- (void)setup;</div><div class="line">@end</div><div class="line"></div><div class="line">.m</div><div class="line">#import &quot;FYNewsPresenter.h&quot;</div><div class="line">@interface FYNewsPresenter()&lt;FYAppleViewProtocol&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYNewsPresenter</div><div class="line">- (void)setup&#123;</div><div class="line">	FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class="line">	FYItemModel *item=[[FYItemModel alloc]init];</div><div class="line">	item.name = @&quot;校长来了&quot;;</div><div class="line">	item.bgColor = [UIColor redColor];</div><div class="line">	view.model = item;</div><div class="line">	[self.vc.view addSubview:view];</div><div class="line">&#125;</div><div class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class="line">	NSLog(@&quot;点击了我&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//VC中</div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic,strong) FYNewsPresenter *presenter;</div><div class="line">@end</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	_presenter=[FYNewsPresenter new];</div><div class="line">	_presenter.vc = self;</div><div class="line">	[_presenter setup];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>再次对<code>VC</code>进行了瘦身，将更多的业务逻辑搬到了<code>FYNewsPresenter</code>处理，其实全部搬过去，意义比不大，<code>FYNewsPresenter</code>也会臃肿，也会出现和<code>VC</code>一样的困惑。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>是将<code>FYNewsPresenter</code>都搬到了<code>FYNewsViewModel</code>中，然后对<code>FYNewsViewModel</code>和<code>View</code>进行了一个双向绑定，双向绑定可以使用代理，<code>block</code>或者<code>KVO</code>实现。<br><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c6603450d271bb?w=642&amp;h=237&amp;f=png&amp;s=13181" alt=""><br>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">@interface FYNewsViewModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic,strong) UIColor *bgColor;</div><div class="line"></div><div class="line">@property (nonatomic,weak) UIViewController *vc;</div><div class="line"></div><div class="line">- (instancetype)initWithController:(UIViewController *)vc;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#import &quot;FYNewsViewModel.h&quot;</div><div class="line">@interface FYNewsViewModel()&lt;FYAppleViewProtocol&gt;</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line">@implementation FYNewsViewModel</div><div class="line">- (instancetype)initWithController:(UIViewController *)vc&#123;</div><div class="line">    if (self =[super init]) &#123;</div><div class="line">        self.vc = vc;</div><div class="line">        </div><div class="line">        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];</div><div class="line">        //    view.model = item;</div><div class="line">        view.delegate = self;</div><div class="line">        view.viewModel = self; //建立kvo</div><div class="line">        </div><div class="line">        view.backgroundColor = [UIColor lightGrayColor];</div><div class="line">        [vc.view addSubview:view];</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        FYItemModel *item=[[FYItemModel alloc]init];</div><div class="line">        item.name = @&quot;校长来了&quot;;</div><div class="line">        item.bgColor = [UIColor redColor];</div><div class="line">        </div><div class="line">        self.name = item.name;</div><div class="line">        self.bgColor = item.bgColor;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class="line">	NSLog(@&quot;点击了我&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在<code>view</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">@class FYAppleView,FYNewsViewModel;</div><div class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@class FYItemModel;</div><div class="line"></div><div class="line">@interface FYAppleView : UIView</div><div class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class="line"></div><div class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class="line">@property (nonatomic,weak) FYNewsViewModel *viewModel;</div><div class="line"></div><div class="line">@property (nonatomic,strong) FYItemModel *model;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface FYAppleView()</div><div class="line">@property (nonatomic,strong) UILabel *nameLabel;</div><div class="line">@end</div><div class="line">@implementation FYAppleView</div><div class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class="line">    if (self =[super initWithFrame:frame]) &#123;</div><div class="line">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class="line">        [self addSubview:_nameLabel];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">  mvc的变种</div><div class="line"> */</div><div class="line">- (void)setModel:(FYItemModel *)model&#123;</div><div class="line">    _model = model;</div><div class="line">    _nameLabel.textColor = model.bgColor;</div><div class="line">    _nameLabel.text = model.name;</div><div class="line">	</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setViewModel:(FYNewsViewModel *)viewModel&#123;</div><div class="line">    _viewModel = viewModel;</div><div class="line">   [_viewModel addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class="line">   //使用FBKVO实现 或者自己使用KVO实现</div><div class="line">//    __weak typeof(self) waekSelf = self;</div><div class="line">//    [self.KVOController observe:viewModel keyPath:@&quot;name&quot;</div><div class="line">//                        options:NSKeyValueObservingOptionNew</div><div class="line">//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123;</div><div class="line">//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class="line">//    &#125;];</div><div class="line">&#125;</div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</div><div class="line">        self.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//添加点击事件</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	if ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) &#123;</div><div class="line">		[self.delegate FYAppleViewDidClick:self];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)dealloc&#123;</div><div class="line">    [_viewModel removeObserver:self</div><div class="line">                    forKeyPath:@&quot;name&quot;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用<code>KVO</code>或者<code>FBKVO</code>或者<code>RAC</code>都是可以的，本章节例子给出了<code>FBKVO</code>或者自己使用<code>KVO</code>的实现。</p>
<h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>三层架构：</p>
<blockquote>
<p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层</p>
</blockquote>
<ul>
<li><p>目的: “高内聚，低耦合”的思想 </p>
</li>
<li><p>优点: 降低层与层之间的依赖 标准化 </p>
</li>
<li><p>缺点: 系统架构复杂，不适合小型项目</p>
</li>
</ul>
<h4 id="三层原理"><a href="#三层原理" class="headerlink" title="三层原理"></a>三层原理</h4><blockquote>
<p>3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。<br>所谓三层体系结构，是在客户端与数据库之间加入了一个<code>中间层</code>，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有<code>B/S</code>应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。</p>
<p>三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过<code>COM/DCOM</code>通讯与中间层建立连接，再经由中间层与数据库进行交互。</p>
<p>三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用<code>COM/DCOM</code>通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互</p>
</blockquote>
<p><code>MVC</code>、<code>MVVM</code>、<code>MVP</code>属于界面层，<br>当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了</p>
<p>分层之后，得到了一个三层架构或四层架构</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c6623d82034790?w=536&amp;h=281&amp;f=png&amp;s=23627" alt="三层架构"></p>
<p>数据层也可以分为两层，分为网络请求和db层。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c6624a552bd892?w=568&amp;h=370&amp;f=png&amp;s=29291" alt="四层架构"></p>
<p>具体在工程中我们通常这样体现</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/6/16c66313fbdd90a3?w=270&amp;h=432&amp;f=png&amp;s=24528" alt=""></p>
<p>在<code>vc</code>中获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic,strong) FYDBPool *db;</div><div class="line">@property (nonatomic,strong) FYHttpPool *http;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line"></div><div class="line">	//当有业务层</div><div class="line">	[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) &#123;</div><div class="line">		</div><div class="line">	&#125; fail:^&#123;</div><div class="line">		</div><div class="line">	&#125;];</div><div class="line">	//当没有有业务层</div><div class="line">	self.db=[FYDBPool new];</div><div class="line">	self.http=[FYHttpPool new];</div><div class="line">	[self.db loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">		if ([ret count]) &#123;</div><div class="line">			NSLog(@&quot;数据获取成功&quot;);</div><div class="line">		&#125;else&#123;</div><div class="line">			[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">				NSLog(@&quot;数据获取成功&quot;);</div><div class="line">			&#125; fail:^&#123;</div><div class="line">				NSLog(@&quot;数据获取失败&quot;);</div><div class="line">			&#125;];</div><div class="line">		&#125;</div><div class="line">	&#125; fail:^&#123;</div><div class="line">		[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">			NSLog(@&quot;数据获取成功&quot;);</div><div class="line">		&#125; fail:^&#123;</div><div class="line">			NSLog(@&quot;数据获取失败&quot;);</div><div class="line">		&#125;];</div><div class="line">	&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在业务层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@interface FYNewsService ()</div><div class="line">@property (nonatomic,strong) FYDBPool *db;</div><div class="line">@property (nonatomic,strong) FYHttpPool *http;</div><div class="line"></div><div class="line">@end</div><div class="line">@implementation FYNewsService</div><div class="line">-(instancetype)init&#123;</div><div class="line">	if (self = [super init]) &#123;</div><div class="line">		self.db=[FYDBPool new];</div><div class="line">		self.http=[FYHttpPool new];</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class="line">				 success:(succcessCallback )succblock</div><div class="line">					fail:(dispatch_block_t)failBlock&#123;</div><div class="line">	[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">		if ([ret count]) &#123;</div><div class="line">			succblock(ret);</div><div class="line">		&#125;else&#123;</div><div class="line">			[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">				succblock(ret);</div><div class="line">			&#125; fail:failBlock];</div><div class="line">		&#125;</div><div class="line">	&#125; fail:^&#123;</div><div class="line">		[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class="line">			succblock(ret);</div><div class="line">		&#125; fail:failBlock];</div><div class="line">	&#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在db层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef void(^succcessCallback)(NSArray *);</div><div class="line">@interface FYDBPool : NSObject</div><div class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class="line">				 success:(succcessCallback )succblock</div><div class="line">					fail:(dispatch_block_t)failBlock;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在网络请求层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef void(^succcessCallback)(NSArray *);</div><div class="line">@interface FYHttpPool : NSObject</div><div class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class="line">				 success:(succcessCallback )succblock</div><div class="line">					fail:(dispatch_block_t)failBlock;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或<code>db</code>，当<code>db</code>足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。<br>不同的人来处理不同的分层，相互影响也比较小，降低耦合。</p>
<p><strong>当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。</strong></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>优雅的代码总是伴随着各种传统设计模式的搭配</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote>
<p>设计模式（Design Pattern）<br>是一套被反复使用、代码设计经验的总结<br>使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性<br>一般与编程语言无关，是一套比较成熟的编程思想</p>
</blockquote>
<p>设计模式可以分为三大类</p>
<ol>
<li><p>创建型模式：对象实例化的模式，用于解耦对象的实例化过程<br>单例模式、工厂方法模式，等等</p>
</li>
<li><p>结构型模式：把类或对象结合在一起形成一个更大的结构<br>代理模式、适配器模式、组合模式、装饰模式，等等</p>
</li>
<li><p>行为型模式：类或对象之间如何交互，及划分责任和算法<br>观察者模式、命令模式、责任链模式，等等</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>适合项目的才是最好的架构</li>
</ul>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84" target="_blank" rel="external">三层架构</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&amp;h=268&amp;f=jpeg&amp;s=27083" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/" class="post-title-link" itemprop="url">iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:22:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:22:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 16:24:31" itemprop="dateModified" datetime="2019-12-03T16:24:31+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看完本文章你将了解到</p>
<blockquote>
<ol>
<li>DisplayLink和timer的使用和原理</li>
<li>内存分配和内存管理</li>
<li>自动释放池原理</li>
<li>weak指针原理和释放时机</li>
<li>引用计数原理</li>
</ol>
</blockquote>
<h3 id="DisplayLink"><a href="#DisplayLink" class="headerlink" title="DisplayLink"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div><div class="line">//runloop没循环一圈都会调用</div><div class="line">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class="line">//从runloop中删除</div><div class="line">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class="line">//取消</div><div class="line">- (void)invalidate;</div></pre></td></tr></table></figure>
<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) CADisplayLink *link;</div><div class="line"></div><div class="line">//初始化</div><div class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">	@synchronized (self) &#123;</div><div class="line">		NSLog(@&quot;FPS:%d&quot;,fps);</div><div class="line">		fps = 0;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">dispatch_resume(timer);</div><div class="line">//全局变量</div><div class="line">dispatch_source_t timer;</div><div class="line">static int fps;</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">	</div><div class="line">	@synchronized (self) &#123;</div><div class="line">		fps += 1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	[self.link invalidate];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</div><div class="line">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</div></pre></td></tr></table></figure>
<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface FYTimerTarget : NSObject</div><div class="line">@property (nonatomic,weak) id target;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYTimerTarget</div><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	return self.target;</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">FYProxy *proxy=[FYProxy proxyWithTarget:self];</div><div class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 17:59:04.339934 -[ViewController test]</div><div class="line">2019-07-30 17:59:04.356292 -[ViewController test]</div><div class="line">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</div><div class="line">2019-07-30 17:59:04.371634 -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@interface FYProxy : NSProxy</div><div class="line">@property (nonatomic,weak) id target;</div><div class="line"></div><div class="line">+(instancetype)proxyWithTarget:(id)target;</div><div class="line">@end</div><div class="line">@implementation FYProxy</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</div><div class="line">	FYProxy *obj=[FYProxy alloc];</div><div class="line">	obj.target = target;</div><div class="line">	return obj;</div><div class="line">&#125;</div><div class="line">//转发</div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</div><div class="line">	[invocation invokeWithTarget:self.target];</div><div class="line">&#125;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</div><div class="line">	return [self.target methodSignatureForSelector:sel];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	return self.target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FYTimerTarget *obj =[FYTimerTarget new];</div><div class="line">obj.target = self;</div><div class="line"></div><div class="line">self.timer = [NSTimer timerWithTimeInterval:1.0f</div><div class="line">									target:obj</div><div class="line">								   selector:@selector(test)</div><div class="line">								   userInfo:nil</div><div class="line">									repeats:YES];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class="line">[self.timer setFireDate:[NSDate distantPast]];</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class="line">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class="line">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</div><div class="line">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">	NSLog(@&quot;123&quot;);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</div><div class="line">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</div><div class="line">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>
<h3 id="GCD中timer"><a href="#GCD中timer" class="headerlink" title="GCD中timer"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//timer 需要强引用 或者设置成全局变量</div><div class="line">    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">    //设置</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">  //code 定时器执行的代码</div><div class="line"> </div><div class="line">    &#125;);</div><div class="line">    //开始定时器</div><div class="line">    dispatch_resume(timer);</div></pre></td></tr></table></figure>
<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_source_set_event_handler_f(timer, function_t);</div><div class="line">void function_t(void * p)&#123;</div><div class="line">    //code here    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>
<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)exeTask:(dispatch_block_t)block</div><div class="line">    	  start:(NSTimeInterval)time</div><div class="line">       interval:(NSTimeInterval)interval</div><div class="line">    	 repeat:(BOOL)repeat</div><div class="line">    	  async:(BOOL)async;</div><div class="line">+ (NSString *)exeTask:(id)target</div><div class="line">		  sel:(SEL)aciton</div><div class="line">		start:(NSTimeInterval)time</div><div class="line">	 interval:(NSTimeInterval)interval</div><div class="line">	   repeat:(BOOL)repeat</div><div class="line">		async:(BOOL)async;</div><div class="line">//取消</div><div class="line">+ (void)exeCancelTask:(NSString *)key;</div></pre></td></tr></table></figure>
<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</div><div class="line">	if (block == nil) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class="line">	//主队列</div><div class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line">	if (async) &#123;</div><div class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	&#125;</div><div class="line">	//创建定时器</div><div class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">	//设置启动时间</div><div class="line">	dispatch_source_set_timer(_timer,</div><div class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class="line">	//设定回调</div><div class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">		block();</div><div class="line">		if (repeat == NO) &#123;</div><div class="line">			dispatch_source_cancel(_timer);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	//启动定时器</div><div class="line">	dispatch_resume(_timer);</div><div class="line">	//存放到字典</div><div class="line">	if (name.length &amp;&amp; _timer) &#123;</div><div class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">		timers[name] = _timer;</div><div class="line">		dispatch_semaphore_signal(samephore);</div><div class="line">	&#125;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+ (NSString *)exeTask:(id)target</div><div class="line">				  sel:(SEL)aciton</div><div class="line">				start:(NSTimeInterval)time</div><div class="line">			 interval:(NSTimeInterval)interval</div><div class="line">			   repeat:(BOOL)repeat</div><div class="line">				async:(BOOL)async&#123;</div><div class="line">	if (target == nil || aciton == NULL) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class="line">	//主队列</div><div class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line">	if (async) &#123;</div><div class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	&#125;</div><div class="line">	//创建定时器</div><div class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">	//设置启动时间</div><div class="line">	dispatch_source_set_timer(_timer,</div><div class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class="line">	//设定回调</div><div class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</div><div class="line">		//这里是会报警告的代码</div><div class="line">		if ([target respondsToSelector:aciton]) &#123;</div><div class="line">			[target performSelector:aciton];</div><div class="line">		&#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line"></div><div class="line">		if (repeat == NO) &#123;</div><div class="line">			dispatch_source_cancel(_timer);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	//启动定时器</div><div class="line">	dispatch_resume(_timer);</div><div class="line">	//存放到字典</div><div class="line">	if (name.length &amp;&amp; _timer) &#123;</div><div class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">		timers[name] = _timer;</div><div class="line">		dispatch_semaphore_signal(samephore);</div><div class="line">	&#125;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line">+ (void)exeCancelTask:(NSString *)key&#123;</div><div class="line">	if (key.length == 0) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">	if ([timers.allKeys containsObject:key]) &#123;</div><div class="line">		dispatch_source_cancel(timers[key]);</div><div class="line">		[timers removeObjectForKey:key];</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_signal(samephore);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用的时候很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">key = [FYTimer exeTask:^&#123;</div><div class="line">        NSLog(@&quot;123&quot;);</div><div class="line">    &#125; start:1</div><div class="line">    interval:1 </div><div class="line">    repeat:YES </div><div class="line">    async:NO];</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div></pre></td></tr></table></figure>
<p>取消执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[FYTimer exeCancelTask:key];</div></pre></td></tr></table></figure>
<p>测试封装的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div><div class="line">&#125;</div><div class="line">-(void)test&#123;</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	[FYTimer exeCancelTask:key];</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</div></pre></td></tr></table></figure>
<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>
<h3 id="NSProxy实战"><a href="#NSProxy实战" class="headerlink" title="NSProxy实战"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>
<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ViewController *vc1 =[[ViewController alloc]init];</div><div class="line">FYProxy *pro1 =[FYProxy proxyWithTarget:vc1];</div><div class="line"></div><div class="line">FYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];</div><div class="line">BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</div><div class="line">BOOL ret2 = [tar isKindOfClass:ViewController.class];</div><div class="line">NSLog(@&quot;%d %d&quot;,ret1,ret2);</div></pre></td></tr></table></figure>
<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>
<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>
<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>
<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>
<p>数据段包括</p>
<ul>
<li>字符串常量：比如NSString * str = @”11”</li>
<li>已初始化数据：已初始化的全局变量、静态变量等</li>
<li>未初始化数据：未初始化的全局变量、静态变量等</li>
</ul>
<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>
<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b ;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        static int c = 20;</div><div class="line">        static int d;</div><div class="line">        int e = 10;</div><div class="line">        int f;</div><div class="line">        NSString * str = @&quot;123&quot;;</div><div class="line">        NSObject *obj =[[NSObject alloc]init];</div><div class="line">        NSLog(@&quot;\na:%p \nb:%p \nc:%p \nd:%p \ne:%p \nf:%p \nobj:%p\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">a:0x1063e0d98 </div><div class="line">b:0x1063e0e64 </div><div class="line">c:0x1063e0d9c </div><div class="line">d:0x1063e0e60 </div><div class="line">e:0x7ffee9820efc </div><div class="line">f:0x7ffee9820ef8 </div><div class="line">obj:0x6000013541a0</div><div class="line">str:0x1063e0068</div></pre></td></tr></table></figure>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static inline void * _Nonnull</div><div class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</div><div class="line">&#123;</div><div class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们拿来这个可以判断对象是否使用了优化技术。</p>
<h4 id="NSNumbe-Tagged-Pointer"><a href="#NSNumbe-Tagged-Pointer" class="headerlink" title="NSNumbe Tagged Pointer"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ //mac开发</div><div class="line">// 64-bit Mac - tag bit is LSB</div><div class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</div><div class="line">#else</div><div class="line">// Everything else - tag bit is MSB</div><div class="line">#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发</div><div class="line">#endif</div><div class="line"></div><div class="line">#if OBJC_MSB_TAGGED_POINTERS</div><div class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</div><div class="line">#else</div><div class="line">#   define _OBJC_TAG_MASK 1UL</div><div class="line">#endif</div><div class="line">bool objc_isTaggedPointer(const void * _Nullable ptr)</div><div class="line">&#123;</div><div class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</div><div class="line">&#125;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSNumber *n1 = @2;</div><div class="line">        NSNumber *n2 = @3;</div><div class="line">        NSNumber *n3 = @(4);</div><div class="line">        NSNumber *n4 = @(0x4fffffffff);</div><div class="line">        NSLog(@&quot;\n%p \n%p \n%p \n%p&quot;,n1,n2,n3,n4);</div><div class="line">        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</div><div class="line">        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</div><div class="line">        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</div><div class="line">        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</div><div class="line"></div><div class="line">        NSLog(@&quot;\nn1:%d \nn2:%d \nn3:%d \nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">0xbf4071e2657ccb95 </div><div class="line">0xbf4071e2657ccb85 </div><div class="line">0xbf4071e2657ccbf5 </div><div class="line">0xbf40751d9a833444</div><div class="line">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </div><div class="line">n1:1 </div><div class="line">n2:1 </div><div class="line">n3:1 </div><div class="line">n4:0</div></pre></td></tr></table></figure>
<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>
<h4 id="NSString-Tagged-Pointer"><a href="#NSString-Tagged-Pointer" class="headerlink" title="NSString Tagged Pointer"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)test1&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先不运行，先分析一下。</p>
<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread: EXC_BAD_ACCESS(code = 1)</div></pre></td></tr></table></figure>
<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>
<p>验证<code>NSString Tagged Pointer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)test&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">			NSLog(@&quot;test1 class:%@&quot;,self.name.class);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class="line">			NSLog(@&quot;test2 class:%@&quot;,self.name.class);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">test1 class:NSTaggedPointerString</div><div class="line">test2 class:__NSCFString</div></pre></td></tr></table></figure>
<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>
<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>
<p> iOS提供了2中拷贝方法</p>
<ol>
<li>copy 拷贝出来不可变对象</li>
<li>mutableCopy 拷贝出来可变对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void test1()&#123;</div><div class="line">	NSString *str = @&quot;strstrstrstr&quot;;</div><div class="line">	NSMutableString *mut1 =[str mutableCopy];</div><div class="line">	[mut1 appendFormat:@&quot;123&quot;];</div><div class="line">	NSString *str2 = [str copy];</div><div class="line">	NSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">str:0x100001040 </div><div class="line">mut1:0x1007385f0 </div><div class="line">str2:0x100001040</div></pre></td></tr></table></figure>
<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>
<p>我们把字符串换成其他常用的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void test2()&#123;</div><div class="line">	NSArray *array = @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</div><div class="line">	NSMutableArray *mut =[array mutableCopy];</div><div class="line">	NSString *array2 = [array copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">0x102840800 </div><div class="line">0x1028408a0</div><div class="line">0x102840800</div><div class="line"></div><div class="line">void test3()&#123;</div><div class="line">	NSArray *array = [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</div><div class="line">	NSMutableArray *mut =[array mutableCopy];</div><div class="line">	NSString *array2 = [array copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">0x102808720 </div><div class="line">0x1028088a0</div><div class="line">0x1028089a0</div></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>
<p>我们再换成其他的常用的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void test4()&#123;</div><div class="line">	NSDictionary *item = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</div><div class="line">	NSMutableDictionary *mut =[item mutableCopy];</div><div class="line">	NSDictionary *item2 = [item copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">0x1007789c0 </div><div class="line">0x100779190</div><div class="line">0x1007789c0</div><div class="line"></div><div class="line">void test5()&#123;</div><div class="line">	NSDictionary *item = [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</div><div class="line">	NSMutableDictionary *mut =[item mutableCopy];</div><div class="line">	NSDictionary *item2 = [item copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">0x1007041d0 </div><div class="line">0x1007042b0</div><div class="line">0x1007043a0</div></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>
<p>由这几个看出来，总结出来下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">copy</th>
<th style="text-align:center">mutableCopy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NSString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSArray</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableArray</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSDictionary</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableDictionary</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
</tbody>
</table>
<h4 id="自定义对象实现协议NSCoping"><a href="#自定义对象实现协议NSCoping" class="headerlink" title="自定义对象实现协议NSCoping"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@protocol NSCopying</div><div class="line"></div><div class="line">- (id)copyWithZone:(nullable NSZone *)zone;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@protocol NSMutableCopying</div><div class="line"></div><div class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,assign) int age;</div><div class="line">@property (nonatomic,assign) int level;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface FYPerson()&lt;NSCopying&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class="line">	FYPerson *p=[[FYPerson alloc]init];</div><div class="line">	p.age = self.age;</div><div class="line">	p.level = self.level;</div><div class="line">	return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">FYPerson *p =[[FYPerson alloc]init];</div><div class="line">p.age = 10;</div><div class="line">p.level = 11;</div><div class="line">FYPerson *p2 =[p copy];</div><div class="line">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</div><div class="line">//log</div><div class="line">10 11</div></pre></td></tr></table></figure>
<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>
<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@implementation NSObject (add)</div><div class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    Class cls = [self class];</div><div class="line">    NSObject * p=[cls new];</div><div class="line">    //成员变量个数</div><div class="line">    unsigned int count;</div><div class="line">    //赋值成员变量数组</div><div class="line">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);</div><div class="line">    //遍历数组</div><div class="line">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">        Ivar var = ivars[i];</div><div class="line">        //获取成员变量名字</div><div class="line">        const char * name = ivar_getName(var);</div><div class="line">        if (name != nil) &#123;</div><div class="line">            NSString *v = [NSString stringWithUTF8String:name];</div><div class="line">            id value = [self valueForKey:v];</div><div class="line">            //给新的对象赋值</div><div class="line">            if (value != NULL) &#123;</div><div class="line">                [p setValue:value forKey:v];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">FYPerson *p =[[FYPerson alloc]init];</div><div class="line">p.age = 10;</div><div class="line">p.level = 11;</div><div class="line">p.name = @&quot;xiaowang&quot;;</div><div class="line">FYPerson *p2 =[p copy];</div><div class="line">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</div><div class="line">		</div><div class="line">//log</div><div class="line">10 </div><div class="line">11 </div><div class="line">xiaowang</div></pre></td></tr></table></figure>
<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>
<h3 id="引用计数原理"><a href="#引用计数原理" class="headerlink" title="引用计数原理"></a>引用计数原理</h3><p>摘自<a href="https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin" target="_blank" rel="external">百度百科</a></p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>
</blockquote>
<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>
<p>在MRC中我们经常都是这样子使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FYPerson *p=[[FYPerson alloc]init];</div><div class="line">FYPerson *p2 =[p retain];</div><div class="line">//code here</div><div class="line">[p release];</div><div class="line">[p2 release];</div></pre></td></tr></table></figure>
<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>
<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>
<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//大概率x==1 提高读取指令的效率</div><div class="line">#define fastpath(x) (__builtin_expect(bool(x), 1))</div><div class="line">//大概率x==0 提高读取指令的效率</div><div class="line">#define slowpath(x) (__builtin_expect(bool(x), 0))</div><div class="line"></div><div class="line"></div><div class="line">//引用计数+1</div><div class="line">//tryRetain 尝试+1</div><div class="line">//handleOverflow 是否覆盖</div><div class="line">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</div><div class="line">&#123;</div><div class="line">	//优化的指针 返回this</div><div class="line">    if (isTaggedPointer()) return (id)this;</div><div class="line"></div><div class="line">    bool sideTableLocked = false;</div><div class="line">    bool transcribeToSideTable = false;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line">    do &#123;</div><div class="line">        transcribeToSideTable = false;</div><div class="line">		//old bits</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">		//使用联合体技术</div><div class="line">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);//nothing</div><div class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();//解锁</div><div class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</div><div class="line">			else return sidetable_retain();////sidetable 引用计数+1</div><div class="line">        &#125;</div><div class="line">        // don&apos;t check newisa.fast_rr; we already called any RR overrides</div><div class="line">		//不尝试retain 和 正在销毁 什么都不做 返回 nil</div><div class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        uintptr_t carry;</div><div class="line">		//引用计数+1 (bits.extra_rc++;)</div><div class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</div><div class="line"></div><div class="line">        if (slowpath(carry)) &#123;</div><div class="line">            // newisa.extra_rc++ 溢出处理</div><div class="line">            if (!handleOverflow) &#123;</div><div class="line">                ClearExclusive(&amp;isa.bits);</div><div class="line">                return rootRetain_overflow(tryRetain);</div><div class="line">            &#125;</div><div class="line">			//为拷贝到side table 做准备</div><div class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class="line">            sideTableLocked = true;</div><div class="line">            transcribeToSideTable = true;</div><div class="line">            newisa.extra_rc = RC_HALF;</div><div class="line">            newisa.has_sidetable_rc = true;</div><div class="line">        &#125;</div><div class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    if (slowpath(transcribeToSideTable)) &#123;</div><div class="line">		//拷贝 平外一半的 引用计数到 side table</div><div class="line">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class="line">    return (id)this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//sidetable 引用计数+1</div><div class="line">id objc_object::sidetable_retain()</div><div class="line">&#123;</div><div class="line">#if SUPPORT_NONPOINTER_ISA</div><div class="line">    assert(!isa.nonpointer);</div><div class="line">#endif</div><div class="line">	//取出table key=this</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    </div><div class="line">    table.lock();</div><div class="line">    size_t&amp; refcntStorage = table.refcnts[this];</div><div class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line"></div><div class="line">    return (id)this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>
<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</div><div class="line">&#123;</div><div class="line">    if (isTaggedPointer()) return false;//指针优化的不存在计数器</div><div class="line"></div><div class="line">    bool sideTableLocked = false;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line"> retry:</div><div class="line">    do &#123;//isa</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            if (sideTableLocked) sidetable_unlock();</div><div class="line">			//side table -1</div><div class="line">            return sidetable_release(performDealloc);</div><div class="line">        &#125;</div><div class="line">        uintptr_t carry;</div><div class="line">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</div><div class="line">        if (slowpath(carry)) &#123;</div><div class="line">            // don&apos;t ClearExclusive()</div><div class="line">            goto underflow;</div><div class="line">        &#125;</div><div class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                             oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line">    return false;</div><div class="line"></div><div class="line"> underflow:</div><div class="line">    newisa = oldisa;</div><div class="line"></div><div class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class="line">        if (!handleUnderflow) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            return rootRelease_underflow(performDealloc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!sideTableLocked) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            sidetable_lock();</div><div class="line">            sideTableLocked = true;</div><div class="line">            goto retry;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		//side table 引用计数-1</div><div class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class="line"></div><div class="line">        if (borrowed &gt; 0) &#123;</div><div class="line">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</div><div class="line">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                                oldisa.bits, newisa.bits);</div><div class="line">            if (!stored) &#123;</div><div class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class="line">                isa_t newisa2 = oldisa2;</div><div class="line">                if (newisa2.nonpointer) &#123;</div><div class="line">                    uintptr_t overflow;</div><div class="line">                    newisa2.bits = </div><div class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</div><div class="line">                    if (!overflow) &#123;</div><div class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class="line">                                                       newisa2.bits);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!stored) &#123;</div><div class="line">                // Inline update failed.</div><div class="line">                // Put the retains back in the side table.</div><div class="line">                sidetable_addExtraRC_nolock(borrowed);</div><div class="line">                goto retry;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sidetable_unlock();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Side table is empty after all. Fall-through to the dealloc path.</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//真正的销毁</div><div class="line"></div><div class="line">    if (slowpath(newisa.deallocating)) &#123;</div><div class="line">        ClearExclusive(&amp;isa.bits);</div><div class="line">        if (sideTableLocked) sidetable_unlock();</div><div class="line">        return overrelease_error();</div><div class="line">        // does not actually return</div><div class="line">    &#125;</div><div class="line">	//设置正在销毁</div><div class="line">    newisa.deallocating = true;</div><div class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</div><div class="line"></div><div class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line"></div><div class="line">    __sync_synchronize();</div><div class="line">    if (performDealloc) &#123;</div><div class="line">		//销毁</div><div class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">inline uintptr_t  objc_object::rootRetainCount()</div><div class="line">&#123;</div><div class="line">	//优化指针 直接返回</div><div class="line">    if (isTaggedPointer()) return (uintptr_t)this;</div><div class="line">//没优化则 到SideTable 读取</div><div class="line">    sidetable_lock();</div><div class="line">	//isa指针</div><div class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</div><div class="line">    ClearExclusive(&amp;isa.bits);//啥都没做</div><div class="line">    if (bits.nonpointer) &#123;//使用联合体存储更多的数据 </div><div class="line">        uintptr_t rc = 1 + bits.extra_rc;//计数数量</div><div class="line">        if (bits.has_sidetable_rc) &#123;//当大过于 联合体存储的值 则另外在SideTable读取数据</div><div class="line">	//读取table的值 相加</div><div class="line">            rc += sidetable_getExtraRC_nolock();</div><div class="line">        &#125;</div><div class="line">        sidetable_unlock();</div><div class="line">        return rc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sidetable_unlock();</div><div class="line">	//在sidetable 中存储的count</div><div class="line">    return sidetable_retainCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="external">使用联合体存储更多的数据</a>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//使用联合体</div><div class="line">size_t  objc_object::sidetable_getExtraRC_nolock()</div><div class="line">&#123;</div><div class="line">	//不是联合体技术 则报错</div><div class="line">    assert(isa.nonpointer);</div><div class="line">	//key是 this，存储了每个对象的table</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">	//找到 it 否则返回0</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class="line">    if (it == table.refcnts.end()) return 0;</div><div class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有优化的是直接读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//未使用联合体的情况，</div><div class="line">uintptr_t objc_object::sidetable_retainCount()</div><div class="line">&#123;//没有联合体存储的计数器则直接在table中取出来</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    size_t refcnt_result = 1;</div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class="line">    if (it != table.refcnts.end()) &#123;</div><div class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    return refcnt_result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="weak指针原理"><a href="#weak指针原理" class="headerlink" title="weak指针原理"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">		//c++析构函数</div><div class="line">        bool cxx = obj-&gt;hasCxxDtor();</div><div class="line">		//关联函数</div><div class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//正在清除side table 和weakly referenced</div><div class="line">inline void </div><div class="line">objc_object::clearDeallocating()</div><div class="line">&#123;</div><div class="line">    if (slowpath(!isa.nonpointer)) &#123;</div><div class="line">        // Slow path for raw pointer isa.</div><div class="line">		//释放weak</div><div class="line">        sidetable_clearDeallocating();</div><div class="line">    &#125;</div><div class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</div><div class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</div><div class="line">		//释放weak 和引用计数</div><div class="line">        clearDeallocating_slow();</div><div class="line">    &#125;</div><div class="line">    assert(!sidetable_present());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NEVER_INLINE void</div><div class="line">objc_object::clearDeallocating_slow()</div><div class="line">&#123;</div><div class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</div><div class="line"></div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    table.lock();</div><div class="line">	//清除weak</div><div class="line">    if (isa.weakly_referenced) &#123;</div><div class="line">		//table.weak_table 弱引用表</div><div class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</div><div class="line">    &#125;</div><div class="line">	//引用计数</div><div class="line">    if (isa.has_sidetable_rc) &#123;</div><div class="line">		//擦除 this</div><div class="line">        table.refcnts.erase(this);</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>
<h3 id="Autoreleasepool-原理"><a href="#Autoreleasepool-原理" class="headerlink" title="Autoreleasepool 原理"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">		FYPerson *p = [[FYPerson alloc]init];</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line"> __AtAutoreleasePool __autoreleasepool;</div><div class="line"> FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">	__AtAutoreleasePool() &#123;//构造函数 生成结构体变量的时候调用</div><div class="line">		atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">	&#125;</div><div class="line">	~__AtAutoreleasePool() &#123;//析构函数 销毁的时候调用</div><div class="line">		objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">	&#125;</div><div class="line">	void * atautoreleasepoolobj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后将上边的代码和c++整合到一起就是这样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    __AtAutoreleasePool pool = objc_autoreleasePoolPush();</div><div class="line">    FYPerson *p = [[FYPerson alloc]init];</div><div class="line">    objc_autoreleasePoolPop(pool)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>
<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class AutoreleasePoolPage &#123;</div><div class="line">    magic_t const magic;</div><div class="line">    id *next;//下一个存放aotoreleass对象的地址</div><div class="line">    pthread_t const thread;//线程</div><div class="line">    AutoreleasePoolPage * const parent; //父节点</div><div class="line">    AutoreleasePoolPage *child;//子节点</div><div class="line">    uint32_t const depth;//深度</div><div class="line">    uint32_t hiwat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>
<ul>
<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>
<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>
<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>
<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>
<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>
</ul>
<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">extern void _objc_autoreleasePoolPrint(void);</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;//r1 = push()</div><div class="line"></div><div class="line">		FYPerson *p = [[FYPerson alloc]init];</div><div class="line">		_objc_autoreleasePoolPrint();</div><div class="line">		printf(&quot;\n--------------\n&quot;);</div><div class="line">	&#125;//pop(r1)</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">objc[23958]: ##############</div><div class="line">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class="line">objc[23958]: 3 releases pending.</div><div class="line">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</div><div class="line">objc[23958]: [0x101000038]  ################  POOL 0x101000038</div><div class="line">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</div><div class="line">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</div><div class="line">objc[23958]: ##############</div><div class="line"></div><div class="line">--------------</div></pre></td></tr></table></figure>
<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;//r1 = push()</div><div class="line"></div><div class="line">		FYPerson *p = [[[FYPerson alloc]init] autorelease];</div><div class="line">		FYPerson *p2 = [[[FYPerson alloc]init] autorelease];</div><div class="line">		@autoreleasepool &#123;//r1 = push()</div><div class="line">			</div><div class="line">			FYPerson *p3 = [[[FYPerson alloc]init] autorelease];</div><div class="line">			FYPerson *p4 = [[[FYPerson alloc]init] autorelease];</div><div class="line">			</div><div class="line">			_objc_autoreleasePoolPrint();</div><div class="line">			printf(&quot;\n--------------\n&quot;);</div><div class="line">		&#125;//pop(r1)</div><div class="line">	&#125;//pop(r1)</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">objc[24025]: ##############</div><div class="line">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class="line">objc[24025]: 6 releases pending.</div><div class="line">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</div><div class="line">objc[24025]: [0x100803038]  ################  POOL 0x100803038</div><div class="line">objc[24025]: [0x100803040]       0x100721580  FYPerson</div><div class="line">objc[24025]: [0x100803048]       0x100721b10  FYPerson</div><div class="line">objc[24025]: [0x100803050]  ################  POOL 0x100803050</div><div class="line">objc[24025]: [0x100803058]       0x100721390  FYPerson</div><div class="line">objc[24025]: [0x100803060]       0x100717620  FYPerson</div><div class="line">objc[24025]: ##############</div></pre></td></tr></table></figure>
<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>
<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line"> &#123;</div><div class="line">     AutoreleasePoolPage *page = hotPage();</div><div class="line">     //当有分页而且分页没有满就添加</div><div class="line">     if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">         return page-&gt;add(obj);</div><div class="line">     &#125; else if (page) &#123;</div><div class="line">         //满则新建一个page进行添加obj和设置hotpage</div><div class="line">         return autoreleaseFullPage(obj, page);</div><div class="line">     &#125; else &#123;</div><div class="line">         //没有page则新建page进行添加</div><div class="line">         return autoreleaseNoPage(obj);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//activities = 0xa0转化成二进制 0b101 0000</div><div class="line">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</div><div class="line">//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</div><div class="line"></div><div class="line">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid = Yes, activities = 0xa0, </div><div class="line">repeats = Yes, order = 2147483647, </div><div class="line">callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </div><div class="line">context = &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type = mutable-small, count = 1, </div><div class="line">values = (\n\t0 : &lt;0x7fb6dc004058&gt;\n)&#125;&#125;&quot;</div></pre></td></tr></table></figure>
<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void test()&#123;</div><div class="line">    FYPerson *p =[[FYPerson alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>
<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>
<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>
<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>
<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>
<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease
</a></li>
<li>小码哥视频</li>
<li>iOS和OS多线程与内存管理</li>
<li>iOS和macOS性能优化<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/" class="post-title-link" itemprop="url">iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:21:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:21:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:06:56" itemprop="dateModified" datetime="2019-12-03T13:06:56+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？<br>这篇文章主要讲解线程安全。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是什么呢？摘抄一段<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin" target="_blank" rel="external">百度百科</a>的一段话</p>
<blockquote>
<p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
</blockquote>
<h4 id="为什么需要线程安全"><a href="#为什么需要线程安全" class="headerlink" title="为什么需要线程安全"></a>为什么需要线程安全</h4><p>ATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。</p>
<p>那么在iOS中，锁是如何使用的呢？</p>
<h3 id="自旋锁-OS-SPINLOCK"><a href="#自旋锁-OS-SPINLOCK" class="headerlink" title="自旋锁 OS_SPINLOCK"></a>自旋锁 OS_SPINLOCK</h3><h4 id="什么是优先级反转"><a href="#什么是优先级反转" class="headerlink" title="什么是优先级反转"></a>什么是优先级反转</h4><p>简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</p>
<p>假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</p>
<p>首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</p>
<p>其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</p>
<p>第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</p>
<p>第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</p>
<p>第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。</p>
<p><code>OS_SPINLOCK</code>叫做<code>自旋锁</code>，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。</p>
<p><code>OS_SPINLOCK</code>API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//初始化 一般是0，或者直接数字0也是ok的。</div><div class="line">#define	OS_SPINLOCK_INIT    0</div><div class="line">//锁的初始化</div><div class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</div><div class="line">//尝试加锁</div><div class="line">bool ret = OSSpinLockTry(&amp;lock);</div><div class="line">//加锁</div><div class="line">OSSpinLockLock(&amp;lock);</div><div class="line">//解锁</div><div class="line">OSSpinLockUnlock(&amp;lock);</div></pre></td></tr></table></figure>
<p><code>OSSpinLock</code>简单实现12306如何卖票</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">//基类实现的卖票</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">    NSInteger oldCount = self.ticketsCount;</div><div class="line">	if (isLog) &#123;</div><div class="line">		sleep(sleepTime);</div><div class="line">	&#125;</div><div class="line">    oldCount --;</div><div class="line">    self.ticketsCount = oldCount;</div><div class="line">	if (isLog) &#123;</div><div class="line">	printf(&quot;还剩% 2ld 张票 - %s \n&quot;,(long)oldCount,[NSThread currentThread].description.UTF8String);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (void)ticketTest&#123;</div><div class="line">    self.ticketsCount = 10000;</div><div class="line">	NSInteger count = self.ticketsCount/3;</div><div class="line">	dispatch_queue_t queue = dispatch_queue_create(&quot;tick.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">		if (time1 == 0) &#123;</div><div class="line">			time1 = CFAbsoluteTimeGetCurrent();</div><div class="line">		&#125;</div><div class="line">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">            [self __saleTicket];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">		if (time1 == 0) &#123;</div><div class="line">			time1 = CFAbsoluteTimeGetCurrent();</div><div class="line">		&#125;</div><div class="line">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">            [self __saleTicket];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">		if (time1 == 0) &#123;</div><div class="line">			time1 = CFAbsoluteTimeGetCurrent();</div><div class="line">		&#125;</div><div class="line">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">            [self __saleTicket];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">	dispatch_barrier_async(queue, ^&#123;</div><div class="line">		CFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;</div><div class="line">		printf(&quot;tick cost time:%f&quot;,time);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)__getMonery&#123;</div><div class="line">    OSSpinLockLock(&amp;_moneyLock);</div><div class="line">    [super __getMonery];</div><div class="line">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class="line">&#125;</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">    OSSpinLockLock(&amp;_moneyLock);</div><div class="line">    [super __saleTicket];</div><div class="line">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class="line">&#125;</div><div class="line">- (void)__saveMonery&#123;</div><div class="line">    OSSpinLockLock(&amp;_moneyLock);</div><div class="line">    [super __saveMonery];</div><div class="line">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)__saleTicket&#123;</div><div class="line">    NSInteger oldCount = self.ticketsCount;</div><div class="line">    oldCount --;</div><div class="line">    self.ticketsCount = oldCount;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">还剩 9 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<h4 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">然后将睡眠时间设置为600s，方便我们调试。</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">    OSSpinLockLock(&amp;_moneyLock);//此行打断点</div><div class="line">    [super __saleTicket];</div><div class="line">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到了断点进入<code>Debug-&gt;Debug WorkFlow -&gt;Always Show Disassembly</code>，到了汇编界面，在<code>LLDB</code>输入<code>stepi</code>，然后一直按<code>enter</code>，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现<code>ja</code>跳转到地址<code>0x103f3d0f9</code>，每次执行到<code>ja</code>总是跳转到<code>0x103f3d0f9</code>，直到线程睡眠结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-&gt;  0x103f3d0f9 &lt;+241&gt;: movq   %rcx, (%r8)</div><div class="line">0x103f3d0fc &lt;+244&gt;: addq   $0x8, %r8</div><div class="line">0x103f3d100 &lt;+248&gt;: cmpq   %r8, %r9</div><div class="line">0x103f3d103 &lt;+251&gt;: ja     0x103f3d0f9</div></pre></td></tr></table></figure>
<p>可以通过汇编分析了解到<code>自旋锁</code>是真的<code>忙等</code>，闲不住的锁。</p>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的<code>OSSpinLock</code>，而且必须使用<code>OS_UNFAIR_LOCK_INIT</code>来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在<code>__IOS_AVAILABLE(10.0)</code>，锁的数据结构是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">OS_UNFAIR_LOCK_AVAILABILITY</div><div class="line">typedef struct os_unfair_lock_s &#123;</div><div class="line">	uint32_t _os_unfair_lock_opaque;</div><div class="line">&#125; os_unfair_lock, *os_unfair_lock_t;</div></pre></td></tr></table></figure>
<p><code>os_unfair_lock</code>使用非常简单，只需要在任务前加锁，任务后解锁即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface FYOSUnfairLockDemo : FYBaseDemo</div><div class="line">@property (nonatomic,assign) os_unfair_lock lock;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYOSUnfairLockDemo</div><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self = [super init]) &#123;</div><div class="line">		self.lock = OS_UNFAIR_LOCK_INIT;</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)__saveMonery&#123;</div><div class="line">	os_unfair_lock_lock(&amp;_unlock);</div><div class="line">	[super __saveMonery];</div><div class="line">	os_unfair_lock_unlock(&amp;_unlock);</div><div class="line">&#125;</div><div class="line">- (void)__getMonery&#123;</div><div class="line">	os_unfair_lock_lock(&amp;_unlock);</div><div class="line">	[super __getMonery];</div><div class="line">	os_unfair_lock_unlock(&amp;_unlock);</div><div class="line">&#125;</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">	os_unfair_lock_lock(&amp;_unlock);</div><div class="line">	[super __saleTicket];</div><div class="line">	os_unfair_lock_unlock(&amp;_unlock);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//log</div><div class="line">还剩 9 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<h4 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h4><p><code>LLDB</code> 中命令<code>stepi</code>遇到函数会进入到函数，<code>nexti</code>会跳过函数。我们将断点打到添加锁的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)__saleTicket&#123;</div><div class="line"> 	os_unfair_lock_lock(&amp;_unlock);//断点位置</div><div class="line">	[super __saleTicket];</div><div class="line">	os_unfair_lock_unlock(&amp;_unlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行<code>si</code>,一直<code>enter</code>，最终是停止该位子，模拟器缺跳出来了，再<code>enter</code>也没用了，因为线程在睡眠了。<code>syscall</code>是调用系统函数的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">libsystem_kernel.dylib`__ulock_wait:</div><div class="line">    0x107a3b9d4 &lt;+0&gt;:  movl   $0x2000203, %eax          ; imm = 0x2000203 </div><div class="line">    0x107a3b9d9 &lt;+5&gt;:  movq   %rcx, %r10</div><div class="line">-&gt;  0x107a3b9dc &lt;+8&gt;:  syscall</div></pre></td></tr></table></figure>
<h3 id="互斥锁-pthread-mutex-t"><a href="#互斥锁-pthread-mutex-t" class="headerlink" title="互斥锁 pthread_mutex_t"></a>互斥锁 pthread_mutex_t</h3><p><code>mutex</code>叫互斥锁，等待锁的线程会处于休眠状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">-(void)dealloc&#123;</div><div class="line">	pthread_mutex_destroy(&amp;_plock);</div><div class="line">	pthread_mutexattr_destroy(&amp;t);</div><div class="line">&#125;</div><div class="line">-(instancetype)init&#123;</div><div class="line">	if (self =[super init]) &#123;</div><div class="line">		//初始化锁的属性 </div><div class="line">//		pthread_mutexattr_init(&amp;t);</div><div class="line">//		pthread_mutexattr_settype(&amp;t, PTHREAD_MUTEX_NORMAL);</div><div class="line">//		//初始化锁</div><div class="line">//		pthread_mutex_init(&amp;_plock, &amp;t);</div><div class="line">		</div><div class="line">		pthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;</div><div class="line">		self.plock = plock;</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">-(void)__saleTicket&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	[super __saleTicket];</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line">- (void)__getMonery&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	[super __getMonery];</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line">- (void)__saveMonery&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	[super __saveMonery];</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">还剩 9 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>互斥锁有三个类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Mutex type attributes</div><div class="line"> */</div><div class="line"> 普通锁</div><div class="line">#define PTHREAD_MUTEX_NORMAL		0</div><div class="line">//检查错误</div><div class="line">#define PTHREAD_MUTEX_ERRORCHECK	1</div><div class="line">//递归锁</div><div class="line">#define PTHREAD_MUTEX_RECURSIVE		2</div><div class="line">//普通锁</div><div class="line">#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_NORMAL</div></pre></td></tr></table></figure>
<p>当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)otherTest&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self otherTest2];</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line">- (void)otherTest2&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">-[FYPthread_mutex2 otherTest]</div></pre></td></tr></table></figure>
<p>上面这个需求需要使用两把锁，或者使用递归锁来解决问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)otherTest&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self otherTest2];</div><div class="line">	pthread_mutex_unlock(&amp;_plock);</div><div class="line">&#125;</div><div class="line">- (void)otherTest2&#123;</div><div class="line">	pthread_mutex_lock(&amp;_plock2);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	pthread_mutex_unlock(&amp;_plock2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">-[FYPthread_mutex2 otherTest]</div><div class="line">-[FYPthread_mutex2 otherTest2]</div></pre></td></tr></table></figure>
<p>从使用2把锁是可以解决这个问题的。<br>递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。</p>
<h3 id="NSLock、NSRecursiveLosk"><a href="#NSLock、NSRecursiveLosk" class="headerlink" title="NSLock、NSRecursiveLosk"></a>NSLock、NSRecursiveLosk</h3><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p>
<p>使用<code>(LLDB) si</code>可以跟踪<code>[myLock lock];</code>的内部函数最终是<code>pthread_mutex_lock</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Foundation`-[NSLock lock]:</div><div class="line">    0x1090dfb5a &lt;+0&gt;:  pushq  %rbp</div><div class="line">    0x1090dfb5b &lt;+1&gt;:  movq   %rsp, %rbp</div><div class="line">    0x1090dfb5e &lt;+4&gt;:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars</div><div class="line">    0x1090dfb63 &lt;+9&gt;:  movq   %rax, %rdi</div><div class="line">    0x1090dfb66 &lt;+12&gt;: popq   %rbp</div><div class="line">-&gt;  0x1090dfb67 &lt;+13&gt;: jmp    0x1092ca596   ;</div><div class="line">//  symbol stub for: pthread_mutex_lock</div></pre></td></tr></table></figure>
<p><code>NSLock API</code>大全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//协议NSLocking</div><div class="line">@protocol NSLocking</div><div class="line"></div><div class="line">- (void)lock;</div><div class="line">- (void)unlock;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</div><div class="line">@private</div><div class="line">    void *_priv;</div><div class="line">&#125;</div><div class="line">- (BOOL)tryLock;//尝试加锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，</div><div class="line">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>用法也很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface FYNSLock()&#123;</div><div class="line">	NSLock *_lock;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYNSLock</div><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self = [super init]) &#123;</div><div class="line">		//封装了mutex的普通锁</div><div class="line">		_lock=[[NSLock alloc]init];</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)__saveMonery&#123;</div><div class="line">	[_lock lock];</div><div class="line">	[super __saveMonery];</div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">	[_lock lock];</div><div class="line">	[super __saleTicket];</div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">- (void)__getMonery&#123;</div><div class="line">	[_lock lock];</div><div class="line">	[super __getMonery];</div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//log</div><div class="line"></div><div class="line">还剩 9 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<p><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)tryLock;//尝试加锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁</div></pre></td></tr></table></figure>
<p>递归锁可以对相同的线程进行反复加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@implementation FYRecursiveLockDemo</div><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self = [super init]) &#123;</div><div class="line">		//封装了mutex的递归锁</div><div class="line">		_lock=[[NSRecursiveLock alloc]init];</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">- (void)otherTest&#123;</div><div class="line">	static int count = 10;</div><div class="line">	[_lock lock];</div><div class="line">	while (count &gt; 0) &#123;</div><div class="line">		count -= 1;</div><div class="line">		printf(&quot;循环% 2d次 - %s \n&quot;,count,[NSThread currentThread].description.UTF8String);</div><div class="line">		[self otherTest];</div><div class="line">	&#125;</div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">//log</div><div class="line">循环 9次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 8次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 7次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 6次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 5次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 4次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 3次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 2次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 1次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class="line">循环 0次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<h3 id="NSCondition-条件"><a href="#NSCondition-条件" class="headerlink" title="NSCondition 条件"></a>NSCondition 条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)wait;//等待</div><div class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</div><div class="line">- (void)signal;//唤醒一个线程</div><div class="line">- (void)broadcast;//唤醒多个线程</div></pre></td></tr></table></figure>
<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self = [super init]) &#123;</div><div class="line">		//遵守的 lock协议 的 条件🔐</div><div class="line">		_lock=[[NSCondition alloc]init];</div><div class="line">		self.array =[NSMutableArray array];</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">- (void)otherTest&#123;</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];</div><div class="line">&#125;</div><div class="line">- (void)__add&#123;</div><div class="line">	[_lock lock];</div><div class="line">	[self.array addObject:@&quot;Test&quot;];</div><div class="line">	NSLog(@&quot;添加成功&quot;);</div><div class="line">	sleep(1);</div><div class="line">	[_lock signal];//唤醒一个线程</div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">- (void)__remove&#123;</div><div class="line">	[_lock lock];</div><div class="line">	if (self.array.count == 0) &#123;</div><div class="line">		[_lock wait];</div><div class="line">	&#125;</div><div class="line">	[self.array removeLastObject];</div><div class="line">	NSLog(@&quot;删除成功&quot;);</div><div class="line"></div><div class="line">	[_lock unlock];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//Log</div><div class="line"></div><div class="line">2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功</div><div class="line">2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功</div></pre></td></tr></table></figure>
<p>可以看到时间上差了1秒，正好是我们设定的<code>sleep(1);</code>。优点是可以让线程之间形成依赖，缺点是没有明确的条件。</p>
<h3 id="NSConditionLock-可以实现线程依赖的锁"><a href="#NSConditionLock-可以实现线程依赖的锁" class="headerlink" title="NSConditionLock 可以实现线程依赖的锁"></a>NSConditionLock 可以实现线程依赖的锁</h3><p><code>NSConditionLock</code>是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用<code>NSConditionLock</code>来解决问题。<br>首先看下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@property (readonly) NSInteger condition;//条件值</div><div class="line">- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住</div><div class="line">//尝试加锁</div><div class="line">- (BOOL)tryLock;</div><div class="line">//当con为condition进行尝试锁住</div><div class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</div><div class="line">//当con为condition进行解锁</div><div class="line">- (void)unlockWithCondition:(NSInteger)condition;</div><div class="line">//NSDate 小余 limit进行 加锁</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class="line">//条件为condition 在limit之前进行加锁</div><div class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure>
<p>条件锁的使用，在<code>lockWhenCondition:(NSInteger)condition</code>的条件到达的时候才能进行正常的加锁和<code>unlockWithCondition:(NSInteger)condition</code>解锁，否则会阻塞线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)otherTest&#123;</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];</div><div class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (void)__test1&#123;</div><div class="line">	[_lock lockWhenCondition:1];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[_lock unlockWithCondition:2];//解锁 并赋值2</div><div class="line">&#125;</div><div class="line">- (void)__test2&#123;</div><div class="line">	[_lock lockWhenCondition:2];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[_lock unlockWithCondition:3];//解锁 并赋值3</div><div class="line">&#125;</div><div class="line">- (void)__test3&#123;</div><div class="line">	[_lock lockWhenCondition:3];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[_lock unlockWithCondition:4];//解锁 并赋值4</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//log</div><div class="line">-[FYCondLockDemo2 __test1]</div><div class="line">-[FYCondLockDemo2 __test2]</div><div class="line">-[FYCondLockDemo2 __test3]</div></pre></td></tr></table></figure>
<p>当<code>con = 1</code>进行<code>test1</code>加锁和执行任务<code>A</code>，任务<code>A</code>执行完毕，进行解锁，并把值2赋值给<code>lock</code>，这是当<code>con = 2</code>的锁开始加锁，进入任务<code>B</code>，开始执行任务<code>B</code>，当任务<code>B</code>执行完毕，进行解锁并赋值为3，然后<code>con=3</code>的锁进行加锁，解锁并赋值4来进行线程之间的依赖。</p>
<h3 id="dispatch-queue-特殊的锁"><a href="#dispatch-queue-特殊的锁" class="headerlink" title="dispatch_queue 特殊的锁"></a>dispatch_queue 特殊的锁</h3><p>其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface FYSerialQueueDemo()&#123;</div><div class="line">	dispatch_queue_t _queue;</div><div class="line">&#125;@end</div><div class="line">@implementation FYSerialQueueDemo</div><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self =[super init]) &#123;</div><div class="line">		_queue = dispatch_queue_create(&quot;fyserial.queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">	dispatch_sync(_queue, ^&#123;</div><div class="line">		[super __saleTicket];</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)__getMonery&#123;</div><div class="line">	dispatch_sync(_queue, ^&#123;</div><div class="line">		[super __getMonery];</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)__saveMonery&#123;</div><div class="line">	dispatch_sync(_queue, ^&#123;</div><div class="line">		[super __saveMonery];</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//log</div><div class="line">还剩 9 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<h3 id="dispatch-semaphore-信号量控制并发数量"><a href="#dispatch-semaphore-信号量控制并发数量" class="headerlink" title="dispatch_semaphore 信号量控制并发数量"></a>dispatch_semaphore 信号量控制并发数量</h3><p>当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？<code>dispatch_semaphore</code>信号量正好可以满足我们的需求。<br><code>dispatch_semaphore</code>可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//初始化信号量 值为2，就是最多允许同时2个线程执行</div><div class="line">_semaphore = dispatch_semaphore_create(2);</div><div class="line">//生成多个线程进行并发访问test</div><div class="line">- (void)otherTest&#123;</div><div class="line">	for (int i = 0; i &lt; 10; i ++) &#123;</div><div class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)test&#123;</div><div class="line">//如果信号量&gt;0 ，让信号量-1，继续向下执行。</div><div class="line">//如果信号量 &lt;= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER</div><div class="line">	dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">	sleep(2);//睡眠时间2s</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	//释放一个信号量</div><div class="line">	dispatch_semaphore_signal(_semaphore);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] &lt;NSThread: 0x600002c45240&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] &lt;NSThread: 0x600002c45200&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] &lt;NSThread: 0x600002c45540&gt;&#123;number = 10, name = (null)&#125;</div><div class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] &lt;NSThread: 0x600002c45440&gt;&#123;number = 6, name = (null)&#125;</div><div class="line">2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] &lt;NSThread: 0x600002c45480&gt;&#123;number = 7, name = (null)&#125;</div><div class="line">2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] &lt;NSThread: 0x600002c454c0&gt;&#123;number = 8, name = (null)&#125;</div><div class="line">2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] &lt;NSThread: 0x600002c45500&gt;&#123;number = 9, name = (null)&#125;</div><div class="line">2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] &lt;NSThread: 0x600002c45400&gt;&#123;number = 5, name = (null)&#125;</div><div class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] &lt;NSThread: 0x600002c455c0&gt;&#123;number = 12, name = (null)&#125;</div><div class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] &lt;NSThread: 0x600002c45580&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>一次最多2个线程同时执行任务，暂停时间是2s。<br>使用信号量实现线程最大并发锁，<br>同时只有2个线程执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init&#123;</div><div class="line">	if (self =[super init]) &#123;</div><div class="line">		_semaphore = dispatch_semaphore_create(1);</div><div class="line">	&#125;</div><div class="line">	return self;</div><div class="line">&#125;</div><div class="line">- (void)__saleTicket&#123;</div><div class="line">	dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">	[super __saleTicket];</div><div class="line">	dispatch_semaphore_signal(_semaphore);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">还剩 9 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p><code>@synchronized(id obj){}</code>锁的是对象<code>obj</code>，使用该锁的时候，底层是对象计算出来的值作为<code>key</code>，生成一把锁，不同的资源的读写可以使用不同<code>obj</code>作为锁对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)__saleTicket&#123;</div><div class="line">	@synchronized (self) &#123;</div><div class="line">		[super __saleTicket];</div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line"> //log</div><div class="line">还剩 9 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 8 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 7 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 6 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 5 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 4 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">还剩 3 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">还剩 2 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">还剩 1 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<h3 id="atmoic-原子操作"><a href="#atmoic-原子操作" class="headerlink" title="atmoic 原子操作"></a>atmoic 原子操作</h3><p>给属性添加<code>atmoic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证了<code>setter</code>和<code>getter</code>的内部是线程同步的。<br>原子操作是最终调用了<code>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">//设置属性原子操作</div><div class="line">void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class="line">&#123;</div><div class="line">    reallySetProperty(self, _cmd, newValue, offset, true, false, false);</div><div class="line">&#125;</div><div class="line">//非原子操作设置属性</div><div class="line">void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class="line">&#123;</div><div class="line">    reallySetProperty(self, _cmd, newValue, offset, false, false, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</div><div class="line">&#123;//偏移量等于0则是class指针</div><div class="line">    if (offset == 0) &#123;</div><div class="line">        object_setClass(self, newValue);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//其他的value</div><div class="line">    id oldValue;</div><div class="line">    id *slot = (id*) ((char*)self + offset);</div><div class="line"></div><div class="line">    if (copy) &#123;</div><div class="line">    //如果是copy 用copyWithZone:</div><div class="line">        newValue = [newValue copyWithZone:nil];</div><div class="line">    &#125; else if (mutableCopy) &#123;</div><div class="line">        //mutableCopy则调用mutableCopyWithZone:</div><div class="line">        newValue = [newValue mutableCopyWithZone:nil];</div><div class="line">    &#125; else &#123;</div><div class="line">    //如果赋值和原来的相等 则不操作</div><div class="line">        if (*slot == newValue) return;</div><div class="line">        newValue = objc_retain(newValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!atomic) &#123;//非原子操作 直接赋值</div><div class="line">        oldValue = *slot;</div><div class="line">        *slot = newValue;</div><div class="line">    &#125; else &#123;//原子操作 加锁</div><div class="line">    //锁和属性是一一对应的-&gt;自旋锁</div><div class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class="line">        slotlock.lock();</div><div class="line">        oldValue = *slot;</div><div class="line">        *slot = newValue;//赋值</div><div class="line">        slotlock.unlock();//解锁</div><div class="line">    &#125;</div><div class="line">    objc_release(oldValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</div><div class="line">    if (offset == 0) &#123;</div><div class="line">        return object_getClass(self);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Retain release world</div><div class="line">    id *slot = (id*) ((char*)self + offset);</div><div class="line">    if (!atomic) return *slot;//非原子操作 直接返回值</div><div class="line">        </div><div class="line">    // Atomic retain release world</div><div class="line">	//原子操作 加锁-&gt;自旋锁</div><div class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class="line">    slotlock.lock();//加锁</div><div class="line">    id value = objc_retain(*slot);</div><div class="line">    slotlock.unlock();//解锁</div><div class="line">    </div><div class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</div><div class="line">    return objc_autoreleaseReturnValue(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//以属性的地址为参数计算出key ，锁为value</div><div class="line">StripedMap&lt;spinlock_t&gt; PropertyLocks;</div></pre></td></tr></table></figure>
<p>从源码了解到设置属性读取是<code>self</code>+属性的偏移量，当<code>copy</code>或<code>mutableCopy</code>会调用到<code>[newValue copyWithZone:nil]</code>或<code>[newValue mutableCopyWithZone:nil]</code>，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取<code>spinlock_t&amp; slotlock = PropertyLocks[slot]</code>进行加锁、赋值、解锁操作。而且<code>PropertyLocks</code>是一个类，类有一个数组属性，使用<code>*p</code>计算出来的值作为<code>key</code>。</p>
<p>我们提取出来关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//原子操作 加锁</div><div class="line">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class="line">slotlock.lock();</div><div class="line">oldValue = *slot;</div><div class="line">*slot = newValue;//赋值</div><div class="line">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>
<p>使用自旋锁对赋值操作进行加锁，保证了<code>setter()</code>方法的安全性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//原子操作 加锁 -&gt;自旋锁</div><div class="line">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class="line">slotlock.lock();//加锁</div><div class="line">id value = objc_retain(*slot);</div><div class="line">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>
<p>取值之前进行加锁，取值之后进行解锁，保证了<code>getter()</code>方法的安全。</p>
<p>由上面得知<code>atmoic</code>仅仅是对方法<code>setter()</code>和<code>getter()</code>安全，对成员变量不保证安全，对于属性的读写一般使用<code>nonatomic</code>，性能好，<code>atomic</code>读取频率高的时候会导致线程都在排队，浪费CPU时间。</p>
<p>大概使用者几种锁分别对卖票功能进行了性能测试，<br>性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁类型</th>
<th style="text-align:center">1万次</th>
<th style="text-align:center">100万次</th>
<th style="text-align:center">1000万次</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pthread_mutex_t</td>
<td style="text-align:center">0.000309</td>
<td style="text-align:center">0.027238</td>
<td style="text-align:center">0.284714</td>
</tr>
<tr>
<td style="text-align:center">os_unfair_lock</td>
<td style="text-align:center">0.000274</td>
<td style="text-align:center">0.028266</td>
<td style="text-align:center">0.285685</td>
</tr>
<tr>
<td style="text-align:center">OSSpinLock</td>
<td style="text-align:center">0.030688</td>
<td style="text-align:center">0.410067</td>
<td style="text-align:center">0.437702</td>
</tr>
<tr>
<td style="text-align:center">NSCondition</td>
<td style="text-align:center">0.005067</td>
<td style="text-align:center">0.323492</td>
<td style="text-align:center">1.078636</td>
</tr>
<tr>
<td style="text-align:center">NSLock</td>
<td style="text-align:center">0.038692</td>
<td style="text-align:center">0.151601</td>
<td style="text-align:center">1.322062</td>
</tr>
<tr>
<td style="text-align:center">NSRecursiveLock</td>
<td style="text-align:center">0.007973</td>
<td style="text-align:center">0.151601</td>
<td style="text-align:center">1.673409</td>
</tr>
<tr>
<td style="text-align:center">@synchronized</td>
<td style="text-align:center">0.008953</td>
<td style="text-align:center">0.640234</td>
<td style="text-align:center">2.790291</td>
</tr>
<tr>
<td style="text-align:center">NSConditionLock</td>
<td style="text-align:center">0.229148</td>
<td style="text-align:center">5.325272</td>
<td style="text-align:center">10.681123</td>
</tr>
<tr>
<td style="text-align:center">semaphore</td>
<td style="text-align:center">0.094267</td>
<td style="text-align:center">0.415351</td>
<td style="text-align:center">24.699100</td>
</tr>
<tr>
<td style="text-align:center">SerialQueue</td>
<td style="text-align:center">0.213386</td>
<td style="text-align:center">9.058581</td>
<td style="text-align:center">50.820202</td>
</tr>
</tbody>
</table>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>平时我们简单使用的话没有很大的区别，还是推荐使用<code>NSLock</code>和信号量,最简单的是<code>@synchronized</code>，不用声明和初始化，直接拿来就用。</p>
<h3 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h3><p>自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁在等待时间比较短的时候比较合适</li>
<li>临界区代码经常被调用，但竞争很少发生</li>
<li>CPU不紧张</li>
<li>多核处理器<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4></li>
<li>预计线程等待时间比较长</li>
<li>单核处理器</li>
<li>临界区IO操作</li>
<li>临界区代码比较多、复杂，或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<h2 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h2><h4 id="简单读写锁"><a href="#简单读写锁" class="headerlink" title="简单读写锁"></a>简单读写锁</h4><p>一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view.</div><div class="line">	self.semaphore = dispatch_semaphore_create(1);</div><div class="line">	</div><div class="line">	for (NSInteger i = 0; i &lt; 10; i ++) &#123;</div><div class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];</div><div class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)read&#123;</div><div class="line">	dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	dispatch_semaphore_signal(self.semaphore);</div><div class="line">&#125;</div><div class="line">- (void)write&#123;</div><div class="line">	dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	dispatch_semaphore_signal(self.semaphore);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点</p>
<ol>
<li>同一时间，只能有1个线程进行写操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许读写操作同时进行</li>
</ol>
<p>典型的<code>多读单写</code>，经常用于文件等数据的读写操作，我们实现2种</p>
<h4 id="读写锁-pthread-rwlock"><a href="#读写锁-pthread-rwlock" class="headerlink" title="读写锁 pthread_rwlock"></a>读写锁 pthread_rwlock</h4><p>这是有c语言封装的读写锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//初始化读写锁</div><div class="line">int pthread_rwlock_init(pthread_rwlock_t * __restrict,</div><div class="line">		const pthread_rwlockattr_t * _Nullable __restrict)</div><div class="line">//读上锁</div><div class="line">pthread_rwlock_rdlock(pthread_rwlock_t *)</div><div class="line">//尝试加锁读</div><div class="line">pthread_rwlock_tryrdlock(pthread_rwlock_t *)</div><div class="line">//尝试加锁写</div><div class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *)</div><div class="line">//写入加锁</div><div class="line">pthread_rwlock_wrlock(pthread_rwlock_t *)</div><div class="line">//解锁</div><div class="line">pthread_rwlock_unlock(pthread_rwlock_t *)</div><div class="line">//销毁锁属性</div><div class="line">pthread_rwlockattr_destroy(pthread_rwlockattr_t *)</div><div class="line">//销毁锁</div><div class="line">pthread_rwlock_destroy(pthread_rwlock_t * )</div></pre></td></tr></table></figure>
<p><code>pthread_rwlock_t</code>使用很简单，只需要在读之前使用<code>pthread_rwlock_rdlock</code>，读完解锁<code>pthread_rwlock_unlock</code>,写入前需要加锁<code>pthread_rwlock_wrlock</code>，写入完成之后解锁<code>pthread_rwlock_unlock</code>，任务都执行完了可以选择销毁<code>pthread_rwlock_destroy</code>或者等待下次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,assign) pthread_rwlock_t rwlock;</div><div class="line"></div><div class="line"></div><div class="line">- (void)dealloc&#123;</div><div class="line">	pthread_rwlock_destroy(&amp;_rwlock);//销毁锁</div><div class="line">&#125;</div><div class="line">//初始化读写锁</div><div class="line">pthread_rwlock_init(&amp;_rwlock, NULL);</div><div class="line">	</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];</div><div class="line">			[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">- (void)readPthreadRWLock&#123;</div><div class="line">    pthread_rwlock_rdlock(&amp;_rwlock);</div><div class="line">    NSLog(@&quot;读文件&quot;);</div><div class="line">    sleep(1);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">&#125;</div><div class="line">- (void)writePthreadRWLock&#123;</div><div class="line">    pthread_rwlock_wrlock(&amp;_rwlock);</div><div class="line">    NSLog(@&quot; 写入文件&quot;);</div><div class="line">    sleep(1);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 10:47:16 读文件</div><div class="line">2019-07-30 10:47:16 读文件</div><div class="line">2019-07-30 10:47:17 写入文件</div><div class="line">2019-07-30 10:47:18 写入文件</div><div class="line">2019-07-30 10:47:19 读文件</div><div class="line">2019-07-30 10:47:19 读文件</div><div class="line">2019-07-30 10:47:19 读文件</div><div class="line">2019-07-30 10:47:20 写入文件</div><div class="line">2019-07-30 10:47:21 写入文件</div><div class="line">2019-07-30 10:47:22 写入文件</div></pre></td></tr></table></figure>
<p>读文件会出现同一秒读多次，写文件同一秒只有一个。</p>
<h4 id="异步栅栏调用-dispatch-barrier-async"><a href="#异步栅栏调用-dispatch-barrier-async" class="headerlink" title="异步栅栏调用 dispatch_barrier_async"></a>异步栅栏调用 dispatch_barrier_async</h4><p>栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">任务</th>
<th style="text-align:center">任务</th>
<th style="text-align:center">任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
</tr>
</tbody>
</table>
<p>这个函数传入的并发队列必须是通过<code>dispatch_queue_create</code>创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于<code>dispatch_async</code>的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//初始化 异步队列</div><div class="line">self.rwqueue = dispatch_queue_create(&quot;rw.thread&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">	dispatch_async(queue, ^&#123;</div><div class="line">		[self readBarryier];</div><div class="line">		[self readBarryier];</div><div class="line">		[self readBarryier];</div><div class="line">		[self writeBarrier];</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)readBarryier&#123;</div><div class="line">//添加任务到rwqueue</div><div class="line">	dispatch_async(self.rwqueue, ^&#123;</div><div class="line">		NSLog(@&quot;读文件 %@&quot;,[NSThread currentThread]);</div><div class="line">		sleep(1);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)writeBarrier&#123;</div><div class="line">//barrier_async添加任务到self.rwqueue中</div><div class="line">	dispatch_barrier_async(self.rwqueue, ^&#123;</div><div class="line">		NSLog(@&quot;写入文件 %@&quot;,[NSThread currentThread]);</div><div class="line">		sleep(1);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae0740&gt;&#123;number = 9, name = (null)&#125;</div><div class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8500&gt;&#123;number = 10, name = (null)&#125;</div><div class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8040&gt;&#123;number = 8, name = (null)&#125;</div><div class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class="line">2019-07-30 11:16:54 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class="line">2019-07-30 11:16:55 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class="line">2019-07-30 11:16:56 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>读文件会出现同一秒读多个，写文件同一秒只有一个。</p>
<p>读写任务都添加到异步队列<code>rwqueue</code>中，使用栅栏函数<code>dispatch_barrier_async</code>拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>普通线程锁本质就是同步执行</li>
<li><code>atomic</code>原子操作只限制<code>setter</code>和<code>getter</code>方法，不限制成员变量</li>
<li>读写锁高性能可以使用<code>pthread_rwlock_t</code>和<code>dispatch_barrier_async</code><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="https://blog.csdn.net/Fly_as_tadpole/article/details/86436161" target="_blank" rel="external">优先级反转</a></li>
<li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16" target="_blank" rel="external">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="external">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="external">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a></li>
<li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/" class="post-title-link" itemprop="url">iOS底层原理  多线程之GCD看我就够了 --(10)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:20:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:20:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:06:41" itemprop="dateModified" datetime="2019-12-03T13:06:41+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>RunLoop</code>和线程的关系，以及<code>Thread</code>如何保活和控制生命周期，今天我们再探究下另外的一个线程<code>GCD</code>，揭开蒙娜丽莎的面纱。</p>
<h3 id="GCD-基础知识"><a href="#GCD-基础知识" class="headerlink" title="GCD 基础知识"></a>GCD 基础知识</h3><p>GCD是什么呢？我们引用<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="external">百度百科</a>的一段话。</p>
<blockquote>
<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>
</blockquote>
<p>GCD有哪些优点</p>
<ul>
<li>GCD自动管理线程</li>
<li>开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可</li>
<li>GCD 自动管理线程，线程创建，挂起，销毁。</li>
</ul>
<p>那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发</p>
<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。</p>
<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><p>并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活</p>
<p><strong>串行队列</strong>相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。</p>
<p><strong>并行队列</strong>是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。</p>
<p><strong>并发</strong>是多个流水线在同时加工产品。</p>
<h4 id="GCD中的串行队列"><a href="#GCD中的串行队列" class="headerlink" title="GCD中的串行队列()"></a>GCD中的串行队列()</h4><h5 id="串行队列（Serial-Dispatch-Queue）："><a href="#串行队列（Serial-Dispatch-Queue）：" class="headerlink" title="串行队列（Serial Dispatch Queue）："></a>串行队列（Serial Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。</p>
<p><img src="../images/10-1.png" alt=""></p>
<h5 id="并发队列（Concurrent-Dispatch-Queue）："><a href="#并发队列（Concurrent-Dispatch-Queue）：" class="headerlink" title="并发队列（Concurrent Dispatch Queue）："></a>并发队列（Concurrent Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。</p>
<p><img src="../images/10-2.png" alt=""></p>
<h3 id="GCD使用步骤"><a href="#GCD使用步骤" class="headerlink" title="GCD使用步骤"></a>GCD使用步骤</h3><p>GCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。</p>
<p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p>
<h4 id="获取主队列"><a href="#获取主队列" class="headerlink" title="获取主队列"></a>获取主队列</h4><p>主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过<code>dispatch_get_main_queue()</code>，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取主队列</div><div class="line">dispatch_queue_t main_queue= dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<h4 id="获取全局队列"><a href="#获取全局队列" class="headerlink" title="获取全局队列"></a>获取全局队列</h4><p>全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>,第一个参数是<code>identifier</code>，表示队列的优先级，一般传入<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数<code>flags</code>，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a></p>
<blockquote>
<p>Use the<br>.Fn dispatch_get_global_queue<br>function to obtain the global queue of given priority. The<br>.Fa flags<br>argument is reserved for future use and must be zero. Passing any value other<br>than zero may result in a NULL return value.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取全局队列</div><div class="line">dispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法的<code>spatch_async</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 同步执行任务创建方法</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">    // 这里放同步执行任务代码</div><div class="line">&#125;);</div><div class="line">// 异步执行任务创建方法</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    // 这里放异步执行任务代码</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>虽然是只有同步异步但是他们组合的多变的</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">并发队列</th>
<th style="text-align:center">创建的串行队列</th>
<th style="text-align:center">主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同步(sync)</td>
<td style="text-align:center">没开启新线程，串行执行</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
</tr>
<tr>
<td style="text-align:center">异步(async)</td>
<td style="text-align:center">能开启新线程，并发执行</td>
<td style="text-align:center">能开启新线程，串行执行任务</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<h3 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h3><h4 id="主队列-同步"><a href="#主队列-同步" class="headerlink" title="主队列+同步"></a>主队列+同步</h4><p>在主队列中执行任务，并同步添加任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//主队列+同步</div><div class="line">-(void)syn_main&#123;</div><div class="line">	NSLog(@&quot;1&quot;);</div><div class="line">	dispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class="line">	dispatch_sync(main_queue, ^&#123;</div><div class="line">		NSLog(@&quot;2&quot;);</div><div class="line">	&#125;);</div><div class="line">	NSLog(@&quot;3&quot;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">1</div></pre></td></tr></table></figure>
<p>看到日志只输出了1就崩溃了提示<code>exc_bad_instuction</code>,为什么出问题呢？<br>主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。<br><strong>what</strong>???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句<code>exc_bad_instuction</code>，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。<br>那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//主队列+同步</div><div class="line">-(void)syn_main2&#123;</div><div class="line">	NSLog(@&quot;1任务执行&quot;);</div><div class="line">	sleep(1);</div><div class="line">	NSLog(@&quot;2任务执行&quot;);</div><div class="line">	sleep(1);</div><div class="line">	NSLog(@&quot;3任务执行&quot;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">1任务执行</div><div class="line">2任务执行</div><div class="line">3任务执行</div></pre></td></tr></table></figure>
<p>没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。</p>
<h4 id="主队列-异步"><a href="#主队列-异步" class="headerlink" title="主队列+异步"></a>主队列+异步</h4><p>在主队列中异步添加任务并执行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//主队列+异步</div><div class="line">	NSLog(@&quot;start&quot;);</div><div class="line">	dispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class="line">	dispatch_async(main_queue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(main_queue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(main_queue, ^&#123;</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	NSLog(@&quot;end&quot;);</div><div class="line">//log</div><div class="line">2019-07-24 15:12:24.73 start</div><div class="line">2019-07-24 15:12:24.73 end</div><div class="line"></div><div class="line">&lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 0</div><div class="line">2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 1</div><div class="line">2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 2</div><div class="line">2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 3</div><div class="line">2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 4</div><div class="line">2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 5</div><div class="line">2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 7</div><div class="line">2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 8</div><div class="line">2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 9</div></pre></td></tr></table></figure>
<p>在主队列异步执行任务，从日志看出来<code>end</code>早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到</p>
<ul>
<li>主线程多个任务异步不能创建新线程</li>
<li>主线程异步也是串行执行</li>
</ul>
<h4 id="全局队列-同步"><a href="#全局队列-同步" class="headerlink" title="全局队列+同步"></a>全局队列+同步</h4><p>全局队列是并行队列，和同步配合就是串行执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//全局队列+同步</div><div class="line">-(void)sync_global&#123;</div><div class="line">	printf(&quot;\n start&quot;);</div><div class="line">	dispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">	dispatch_sync(global_queue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_sync(global_queue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_sync(global_queue, ^&#123;</div><div class="line">		NSThread *thread = [NSThread currentThread];</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n end&quot;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">start</div><div class="line"> 2019-07-24 15:35:36 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 0</div><div class="line"> 2019-07-24 15:35:37 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 1</div><div class="line"> 2019-07-24 15:35:38 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 2</div><div class="line"> 2019-07-24 15:35:39 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 3</div><div class="line"> 2019-07-24 15:35:40 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 4</div><div class="line"> 2019-07-24 15:35:41 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 5</div><div class="line"> 2019-07-24 15:35:42 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 7</div><div class="line"> 2019-07-24 15:35:43 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 8</div><div class="line"> 2019-07-24 15:35:44 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 9</div><div class="line"> end</div></pre></td></tr></table></figure>
<p>在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。</p>
<h4 id="全局队列-异步"><a href="#全局队列-异步" class="headerlink" title="全局队列+异步"></a>全局队列+异步</h4><p>全局队列有创建子线程的能力，但是需要异步<code>async</code>去执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//全局队列+异步</div><div class="line">-(void)async_global&#123;</div><div class="line">	printf(&quot;\n start&quot;);</div><div class="line">	dispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">	dispatch_async(global_queue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(global_queue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(global_queue, ^&#123;</div><div class="line">		NSThread *thread = [NSThread currentThread];</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n end&quot;);</div><div class="line">&#125;</div><div class="line">-(NSString *)currentDateString&#123;</div><div class="line">	NSDate *date=[NSDate new];</div><div class="line">	NSDateFormatter *format = [[NSDateFormatter alloc]init];</div><div class="line">	[format setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">	return [format stringFromDate:date];</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line"> start</div><div class="line"> end</div><div class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 3</div><div class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 0</div><div class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 7</div><div class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 1</div><div class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 8</div><div class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 4</div><div class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 9</div><div class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 2</div><div class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 5</div></pre></td></tr></table></figure>
<p>全局队列当搭配<code>async</code>的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。</p>
<h4 id="创建串行队列-同步"><a href="#创建串行队列-同步" class="headerlink" title="创建串行队列+同步"></a>创建串行队列+同步</h4><p>开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//创建串行队列+同步</div><div class="line">-(void)sync_cust_queue&#123;</div><div class="line">	printf(&quot;\n start&quot;);</div><div class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">	dispatch_sync(custQueue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_sync(custQueue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_sync(custQueue, ^&#123;</div><div class="line">		NSThread *thread = [NSThread currentThread];</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n end&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">start</div><div class="line"> 2019-07-24 15:53:15 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 0</div><div class="line"> 2019-07-24 15:53:16 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 1</div><div class="line"> 2019-07-24 15:53:17 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 2</div><div class="line"> 2019-07-24 15:53:18 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 3</div><div class="line"> 2019-07-24 15:53:19 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 4</div><div class="line"> 2019-07-24 15:53:20 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 5</div><div class="line"> 2019-07-24 15:53:21 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 7</div><div class="line"> 2019-07-24 15:53:22 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 8</div><div class="line"> 2019-07-24 15:53:23 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 9</div><div class="line"> end</div></pre></td></tr></table></figure>
<p>同步向串行队列添加任务并没有死锁！原因是添加任务是在<code>main_queue</code>执行的，添加的任务是在<code>cust-queue</code>中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在<code>main</code>线程中。</p>
<h4 id="创建串行队列-异步"><a href="#创建串行队列-异步" class="headerlink" title="创建串行队列+异步"></a>创建串行队列+异步</h4><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//创建串行队列+异步</div><div class="line">-(void)async_cust_queue&#123;</div><div class="line">	printf(&quot;\n start&quot;);</div><div class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		NSThread *thread = [NSThread currentThread];</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n end&quot;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line"> start</div><div class="line"> end</div><div class="line"> 2019-07-24 16:12:57 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 0</div><div class="line"> 2019-07-24 16:12:58 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 1</div><div class="line"> 2019-07-24 16:12:59 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 2</div><div class="line"> 2019-07-24 16:13:00 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 3</div><div class="line"> 2019-07-24 16:13:01 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 4</div><div class="line"> 2019-07-24 16:13:02 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 5</div><div class="line"> 2019-07-24 16:13:03 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class="line"> 2019-07-24 16:13:04 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class="line"> 2019-07-24 16:13:05 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 9</div></pre></td></tr></table></figure>
<p>在<code>异步 + 串行队列</code>可以看到：</p>
<p>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。<br>所有任务是在打印的<code>end</code>之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<h4 id="创建并行队列-同步"><a href="#创建并行队列-同步" class="headerlink" title="创建并行队列+同步"></a>创建并行队列+同步</h4><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">start</div><div class="line">2019-07-24 16:21:24 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 0</div><div class="line">2019-07-24 16:21:25 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 1</div><div class="line">2019-07-24 16:21:26 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 2</div><div class="line">2019-07-24 16:21:27 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 3</div><div class="line">2019-07-24 16:21:28 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 4</div><div class="line">2019-07-24 16:21:29 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 5</div><div class="line">2019-07-24 16:21:30 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 7</div><div class="line">2019-07-24 16:21:31 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 8</div><div class="line">2019-07-24 16:21:32 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 9</div><div class="line">end</div></pre></td></tr></table></figure>
<p>全局队列其实就是特殊的并行队列，这里结果和<code>全局队列+同步</code>一致。</p>
<h4 id="创建并行队列-异步"><a href="#创建并行队列-异步" class="headerlink" title="创建并行队列+异步"></a>创建并行队列+异步</h4><p>在当前线程中执行任务，会开启新线程，可以同时执行多个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//创建并行队列+异步</div><div class="line">-(void)async_queue&#123;</div><div class="line">	printf(&quot;\n start&quot;);</div><div class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(custQueue, ^&#123;</div><div class="line">		NSThread *thread = [NSThread currentThread];</div><div class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n end&quot;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">start</div><div class="line"> end</div><div class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 0</div><div class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 3</div><div class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 1</div><div class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 4</div><div class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 9</div><div class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 2</div><div class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>
<p><code>并行队列+异步</code>和<code>全局队列+异步</code>一致，也会新建线程执行任务，且是并发执行。</p>
<h3 id="GCD其他高级用法"><a href="#GCD其他高级用法" class="headerlink" title="GCD其他高级用法"></a>GCD其他高级用法</h3><h4 id="子线程执行任务-主线程刷新UI"><a href="#子线程执行任务-主线程刷新UI" class="headerlink" title="子线程执行任务 主线程刷新UI"></a>子线程执行任务 主线程刷新UI</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)backToMain&#123;</div><div class="line">	dispatch_queue_t main = dispatch_get_main_queue();</div><div class="line">	dispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">	dispatch_async(glo, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">		dispatch_sync(main, ^&#123;</div><div class="line">			printf(&quot;\n %s %s 我在刷新UI&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">		&#125;);</div><div class="line">	&#125;);	</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"> 2019-07-24 16:45:07 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 0</div><div class="line"> 2019-07-24 16:45:08 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 1</div><div class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 2</div><div class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001ef2940&gt;&#123;number = 1, name = main&#125; 我在刷新UI</div></pre></td></tr></table></figure>
<h4 id="队列分组-dispatch-group-t"><a href="#队列分组-dispatch-group-t" class="headerlink" title="队列分组 dispatch_group_t"></a>队列分组 dispatch_group_t</h4><h5 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h5><p>GCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过<code>dispatch_group_notify</code>完成回调，第一个参数<code>group</code>是某个分组的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">-(void)group&#123;</div><div class="line">	dispatch_group_t group = dispatch_group_create();</div><div class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;cust2.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_group_async(group, queue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_group_async(group, queue2, ^&#123;</div><div class="line">		for (int i = 4; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">		printf(&quot;\n %s %s ---end1----&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">	&#125;);</div><div class="line">	dispatch_group_async(group, queue, ^&#123;</div><div class="line">		for (int i = 6; i &lt; 8; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_group_async(group, queue2, ^&#123;</div><div class="line">		for (int i = 8; i &lt; 10; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave"><a href="#dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave" class="headerlink" title="dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave"></a>dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave</h5><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>需要成对使用，否则<code>dispatch_group_wait</code>在缺少<code>leave</code>的情况下会等待到死，造成线程阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static	dispatch_group_t group ;</div><div class="line">if (group == nil) &#123;</div><div class="line">	group = dispatch_group_create();</div><div class="line">&#125;</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">//	dispatch_group_enter(group);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">	[self print];</div><div class="line">	[NSThread sleepForTimeInterval:2];</div><div class="line">//		dispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行</div><div class="line">&#125;);</div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">	[self print];</div><div class="line">	[NSThread sleepForTimeInterval:2];</div><div class="line">	dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">//log</div><div class="line">2019-07-25 10:58:50 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">2019-07-25 10:58:52 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<h4 id="栅栏函数-dispatch-barrier-sync"><a href="#栅栏函数-dispatch-barrier-sync" class="headerlink" title="栅栏函数 dispatch_barrier_sync"></a>栅栏函数 dispatch_barrier_sync</h4><p>栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (void)barry&#123;</div><div class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(queue, ^&#123;</div><div class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_barrier_sync(queue, ^&#123;</div><div class="line">		printf(&quot;\n %s %s ---中间暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">	&#125;);</div><div class="line">	dispatch_async(queue, ^&#123;</div><div class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</div><div class="line">			[NSThread sleepForTimeInterval:1];</div><div class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_barrier_async(queue, ^&#123;</div><div class="line">		printf(&quot;\n %s %s ---中间第二次暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"> 2019-07-24 16:52:33 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 0</div><div class="line"> 2019-07-24 16:52:34 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 1</div><div class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 2</div><div class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x6000031293c0&gt;&#123;number = 1, name = main&#125; ---中间暂停一下----</div><div class="line"> 2019-07-24 16:52:36 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 3</div><div class="line"> 2019-07-24 16:52:37 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 4</div><div class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 5</div><div class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; ---中间第二次暂停一下----</div></pre></td></tr></table></figure>
<h4 id="单例-执行一次的函数-dispatch-once-t"><a href="#单例-执行一次的函数-dispatch-once-t" class="headerlink" title="单例-执行一次的函数 dispatch_once_t"></a>单例-执行一次的函数 dispatch_once_t</h4><p>单例可以通过这个函数实现，只执行一次的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//只执行一次的dispatch_once</div><div class="line">-(void)exc_once&#123;</div><div class="line">	static dispatch_once_t onceToken;</div><div class="line">	static NSObject *obj;</div><div class="line">	dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">		obj=[NSObject new];</div><div class="line">		printf(&quot;\n just once %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class="line">&#125;</div><div class="line">调用4次</div><div class="line">dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class="line">		[self exc_once];</div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">//log</div><div class="line">just once 2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div></pre></td></tr></table></figure>
<p>当调用4次的时候，日志打印的四次<code>obj</code>均为同一个地址，证明<code>block</code>回调四次但是只执行了一次。</p>
<h4 id="延迟执行-dispatch-after"><a href="#延迟执行-dispatch-after" class="headerlink" title="延迟执行 dispatch_after"></a>延迟执行 dispatch_after</h4><p>当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//延迟执行</div><div class="line">-(void)delayTimeExc&#123;</div><div class="line">	printf(&quot;\n %s %s begin&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">	</div><div class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	</div><div class="line">		printf(&quot;\n %s %s&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">		</div><div class="line">	&#125;);</div><div class="line">	printf(&quot;\n %s %s end&quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; begin</div><div class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; end</div><div class="line">2019-07-24 17:07:50 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<h4 id="信号量-dispatch-semaphore-t"><a href="#信号量-dispatch-semaphore-t" class="headerlink" title="信号量  dispatch_semaphore_t"></a>信号量  dispatch_semaphore_t</h4><p>信号量为1可以作为线程锁来用，当N&gt;1的时候，同时执行的有N个任务。<br><code>dispatch_apply</code>可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//信号量 当信号量为1 可以未做锁来用，当N&gt;1，t通知执行的数量则是数字N。</div><div class="line">- (void)semaphore&#123;</div><div class="line">	static dispatch_semaphore_t sem;</div><div class="line">	if (sem == NULL) &#123;</div><div class="line">		sem = dispatch_semaphore_create(1);</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class="line">	static int i = 0;</div><div class="line">	int currentI = i +2;</div><div class="line">	for (; i &lt; currentI; i ++) &#123;</div><div class="line">		[NSThread sleepForTimeInterval:1];</div><div class="line">		printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_signal(sem);</div><div class="line">&#125;</div><div class="line">-(void)asyn_semaphore&#123;</div><div class="line">	dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class="line">		[self semaphore];</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">2019-07-24 17:25:04 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 0</div><div class="line">2019-07-24 17:25:05 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 1</div><div class="line">2019-07-24 17:25:06 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 2</div><div class="line">2019-07-24 17:25:07 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 3</div><div class="line">2019-07-24 17:25:08 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 4</div><div class="line">2019-07-24 17:25:09 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>
<p>设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(void)muchQueueBuyTick&#123;</div><div class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(queue, ^&#123;</div><div class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">			[self semaphore_buy_ticks:4];</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(queue2, ^&#123;</div><div class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">			[self semaphore_buy_ticks:2];</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)semaphore_buy_ticks:(NSInteger)windowsCount&#123;</div><div class="line">	static dispatch_semaphore_t sem;</div><div class="line">	if (sem == NULL) &#123;</div><div class="line">		sem = dispatch_semaphore_create(windowsCount);</div><div class="line">	&#125;</div><div class="line">	//信号量-1</div><div class="line">	dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class="line">	self.count--;</div><div class="line">	if (self.count &gt; 0) &#123;</div><div class="line">		printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class="line">		[NSThread sleepForTimeInterval:0.2];</div><div class="line">	&#125;</div><div class="line">	//信号量+1</div><div class="line">	dispatch_semaphore_signal(sem);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">2019-07-24 18:01:44 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class="line"> 2019-07-24 18:01:44 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第8个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第6个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第4个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第2个人买到票了</div><div class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第0个人买到票了</div></pre></td></tr></table></figure>
<p>两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。<br>当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-(void)muchQueueBuyTick&#123;</div><div class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(queue, ^&#123;</div><div class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">			[self semaphore_buy_ticks:1];</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	dispatch_async(queue2, ^&#123;</div><div class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">			[self semaphore_buy_ticks:1];</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-24 18:03:56 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第9个人买到票了</div><div class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第7个人买到票了</div><div class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第5个人买到票了</div><div class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第3个人买到票了</div><div class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第1个人买到票了</div></pre></td></tr></table></figure>
<p>顺序是对了，数量也对了。</p>
<p>再换一种思路实现锁住窗口，我们使用串行队列也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//使用同步队列卖票</div><div class="line">- (void)sync_buy_tick&#123;</div><div class="line">	dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">		self.count--;</div><div class="line">		if (self.count &gt; 0) &#123;</div><div class="line">			printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class="line">			[NSThread sleepForTimeInterval:0.2];</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第9个人买到票了</div><div class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第8个人买到票了</div><div class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第7个人买到票了</div><div class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第6个人买到票了</div><div class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第5个人买到票了</div><div class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第4个人买到票了</div><div class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第3个人买到票了</div><div class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第2个人买到票了</div><div class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第1个人买到票了</div></pre></td></tr></table></figure>
<p>串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。</p>
<h4 id="快速迭代方法：dispatch-apply"><a href="#快速迭代方法：dispatch-apply" class="headerlink" title="快速迭代方法：dispatch_apply"></a>快速迭代方法：dispatch_apply</h4><p>快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">同时新建了多条线程来做任务</div><div class="line">*/</div><div class="line">	dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class="line">		printf(&quot;\n %s %s &quot;,[self dateUTF8],[self threadInfo]);</div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">	//log</div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125; </div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000979dc0&gt;&#123;number = 5, name = (null)&#125; </div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000090d3c0&gt;&#123;number = 1, name = main&#125; </div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000095cfc0&gt;&#123;number = 6, name = (null)&#125; </div><div class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000950140&gt;&#123;number = 8, name = (null)&#125; </div><div class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000095d0c0&gt;&#123;number = 9, name = (null)&#125; </div><div class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a400&gt;&#123;number = 7, name = (null)&#125; </div><div class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>可以看到新建了<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>、<code>main</code>来执行任务。</p>
<h3 id="多线程RunLoop实战"><a href="#多线程RunLoop实战" class="headerlink" title="多线程RunLoop实战"></a>多线程RunLoop实战</h3><p>问题一：请问下边代码输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);</div><div class="line">    dispatch_async(que, ^&#123;</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class="line">        NSLog(@&quot;3&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">- (void)test&#123;</div><div class="line">    NSLog(@&quot;2&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>猜想1：结果是<code>123</code></li>
<li>猜想2：结果是<code>132</code></li>
</ul>
<p>有没有第三种结果呢？</p>
<p>猜想1分析：<br>因为是延迟<code>0</code>s执行，当然是先执行<code>2</code>，再执行<code>3</code>了。</p>
<p>猜想2分析：</p>
<p>我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出<code>1</code>，然后输出<code>3</code>，最后输出<code>2</code>.</p>
<p>最后验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div></pre></td></tr></table></figure>
<p>为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在<code>runloop.h</code>文件中，我们猜测延迟执行是<code>timer</code>添加到<code>runloop</code>中了，添加进去也应该输出<code>132</code>的。因为在子线程中，没有主动调用不会有<code>runloop</code>的，及时调用了也需要保活技术，那么代码改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_async(que, ^&#123;</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">        // 相当于[self test];</div><div class="line">//       [self performSelector:@selector(test) withObject:nil];</div><div class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class="line">        </div><div class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class="line">        [[NSRunLoop currentRunLoop] run];</div><div class="line">        NSLog(@&quot;3&quot;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>经测试输出了<code>12</code>，这和我们猜想的还是不对，原来输出<code>3</code>放在了最后，导致的问题，<code>RunLoop</code>运行起来，进入了循环，则后面的就不会执行了，除非停止当前<code>RunLoop</code>，我们再改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_async(que, ^&#123;</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">        // 相当于[self test];</div><div class="line">//       [self performSelector:@selector(test) withObject:nil];</div><div class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class="line">         NSLog(@&quot;3&quot;);</div><div class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class="line">        [[NSRunLoop currentRunLoop] run];</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>最后终于输出了<code>132</code>。缺点是子线程成了<strong>死待</strong>，不死之身，关于怎么杀死<strong>死待</strong>请看<a href="https://juejin.im/post/5d35b347f265da1b8608c49b" target="_blank" rel="external">上篇优雅控制RunLoop生命周期</a>。<br>关于<code>performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>中有延迟的，都是添加到当前你线程的<code>RunLoop</code>，如果没有启动<code>RunLoop</code>和保活恐怕也不能一直执行。<code>[self performSelector:@selector(test) withObject:nil]</code>是在<code>Foudation</code>中，源码是直接<code>objc_msgSend()</code>，相当于直接<code>[self test]</code>，不会有延迟。</p>
<p>问题2：请问输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSThread *thread=[[NSThread alloc]initWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">&#125;];</div><div class="line">[thread start];</div><div class="line">[self performSelector:@selector(test)</div><div class="line">             onThread:thread</div><div class="line">           withObject:nil</div><div class="line">        waitUntilDone:YES];</div></pre></td></tr></table></figure>
<p>这个和上面的类似，结果是打印了<code>1</code>就崩溃了，原因是<code>thread start</code>之后执行完<code>block</code>就结束了，没有<code>runloop</code>的支撑。当执行<code>performSelector</code>的时候，线程已经死掉。解决这个问题只需要向子线程中添加<code>RunLoop</code>，而且保证<code>RunLoop</code>不停止就行了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI</li>
<li>队列多任务异步执行最后全局执行完毕可以使用<code>group_notify</code>来监听执行完毕时间</li>
<li>队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用<code>dispatch_barrier_sync</code></li>
<li>当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16" target="_blank" rel="external">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="external">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="external">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a></li>
<li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/" class="post-title-link" itemprop="url">iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:19:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:19:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:04:59" itemprop="dateModified" datetime="2019-12-03T13:04:59+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>
<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int ret = 0;</div><div class="line">do &#123;</div><div class="line">    //睡眠中等待消息</div><div class="line">    int messgae = sleep_and_wait();</div><div class="line">    //处理消息</div><div class="line">    ret = process_message(messgae);</div><div class="line">&#125; while (ret == 0);</div></pre></td></tr></table></figure>
<h3 id="获取runloop"><a href="#获取runloop" class="headerlink" title="获取runloop"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</div><div class="line">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</div><div class="line"></div><div class="line">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</div><div class="line">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</div><div class="line">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</div><div class="line">NSLog(@&quot;%@&quot;,runloop1);</div><div class="line">//打印</div><div class="line">runlopp1:0x600001bc58c0 </div><div class="line">mainloop1:0x600001bc58c0 </div><div class="line">runloop2:0x6000003cc300 </div><div class="line">mainloop1:0x6000003cc300</div><div class="line"></div><div class="line">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</div></pre></td></tr></table></figure>
<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>
<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* model list 锁 */</div><div class="line">    __CFPort _wakeUpPort;			// 接受 CFRunLoopWakeUp的端口</div><div class="line">    Boolean _unused;//是否使用</div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class="line">    pthread_t _pthread; //线程</div><div class="line">    uint32_t _winthread;//win线程</div><div class="line">    CFMutableSetRef _commonModes; //modes</div><div class="line">    CFMutableSetRef _commonModeItems; //modeItems</div><div class="line">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class="line">    CFMutableSetRef _modes; //所有的modes</div><div class="line">    struct _block_item *_blocks_head; //待执行的block列表头部</div><div class="line">    struct _block_item *_blocks_tail; //待执行的block 尾部</div><div class="line">    CFAbsoluteTime _runTime; //runtime</div><div class="line">    CFAbsoluteTime _sleepTime; //sleeptime</div><div class="line">    CFTypeRef _counterpart; //</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过简化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    pthread_t _pthread; //线程</div><div class="line">    CFMutableSetRef _commonModes; //modes</div><div class="line">    CFMutableSetRef _commonModeItems; //modeItems</div><div class="line">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class="line">    CFMutableSetRef _modes; //所有的modes</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>
<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>
<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>
</ol>
<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过简化之后是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;//当前mode的名字</div><div class="line">    CFMutableSetRef _sources0;//souces0</div><div class="line">    CFMutableSetRef _sources1;//sources1</div><div class="line">    CFMutableArrayRef _observers;//observers</div><div class="line">    CFMutableArrayRef _timers;//timers</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>
<p><img src="../images/9-1.png" alt=""></p>
<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>
<h4 id="souces0"><a href="#souces0" class="headerlink" title="souces0"></a>souces0</h4><ul>
<li>触摸事件</li>
<li>performSelector:onThread:</li>
</ul>
<p>测试下点击事件处理源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);//此处断点</div><div class="line">&#125;</div><div class="line"></div><div class="line">(LLDB) bt //输出当前调用栈</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class="line">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</div><div class="line">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</div><div class="line">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</div><div class="line">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</div><div class="line">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</div><div class="line">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</div><div class="line">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</div><div class="line">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</div><div class="line">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</div><div class="line">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</div><div class="line">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</div><div class="line">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</div><div class="line">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</div><div class="line">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</div><div class="line">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</div><div class="line">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</div><div class="line">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>
<h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">	static int count = 5;</div><div class="line">	dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class="line">	dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">		NSLog(@&quot;-------：%d \n&quot;,count++);</div><div class="line">	&#125;);</div><div class="line">	dispatch_resume(timer);</div><div class="line">	//log</div><div class="line">	(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class="line">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</div><div class="line">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</div><div class="line">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</div><div class="line">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</div><div class="line">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</div><div class="line">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</div><div class="line">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</div><div class="line">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</div></pre></td></tr></table></figure>
<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</div><div class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</div></pre></td></tr></table></figure>
<p>那么这两个Mode都是在什么情况下运行的呢？</p>
<ol>
<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>
</ol>
<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="external">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>
<p>现在我们了解到：</p>
<ol>
<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>
<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>
<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>
</ol>
<h5 id="runloop切换Mode"><a href="#runloop切换Mode" class="headerlink" title="runloop切换Mode"></a>runloop切换Mode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">    switch (activity) &#123;</div><div class="line">    	case kCFRunLoopEntry:&#123;</div><div class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class="line">    		NSLog(@&quot;即将进入 mode:%@&quot;,m);</div><div class="line">    		CFRelease(m);</div><div class="line">    		break;</div><div class="line">    	&#125;</div><div class="line">    		</div><div class="line">    	case kCFRunLoopExit:</div><div class="line">    	&#123;</div><div class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class="line">    		NSLog(@&quot;即将退出 mode:%@&quot;,m);</div><div class="line">    		CFRelease(m);</div><div class="line">    		break;</div><div class="line">    	&#125;</div><div class="line">    	default:</div><div class="line">    		break;</div><div class="line">    &#125;</div><div class="line">	&#125;);</div><div class="line">	CFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</div><div class="line">	CFRelease(obs);</div><div class="line">	</div><div class="line">	//当滑动tb的时候log</div><div class="line">	</div><div class="line">即将退出 mode:kCFRunLoopDefaultMode</div><div class="line">即将进入 mode:UITrackingRunLoopMode</div><div class="line">即将退出 mode:UITrackingRunLoopMode</div><div class="line">即将进入 mode:kCFRunLoopDefaultMode</div></pre></td></tr></table></figure>
<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>
<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">//	//获取loop</div><div class="line">	CFRunLoopRef ref = CFRunLoopGetMain();</div><div class="line">	//获取obs</div><div class="line">	CFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</div><div class="line">	//添加监听</div><div class="line">	CFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</div><div class="line">	CFRelease(obs);</div><div class="line">	</div><div class="line">	</div><div class="line">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</div><div class="line">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</div><div class="line">	printf(&quot;- &quot;);</div><div class="line">	count ++;</div><div class="line">	printf(&quot;%d&quot;,count);</div><div class="line">	switch (activity) &#123;</div><div class="line">		case kCFRunLoopEntry:</div><div class="line">			printf(&quot;即将进入 \n&quot;);</div><div class="line">			count = 0;</div><div class="line">			break;</div><div class="line">		case kCFRunLoopExit:</div><div class="line">			printf(&quot;即将退出 \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopAfterWaiting:</div><div class="line">			printf(&quot;即将从休眠中唤醒 \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeTimers:</div><div class="line">			printf(&quot;即将进入处理 timers \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeSources:</div><div class="line">			printf(&quot;即将进入 sources \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeWaiting:</div><div class="line">			printf(&quot;即将进入 休眠 \n&quot;);</div><div class="line">			count = 0;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//点击的时候 会出发loop来处理触摸事件</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">- 4即将进入处理 timers </div><div class="line">- 5即将进入 sources </div><div class="line">- 6即将进入处理 timers </div><div class="line">- 7即将进入 sources </div><div class="line">- 8即将进入处理 timers </div><div class="line">- 9即将进入 sources </div><div class="line">- 10即将进入 休眠 </div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">- 4即将进入处理 timers </div><div class="line">- 5即将进入 sources </div><div class="line">- 6即将进入 休眠 </div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">- 4即将进入 休眠</div></pre></td></tr></table></figure>
<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>
<h5 id="RunLoop在不获取的时候不存在-获取才生成"><a href="#RunLoop在不获取的时候不存在-获取才生成" class="headerlink" title="RunLoop在不获取的时候不存在,获取才生成"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>
<p>首先看官方给的图：</p>
<p><img src="../images/9-2.png" alt=""><br>那我又整理了一个表格来更直观的了解状态运转<br>|步骤|任务|<br>|:-:|:-:|<br>|1|通知Observers:进入Loop|<br>|2|通知Observers:即将处理Timers|<br>|3|通知Observers:即将处理Sources|<br>|4|处理blocks|<br>|5|处理Source0(可能再处理Blocks)|<br>|6|如果存在Source1，跳转第8步|<br>|7|通知Observers:开始休眠|<br>|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|<br>|9|处理Blocks|<br>|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|<br>|11|通知Observers:退出Loop|</p>
<p>查看<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">runloop源码</a>中<code>runloop.c</code>2333行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div></pre></td><td class="code"><pre><div class="line">//入口函数</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line"></div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">	timeout_context-&gt;ds = timeout_timer;</div><div class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</div><div class="line">        voucher_t voucherCopy = NULL;</div><div class="line">#endif</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">#endif</div><div class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line"></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">//通知即将处理Timers</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">//通知即将处理Sources</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">//处理Blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">//处理Source0</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">	//处理Block</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	&#125;</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line"></div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">	//y判断是否有Source1</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">	//有则去 handle_msg</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">        didDispatchPortLastTime = false;</div><div class="line">//即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	//开始休眠</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line"></div><div class="line">    __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line"></div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //等待消息来唤醒当前线程</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">			</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line"></div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">        // user callouts now OK again</div><div class="line">	__CFRunLoopUnsetSleeping(rl);</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">	//结束休眠</div><div class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">//标签 handle_msg</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">			</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">	//被timer唤醒</div><div class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">	//被GCD换醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">	//处理GCD</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">	//处理Source1</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">			</div><div class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            if (rls) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">		mach_msg_header_t *reply = NULL;</div><div class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">		if (NULL != reply) &#123;</div><div class="line">		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">		&#125;</div><div class="line">#endif</div><div class="line">	    &#125;</div><div class="line">            </div><div class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">        &#125;</div><div class="line">        //处理bBlock</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">//设置返回值</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        voucher_mach_msg_revert(voucherState);</div><div class="line">        os_release(voucherCopy);</div><div class="line">#endif</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过及进一步精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">//入口函数</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line"></div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">//通知即将处理Timers</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">//通知即将处理Sources</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">//处理Blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">//处理Source0</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">	//处理Block</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	&#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">	//y判断是否有Source1</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">	//有则去 handle_msg</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">//即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	//开始休眠</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line">        do &#123;</div><div class="line">    //等待消息来唤醒当前线程</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">	//结束休眠</div><div class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">//标签 handle_msg</div><div class="line">        handle_msg:;</div><div class="line">	//被timer唤醒</div><div class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">	//被GCD换醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">	//处理GCD</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">	//处理Source1</div><div class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">            // Restore the previous voucher</div><div class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">        &#125;</div><div class="line">        //处理bBlock</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">    //设置返回值</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="external">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>
<h5 id="timer保活和多mode运行"><a href="#timer保活和多mode运行" class="headerlink" title="timer保活和多mode运行"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static int i = 0;</div><div class="line">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">	NSLog(@&quot;%d&quot;,++i);</div><div class="line">&#125;];</div><div class="line">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</div><div class="line">//timer在设置为common模式下能运行</div><div class="line">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</div><div class="line">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">//log</div><div class="line">	</div><div class="line">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</div><div class="line">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</div><div class="line">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</div><div class="line">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</div><div class="line">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</div><div class="line">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</div><div class="line">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</div><div class="line">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</div></pre></td></tr></table></figure>
<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	CFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</div><div class="line">	dispatch_source_cancel(timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>
<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>
<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">    &#125; else &#123;</div><div class="line">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>
<h5 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </div><div class="line">                            forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>
<p>验证线程保活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) FYThread *thread;</div><div class="line"></div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class="line">	_thread.name = @&quot;test thread&quot;;</div><div class="line">	[_thread start];</div><div class="line">&#125;</div><div class="line">- (void)test &#123;</div><div class="line">//添加端口</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	[[NSRunLoop currentRunLoop] run];</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">//注释掉添加端口代码</div><div class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">--end--</div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">执行完毕了子线程</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//注释放开的时候点击触发log</div><div class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line"></div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">执行完毕了子线程</div><div class="line">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</div></pre></td></tr></table></figure>
<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>
<p>那我们测试下该线程声明周期多长？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class="line">	_thread.name = @&quot;test thread&quot;;</div><div class="line">	[_thread start];</div><div class="line">&#125;</div><div class="line">- (void)test &#123;</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	//获取obs</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	/*</div><div class="line">	 If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</div><div class="line">	 */</div><div class="line">	[[NSRunLoop currentRunLoop] run];</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//返回上页</div><div class="line">- (IBAction)popVC:(id)sender &#123;</div><div class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">-[ViewController stop]</div></pre></td></tr></table></figure>
<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>
<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BOOL shouldKeepRunning = YES; // global</div><div class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure>
<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	//获取obs</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	self.shouldKeepRunning = YES;//默认运行</div><div class="line">	NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">	while (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//返回上页</div><div class="line">- (IBAction)popVC:(id)sender &#123;</div><div class="line">	self.shouldKeepRunning = NO;</div><div class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">- (void)pop&#123;</div><div class="line">	[self.navigationController popViewControllerAnimated:YES];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">--end--</div><div class="line">-[ViewController dealloc]</div><div class="line">-[FYThread dealloc]</div></pre></td></tr></table></figure>
<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">    if (self.thread == nil) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">- (void)stopThread&#123;</div><div class="line">    self.shouldKeepRunning = NO;</div><div class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc&#123;</div><div class="line">    [self stop];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) __weakSelf = self;</div><div class="line">self.thread = [[FYThread alloc]initWithBlock:^&#123;</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">    NSLog(@&quot;--start--&quot;);</div><div class="line">    __weakSelf.shouldKeepRunning = YES;//默认运行</div><div class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</div><div class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">    &#125;;</div><div class="line">    NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>测试下崩溃了，崩溃到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (__weakSelf.shouldKeepRunning  )&#123;</div><div class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//log</div><div class="line"></div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">-[ViewController dealloc]</div><div class="line">--end--</div><div class="line">-[FYThread dealloc]</div></pre></td></tr></table></figure>
<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">runloop源码</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="external">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="external">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80" target="_blank" rel="external">thread保活c语言版本</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85" target="_blank" rel="external">thread 保活</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/" class="post-title-link" itemprop="url">iOS底层原理 runtime - super、hook、以及简单应用--(8)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:18:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:18:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:03:32" itemprop="dateModified" datetime="2019-12-03T13:03:32+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h3><p>关键字<code>super</code>,在调用<code>[super init]</code>的时候，<code>super</code>会转化成结构体<code>__rw_objc_super</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct __rw_objc_super &#123; </div><div class="line">	struct objc_object *object; //消息接受者</div><div class="line">	struct objc_object *superClass; //父类</div><div class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>[super init]</code>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m</code>转化成<code>cpp</code><br>打开<code>cpp</code>大概在底部的位置找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>
<p>简化之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(void *)objc_msgSendSuper((__rw_objc_super)&#123;self, class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>
<p><code>void
objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )</code><br>    其实是向父类发送消息，参数是<code>struct objc_super *super, SEL op, ...</code>，我们源码中找到了该函数的实现在<code>objc-msg-arm64.s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ENTRY _objc_msgSendSuper</div><div class="line">UNWIND _objc_msgSendSuper, NoFrame</div><div class="line">//根据结构体struct __rw_objc_super </div><div class="line">&#123; </div><div class="line">	//struct objc_object *object; //消息接受者</div><div class="line">	//struct objc_object *superClass; //父类</div><div class="line">&#125;占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，</div><div class="line">//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class="line">ldp	p0, p16, [x0]		// p0 = self , p16 = superclass</div><div class="line"></div><div class="line">CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</div><div class="line"></div><div class="line">END_ENTRY _objc_msgSendSuper</div></pre></td></tr></table></figure>
<p>将<code>self</code>和<code>superclass</code>赋值给 <code>p0, p16</code>调用<code>CacheLookup NORMAL</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class="line">	// p1 = SEL, p16 = isa</div><div class="line">	ldp	p10, p11, [x16, #CACHE]	// p10 = buckets, p11 = occupied|mask</div><div class="line">#if !__LP64__</div><div class="line">	and	w11, w11, 0xffff	// p11 = mask</div><div class="line">#endif</div><div class="line">	and	w12, w1, w11		// x12 = _cmd &amp; mask</div><div class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</div><div class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp 命中 调用或者返回imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket 没有命中</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// wrap: p12 = first bucket, w11 = mask</div><div class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class="line">		                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line"></div><div class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class="line">	// The slow path may detect any corruption and halt later.</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// double wrap</div><div class="line">	JumpMiss $0</div><div class="line">	</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>汇编比较多，只看到第二行<code>p1 = SEL, p16 = isa</code>，查找缓存是从<code>p16</code>,也就是<code>superclass</code>开始查找，后边的都和<code>objc_msgSend</code>一样。<br>大致上比较清楚了，<code>super</code>本质上调用了<code>objc_msgSendSuper</code>，<code>objc_msgSendSuper</code>是查找从父类开始查找方法。</p>
<p><code>[super init]</code>就是<code>self</code>直接调用父类<code>init</code>的方法，但是<code>objc_msgSend</code>接受者是<code>self</code>，假如是<code>[self init]</code>则会产生死循环。<code>[super test]</code>则是执行父类的<code>test</code>。<br>使用<code>Debug Workflow-&gt;Always Show Disassemdly</code>发现<code>super</code>其实调用了汇编的<code>objc_msgSendSuper2</code>，进入<code>objc_msgSendSuper2 objc-msg-arm64.s 422 行</code>发现和<code>objc_msgSendSuper</code>其实基本一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//_objc_msgSendSuper 开始</div><div class="line">	ENTRY _objc_msgSendSuper</div><div class="line">	UNWIND _objc_msgSendSuper, NoFrame</div><div class="line">//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class="line">	ldp	p0, p16, [x0]		// p0 = self , p16 = superclass</div><div class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</div><div class="line">	END_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束</div><div class="line">	</div><div class="line">//objc_msgLookupSuper2 开始</div><div class="line">	ENTRY _objc_msgSendSuper2 </div><div class="line">	UNWIND _objc_msgSendSuper2, NoFrame</div><div class="line"></div><div class="line">	ldp	p0, p16, [x0]		// p0 = real receiver, p16 = class</div><div class="line">	//将存储器地址为x16+8的字数据读入寄存器p16。</div><div class="line">	ldr	p16, [x16, #SUPERCLASS]	// p16 = class-&gt;superclass</div><div class="line">	CacheLookup NORMAL</div><div class="line">	END_ENTRY _objc_msgSendSuper2</div></pre></td></tr></table></figure>
<p>也可以使用<code>LLVM</code>转化成中间代码来查看，<code>clang -emit-llvm -S FYCat.m</code>查看关键函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define internal void @&quot;\01-[FYCat forwardInvocation:]&quot;(%1*, i8*, %2*) #1 &#123;</div><div class="line">    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是<code>forwardInvocation</code>函数的调用代码，简化之后是<code>objc_msgSendSuper2(self,struct._objc_super i8*,%2*)</code>，就是<code>objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)</code>。</p>
<p>验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">- (int)age;</div><div class="line">-(void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line">- (void)test&#123;</div><div class="line">    ;    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">- (int)age&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    return 10;</div><div class="line">&#125;</div><div class="line">- (NSString *)name&#123;</div><div class="line">    return [_name stringByAppendingString:@&quot; eat apple&quot;];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface FYStudent : FYPerson</div><div class="line"></div><div class="line">@end</div><div class="line">@implementation FYStudent</div><div class="line">- (void)test&#123;</div><div class="line">    [super test]; //执行父类的test</div><div class="line">    int age = [super age]; //获取父类的方法 返回值</div><div class="line">    NSLog(@&quot;age is %d&quot;,age);</div><div class="line">    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值</div><div class="line">    NSLog(@&quot;%@&quot;,name);</div><div class="line">&#125;</div><div class="line">-(int)age&#123;</div><div class="line">    return 12;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//输出</div><div class="line">-[FYPerson test]</div><div class="line">-[FYPerson age]</div><div class="line">age is 10</div><div class="line">小李子 eat apple</div></pre></td></tr></table></figure>
<p><code>test</code>是执行父类的方法，<code>[super age]</code>获取父类中固定的<code>age</code>,<br><code>[self name]</code>从父类开始寻找<code>name</code>的值，但返回的是<code>self.name</code>的值。</p>
<h3 id="isMemberOfClass-amp-isKindOfClass"><a href="#isMemberOfClass-amp-isKindOfClass" class="headerlink" title="isMemberOfClass &amp;  isKindOfClass"></a>isMemberOfClass &amp;  isKindOfClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return object_getClass((id)self) == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        printf(&quot;%s %s\n&quot;,class_getName(tcls),class_getName(cls));</div><div class="line">        if (tcls == cls)</div><div class="line">        &#123;return YES;&#125;else&#123;</div><div class="line">            printf(&quot;%s&quot;,class_getName(tcls));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        </div><div class="line">        printf(&quot; %s %s\n&quot;,class_getName(tcls),class_getName(cls));</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isSubclassOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>- (BOOL)isMemberOfClass</code>和<code>- (BOOL)isKindOfClass:(Class)cls</code>比较简单，都是判断<code>self.class</code> 和<code>cls</code>，<code>+ (BOOL)isMemberOfClass:(Class)cls</code>是判断<code>self.class-&gt;isa</code>是否和<code>cls</code>相等，<code>+ (BOOL)isKindOfClass:(Class)cls</code>判断<code>cls-&gt;isa</code>和<code>cls-&gt;isa-&gt;isa</code>有没有可能和<code>cls</code>相等？只有基类是，其他的都不是。</p>
<h4 id="验证-实例方法"><a href="#验证-实例方法" class="headerlink" title="验证 实例方法"></a>验证 实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Class cls = NSObject.class;</div><div class="line">Class pcls = FYPerson.class;</div><div class="line">FYPerson *p=[FYPerson new];</div><div class="line">NSObject *obj=[NSObject new];</div><div class="line">BOOL res11 =[p isKindOfClass:pcls];</div><div class="line">BOOL res12 =[p isMemberOfClass:pcls];</div><div class="line">BOOL res13 =[obj isKindOfClass:cls];</div><div class="line">BOOL res14 =[obj isMemberOfClass:cls];</div><div class="line">NSLog(@&quot;instance:%d %d %d %d&quot;,res11,res12,res13,res14);</div><div class="line">//log</div><div class="line">//instance:1 1 1 1</div></pre></td></tr></table></figure>
<p><code>p</code>是<code>pcls</code>的子类，<code>obj</code> 是<code>cls</code>的子类，在明显不过了。</p>
<h4 id="验证-类方法"><a href="#验证-类方法" class="headerlink" title="验证 类方法"></a>验证 类方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//isKindOfClass cls-&gt;isa 和cls/cls-&gt;superclass相等吗?</div><div class="line">//元类对象和类对象不相等，但是最后一个元类的isa-&gt;superclass是指向NSObject的class 所以res1 = YES;</div><div class="line">//cls-&gt;isa:元类对象 cls-&gt;isa-&gt;superclass: NSObject类对象</div><div class="line">//cls:类对象</div><div class="line">BOOL res1 =[cls isKindOfClass:cls];</div><div class="line">//cls-&gt;isa 和cls相等吗？ 不相等 cls-&gt;isa是元类对象,cls是类对象，不可能相等。</div><div class="line">BOOL res2 =[cls isMemberOfClass:cls];</div><div class="line">//pcls-&gt;isa:person的元类对象 cls-&gt;isa-&gt;superclass: NSObject元类类对象 -&gt;superclass:NSObject类对象 -&gt;superclass:nil</div><div class="line">//pcls:person类对象</div><div class="line">BOOL res3 =[pcls isKindOfClass:pcls];</div><div class="line">//pcls-&gt;isa:person的元类对象</div><div class="line">//pcls:person类对象</div><div class="line">BOOL res4 =[pcls isMemberOfClass:pcls];</div><div class="line">NSLog(@&quot;%d %d %d %d&quot;,res1,res2,res3,res4);</div><div class="line">结果：</div><div class="line">1 0 0 0</div></pre></td></tr></table></figure>
<h3 id="堆栈-对象本质-class本质实战"><a href="#堆栈-对象本质-class本质实战" class="headerlink" title="堆栈 对象本质 class本质实战"></a>堆栈 对象本质 class本质实战</h3><p>网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。<br>其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文<a href="https://juejin.im/post/5d2d200be51d4510a7328161" target="_blank" rel="external">obj_msgsend基础</a>、<a href="https://juejin.im/post/5d19c59e6fb9a07f04205f95" target="_blank" rel="external">类的本质</a>、<a href="https://juejin.im/post/5d15887ee51d45108126d28d" target="_blank" rel="external">对象的本质</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">- (void)print;</div><div class="line">@end</div><div class="line">@implementation FYPerson</div><div class="line">- (void)print&#123;</div><div class="line">    NSLog(@&quot;my name is %@&quot;,self.name);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030</div><div class="line">    id cls  = [FYPerson class];针</div><div class="line">    void * obj = &amp;cls; </div><div class="line">    [(__bridge id)obj print];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="问题一-能否编译成功？"><a href="#问题一-能否编译成功？" class="headerlink" title="问题一 能否编译成功？"></a>问题一 能否编译成功？</h4><p>当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有<code>id self</code>和<code>SEL sel</code>，现在<code>cls</code>和<code>obj</code>都在栈区，<code>obj</code> 指针指向<code>cls</code>的内存地址，访问<code>obj</code>相当于直接访问<code>cls</code>内存存储的值，<code>cls</code>存储的是<code>Person.class</code>,<code>[obj print]</code> 相当于<code>objc_msgSend(cls,@selector(print))</code>,<code>cls</code>是有<code>print</code>方法的，所以会编译成功。</p>
<h4 id="输出什么？"><a href="#输出什么？" class="headerlink" title="输出什么？"></a>输出什么？</h4><p><code>fix/cls/obj</code>这三个对象都是存储在栈上，<code>fix/cls/obj</code>地址是连续从高到低的，而且他们地址相差都是<code>8</code>字节，一个指针大小是<code>8</code>字节。他们三个地址如下所示：</p>
<p>使用图来表示<code>fix</code>和<code>obj</code>：<br>|对象|地址|地址高低|<br>|:-:|:-:|:-:|:-:|<br>|fix|0x7ffeec3df920| 高 |<br>|cls|0x7ffeec3df918|中|<br>|obj|0x7ffeec3df910|低|</p>
<p>寻找属性先是寻找<code>isa</code>，然后再在<code>isa</code>地址上+<code>8</code>则是属性的值，所以根据<code>obj</code>寻找<code>cls</code>地址是<code>0x7ffeec3df918</code>,然后<code>cls</code>地址+8字节则是<code>_name</code>的地址，<code>cls</code>地址是<code>0x7ffeec3df918</code>，加上<code>8</code>字节正好是<code>fix</code>的地址<code>0x7ffeec3df920</code>，因为都是指针，所以都是<code>8</code>字节,所以最后输出是结果是<code>fix</code>对象的地址的数据。</p>
<p>情况再复杂一点，<code>FYPerson</code>结构改动一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic,copy) NSString *name2;</div><div class="line">@property (nonatomic,copy) NSString *name3;</div><div class="line">- (void)print;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>则他们的<code>_name</code>、<code>_name2</code>、<code>_name3</code>则在<code>cls</code>的地址基础上再向上寻找<code>8*1=8/8*2=16/8*3=24</code>字节，就是向上寻找第1个，第2个，第3个指向对象的指针。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic,copy) NSString *name2;</div><div class="line">@property (nonatomic,copy) NSString *name3;</div><div class="line">- (void)print;</div><div class="line">@end</div><div class="line">@implementation FYPerson</div><div class="line">- (void)print&#123;</div><div class="line">    NSLog(@&quot;name1:%@ name2:%@ name3:%@&quot;,self.name1,self.name2,self.name3);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">//主函数</div><div class="line"></div><div class="line">NSObject *fix =[NSObject new];</div><div class="line">FYPerson *fix2 =[FYPerson new];</div><div class="line"></div><div class="line">id cls  = [FYPerson class];</div><div class="line">void * obj = &amp;cls; </div><div class="line">[(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class="line">NSLog(@&quot;fix:%p fix2:%p cls:%p obj:%p&quot;,&amp;fix,&amp;fix2,&amp;cls,&amp;obj);</div><div class="line"></div><div class="line">//log</div><div class="line">name1:&lt;FYPerson: 0x6000033a38a0&gt; </div><div class="line">name2:&lt;NSObject: 0x6000031f5380&gt; </div><div class="line">name3:&lt;ViewController: 0x7f8307505580&gt;</div><div class="line"></div><div class="line">fix: 0x7ffeec3d f9 28 </div><div class="line">fix2:0x7ffeec3d f9 20 </div><div class="line">cls: 0x7ffeec3d f9 18 </div><div class="line">obj: 0x7ffeec3d f9 10</div></pre></td></tr></table></figure>
<p>再变形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	/*</div><div class="line">	 objc_msgSuperSend(self,ViewController,sel)</div><div class="line">	 */</div><div class="line">NSLog(@&quot;self:%p ViewController.class:%p SEL:%p&quot;,self,ViewController.class,@selector(viewDidLoad));</div><div class="line">    id cls  = [FYPerson class];//cls 是类指针</div><div class="line">    void * obj = &amp;cls; //obj </div><div class="line">    [(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class="line">    </div><div class="line"> NSLog(@&quot;cls:%p obj:%p&quot;,&amp;cls,&amp;obj);</div><div class="line"> //log</div><div class="line"> </div><div class="line"> name1:&lt;ViewController: 0x7fad03e04ea0&gt; </div><div class="line"> name2:ViewController</div><div class="line"> </div><div class="line"> self:                  0x7fad03e04ea0 </div><div class="line"> ViewController.class:  0x10d0edf00 </div><div class="line"> SEL:                   0x1117d5687</div><div class="line"> </div><div class="line"> cls:0x7ffee2b11908 </div><div class="line"> obj:0x7ffee2b11900</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_name1</code>是<code>cls</code>地址向上+8字节，<code>_name2</code>是向上移动16字节，<code>[super viewDidLoad]</code>本质上是<code>objc_msgSuperSend(self,ViewController.class,sel)</code>，<code>self</code>、<code>ViewController.class</code>、<code>SEL</code>是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，<br>结构体如下图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">地址高低</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">self</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">ViewController.class</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:center">SEL</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
<h3 id="常用的runtimeAPI"><a href="#常用的runtimeAPI" class="headerlink" title="常用的runtimeAPI"></a>常用的runtimeAPI</h3><table>
<thead>
<tr>
<th style="text-align:center">method</th>
<th style="text-align:center">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</td>
<td style="text-align:center">动态创建一个类（参数：父类，类名，额外的内存空间</td>
</tr>
<tr>
<td style="text-align:center">void objc_registerClassPair(Class cls))</td>
<td style="text-align:center">注册一个类</td>
</tr>
<tr>
<td style="text-align:center">void objc_disposeClassPair(Class cls)</td>
<td style="text-align:center">销毁一个类</td>
</tr>
<tr>
<td style="text-align:center">Class objcect_getClass(id obj)</td>
<td style="text-align:center">获取isa指向的class</td>
</tr>
<tr>
<td style="text-align:center">Class object_setClass (id obj,Class cls)</td>
<td style="text-align:center">设置isa指向的class</td>
</tr>
<tr>
<td style="text-align:center">BOOL object_isClass(id class)</td>
<td style="text-align:center">判断oc对象是否为Class</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_isMetaClass(Class cls)</td>
<td style="text-align:center">是否是元类</td>
</tr>
<tr>
<td style="text-align:center">Class class_getSuperclass(Class cls)</td>
<td style="text-align:center">获取父类</td>
</tr>
<tr>
<td style="text-align:center">Ivar class_getInstanceVariable(Class cls ,const char * name</td>
<td style="text-align:center">获取一个实例变量信息</td>
</tr>
<tr>
<td style="text-align:center">Ivar <em> class_copyIvarList(Class cls,unsigned int </em> outCount)</td>
<td style="text-align:center">拷贝实例变量列表，需要free</td>
</tr>
<tr>
<td style="text-align:center">void object_setIvar(id obj,Ivar ivar,id value</td>
<td style="text-align:center">设置获取实例变量的值</td>
</tr>
<tr>
<td style="text-align:center">id object_getIvar(id obj,Ivar ivar)</td>
<td style="text-align:center">获取实例变量的值</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_addIvar(Class cls,const cahr <em> name ,size_t size,uint_t alignment,const char </em> types)</td>
<td style="text-align:center">动态添加成员变量（已注册的类不能动态添加成员变量）</td>
</tr>
<tr>
<td style="text-align:center">const char * ivar_getName（Ivar v)</td>
<td style="text-align:center">获取变量名字</td>
</tr>
<tr>
<td style="text-align:center">const char * ivar_getTypeEncoding(Ivar v)</td>
<td style="text-align:center">变量的encode</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t class_getProperty(Class cls,const char* name)</td>
<td style="text-align:center">获取一个属性</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t _Nonnull <em> _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)</td>
<td style="text-align:center">拷贝属性列表</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)</td>
<td style="text-align:center">获取属性列表</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_addProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes,unsigned int attributeCount)</td>
<td style="text-align:center">添加属性</td>
</tr>
<tr>
<td style="text-align:center">void class_replaceProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes, unsigned int attributeCount)</td>
<td style="text-align:center">替换属性</td>
</tr>
<tr>
<td style="text-align:center">void class_replaceProperty(Class cls, const char <em>name, const objc_property_attribute_t </em>attributes,unsigned int attributeCount)</td>
<td style="text-align:center">动态替换属性</td>
</tr>
<tr>
<td style="text-align:center">const char * _Nonnull property_getName(objc_property_t _Nonnull property)</td>
<td style="text-align:center">获取name</td>
</tr>
<tr>
<td style="text-align:center">const char * _Nullable property_getAttributes(objc_property_t _Nonnull property)</td>
<td style="text-align:center">获取属性的属性</td>
</tr>
<tr>
<td style="text-align:center">IMP imp_implementationWithBlock(id block)</td>
<td style="text-align:center">获取block的IMP</td>
</tr>
<tr>
<td style="text-align:center">id imp_getBlock(IMP anIMP)</td>
<td style="text-align:center">通过imp 获取block</td>
</tr>
<tr>
<td style="text-align:center">BOOL imp_removeBlock(IMP anIMP)</td>
<td style="text-align:center">IMP是否被删除</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们<br>获取<code>class</code>的所有成员变量,可以获取<code>Ivar</code>查看是否有该变量，然后可以通过<code>KVC</code>来赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface FYCat : NSObject</div><div class="line">@property (nonatomic,copy) NSString * name;</div><div class="line">@property (nonatomic,assign) int  age;</div><div class="line">@end</div><div class="line"></div><div class="line">FYCat *cat=[FYCat new];</div><div class="line">unsigned int count = 0;</div><div class="line">Ivar *vars= class_copyIvarList(cat.class, &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">	Ivar item = vars[i];</div><div class="line">	const char *name = ivar_getName(item);</div><div class="line">	NSLog(@&quot;%s&quot;,name);</div><div class="line">&#125;</div><div class="line">free(vars);</div><div class="line"></div><div class="line">Method *m1= class_copyMethodList(cat.class, &amp;count);</div><div class="line">for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">	Method item = m1[i];</div><div class="line">	SEL name = method_getName(item);</div><div class="line">	printf(&quot;method:%s \n&quot;,NSStringFromSelector(name).UTF8String);</div><div class="line">&#125;</div><div class="line">free(m1);</div><div class="line">		</div><div class="line">//log</div><div class="line">_age</div><div class="line">_name</div><div class="line"></div><div class="line">method:.cxx_destruct </div><div class="line">method:name </div><div class="line">method:setName: </div><div class="line">method:methodSignatureForSelector: </div><div class="line">method:forwardInvocation: </div><div class="line">method:age </div><div class="line">method:setAge:</div></pre></td></tr></table></figure>
<p>大家常用的一个功能是<code>JsonToModel</code>，那么我们已经了解到了<code>runtime</code>的基础知识，现在可以自己撸一个<code>JsonToModel</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (Json)</div><div class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json;</div><div class="line">@end</div><div class="line">@implementation NSObject (Json)</div><div class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json&#123;</div><div class="line">	id obj = [[self alloc]init];</div><div class="line">	unsigned int count = 0;</div><div class="line">	Ivar *vars= class_copyIvarList(self, &amp;count);</div><div class="line">	for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">		Ivar item = vars[i];</div><div class="line">		const char *name = ivar_getName(item);</div><div class="line">		NSString * nameOC= [NSString stringWithUTF8String:name];</div><div class="line">		if (nameOC.length&gt;1) &#123;</div><div class="line">			nameOC = [nameOC substringFromIndex:1];</div><div class="line">			NSString * value = json[nameOC];</div><div class="line">			if ([value isKindOfClass:NSString.class] &amp;&amp; value.length) &#123;</div><div class="line">				[obj setValue:value forKey:nameOC];</div><div class="line">			&#125;else if ([value isKindOfClass:NSArray.class])&#123;</div><div class="line">				[obj setValue:value forKey:nameOC];</div><div class="line">			&#125;else if ([value isKindOfClass:NSDictionary.class])&#123;</div><div class="line">				[obj setValue:value forKey:nameOC];</div><div class="line">			&#125;else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])</div><div class="line">			&#123;</div><div class="line">				printf(&quot;%s value is nil or null \n&quot;,name);</div><div class="line">			&#125;else if ([value integerValue] &gt; 0)&#123;</div><div class="line">				[obj setValue:value forKey:nameOC];</div><div class="line">			&#125;else&#123;</div><div class="line">				printf(&quot;未知错误 \n&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	free(vars);</div><div class="line">	return obj;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后自己定义一个字典，来测试一下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface FYCat : NSObject</div><div class="line">@property (nonatomic,copy) NSString * name;</div><div class="line">@property (nonatomic,assign) int  age;</div><div class="line"></div><div class="line">- (void)run;</div><div class="line">@end</div><div class="line"></div><div class="line">NSDictionary * info = @&#123;@&quot;age&quot;:@&quot;10&quot;,@&quot;value&quot;:@10,@&quot;name&quot;:@&quot;小明&quot;&#125;;</div><div class="line">		FYCat *cat=[FYCat fy_objectWithJson:info];</div><div class="line">//log</div><div class="line">age:10 name:小明</div></pre></td></tr></table></figure>
<h4 id="hook钩子-method-exchangeImplementations"><a href="#hook钩子-method-exchangeImplementations" class="headerlink" title="hook钩子(method_exchangeImplementations)"></a>hook钩子(method_exchangeImplementations)</h4><p>由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@implementation UIButton (add)</div><div class="line">+ (void)load&#123;</div><div class="line">	Method m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));</div><div class="line">	Method m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));</div><div class="line">	static dispatch_once_t onceToken;</div><div class="line">	dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">		method_exchangeImplementations(m1, m2);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%@ &quot;,NSStringFromSelector(action));</div><div class="line">	/*</div><div class="line">	 code here</div><div class="line">	 */</div><div class="line">	 //sel IMP 已经交换过了，所以不会死循环</div><div class="line">	[self fy_sendAction:action to:target forEvent:event];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可以在<code>code here</code>添加需要处理的代码，一般记录日志和延迟触发都可以处理。<code>[self fy_sendAction:action to:target forEvent:event];</code>不会产生死循环，原因是在<code>+load</code>中已经将<code>m1</code>和<code>m2</code>已经交换过了<code>IMP</code>。我们进入到<code>method_exchangeImplementations</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void method_exchangeImplementations(Method m1, Method m2)</div><div class="line">&#123;</div><div class="line">    if (!m1  ||  !m2) return;</div><div class="line"></div><div class="line">    mutex_locker_t lock(runtimeLock);</div><div class="line"></div><div class="line">//交换IMP</div><div class="line">    IMP m1_imp = m1-&gt;imp;</div><div class="line">    m1-&gt;imp = m2-&gt;imp;</div><div class="line">    m2-&gt;imp = m1_imp;</div><div class="line"></div><div class="line">//刷新缓存</div><div class="line">    flushCaches(nil);</div><div class="line"></div><div class="line">    updateCustomRR_AWZ(nil, m1);</div><div class="line">    updateCustomRR_AWZ(nil, m2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct method_t &#123;</div><div class="line">    SEL name;</div><div class="line">    const char *types;</div><div class="line">    MethodListIMP imp;</div><div class="line">&#125;;</div><div class="line">using MethodListIMP = IMP;</div></pre></td></tr></table></figure>
<p><code>m1</code>和<code>m2</code>交换了<code>IMP</code>，交换的是<code>method_t-&gt;imp</code>，然后刷新缓存(清空缓存)，等下次调用<code>IMP</code>则需要在<code>cls-&gt;rw-&gt;data-&gt;method</code>中去寻找。</p>
<h4 id="数组越界和nil处理"><a href="#数组越界和nil处理" class="headerlink" title="数组越界和nil处理"></a>数组越界和nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">@implementation NSMutableArray (add)</div><div class="line">+ (void)load&#123;</div><div class="line">	Class cls= NSClassFromString(@&quot;__NSArrayM&quot;);</div><div class="line">	Method m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</div><div class="line">	SEL sel = @selector(fy_insertObject:atIndex:);</div><div class="line">	Method m2= class_getInstanceMethod(cls, sel);</div><div class="line">	</div><div class="line">	Method m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));</div><div class="line">	Method m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));</div><div class="line"></div><div class="line">	static dispatch_once_t onceToken;</div><div class="line">	dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">		method_exchangeImplementations(m1, m2);</div><div class="line">		method_exchangeImplementations(m3, m4);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index&#123;</div><div class="line">	if (anObject != nil) &#123;</div><div class="line">		[self fy_insertObject:anObject atIndex:index];</div><div class="line">	&#125;else&#123;</div><div class="line">		printf(&quot; anObject is nil \n&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx&#123;</div><div class="line">	if (self.count &gt; idx) &#123;</div><div class="line">		return [self fy_objectAtIndexedSubscript:idx];</div><div class="line">	&#125;else&#123;</div><div class="line">		printf(&quot; %ld is outof rang \n&quot;,(long)idx);</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">NSMutableArray *array=[NSMutableArray array];</div><div class="line">id obj = nil;</div><div class="line">[array addObject:obj];</div><div class="line">array[1];</div><div class="line"></div><div class="line">//log</div><div class="line"> anObject is nil </div><div class="line"> 1 is outof rang</div></pre></td></tr></table></figure>
<p><code>NSMutableArray</code>是类簇，使用工厂模式，<code>NSMutableArray</code>不是数组实例，而是生产数组对象的工厂。<br>真实的数组对象是<code>__NSArrayM</code>,然后给<code>__NSArrayM</code>钩子，交换<code>objectAtIndexedSubscript:(NSUInteger)idx</code>和<code>insertObject:(id)anObject atIndex:(NSUInteger)index</code>方法，实现崩溃避免。</p>
<h4 id="字典nil处理"><a href="#字典nil处理" class="headerlink" title="字典nil处理"></a>字典nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@interface NSMutableDictionary (add)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSMutableDictionary (add)</div><div class="line">+ (void)load&#123;</div><div class="line">    Class cls= NSClassFromString(@&quot;__NSDictionaryM&quot;);</div><div class="line">    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));</div><div class="line">//    __NSDictionaryM</div><div class="line">    SEL sel = @selector(fy_setObject:forKey:);</div><div class="line">    Method m2= class_getInstanceMethod(cls, sel);</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        method_exchangeImplementations(m1, m2);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">- (void)fy_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey&#123;</div><div class="line">    if (anObject) &#123;</div><div class="line">        [self fy_setObject:anObject forKey:aKey];</div><div class="line">    &#125;else&#123;</div><div class="line">        NSString * key = (NSString *)aKey;</div><div class="line">        printf(&quot;key:%s anobj is nil \n&quot;,key.UTF8String);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>利用类别<code>+load</code>给<code>__NSDictionaryM</code>添加方法，然后交换<code>IMP</code>，实现给<code>NSMutableDictionary setObject:Key:</code>的时候进行<code>nil</code>校验,<code>+load</code>虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成<code>IMP</code>和<code>SEL</code>混乱，使用<code>dispatch_once</code>进行单次运行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><code>super</code>本质上是<code>self</code>调用函数，不过查找函数是从<code>sueprclass</code>开始查找的</li>
<li><code>+isKandOfClass</code>是判断<code>self</code>是否是<code>cls</code>的子类，<code>+isMemberOfClass:</code>是判断<code>self</code>是否和<code>cls</code>相同。</li>
<li>了解<code>+load</code>在<code>Category</code>是启动的时候使用运行时编译的，而且只会加载一次,然后利用<code>objc/runtime.h</code>中<code>method_exchangeImplementations</code>实现交换两个函数的<code>IMP</code>，可以实现拦截<code>nil</code>，降低崩溃率。</li>
<li><code>NSMutableDictionary</code>、<code>NSMutableArray</code>是类簇，先找到他们的类然后再交换该类的函数的<code>IMP</code>。</li>
</ol>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="external">小码哥视频</a></li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/" class="post-title-link" itemprop="url">iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:17:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:17:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:03:16" itemprop="dateModified" datetime="2019-12-03T13:03:16+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ol>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">objc-msg-arm64.s</div><div class="line">ENTRY _objc_msgSend</div><div class="line">b.le	LNilOrTagged //&lt;0则返回</div><div class="line">CacheLookup NORMAL //缓存查找 未命中则继续查找</div><div class="line">.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp</div><div class="line">.macro CheckMiss //miss 则跳转__objc_msgSend_uncached</div><div class="line">STATIC_ENTRY __objc_msgSend_uncached </div><div class="line">.macro MethodTableLookup//方法中查找</div><div class="line">__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class="line"></div><div class="line"></div><div class="line">objc-runtime-new.mm</div><div class="line">_class_lookupMethodAndLoadCache3</div><div class="line">lookUpImpOrForward</div><div class="line">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</div><div class="line">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</div><div class="line">_class_resolveInstanceMethod</div><div class="line">_objc_msgForward_impcache</div><div class="line"></div><div class="line"></div><div class="line">objc-msg-arm64.s</div><div class="line">STATIC_ENTRY __objc_msgForward_impcache</div><div class="line">ENTRY __objc_msgForward</div><div class="line"></div><div class="line">Core Foundation</div><div class="line">__forwarding__（不开源）</div></pre></td></tr></table></figure>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">	ENTRY _objc_msgSend // _objc_msgSend 开始</div><div class="line">	UNWIND _objc_msgSend, NoFrame</div><div class="line"></div><div class="line">	cmp	p0, #0			// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">	b.le	LNilOrTagged		// if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</div><div class="line">#else</div><div class="line">	b.eq	LReturnZero // if le == 0 -&gt;  跳转到标签  LReturnZero</div><div class="line">#endif</div><div class="line">	ldr	p13, [x0]		// p13 = isa</div><div class="line">	GetClassFromIsa_p16 p13		// p16 = class</div><div class="line">LGetIsaDone:</div><div class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</div><div class="line"></div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">LNilOrTagged:</div><div class="line">	b.eq	LReturnZero		// 如果==0 -&gt; LReturnZero</div><div class="line"></div><div class="line">	// tagged</div><div class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</div><div class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</div><div class="line">	ubfx	x11, x0, #60, #4</div><div class="line">	ldr	x16, [x10, x11, LSL #3]</div><div class="line">	adrp	x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</div><div class="line">	add	x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</div><div class="line">	cmp	x10, x16</div><div class="line">	b.ne	LGetIsaDone</div><div class="line"></div><div class="line">	// ext tagged</div><div class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</div><div class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</div><div class="line">	ubfx	x11, x0, #52, #8</div><div class="line">	ldr	x16, [x10, x11, LSL #3]</div><div class="line">	b	LGetIsaDone</div><div class="line">// SUPPORT_TAGGED_POINTERS</div><div class="line">#endif</div><div class="line"></div><div class="line">LReturnZero:</div><div class="line">	// x0 is already zero</div><div class="line">	mov	x1, #0</div><div class="line">	movi	d0, #0</div><div class="line">	movi	d1, #0</div><div class="line">	movi	d2, #0</div><div class="line">	movi	d3, #0</div><div class="line">	ret //return 返回结束掉</div><div class="line"></div><div class="line">	END_ENTRY _objc_msgSend // _objc_msgSend 结束</div></pre></td></tr></table></figure>
<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class="line">	// p1 = SEL, p16 = isa</div><div class="line">	ldp	p10, p11, [x16, #CACHE]	// p10 = buckets, p11 = occupied|mask</div><div class="line">#if !__LP64__</div><div class="line">	and	w11, w11, 0xffff	// p11 = mask</div><div class="line">#endif</div><div class="line">	and	w12, w1, w11		// x12 = _cmd &amp; mask</div><div class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</div><div class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp 命中 调用或者返回imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket 没有命中</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// wrap: p12 = first bucket, w11 = mask</div><div class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class="line">		                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line"></div><div class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class="line">	// The slow path may detect any corruption and halt later.</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// double wrap</div><div class="line">	JumpMiss $0</div><div class="line">	</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.macro CheckMiss</div><div class="line">	// miss if bucket-&gt;sel == 0</div><div class="line">.if $0 == GETIMP</div><div class="line">	cbz	p9, LGetImpMiss</div><div class="line">.elseif $0 == NORMAL</div><div class="line">	cbz	p9, __objc_msgSend_uncached</div><div class="line">.elseif $0 == LOOKUP</div><div class="line">	cbz	p9, __objc_msgLookup_uncached</div><div class="line">.else</div><div class="line">.abort oops</div><div class="line">.endif</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">STATIC_ENTRY __objc_msgSend_uncached</div><div class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class="line">MethodTableLookup</div><div class="line">TailCallFunctionPointer x17</div><div class="line">END_ENTRY __objc_msgSend_uncached</div></pre></td></tr></table></figure>
<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line">	// push frame</div><div class="line">	SignLR</div><div class="line">	stp	fp, lr, [sp, #-16]!</div><div class="line">	mov	fp, sp</div><div class="line"></div><div class="line">	// save parameter registers: x0..x8, q0..q7</div><div class="line">	sub	sp, sp, #(10*8 + 8*16)</div><div class="line">	stp	q0, q1, [sp, #(0*16)]</div><div class="line">	stp	q2, q3, [sp, #(2*16)]</div><div class="line">	stp	q4, q5, [sp, #(4*16)]</div><div class="line">	stp	q6, q7, [sp, #(6*16)]</div><div class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">	str	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">	// receiver and selector already in x0 and x1</div><div class="line">	mov	x2, x16</div><div class="line">	bl	__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class="line"></div><div class="line">	// IMP in x0</div><div class="line">	mov	x17, x0</div><div class="line">	</div><div class="line">	// restore registers and return</div><div class="line">	ldp	q0, q1, [sp, #(0*16)]</div><div class="line">	ldp	q2, q3, [sp, #(2*16)]</div><div class="line">	ldp	q4, q5, [sp, #(4*16)]</div><div class="line">	ldp	q6, q7, [sp, #(6*16)]</div><div class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">	ldr	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">	mov	sp, fp</div><div class="line">	ldp	fp, lr, [sp], #16</div><div class="line">	AuthenticateLR</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* lookUpImpOrForward.</div><div class="line">* initialize==NO 尽量避免调用，有时可能也会调用。</div><div class="line">* cache==NO 跳过缓存查找，其他地方可能会不调过</div><div class="line">* 大多数人会传值 initialize==YES and cache==YES</div><div class="line">*   如果cls是非初始化的元类，则非Non-nil会快点</div><div class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class="line">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</div><div class="line">**********************************************************************/</div><div class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class="line">                       bool initialize, bool cache, bool resolver)</div><div class="line">&#123;</div><div class="line">    IMP imp = nil;</div><div class="line">    bool triedResolver = NO;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    // Optimistic cache lookup</div><div class="line">    if (cache) &#123; //从汇编过来是NO</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        if (imp) return imp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.lock();</div><div class="line">    checkIsKnownClass(cls);</div><div class="line"></div><div class="line">    if (!cls-&gt;isRealized()) &#123;</div><div class="line">        realizeClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">		//当cls需要初始化和没有初始化的时候 进行cls初始化，</div><div class="line">		//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</div><div class="line">		//数据的大小最小是4，扩容规则是：n*2+1;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">        runtimeLock.lock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line"> retry:    </div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">//再次获取imp</div><div class="line">    imp = cache_getImp(cls, sel);</div><div class="line">    if (imp) goto done;</div><div class="line"></div><div class="line">    //尝试在本类中查找method</div><div class="line">    &#123;//从cls-&gt;data()-&gt;methods查找method</div><div class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">        if (meth) &#123;//找到添加到cache中</div><div class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Try superclass caches and method lists.</div><div class="line">	//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</div><div class="line">    &#123;</div><div class="line">        unsigned attempts = unreasonableClassCount();</div><div class="line">        for (Class curClass = cls-&gt;superclass;</div><div class="line">             curClass != nil;</div><div class="line">             curClass = curClass-&gt;superclass)</div><div class="line">        &#123;</div><div class="line">            // Halt if there is a cycle in the superclass chain.</div><div class="line">            if (--attempts == 0) &#123;</div><div class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass cache.</div><div class="line">            imp = cache_getImp(curClass, sel);</div><div class="line">            if (imp) &#123;</div><div class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">                    // Found the method in a superclass. Cache it in this class.</div><div class="line">					//将父类添加到 子类的缓存中</div><div class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">                    goto done;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    // Found a forward:: entry in a superclass.</div><div class="line">                    // Stop searching, but don&apos;t cache yet; call method </div><div class="line">                    // resolver for this class first.</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass method list.</div><div class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">            if (meth) &#123;</div><div class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">                imp = meth-&gt;imp;</div><div class="line">                goto done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//如果还没有找到imp，进入动态方法解析阶段</div><div class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_resolveMethod(cls, sel, inst);</div><div class="line">        runtimeLock.lock();</div><div class="line">        triedResolver = YES;</div><div class="line">        goto retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果没找到resolveInstanceMethod 和resolveClassMethod，</div><div class="line">//	进行消息转发 阶段</div><div class="line">    imp = (IMP)_objc_msgForward_impcache;</div><div class="line">	//填充 cache</div><div class="line">    cache_fill(cls, sel, imp, inst);</div><div class="line"> done:</div><div class="line">    runtimeLock.unlock();</div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </div><div class="line">// field as an index into a class table.</div><div class="line">// Note, keep this in sync with any .s files which also define it.</div><div class="line">// Be sure to edit objc-abi.h as well.</div><div class="line">// __ARM_ARCH_7K__ 处理器架构指令集版本</div><div class="line">//__arm64__ 架构</div><div class="line">//__LP64__ uinx 和uinx  mac os</div><div class="line">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</div><div class="line">#   define SUPPORT_INDEXED_ISA 1</div><div class="line">#else</div><div class="line">#   define SUPPORT_INDEXED_ISA 0</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>
<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>
<p>借用网上找一个图， 可以更直观的看出流程运转。</p>
<p><img src="../images/7-1.png" alt=""></p>
<h4 id="realizeClass-解析"><a href="#realizeClass-解析" class="headerlink" title="realizeClass()解析"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* realizeClass</div><div class="line"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</div><div class="line"> runtimelock 必须有调用者把写入锁锁起来</div><div class="line">**********************************************************************/</div><div class="line">static Class realizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line">    class_rw_t *rw;</div><div class="line">    Class supercls;</div><div class="line">    Class metacls;</div><div class="line">    bool isMeta;</div><div class="line"></div><div class="line">    if (!cls) return nil;</div><div class="line">    if (cls-&gt;isRealized()) return cls;</div><div class="line">    assert(cls == remapClass(cls));</div><div class="line"></div><div class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class="line">//首先将tw赋值给to，因为数据结构一样可以直接强制转化</div><div class="line">    ro = (const class_ro_t *)cls-&gt;data();</div><div class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</div><div class="line">        rw = cls-&gt;data();</div><div class="line">        ro = cls-&gt;data()-&gt;ro;</div><div class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 正常情况下 申请class_rw_t空间</div><div class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class="line">        rw-&gt;ro = ro;//cls-&gt;rw-&gt;ro 指向现在的ro</div><div class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1</div><div class="line">        cls-&gt;setData(rw);//赋值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isMeta = ro-&gt;flags &amp; RO_META;//是否是元类</div><div class="line">	</div><div class="line"></div><div class="line">    rw-&gt;version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0</div><div class="line"></div><div class="line"></div><div class="line">    // Choose an index for this class.</div><div class="line">//设置cls的索引</div><div class="line">	cls-&gt;chooseClassArrayIndex();</div><div class="line"></div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        _objc_inform(&quot;CLASS: realizing class &apos;%s&apos;%s %p %p #%u&quot;, </div><div class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </div><div class="line">                     (void*)cls, ro, cls-&gt;classArrayIndex());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果父类没有初始化则进行初始化</div><div class="line">    // root_class 做完需要设置RW_REALIZED=1，</div><div class="line">    // root metaclasses 需要执行完.</div><div class="line">	//从NXMapTable 获取cls ，然后进行初始化</div><div class="line">	//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</div><div class="line">    supercls = realizeClass(remapClass(cls-&gt;superclass));</div><div class="line">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</div><div class="line">//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。</div><div class="line">#if SUPPORT_NONPOINTER_ISA</div><div class="line">    // Disable non-pointer isa for some classes and/or platforms.</div><div class="line">    // Set instancesRequireRawIsa.</div><div class="line">    bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</div><div class="line">    bool rawIsaIsInherited = false;</div><div class="line">    static bool hackedDispatch = false;</div><div class="line"></div><div class="line">    if (DisableNonpointerIsa) &#123;</div><div class="line">        // Non-pointer isa disabled by environment or app SDK version</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">    &#125;</div><div class="line">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </div><div class="line">             0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)) </div><div class="line">    &#123;</div><div class="line">        // hack for libdispatch et al - isa also acts as vtable pointer</div><div class="line">        hackedDispatch = true;</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">    &#125;</div><div class="line">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </div><div class="line">             supercls-&gt;instancesRequireRawIsa()) </div><div class="line">    &#123;</div><div class="line">        // This is also propagated by addSubclass() </div><div class="line">        // but nonpointer isa setup needs it earlier.</div><div class="line">        // Special case: instancesRequireRawIsa does not propagate </div><div class="line">        // from root class to root metaclass</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">        rawIsaIsInherited = true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (instancesRequireRawIsa) &#123;</div><div class="line">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</div><div class="line">    &#125;</div><div class="line">// SUPPORT_NONPOINTER_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line">    // Update superclass and metaclass in case of remapping</div><div class="line">    cls-&gt;superclass = supercls;</div><div class="line">    cls-&gt;initClassIsa(metacls);</div><div class="line"></div><div class="line">	// 协调实例变量偏移/布局</div><div class="line">	//可能重新申请空间 class_ro_t,更新我们的class_ro_t</div><div class="line">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</div><div class="line"></div><div class="line">    // 设置setInstanceSize 从ro-&gt;instanceSize</div><div class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</div><div class="line"></div><div class="line">	//拷贝flags 从ro到rw中</div><div class="line">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</div><div class="line">        cls-&gt;setHasCxxDtor();</div><div class="line">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</div><div class="line">            cls-&gt;setHasCxxCtor();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//添加superclass指针</div><div class="line">    if (supercls) &#123;</div><div class="line">        addSubclass(supercls, cls);</div><div class="line">    &#125; else &#123;</div><div class="line">        addRootClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attach categories</div><div class="line">	//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</div><div class="line">    methodizeClass(cls);</div><div class="line"></div><div class="line">    return cls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* methodizeClass</div><div class="line"> 修复cls方法列表想，协议列表和属性列表</div><div class="line">* 加锁</div><div class="line">**********************************************************************/</div><div class="line">static void methodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line">    auto ro = rw-&gt;ro;</div><div class="line"></div><div class="line">    // Methodizing for the first time</div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        _objc_inform(&quot;CLASS: methodizing class &apos;%s&apos; %s&quot;, </div><div class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//方法列表</div><div class="line">    method_list_t *list = ro-&gt;baseMethods();</div><div class="line">    if (list) &#123;</div><div class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</div><div class="line">	//将对象的方法追加到cls-&gt;rw-&gt;methods后面</div><div class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class="line">    if (proplist) &#123;</div><div class="line">	//将对象的属性追加到rw-&gt;properties后面</div><div class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class="line">    if (protolist) &#123;</div><div class="line">	//将对象的协议追加到rw-&gt;protocols后面</div><div class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Root classes get bonus method implementations if they don&apos;t have </div><div class="line">    // them already. These apply before category replacements.</div><div class="line">    if (cls-&gt;isRootMetaclass()) &#123;</div><div class="line">        // root metaclass</div><div class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attach categories.</div><div class="line">	//类别 从全局NXMapTable *category_map 已经加载过了。</div><div class="line">    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);</div><div class="line">	//收集所有的cats到cls -&gt; rw中</div><div class="line">    attachCategories(cls, cats, false /*don&apos;t flush caches*/);</div><div class="line"></div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        if (cats) &#123;</div><div class="line">            for (uint32_t i = 0; i &lt; cats-&gt;count; i++) &#123;</div><div class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </div><div class="line">                             isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (cats) free(cats);//释放cats</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">    // Debug: sanity-check all SELs; log method list contents</div><div class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</div><div class="line">        if (PrintConnecting) &#123;</div><div class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</div><div class="line">        &#125;</div><div class="line">        assert(sel_registerName(sel_getName(meth.name)) == meth.name); </div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="attachCategories-解析"><a href="#attachCategories-解析" class="headerlink" title="attachCategories()解析"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // fixme rearrange to remove these intermediate allocations</div><div class="line">	//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">	//属性数组</div><div class="line">    property_list_t **proplists = (property_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">	//协议数组</div><div class="line">    protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int propcount = 0;</div><div class="line">    int protocount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    bool fromBundle = NO;</div><div class="line">    while (i--) &#123;</div><div class="line">		//取出某个分类</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line">//取出分类 的 instance方法或者class方法</div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有分类属性</div><div class="line">        property_list_t *proplist = </div><div class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">        if (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有协议方法</div><div class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">        if (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//收集了所有协议 分类方法</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">	//追加所有分类方法</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">	//释放数组</div><div class="line">    free(mlists);</div><div class="line">	//刷新该类的缓存</div><div class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">//追加所有分类属性</div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    free(proplists);//释放数组</div><div class="line">//追加所有分类协议</div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    free(protolists);//释放数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="rw-gt-list-gt-attachLists-解析"><a href="#rw-gt-list-gt-attachLists-解析" class="headerlink" title="rw-&gt;list-&gt;attachLists()解析"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">       if (addedCount == 0) return;</div><div class="line"></div><div class="line">       if (hasArray()) &#123;</div><div class="line">           // many lists -&gt; many lists</div><div class="line">           uint32_t oldCount = array()-&gt;count;</div><div class="line">		//一共需要的数量</div><div class="line">           uint32_t newCount = oldCount + addedCount;</div><div class="line">		//分配内存 内存不够用了，需要扩容</div><div class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">		//赋值count</div><div class="line">           array()-&gt;count = newCount;</div><div class="line">		// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class="line">           memmove(array()-&gt;lists + addedCount/*数组末尾*/, array()-&gt;lists/*数组*/,</div><div class="line">                   oldCount * sizeof(array()-&gt;lists[0])/*移动的大小*/);</div><div class="line">		//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class="line">           memcpy(array()-&gt;lists, addedLists, </div><div class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">		/*</div><div class="line">		图示讲解：</div><div class="line">		array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">	addedCount:3</div><div class="line">	addedLists:P-&gt;L-&gt;V</div><div class="line">		memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">		然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class="line">		P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">		 */</div><div class="line">       &#125;</div><div class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">           // 0 lists -&gt; 1 list</div><div class="line">           list = addedLists[0];</div><div class="line">       &#125; </div><div class="line">       else &#123;</div><div class="line">           // 1 list -&gt; many lists</div><div class="line">           List* oldList = list;</div><div class="line">           uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">           uint32_t newCount = oldCount + addedCount;</div><div class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">           array()-&gt;count = newCount;</div><div class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">           memcpy(array()-&gt;lists, addedLists, </div><div class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>
<h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_resolveMethod</div><div class="line">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</div><div class="line">* 如果存在了则不检查</div><div class="line">**********************************************************************/</div><div class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    if (! cls-&gt;isMetaClass()) &#123;//不是元类则调用 实例的</div><div class="line">	//首先调用</div><div class="line">		_class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // try [nonMetaClass resolveClassMethod:sel]</div><div class="line">        // and [cls resolveInstanceMethod:sel]</div><div class="line">		//寻找classMethod</div><div class="line">        _class_resolveClassMethod(cls, sel, inst);</div><div class="line">        if (!lookUpImpOrNil(cls, sel, inst, </div><div class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">        &#123;</div><div class="line">            _class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_resolveInstanceMethod</div><div class="line">* 调用 class添加的函数 +resolveInstanceMethod</div><div class="line">* 有可能是元类</div><div class="line">* 如果方法存在则不检查</div><div class="line">**********************************************************************/</div><div class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </div><div class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">    &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class="line"></div><div class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class="line">        if (imp) &#123;</div><div class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class="line">                         &quot;dynamically resolved to %p&quot;, </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Method resolver didn&apos;t add anything?</div><div class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</div><div class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    assert(cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </div><div class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">    &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </div><div class="line">                        SEL_resolveClassMethod, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class="line"></div><div class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class="line">        if (imp) &#123;</div><div class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class="line">                         &quot;dynamically resolved to %p&quot;, </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Method resolver didn&apos;t add anything?</div><div class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</div><div class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态解析至此完成。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">STATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache</div><div class="line">	// No stret specialization.</div><div class="line">	b	__objc_msgForward//跳转-&gt;__objc_msgForward</div><div class="line">	END_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache</div><div class="line"></div><div class="line">	</div><div class="line">	ENTRY __objc_msgForward // 开始 __objc_msgForward</div><div class="line"></div><div class="line">	adrp	x17, __objc_forward_handler@PAGE</div><div class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和</div><div class="line">	TailCallFunctionPointer x17 //跳转-&gt; TailCallFunctionPointer</div><div class="line"></div><div class="line">	END_ENTRY __objc_msgForward//结束 __objc_msgForward</div></pre></td></tr></table></figure>
<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__attribute__((noreturn)) void </div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>
<p>网上有大神总结的点我们先参考下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">// 伪代码</div><div class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</div><div class="line">    id receiver = *(id *)frameStackPointer;</div><div class="line">    SEL sel = *(SEL *)(frameStackPointer + 8);</div><div class="line">    const char *selName = sel_getName(sel);</div><div class="line">    Class receiverClass = object_getClass(receiver);</div><div class="line"></div><div class="line">    // 调用 forwardingTargetForSelector:</div><div class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</div><div class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</div><div class="line">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</div><div class="line">            if (isStret == 1) &#123;</div><div class="line">                int ret;</div><div class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</div><div class="line">                return ret;</div><div class="line">            &#125;</div><div class="line">            return objc_msgSend(forwardingTarget, sel, ...);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 僵尸对象</div><div class="line">    const char *className = class_getName(receiverClass);</div><div class="line">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</div><div class="line">    size_t prefixLen = strlen(zombiePrefix); // 0xa</div><div class="line">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</div><div class="line">        CFLog(kCFLogLevelError,</div><div class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</div><div class="line">              className + prefixLen,</div><div class="line">              selName,</div><div class="line">              receiver);</div><div class="line">        &lt;breakpoint-interrupt&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</div><div class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</div><div class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</div><div class="line">        if (methodSignature) &#123;</div><div class="line">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</div><div class="line">            if (signatureIsStret != isStret) &#123;</div><div class="line">                CFLog(kCFLogLevelWarning ,</div><div class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</div><div class="line">                      selName,</div><div class="line">                      signatureIsStret ? &quot;&quot; : not,</div><div class="line">                      isStret ? &quot;&quot; : not);</div><div class="line">            &#125;</div><div class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</div><div class="line">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</div><div class="line"></div><div class="line">                [receiver forwardInvocation:invocation];</div><div class="line"></div><div class="line">                void *returnValue = NULL;</div><div class="line">                [invocation getReturnValue:&amp;value];</div><div class="line">                return returnValue;</div><div class="line">            &#125; else &#123;</div><div class="line">                CFLog(kCFLogLevelWarning ,</div><div class="line">                      @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;,</div><div class="line">                      receiver,</div><div class="line">                      className);</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SEL *registeredSel = sel_getUid(selName);</div><div class="line"></div><div class="line">    // selector 是否已经在 Runtime 注册过</div><div class="line">    if (sel != registeredSel) &#123;</div><div class="line">        CFLog(kCFLogLevelWarning ,</div><div class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;,</div><div class="line">              sel,</div><div class="line">              selName,</div><div class="line">              registeredSel);</div><div class="line">    &#125; // doesNotRecognizeSelector</div><div class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</div><div class="line">        [receiver doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        CFLog(kCFLogLevelWarning ,</div><div class="line">              @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement doesNotRecognizeSelector: -- abort&quot;,</div><div class="line">              receiver,</div><div class="line">              className);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // The point of no return.</div><div class="line">    kill(getpid(), 9);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="验证动态解析"><a href="#验证动态解析" class="headerlink" title="验证动态解析"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (void)test;</div><div class="line">@end</div><div class="line">@implementation Person</div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	if (sel == @selector(test)) &#123;</div><div class="line">		Method me = class_getInstanceMethod(self, @selector(test2));</div><div class="line">		class_addMethod(self, sel,</div><div class="line">						method_getImplementation(me),</div><div class="line">						method_getTypeEncoding(me));</div><div class="line">		return YES;</div><div class="line">	&#125;</div><div class="line">	return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">-(void)test2&#123;</div><div class="line">	NSLog(@&quot;来了，老弟&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">Person *p = [[Person alloc]init];</div><div class="line">[p test];</div><div class="line">[p test];</div><div class="line"> //输出</div><div class="line">+[FYPerson resolveInstanceMethod:]</div><div class="line"> -[FYPerson test3]</div><div class="line"> -[FYPerson test3]</div></pre></td></tr></table></figure>
<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>
<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">+ (void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">+ (void)test3&#123;</div><div class="line">	NSLog(@&quot;来了，老弟&quot;);</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	if (sel == @selector(test)) &#123;</div><div class="line">		Method me = class_getClassMethod(self, @selector(test3));//获取method</div><div class="line">		//给sel 添加方法实现 @selecter(test3)</div><div class="line">		class_addMethod(object_getClass(self), sel,</div><div class="line">						method_getImplementation(me),</div><div class="line">						method_getTypeEncoding(me));</div><div class="line">		return YES;</div><div class="line">	&#125;</div><div class="line">	return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[Person test];</div><div class="line"></div><div class="line">//输出</div><div class="line">+[Person resolveClassMethod:]</div><div class="line">来了，老弟</div></pre></td></tr></table></figure>
<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    if (sel == @selector(test)) &#123;</div><div class="line">//        Method me = class_getInstanceMethod(self, @selector(test3));</div><div class="line">//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</div><div class="line">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">void test3(id self,SEL sel)&#123;</div><div class="line">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">+[FYPerson resolveInstanceMethod:]</div><div class="line">test3:test</div><div class="line">test3:test</div></pre></td></tr></table></figure>
<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>
<h3 id="验证消息转发"><a href="#验证消息转发" class="headerlink" title="验证消息转发"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Student.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [[Struent alloc]init];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//输出</div><div class="line">-[Student test]</div></pre></td></tr></table></figure>
<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>
<p>第一步没拦截，可以在第二步拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//消息转发第二步 没有对象来处理方法，那将函数签名来实现</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	if (aSelector == @selector(test)) &#123;</div><div class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class="line">		return sign;</div><div class="line">	&#125;</div><div class="line">	return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">// 函数签名已返回，到了函数调用的地方</div><div class="line">//selector 函数的sel</div><div class="line">//target   函数调用者</div><div class="line">//methodSignature 函数签名</div><div class="line">//NSInvocation  封装数据的对象</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">-[Person forwardInvocation:]</div></pre></td></tr></table></figure></p>
<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, retain) NSMethodSignature *methodSignature;//只读</div><div class="line">- (void)retainArguments;</div><div class="line">@property (readonly) BOOL argumentsRetained;</div><div class="line">@property (nullable, assign) id target;//读写</div><div class="line">@property SEL selector;//读写</div></pre></td></tr></table></figure>
<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//class 转发</div><div class="line">// 消息转发第一步 拦截是否有转发的class对象处理方法</div><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [Student class];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)test3&#123;</div><div class="line">//	NSLog(@&quot;+[Student test3]&quot;);</div><div class="line">//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错</div><div class="line">//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</div><div class="line">//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 输出</div><div class="line">-[Student test2]</div></pre></td></tr></table></figure>
<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [[Student alloc]init];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test3&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">-[Student test3]</div></pre></td></tr></table></figure>
<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//消息转发第二步 没有class来处理方法，那将函数签名来实现</div><div class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class="line">		return sign;</div><div class="line">	&#125;</div><div class="line">	return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">// 函数签名已返回，到了函数调用的地方</div><div class="line">//selector 函数的sel</div><div class="line">//target   函数调用者</div><div class="line">//methodSignature 函数签名</div><div class="line">//NSInvocation  封装数据的对象</div><div class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">//	anInvocation.selector = @selector(test2);</div><div class="line">//此处换成[Student class]同样可以</div><div class="line">//	anInvocation.target = (id)[[Student alloc]init];</div><div class="line"></div><div class="line">//	[anInvocation invoke];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">+[Person forwardInvocation:]</div></pre></td></tr></table></figure>
<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>
<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>
<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>
<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>
<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></li>
</ul>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/" class="post-title-link" itemprop="url">iOS底层原理 runtime-object_class拾遗基础篇--(6)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:16:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:16:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:02:33" itemprop="dateModified" datetime="2019-12-03T13:02:33+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="runtime-基础知识"><a href="#runtime-基础知识" class="headerlink" title="runtime 基础知识"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">public:</div><div class="line">    // ISA() assumes this is NOT a tagged pointer object</div><div class="line">    Class ISA();</div><div class="line">    // getIsa() allows this to be a tagged pointer object</div><div class="line">    Class getIsa();</div><div class="line">    //****</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#include &quot;isa.h&quot;</div><div class="line">union isa_t &#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line">#if defined(ISA_BITFIELD)</div><div class="line">    struct &#123;</div><div class="line">        ISA_BITFIELD;  // defined in isa.h</div><div class="line">    &#125;;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class="line">#   define ISA_BITFIELD                                         </div><div class="line">      uintptr_t nonpointer        : 1;                              </div><div class="line">      uintptr_t has_assoc         : 1;                                  </div><div class="line">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class="line">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</div><div class="line">      uintptr_t magic             : 6;                                  </div><div class="line">      uintptr_t weakly_referenced : 1;                                  </div><div class="line">      uintptr_t deallocating      : 1;                                  </div><div class="line">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class="line">      uintptr_t extra_rc          : 19</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</div><div class="line"></div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class="line">#   define ISA_BITFIELD                                                 </div><div class="line">      uintptr_t nonpointer        : 1;                                  </div><div class="line">      uintptr_t has_assoc         : 1;                                  </div><div class="line">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</div><div class="line">      uintptr_t magic             : 6;                                  </div><div class="line">      uintptr_t weakly_referenced : 1;                                  </div><div class="line">      uintptr_t deallocating      : 1;                                  </div><div class="line">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class="line">      uintptr_t extra_rc          : 8</div><div class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</div><div class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</div><div class="line"># else</div><div class="line">#   error unknown architecture for packed isa</div><div class="line"># endif</div></pre></td></tr></table></figure>
<p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">union isa_t &#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line">    struct &#123;</div><div class="line">      uintptr_t nonpointer        : 1;                                </div><div class="line">      uintptr_t has_assoc         : 1;                                  </div><div class="line">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</div><div class="line">      uintptr_t magic             : 6;                                  </div><div class="line">      uintptr_t weakly_referenced : 1;                                  </div><div class="line">      uintptr_t deallocating      : 1;                                  </div><div class="line">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class="line">      uintptr_t extra_rc          : 8</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p>
<h4 id="共用体基础知识"><a href="#共用体基础知识" class="headerlink" title="共用体基础知识"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,assign) BOOL rich;</div><div class="line">@property (nonatomic,assign) BOOL tell;</div><div class="line">@property (nonatomic,assign) BOOL handsome;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后查看该类的实例占用空间大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FYPerson *p=[[FYPerson alloc]init];</div><div class="line">		p.handsome = YES;</div><div class="line">		p.rich = NO;</div><div class="line">		NSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</div><div class="line">		//16</div></pre></td></tr></table></figure>
<p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (void)setTall:(BOOL)tall;</div><div class="line">- (void)setRich:(BOOL)rich;</div><div class="line">- (void)setHandsome:(BOOL)handsome;</div><div class="line"></div><div class="line">- (BOOL)isTall;</div><div class="line">- (BOOL)isRich;</div><div class="line">- (BOOL)isHandsome;</div><div class="line"></div><div class="line">//实现：</div><div class="line">//使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</div><div class="line">//#define FYHandsomeMask 0b00000001</div><div class="line">//#define FYTallMask 0b00000010</div><div class="line">//#define FYRichMask 0b00000001</div><div class="line"></div><div class="line"></div><div class="line">#define FYHandsomeMask (1&lt;&lt;0)</div><div class="line">#define FYTallMask (1&lt;&lt;1)</div><div class="line">#define FYRichMask (1&lt;&lt;2)</div><div class="line"></div><div class="line">@interface FYPerson()</div><div class="line">&#123;</div><div class="line">	char _richTellHandsome;//0000 0000 rich tall handsome</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line"></div><div class="line">- (void)setRich:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome = _richTellHandsome|FYRichMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome = _richTellHandsome&amp;~FYRichMask;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">- (void)setTall:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome = _richTellHandsome|FYTallMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome = _richTellHandsome&amp;~FYTallMask;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">- (void)setHandsome:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (BOOL)isRich&#123;</div><div class="line">	return !!(_richTellHandsome&amp;FYRichMask);</div><div class="line">&#125;</div><div class="line">- (BOOL)isTall&#123;</div><div class="line">	return !!(_richTellHandsome&amp;FYTallMask);</div><div class="line">&#125;</div><div class="line">- (BOOL)isHandsome&#123;</div><div class="line">	return !!(_richTellHandsome&amp;FYHandsomeMask);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson()</div><div class="line">&#123;</div><div class="line">//	char _richTellHandsome;//0000 0000 rich tall handsome</div><div class="line">	//位域</div><div class="line">	struct&#123;</div><div class="line">		char tall : 1;//高度</div><div class="line">		char rich : 1;//富有</div><div class="line">		char handsome : 1; //帅</div><div class="line">	&#125; _richTellHandsome; // 0b0000 0000</div><div class="line">	//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</div><div class="line">	//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line"></div><div class="line">- (void)setRich:(BOOL)tall&#123;</div><div class="line">	_richTellHandsome.rich = tall;</div><div class="line">&#125;</div><div class="line">- (void)setTall:(BOOL)tall&#123;</div><div class="line">	_richTellHandsome.tall = tall;</div><div class="line">&#125;</div><div class="line">- (void)setHandsome:(BOOL)tall&#123;</div><div class="line">	_richTellHandsome.handsome = tall;</div><div class="line">&#125;</div><div class="line">- (BOOL)isRich&#123;</div><div class="line">	return !!_richTellHandsome.rich;</div><div class="line">&#125;</div><div class="line">- (BOOL)isTall&#123;</div><div class="line">	return !!_richTellHandsome.tall;</div><div class="line">&#125;</div><div class="line">- (BOOL)isHandsome&#123;</div><div class="line">	return !!_richTellHandsome.handsome;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (tall) &#123;</div><div class="line">		_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson()</div><div class="line">&#123;</div><div class="line">	union &#123;</div><div class="line">		char bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间</div><div class="line">		struct&#123;</div><div class="line">			char tall : 1;//高度</div><div class="line">			char rich : 1;//富有</div><div class="line">			char handsome : 1; //帅</div><div class="line">		&#125;; // 0b0000 0000</div><div class="line">	&#125;_richTellHandsome;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line"></div><div class="line">- (void)setRich:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome.bits |= FYRichMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome.bits &amp;= ~FYRichMask;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)setTall:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome.bits |= FYTallMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome.bits &amp;= ~FYTallMask;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)setHandsome:(BOOL)tall&#123;</div><div class="line">	if (tall) &#123;</div><div class="line">		_richTellHandsome.bits |= FYHandsomeMask;</div><div class="line">	&#125;else&#123;</div><div class="line">		_richTellHandsome.bits &amp;= ~FYHandsomeMask;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (BOOL)isRich&#123;</div><div class="line">	return !!(_richTellHandsome.bits &amp; FYRichMask);</div><div class="line">&#125;</div><div class="line">- (BOOL)isTall&#123;</div><div class="line">	return !!(_richTellHandsome.bits &amp; FYTallMask);</div><div class="line">&#125;</div><div class="line">- (BOOL)isHandsome&#123;</div><div class="line">	return (_richTellHandsome.bits &amp; FYHandsomeMask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</div><div class="line">        NSKeyValueObservingOptionNew = 0x01,</div><div class="line">    NSKeyValueObservingOptionOld = 0x02,</div><div class="line">    NSKeyValueObservingOptionInitial = 0x04,</div><div class="line">    NSKeyValueObservingOptionPrior = 0x08</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">typedef enum &#123;</div><div class="line">	FYOne = 1,//  0b 0001</div><div class="line">	FYTwo = 2,//  0b 0010</div><div class="line">	FYTHree = 4,//0b 0100</div><div class="line">	FYFour = 8,// 0b 1000</div><div class="line">&#125;FYOptions;</div><div class="line"></div><div class="line">- (void)setOptions:(FYOptions )ops&#123;</div><div class="line">	if (ops &amp;FYOne) &#123;</div><div class="line">		NSLog(@&quot;FYOne is show&quot;);</div><div class="line">	&#125;</div><div class="line">	if (ops &amp;FYTwo) &#123;</div><div class="line">		NSLog(@&quot;FYTwo is show&quot;);</div><div class="line">	&#125;</div><div class="line">	if (ops &amp;FYTHree) &#123;</div><div class="line">		NSLog(@&quot;FYTHree is show&quot;);</div><div class="line">	&#125;</div><div class="line">	if (ops &amp;FYFour) &#123;</div><div class="line">		NSLog(@&quot;FYFour is show&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[self setOptions:FYOne|FYTwo|FYTHree];</div><div class="line"></div><div class="line">//输出是：</div><div class="line">FYOne is show</div><div class="line">FYTwo is show</div><div class="line">FYTHree is show</div></pre></td></tr></table></figure>
<p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p>
<h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nonpointer</td>
<td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td>
</tr>
<tr>
<td>has_assoc</td>
<td>是否有设置过关联对象，如果没有，释放时会更快</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>存储着Class、Meta-Class对象的内存地址信息</td>
</tr>
<tr>
<td>magic</td>
<td>用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>是否有被弱引用指向过，如果没有，释放时会更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>对象是否正在释放</td>
</tr>
<tr>
<td>extra_rc</td>
<td>里面存储的值是引用计数器减1</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>引用计数器是否过大无法存储在isa中</td>
</tr>
</tbody>
</table>
<p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p>
<p>class结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct fy_objc_class : xx_objc_object &#123;</div><div class="line">	Class superclass;</div><div class="line">	cache_t cache;</div><div class="line">	class_data_bits_t bits;</div><div class="line">public:</div><div class="line">	class_rw_t* data() &#123;</div><div class="line">		return bits.data();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</div><div class="line">		// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</div><div class="line">		return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">struct class_rw_t &#123;</div><div class="line">	uint32_t flags;</div><div class="line">	uint32_t version;</div><div class="line">	const class_ro_t *ro;//只读 数据</div><div class="line">	method_list_t * methods;    // 方法列表</div><div class="line">	property_list_t *properties;    // 属性列表</div><div class="line">	const protocol_list_t * protocols;  // 协议列表</div><div class="line">	Class firstSubclass;</div><div class="line">	Class nextSiblingClass;</div><div class="line">	char *demangledName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">struct class_ro_t &#123;</div><div class="line">	uint32_t flags;</div><div class="line">	uint32_t instanceStart;</div><div class="line">	uint32_t instanceSize;  // instance对象占用的内存空间</div><div class="line">#ifdef __LP64__</div><div class="line">	uint32_t reserved;</div><div class="line">#endif</div><div class="line">	const uint8_t * ivarLayout;</div><div class="line">	const char * name;  // 类名</div><div class="line">	method_list_t * baseMethodList;</div><div class="line">	protocol_list_t * baseProtocols;</div><div class="line">	const ivar_list_t * ivars;  // 成员变量列表</div><div class="line">	const uint8_t * weakIvarLayout;</div><div class="line">	property_list_t *baseProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line">    class_rw_t *rw;</div><div class="line">    Class supercls;</div><div class="line">    Class metacls;</div><div class="line">    bool isMeta;</div><div class="line"></div><div class="line">    if (!cls) return nil;</div><div class="line">    //如果已注册 就返回</div><div class="line">    if (cls-&gt;isRealized()) return cls;</div><div class="line">    assert(cls == remapClass(cls));</div><div class="line"></div><div class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class="line">//只读ro</div><div class="line">    ro = (const class_ro_t *)cls-&gt;data();</div><div class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</div><div class="line">        // This was a future class. rw data is already allocated.</div><div class="line">        rw = cls-&gt;data();//初始化ro</div><div class="line">        ro = cls-&gt;data()-&gt;ro;</div><div class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Normal class. Allocate writeable class data.</div><div class="line">        //初始化 rw </div><div class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class="line">        rw-&gt;ro = ro;</div><div class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</div><div class="line">        //指针指向rw 一开始是指向ro的</div><div class="line">        cls-&gt;setData(rw);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isMeta = ro-&gt;flags &amp; RO_META;</div><div class="line"></div><div class="line">    rw-&gt;version = isMeta ? 7 : 0;  // old runtime went up to 6</div><div class="line">`</div></pre></td></tr></table></figure>
<p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class method_array_t : </div><div class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </div><div class="line">&#123;</div><div class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</div><div class="line"></div><div class="line"> public:</div><div class="line">    method_list_t **beginCategoryMethodLists() &#123;</div><div class="line">        return beginLists();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    method_list_t **endCategoryMethodLists(Class cls);</div><div class="line"></div><div class="line">    method_array_t duplicate() &#123;</div><div class="line">        return Super::duplicate&lt;method_array_t&gt;();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct method_t &#123;</div><div class="line">    SEL name;</div><div class="line">    const char *types;</div><div class="line">    MethodListIMP imp;</div><div class="line"></div><div class="line">    struct SortBySELAddress :</div><div class="line">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</div><div class="line">    &#123;</div><div class="line">        bool operator() (const method_t&amp; lhs,</div><div class="line">                         const method_t&amp; rhs)</div><div class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><ul>
<li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似</li>
<li>可以通过@selector()和sel_registerName()获得</li>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
<h5 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">官方网站插件encodeing</a></p>
<table>
<thead>
<tr>
<th>code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>A char</td>
</tr>
<tr>
<td>i</td>
<td>An int</td>
</tr>
<tr>
<td>s</td>
<td>A short</td>
</tr>
<tr>
<td>l</td>
<td>A long</td>
</tr>
<tr>
<td>l</td>
<td>is treated as a 32-bit quantity on 64-bit programs.</td>
</tr>
<tr>
<td>q</td>
<td>A long long</td>
</tr>
<tr>
<td>C</td>
<td>An unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>An unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>An unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>An unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>An unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>A float</td>
</tr>
<tr>
<td>d</td>
<td>A double</td>
</tr>
<tr>
<td>B</td>
<td>A C++ bool or a C99 _Bool</td>
</tr>
<tr>
<td>v</td>
<td>A void</td>
</tr>
<tr>
<td>*</td>
<td>A character string (char *)</td>
</tr>
<tr>
<td>@</td>
<td>An object (whether statically typed or typed id)</td>
</tr>
<tr>
<td>#</td>
<td>A class object (Class)</td>
</tr>
<tr>
<td>:</td>
<td>A method selector (SEL)</td>
</tr>
<tr>
<td>[array type]</td>
<td>An array</td>
</tr>
<tr>
<td>{name=type…}</td>
<td>A structure</td>
</tr>
<tr>
<td>(name=type…)</td>
<td>A union</td>
</tr>
<tr>
<td>bnum</td>
<td>A bit field of num bits</td>
</tr>
<tr>
<td>^type</td>
<td>A pointer to type</td>
</tr>
<tr>
<td>?</td>
<td>An unknown type (among other things, this code is used for function pointers)</td>
</tr>
</tbody>
</table>
<p>我们通过一个例子来了解encode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-(void)test:(int)age heiht:(float)height&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">FYPerson *p=[[FYPerson alloc]init];</div><div class="line">	SEL sel = @selector(test:heiht:);</div><div class="line">	Method m1= class_getInstanceMethod(p.class, sel);</div><div class="line">	const char *type = method_getTypeEncoding(m1);</div><div class="line">	NSLog(@&quot;%s&quot;,type);</div><div class="line">	</div><div class="line">	//输出</div><div class="line">	v24@0:8i16f20</div><div class="line">	//0id 8 SEL 16 int 20 float = 24</div></pre></td></tr></table></figure>
<p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p>
<h4 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct cache_t &#123;</div><div class="line">    struct bucket_t *_buckets;//散列表</div><div class="line">    mask_t _mask;//散列表长度-1</div><div class="line">    mask_t _occupied;//已经存储的方法数量</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct bucket_t &#123;</div><div class="line">#if __arm64__</div><div class="line">    MethodCacheIMP _imp;</div><div class="line">    cache_key_t _key;</div><div class="line">#else</div><div class="line">    cache_key_t _key;//SEL作为key </div><div class="line">    MethodCacheIMP _imp; //函数地址</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>散列表的数据结构表格所示</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>bucket_t</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>1</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>2</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>3</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>4</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</div><div class="line">&#123;</div><div class="line">    assert(k != 0);</div><div class="line"></div><div class="line">    bucket_t *b = buckets();</div><div class="line">    mask_t m = mask();</div><div class="line">	//key&amp;mask 得到索引</div><div class="line">    mask_t begin = cache_hash(k, m);</div><div class="line">    mask_t i = begin;</div><div class="line">    do &#123;</div><div class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</div><div class="line">            return &amp;b[i];</div><div class="line">        &#125;</div><div class="line">    &#125; while ((i = cache_next(i, m)) != begin);</div><div class="line"></div><div class="line">    // hack</div><div class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</div><div class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</div><div class="line">// Caches are never built in the dyld shared cache.</div><div class="line"></div><div class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </div><div class="line">&#123;</div><div class="line">    return (mask_t)(key &amp; mask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">#ifndef MJClassInfo_h</div><div class="line">#define MJClassInfo_h</div><div class="line"></div><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line"># endif</div><div class="line"></div><div class="line">#if __LP64__</div><div class="line">typedef uint32_t mask_t;</div><div class="line">#else</div><div class="line">typedef uint16_t mask_t;</div><div class="line">#endif</div><div class="line">typedef uintptr_t cache_key_t;</div><div class="line"></div><div class="line">#if __arm__  ||  __x86_64__  ||  __i386__</div><div class="line">// objc_msgSend has few registers available.</div><div class="line">// Cache scan increments and wraps at special end-marking bucket.</div><div class="line">#define CACHE_END_MARKER 1</div><div class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class="line">    return (i+1) &amp; mask;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#elif __arm64__</div><div class="line">// objc_msgSend has lots of registers available.</div><div class="line">// Cache scan decrements. No end marker needed.</div><div class="line">#define CACHE_END_MARKER 0</div><div class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class="line">    return i ? i-1 : mask;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#else</div><div class="line">#error unknown architecture</div><div class="line">#endif</div><div class="line"></div><div class="line">struct bucket_t &#123;</div><div class="line">    cache_key_t _key;</div><div class="line">    IMP _imp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct cache_t &#123;</div><div class="line">    bucket_t *_buckets;</div><div class="line">    mask_t _mask;</div><div class="line">    mask_t _occupied;</div><div class="line">    </div><div class="line">    IMP imp(SEL selector)</div><div class="line">    &#123;</div><div class="line">        mask_t begin = _mask &amp; (long long)selector;</div><div class="line">        mask_t i = begin;</div><div class="line">        do &#123;</div><div class="line">            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) &#123;</div><div class="line">                return _buckets[i]._imp;</div><div class="line">            &#125;</div><div class="line">        &#125; while ((i = cache_next(i, _mask)) != begin);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct entsize_list_tt &#123;</div><div class="line">    uint32_t entsizeAndFlags;</div><div class="line">    uint32_t count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct method_t &#123;</div><div class="line">    SEL name;</div><div class="line">    const char *types;</div><div class="line">    IMP imp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct method_list_t : entsize_list_tt &#123;</div><div class="line">    method_t first;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct ivar_t &#123;</div><div class="line">    int32_t *offset;</div><div class="line">    const char *name;</div><div class="line">    const char *type;</div><div class="line">    uint32_t alignment_raw;</div><div class="line">    uint32_t size;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct ivar_list_t : entsize_list_tt &#123;</div><div class="line">    ivar_t first;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct property_t &#123;</div><div class="line">    const char *name;</div><div class="line">    const char *attributes;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct property_list_t : entsize_list_tt &#123;</div><div class="line">    property_t first;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct chained_property_list &#123;</div><div class="line">    chained_property_list *next;</div><div class="line">    uint32_t count;</div><div class="line">    property_t list[0];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef uintptr_t protocol_ref_t;</div><div class="line">struct protocol_list_t &#123;</div><div class="line">    uintptr_t count;</div><div class="line">    protocol_ref_t list[0];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct class_ro_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</div><div class="line">#ifdef __LP64__</div><div class="line">    uint32_t reserved;</div><div class="line">#endif</div><div class="line">    const uint8_t * ivarLayout;</div><div class="line">    const char * name;  // 类名</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    const ivar_list_t * ivars;  // 成员变量列表</div><div class="line">    const uint8_t * weakIvarLayout;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct class_rw_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line">    const class_ro_t *ro;</div><div class="line">    method_list_t * methods;    // 方法列表</div><div class="line">    property_list_t *properties;    // 属性列表</div><div class="line">    const protocol_list_t * protocols;  // 协议列表</div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line">    char *demangledName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</div><div class="line">struct class_data_bits_t &#123;</div><div class="line">    uintptr_t bits;</div><div class="line">public:</div><div class="line">    class_rw_t* data() &#123;</div><div class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* OC对象 */</div><div class="line">struct mj_objc_object &#123;</div><div class="line">    void *isa;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* 类对象 */</div><div class="line">struct mj_objc_class : mj_objc_object &#123;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;</div><div class="line">    class_data_bits_t bits;</div><div class="line">public:</div><div class="line">    class_rw_t* data() &#123;</div><div class="line">        return bits.data();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mj_objc_class* metaClass() &#123;</div><div class="line">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>测试代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">FYPerson *p = [[FYPerson alloc]init];</div><div class="line">		Method test1Method = class_getInstanceMethod(p.class, @selector(test));</div><div class="line">		Method test2Method = class_getInstanceMethod(p.class, @selector(test2));</div><div class="line">		IMP imp1= method_getImplementation(test1Method);</div><div class="line">		IMP imp2= method_getImplementation(test2Method);</div><div class="line"></div><div class="line">		mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class="line">		NSLog(@&quot;-----&quot;);</div><div class="line">		[p test];</div><div class="line">		[p test2];</div><div class="line">		cache_t cache = cls-&gt;cache;</div><div class="line">		bucket_t *buck = cache._buckets;</div><div class="line">		</div><div class="line">		</div><div class="line">		for (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class="line">			bucket_t item = buck[i];</div><div class="line">			if (item._key != 0) &#123;</div><div class="line">				NSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		//输出</div><div class="line">p imp1</div><div class="line">(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)</div><div class="line">(lldb) p imp2</div><div class="line">(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)</div><div class="line">p/d @selector(test)             //输出 test方法的sel地址</div><div class="line">(SEL) $6 = 140734025103231 &quot;test&quot;</div><div class="line">(lldb) p/d @selector(test2)     //输出 test2方法的sel地址</div><div class="line">(SEL) $7 = 4294971267 &quot;test2&quot;</div><div class="line"></div><div class="line">key1:140733954181041 imp1:0x7fff59fc4cd1</div><div class="line">key2:4294971267 imp2:0x100000e20         //对应test2</div><div class="line">key3:140734025103231 imp3:0x100000df0    //对应test1</div></pre></td></tr></table></figure>
<p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</div><div class="line">&#123;</div><div class="line">    cacheUpdateLock.assertLocked();</div><div class="line"></div><div class="line">    //当initialized 没有执行完毕的时候不缓存</div><div class="line">    if (!cls-&gt;isInitialized()) return;</div><div class="line"></div><div class="line">    // Make sure the entry wasn&apos;t added to the cache by some other thread </div><div class="line">    // before we grabbed the cacheUpdateLock.</div><div class="line">    if (cache_getImp(cls, sel)) return;</div><div class="line"></div><div class="line">    cache_t *cache = getCache(cls);</div><div class="line">    cache_key_t key = getKey(sel);</div><div class="line"></div><div class="line">    // Use the cache as-is if it is less than 3/4 full</div><div class="line">    mask_t newOccupied = cache-&gt;occupied() + 1;</div><div class="line">    mask_t capacity = cache-&gt;capacity();</div><div class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</div><div class="line">        // Cache is read-only. Replace it.</div><div class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</div><div class="line">    &#125;</div><div class="line">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</div><div class="line">        // Cache &lt;= 3/4 </div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        扩容 之后，缓存清空</div><div class="line">        cache-&gt;expand();</div><div class="line">    &#125;</div><div class="line">//bucket_t 最小是4，当&gt;3/4时候，扩容，空间扩容之后是之前的2️倍。</div><div class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</div><div class="line">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</div><div class="line">    bucket-&gt;set(key, imp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">FYPerson *p = [[FYPerson alloc]init];</div><div class="line">mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class="line">NSLog(@&quot;-----&quot;);</div><div class="line">[p test];</div><div class="line">/*</div><div class="line"> key:init imp:0x7fff58807c2d</div><div class="line"> key:class imp:0x7fff588084b7</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:test imp:0x100000bf0</div><div class="line"> Program ended with exit code: 0</div><div class="line"> */</div><div class="line">[p test2]; //当执行该函数的时候</div><div class="line">/*</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:(null) imp:0x0</div><div class="line"> key:test2 imp:0x100000c20</div><div class="line"> key:(null) imp:0x0</div><div class="line"> */</div><div class="line"></div><div class="line">cache_t cache = cls-&gt;cache;</div><div class="line">bucket_t *buck = cache._buckets;</div><div class="line"></div><div class="line"></div><div class="line">for (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class="line">	bucket_t item = buck[i];</div><div class="line">//            if (item._key != 0) &#123;</div><div class="line">////                printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</div><div class="line">//            &#125;</div><div class="line">    printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li>
<li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li>
<li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li>
<li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li>
<li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
</li>
</ul>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理  block本质 --(5)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg#/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理  block本质 --(5)/" class="post-title-link" itemprop="url">iOS底层原理  block本质 --(5)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:15:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:02:14" itemprop="dateModified" datetime="2019-12-03T13:02:14+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。</p>
<h3 id="block本质"><a href="#block本质" class="headerlink" title="block本质"></a>block本质</h3><p>前几篇文章讲过了，<code>class</code>是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？<code>block</code>具有这几个特点：</p>
<ul>
<li>block本质上也是一个OC对象，它内部也有isa指针</li>
<li>block是封装了函数调用以及函数调用环境的oc对象</li>
</ul>
<p>先简单来看一下<code>block</code>编译之后的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        void (^block)(void) = ^(void)&#123;</div><div class="line">            NSLog(@&quot;hello word&quot;);</div><div class="line">        &#125;;</div><div class="line">        block();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>命令行执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp</code>,来到<code>main.cpp</code>内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">    //构造函数 类似OC init函数</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;//block类型</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;// 执行函数的地址</div><div class="line">    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">    //block 内部代码封装成函数</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;//存储结构体占用空间的大小</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">//定义block</div><div class="line">        void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class="line">        //执行block</div><div class="line">        block-&gt;FuncPtr(block);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终<code>block</code>转化成<code>__main_block_impl_0</code>结构体，赋值给变量<code>block</code>，传入参数是<code>__main_block_func_0</code>和<code>__main_block_desc_0_DATA</code>来执行<code>__main_block_impl_0</code>的构造函数，<code>__main_block_desc_0_DATA</code>函数赋值给<code>__main_block_impl_0-&gt;FuncPtr</code>，执行函数是<code>block-&gt;FuncPtr(block)</code>，删除冗余代码之前是<code>((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code>，那么为什么<code>block</code>可以直接强制转化成<code>__block_impl</code>呢？因为<code>__main_block_impl_0</code>结构体的第一行变量是<code>__block_impl</code>，相当于<code>__main_block_impl_0</code>的内存地址和<code>__block_impl</code>的内存地址一样，强制转化也不会有问题。</p>
<h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>变量捕获分为3种：</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>是否会捕获到block内部</th>
<th>访问方式</th>
<th>内部变量假定是a</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量 auto</td>
<td>会</td>
<td>值传递</td>
<td>a</td>
</tr>
<tr>
<td>局部变量 static</td>
<td>会</td>
<td>指针传递</td>
<td>*a</td>
</tr>
<tr>
<td>全局变量</td>
<td>不会</td>
<td>直接访问</td>
<td>空</td>
</tr>
</tbody>
</table>
<h4 id="auto变量捕获"><a href="#auto变量捕获" class="headerlink" title="auto变量捕获"></a>auto变量捕获</h4><p><code>auto</code> 变量，一般<code>auto</code>是省略不写的，访问方式是值传递，关于值传递不懂的话可以看<a href="https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&amp;oq=%E5%80%BC%E4%BC%A0%E9%80%92&amp;aqs=chrome..69i57.5169j0j4&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="external">这篇博客</a>，<br>看下这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line">void (^block)(void) = ^(void)&#123;</div><div class="line">    NSLog(@&quot;age is %d&quot;,age);</div><div class="line">&#125;;</div><div class="line">age = 20;</div><div class="line">block();</div><div class="line">//实际输出是 age is 10</div></pre></td></tr></table></figure>
<p>有没有疑问呢？在<code>block</code>执行之前<code>age =20</code>，为什么输出是10呢？<br>将这段代码转化成<code>c/c++</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int age;//多了一个变量age,存储值是10</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int age = __cself-&gt;age; // bound by copy</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        int age = 10;</div><div class="line">        void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</div><div class="line">        age = 20;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体<code>__main_block_impl_0</code>多了一个变量<code>age</code>，在<code>block</code>转化成<code>c</code>函数的时候<code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)</code>直接将age的值存储在<code>__main_block_impl_0.age</code>中，此时<code>__main_block_impl_0.age</code>是存储在堆上的，之前的<code>age</code>是存储在数据段的，执行<code>block</code>访问的变量是堆上的<code>`__main_block_impl_0.age</code>,所以最终输出来<code>age is 10</code>。</p>
<h4 id="static变量捕获"><a href="#static变量捕获" class="headerlink" title="static变量捕获"></a>static变量捕获</h4><p>我们通过一个例子来讲解static和auto区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void(^block)(void);</div><div class="line">void test()&#123;</div><div class="line">    int age = 10;</div><div class="line">    static int level = 12;</div><div class="line">    block = ^(void)&#123;</div><div class="line">        NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class="line">    &#125;;</div><div class="line">    age = 20;</div><div class="line">    level = 13;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        test();</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出：age is 10,level is 13</div></pre></td></tr></table></figure>
<p>转化成源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void(*block)(void);</div><div class="line"></div><div class="line">struct __test_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __test_block_desc_0* Desc;</div><div class="line">  int age;</div><div class="line">  int *level;</div><div class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</div><div class="line">  int age = __cself-&gt;age; // bound by copy</div><div class="line">  int *level = __cself-&gt;level; // bound by copy</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">static struct __test_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</div><div class="line">void test()&#123;</div><div class="line">    int age = 10;</div><div class="line">    static int level = 12;</div><div class="line">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, age, &amp;level));</div><div class="line">    age = 20;</div><div class="line">    level = 13;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        test();</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行完<code>test()</code>函数，<code>age</code>变量已经被收回，但是<code>age</code>的值存储在<code>block</code>结构体中，<code>level</code>的地址存储在<code>__test_block_impl_0.level</code>,可以看到<code>level</code>类型是指针类型，读取值的时候也是<code>*level</code>，则不管什么时间改动<code>level</code>的值，读<code>level</code>的值都是最新的，因为它是从地址直接读的。所以结果是<code>age is 10,level is 13</code>。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局不用捕获的，访问的时候直接访问。我们来测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line">static int level = 12;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line"></div><div class="line">        void(^block)(void) = ^(void)&#123;</div><div class="line">            NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class="line">        &#125;;</div><div class="line">        age = 20;</div><div class="line">        level = 13;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转化成<code>c/c++</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line">static int level = 12;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">        age = 20;</div><div class="line">        level = 13;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来编译之后仅仅是多了两行<code>int age = 10;
static int level = 12;</code>，结构体<code>__main_block_impl_0</code>内部和构造函数并没有专门来存储值或者指针，原因是当执行<code>__main_block_func_0</code>，可以直接访问变量<code>age</code>和 <code>level</code>，因为全局变量有效区域是全局，不会出了<code>main</code>函数就消失。<br><strong>基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。</strong></p>
<p>我们再看下更复杂的情况，对象类型的引用是如何处理的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,copy) NSString * name;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line">- (void)test&#123;</div><div class="line">    void (^block)(void) = ^&#123;</div><div class="line">        NSLog(@&quot;person is %@&quot;,self);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    void (^block2)(void) = ^&#123;</div><div class="line">        NSLog(@&quot;name is %@&quot;,_name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct __FYPerson__test_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __FYPerson__test_block_desc_0* Desc;</div><div class="line">  FYPerson *self;</div><div class="line">  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) &#123;</div><div class="line">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);</div><div class="line">    &#125;</div><div class="line">static void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static struct __FYPerson__test_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);</div><div class="line">  void (*dispose)(struct __FYPerson__test_block_impl_0*);</div><div class="line">&#125; __FYPerson__test_block_desc_0_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0&#125;;</div><div class="line"></div><div class="line">struct __FYPerson__test_block_impl_1 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __FYPerson__test_block_desc_1* Desc;</div><div class="line">  FYPerson *self;</div><div class="line">  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) &#123;</div><div class="line">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));</div><div class="line">    &#125;</div><div class="line">static void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static struct __FYPerson__test_block_desc_1 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);</div><div class="line">  void (*dispose)(struct __FYPerson__test_block_impl_1*);</div><div class="line">&#125; __FYPerson__test_block_desc_1_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1&#125;;</div><div class="line"></div><div class="line">static void _I_FYPerson_test(FYPerson * self, SEL _cmd) &#123;</div><div class="line">    void (*block)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &amp;__FYPerson__test_block_desc_0_DATA, self, 570425344));</div><div class="line"></div><div class="line">    void (*block2)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &amp;__FYPerson__test_block_desc_1_DATA, self, 570425344));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>block</code>和<code>block2</code>都是结构体<code>__FYPerson__test_block_impl_1</code>内部引用了一个<code>FYPerson</code>对象指针，<code>FYPerson</code>对象属于局部变量，需要捕获。第2个<code>block</code>访问<code>_name</code>捕捉的也是<code>FYPerson</code>对象，访问<code>_name</code>，需要先访问<code>FYPerson</code>对象，然后再访问<code>_name</code>，本质上是访问<code>person.name</code>,所以捕捉的是<code>FYPerson</code>对象。</p>
<h4 id="验证block是对象类型："><a href="#验证block是对象类型：" class="headerlink" title="验证block是对象类型："></a>验证block是对象类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//ARC环境下</div><div class="line">void(^block)(void)=^&#123;</div><div class="line">			NSLog(@&quot;Hello, World!&quot;);</div><div class="line">		&#125;;</div><div class="line">		NSLog(@&quot;自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@&quot;,[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);</div><div class="line">		//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject</div></pre></td></tr></table></figure>
<p>可以了解到<code>block</code>是继承与基类的，所以<code>block</code>也是OC对象。</p>
<h4 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h4><p><code>block</code>有3种类型，如下所示，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承来自<code>NSBlock</code>类型。</p>
<ul>
<li><strong>NSGlobalBLock</strong>（_NSConcreteGLobalBlock）</li>
<li><strong>NSStackBlock</strong>（_NSConcreteStackBlock）</li>
<li><strong>NSMallocBLock</strong>（_NSConcreteMallocBlock）</li>
</ul>
<p>在应用程序中内存分配是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">---------------</div><div class="line">程序区域 .text区</div><div class="line">---------------</div><div class="line">数据区域 .data区     &lt;--------- _NSConcreteGlobalBlock(存储全局变量)</div><div class="line">---------------</div><div class="line">堆                  &lt;--------- _NSConcreteMallocBlock(动态申请释放内存区域)</div><div class="line">---------------</div><div class="line">栈                  &lt;--------- _NSConcreteStackBlock(存储存局部变量)</div><div class="line">---------------</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NSGlobalBLock</strong></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>访问auto变量</td>
</tr>
<tr>
<td><strong>NSMallocBLock</strong></td>
<td><strong>NSStackBlock</strong> 调用copy</td>
</tr>
</tbody>
</table>
<p>验证需要设置成MRC，找到工程文件，设置<code>project-&gt;Object-C Automatic Reference Counting=</code>为<code>NO</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line"></div><div class="line">void(^block1)(void)=^&#123;</div><div class="line">	NSLog(@&quot;block1&quot;);</div><div class="line">&#125;;</div><div class="line">void(^block2)(void)=^&#123;</div><div class="line">	NSLog(@&quot;block2 %d&quot;,age);</div><div class="line">&#125;;</div><div class="line">void(^block3)(void)=[block2 copy];</div><div class="line">NSLog(@&quot;block1:%@   block2:%@ block3:%@ &quot;,[block1 class],[block2 class],[block3 class]);</div><div class="line"></div><div class="line">//输出</div><div class="line">block1:__NSGlobalBlock__   </div><div class="line">block2:__NSStackBlock__ </div><div class="line">block3:__NSMallocBlock__</div></pre></td></tr></table></figure>
<p>没有访问<code>auto</code>变量的<code>block</code>属于<code>__NSGlobalBlock__</code>，访问了auto变量的是<code>__NSStackBlock__</code>，手动调用了<code>copy</code>的<code>block</code>属于<code>__NSMallocBlock__</code>。<code>__NSMallocBlock__</code>是在堆上，需要程序员手动释放<code>[block3 release];</code>，不释放会造成内存泄露。</p>
<p>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下</p>
<table>
<thead>
<tr>
<th>block类型</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NSGlobalBLock</strong></td>
<td>堆</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td><strong>NSMallocBLock</strong></td>
<td>堆</td>
<td>引用计数+1</td>
</tr>
</tbody>
</table>
<h4 id="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"><a href="#在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况" class="headerlink" title="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"></a>在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况</h4><ul>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<p>在ARC环境下测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">typedef void (^FYBlock)(void);</div><div class="line">typedef void (^FYBlockInt)(int);</div><div class="line">FYBlock myBlock()&#123;</div><div class="line">	return ^&#123;</div><div class="line">		NSLog(@&quot;哈哈&quot;);</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line">FYBlock myBlock2()&#123;</div><div class="line">	int age = 10;</div><div class="line">	return ^&#123;</div><div class="line">		NSLog(@&quot;哈哈 %d&quot;,age);</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;</div><div class="line">		FYBlock block = myBlock();</div><div class="line">		FYBlock block2 = myBlock2();</div><div class="line">		int age = 10;</div><div class="line">		FYBlock block3= ^&#123;</div><div class="line">			NSLog(@&quot;强指针block %d&quot;,age);</div><div class="line">		&#125;;</div><div class="line">		NSLog(@&quot;没访问变量:%@ 访问布局变量：%@ 强指针:%@&quot;,[block class],[block2 class],[block3 class]);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">没访问变量:__NSGlobalBlock__ </div><div class="line">访问局部变量：__NSMallocBlock__ </div><div class="line">强指针:__NSMallocBlock__</div></pre></td></tr></table></figure>
<p><code>arc</code>环境下，没访问变量的<code>block</code>是<code>__NSGlobalBlock__</code>，访问了局部变量是<code>__NSMallocBlock__</code>,有强指针引用的是<code>__NSMallocBlock__</code>,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。</p>
<p><strong>所以有以下建议：</strong></p>
<p>MRC下block属性的建议写法</p>
<ul>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<p>ARC下block属性的建议写法</p>
<ul>
<li>@property (strong, nonatomic) void (^block)(void);</li>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<h3 id="对象类型数据和block交互"><a href="#对象类型数据和block交互" class="headerlink" title="对象类型数据和block交互"></a>对象类型数据和block交互</h3><p>平时我们使用<code>block</code>，对象类型来传递数据的比较多，对象类型读取到<code>block</code>中用<code>__block</code>修饰符，会把对象地址直接读取到<code>block</code>结构体内，<code>__weak</code>修饰的对象是弱引用，默认是强引用，我们看下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//FYPerson.h</div><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,assign) int age;</div><div class="line">@end</div><div class="line"></div><div class="line">//FYPerson.m</div><div class="line">@implementation FYPerson</div><div class="line">@end</div><div class="line"></div><div class="line">//main.m</div><div class="line">typedef void (^FYBlock)(void);</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;</div><div class="line">		FYBlock block ;</div><div class="line">			FYPerson *person = [[FYPerson alloc]init];</div><div class="line">			person.age = 10;</div><div class="line">		__weak typeof(person) __weakPerson = person;</div><div class="line">			block = ^&#123;</div><div class="line">				NSLog(@&quot; %d&quot;,__weakPerson.age);</div><div class="line">			&#125;;</div><div class="line">		</div><div class="line">		block();</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用下面该命令转化成<code>cpp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp</div></pre></td></tr></table></figure>
<p>摘取关键结构体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  FYPerson *__weak __weakPerson;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  FYPerson *__weak __weakPerson = __cself-&gt;__weakPerson; // bound by copy</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(&quot;age&quot;)));</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>FYPerson *__weak __weakPerson</code>是<code>__weak</code>修饰的对象<br>当block内部换成<code>block = ^{
                NSLog(@&quot; %d&quot;,person.age);
            };</code>，转换源码之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  FYPerson *__strong person;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>person</code>默认是使用<code>__storng</code>来修饰的，<code>arc</code>中，<code>block</code>引用外界变量，系统执行了<code>copy</code>操作，将<code>block</code> <code>copy</code>到堆上，由开发者自己管理，转<code>c/c++</code>中结构体描述为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;__weakPerson, (void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div></pre></td></tr></table></figure>
<p>有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数<code>void (*copy)</code>和<code>void (*dispose)</code>就是对block的引用计数的<code>+1</code>和<code>-1</code>。</p>
<p>如果block被拷贝到堆上</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li>
</ul>
<p>如果block从堆上移除</p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">copy函数</td>
<td style="text-align:center">栈上的Block复制到堆时</td>
</tr>
<tr>
<td style="text-align:center">dispose函数</td>
<td style="text-align:center">堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>person什么时间释放？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">FYPerson *person = [[FYPerson alloc]init];</div><div class="line">person.age = 10;</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;---%d&quot;,person.age);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3s后释放，<code>dispatch</code>对<code>block</code>强引用，<code>block</code>强引用<code>person</code>，在<code>block</code>释放的时候，<code>person</code>没其他的引用，就释放掉了。</p>
<p>变换1：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FYPerson *person = [[FYPerson alloc]init];</div><div class="line">person.age = 10;</div><div class="line">__weak FYPerson *__weakPerosn = person;</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;---%d&quot;,__weakPerosn.age);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>__weak</code>没有对<code>perosn</code>进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。<br>变换2：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FYPerson *person = [[FYPerson alloc]init];</div><div class="line">person.age = 10;</div><div class="line">__weak typeof(person) __weakPerson = person;</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">		NSLog(@&quot;---%d&quot;,person.age);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>person</code>被内部<code>block</code>强引用，则<code>block</code>销毁之前<code>person</code>不会释放，<code>__weakPerson</code>执行完<code>person</code>不会销毁，<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。答案是4秒之后<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。</p>
<p>变换3：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FYPerson *person = [[FYPerson alloc]init];</div><div class="line">person.age = 10;</div><div class="line">__weak typeof(person) __weakPerson = person;</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;---%d&quot;,person.age);</div><div class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">		NSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>person</code>被强引用于第一层<code>block</code>，第二层弱引用<code>person</code>，仅仅当第一层block执行完毕的时候，<code>person</code>释放。</p>
<h4 id="修改block外部变量"><a href="#修改block外部变量" class="headerlink" title="修改block外部变量"></a>修改block外部变量</h4><p>想要修改变量，首先要变量的有效区域，或者block持有变量的地址。<br>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line">FYBlock block = ^&#123;</div><div class="line">    age = 20;//会报错</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>报错的原因是<code>age</code>是值传递，想要不报错只需要将<code>int age = 10</code>改成<code>static int age = 10</code>，就由值传递变成地址传递，有了<code>age</code>的地址，在<code>block</code>的内部就可以更改<code>age</code>的值了。或者将<code>int age = 10</code>改成全局变量，全局变量在<code>block</code>中不用捕获，<code>block</code>本质会编译成<code>c</code>函数，<code>c</code>函数访问全局变量在任意地方都可以直接访问。</p>
<h4 id="block本质-1"><a href="#block本质-1" class="headerlink" title="__block本质"></a>__block本质</h4><p><code>__block</code>本质上是修饰的对象或基本类型，编译之后会生成一个结构体<code>__Block_byref_age_0</code>,结构体中<code>*__forwarding</code>指向结构体自己，通过<br><code>(age-&gt;__forwarding-&gt;age) = 20</code>来修改变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_age_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_age_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int age;//10</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_age_0 *age; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</div><div class="line">            (age-&gt;__forwarding-&gt;age) = 20;</div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age-&gt;__forwarding-&gt;age));</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><code>age</code>在<code>block</code>外部有一个，在<code>block</code>内部有一个，他们是同一个吗？我们来探究一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">typedef   void (^FYBlock)(void);</div><div class="line">struct __Block_byref_age_0 &#123;</div><div class="line">    void *__isa;</div><div class="line">    struct __Block_byref_age_0 *__forwarding;</div><div class="line">    int __flags;</div><div class="line">    int __size;</div><div class="line">    int age;//10</div><div class="line">&#125;;</div><div class="line">struct __main_block_desc_0 &#123;</div><div class="line">    size_t reserved;</div><div class="line">    size_t Block_size;</div><div class="line">    void (*copy)(void);</div><div class="line">    void (*dispose)(void);</div><div class="line">&#125;;</div><div class="line">struct __block_impl &#123;</div><div class="line">    void *isa;</div><div class="line">    int Flags;</div><div class="line">    int Reserved;</div><div class="line">    void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">    struct __block_impl impl;</div><div class="line">    struct __main_block_desc_0* Desc;</div><div class="line">    struct __Block_byref_age_0 *age; // by ref</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;</div><div class="line">	    // insert code here...</div><div class="line">	__block	int age = 10;</div><div class="line">        NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class="line">        FYBlock block = ^&#123;</div><div class="line">            age = 20;</div><div class="line">            NSLog(@&quot;age is %d&quot;,age);</div><div class="line">        &#125;;</div><div class="line">        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;</div><div class="line">        NSLog(@&quot; age1:%p age2:%p&quot;,&amp;age,&amp;(main-&gt;age-&gt;__forwarding-&gt;age));</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">输出：</div><div class="line">age1:0x7ffeefbff548</div><div class="line">age1:0x100605358 age2:0x100605358</div></pre></td></tr></table></figure>
<p>经过<code>__block</code>修饰之后，之后访问的<code>age</code>和结构体<code>__Block_byref_age_0</code>中的<code>age</code>地址是一样的，可以判定<code>age</code>被系统<code>copy</code>了一份。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__block	int age = 10;</div><div class="line">       NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class="line">       NSObject *obj=[[NSObject alloc]init];</div><div class="line">       FYBlock block = ^&#123;</div><div class="line">           </div><div class="line">           NSLog(@&quot;age is %d,obj is %p&quot;,age,&amp;obj);</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
<p>使用命令编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</div></pre></td></tr></table></figure>
<p>摘录主要函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_age_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_age_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  NSObject *__strong obj;</div><div class="line">  __Block_byref_age_0 *age; // by ref</div><div class="line">&#125;;</div><div class="line">``` </div><div class="line"></div><div class="line">`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0-&gt;__forwarding-&gt;age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。</div></pre></td></tr></table></figure>
<p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {<br>    _Block_object_assign((void<em>)&amp;dst-&gt;age, (void</em>)src-&gt;age, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>    _Block_object_assign((void<em>)&amp;dst-&gt;obj, (void</em>)src-&gt;obj, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/);}</p>
<pre><code>static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);
_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。</div><div class="line"></div><div class="line">看一下循环引用是反面教材</div></pre></td></tr></table></figure>
<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject</p>
<p>@property (nonatomic,copy) FYBlock blcok;<br>@end</p>
<p>@implementation FYPerson</p>
<ul>
<li>(void)dealloc{<br>  NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end</li>
</ul>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSLog(@” age1:%p”,&amp;age);<br>        FYPerson </em>obj=[[FYPerson alloc]init];<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;obj);<br>        }];<br>        NSLog(@”————–”);<br>    }<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输出是：</div></pre></td></tr></table></figure></p>
<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A&lt;----&gt;B`，相互引用导致执行结束应该释放的时候无法释放。</div><div class="line">将`main`改成</div></pre></td></tr></table></figure></p>
<p>FYPerson *obj=[[FYPerson alloc]init];<br>        __weak typeof(obj) weakObj = obj;<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;weakObj);<br>        }];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">结果是</div></pre></td></tr></table></figure></p>
<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br>-[FYPerson dealloc]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。</div><div class="line">#### `__weak`和`__unsafe__unretain`</div><div class="line">`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。</div><div class="line">下面我们来具体验证一下该结论：</div></pre></td></tr></table></figure></p>
<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject<br>@property (nonatomic,assign) int age ;<br>@end<br>@implementation FYPerson<br>-(void)dealloc{<br>    NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end<br>struct <strong>Block_byref_age_0 {<br>    void *</strong>isa;<br>    struct <strong>Block_byref_age_0 *</strong>forwarding;<br>    int <strong>flags;<br>    int </strong>size;<br>    int age;<br>};<br>struct <strong>block_impl {<br>    void <em>isa;<br>    int Flags;<br>    int Reserved;<br>    void </em>FuncPtr;<br>};<br>struct </strong>main_block_desc_0 {<br>    size_t reserved;<br>    size_t Block_size;<br>    void (<em>copy)(void);<br>    void (</em>dispose)(void);<br>};<br>struct <strong>main_block_impl_0 {<br>    struct </strong>block_impl impl;<br>    struct <strong>main_block_desc_0<em> Desc;<br>    FYPerson </em></strong>unsafe_unretained __unsafe_obj;<br>};</p>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        // insert code here…<br>        FYBlock block;<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            obj.age = 5;<br>            <strong>weak typeof(obj) </strong>unsafe_obj = obj;<br>            block = ^{</p>
<pre><code>            NSLog(@&quot;obj-&gt;age is %d obj:%p&quot;,__unsafe_obj.age,&amp;__unsafe_obj);
        };
        struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;
        NSLog(@&quot;inside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点1
    }
    struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;
    NSLog(@&quot;outside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点2
    block();
    NSLog(@&quot;----end------&quot;);
}
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">根据文中提示断点1处使用`lldb`打印`obj`命令</div></pre></td></tr></table></figure></p>
<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5 //年龄5还是存储在这里的<br>inside struct-&gt;obj:0x102929d80</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在断点2处再次查看`obj`的值，报错不可读取该内存</div></pre></td></tr></table></figure>
<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x0<br>p suct-&gt;__unsafe_obj-&gt;_age<br>error: Couldn’t apply expression side effects : Couldn’t dematerialize a result variable: couldn’t read its memory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。</div><div class="line">上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：</div></pre></td></tr></table></figure></p>
<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5<br>inside struct-&gt;obj:0x10078c0c0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在断点2出再次查看地址并查看`age`的值</div></pre></td></tr></table></figure>
<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x10078c0c0<br>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $1 = 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。</div><div class="line"></div><div class="line"></div><div class="line">当我们离开某个页面需要再执行的操作，那么我们改怎么办？</div><div class="line">实际应用A:</div></pre></td></tr></table></figure></p>
<p>-(void)test{<br>    <strong>weak typeof(self) </strong>weakself = self;<br>    [self setBlcok:^{<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>            NSLog(@”perosn :%p”,__weakself);<br>        });<br>    }];<br>    self.blcok();<br>}</p>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            [obj test];<br>            NSLog(@”block 执行完毕————–”);<br>        }<br>        NSLog(@”person 死了”);<br>    }<br>    return 0;<br>}<br>输出：<br>block 执行完毕————–<br>-[FYPerson dealloc]<br>person 死了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。</div><div class="line">那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：</div></pre></td></tr></table></figure></p>
<pre><code>__block typeof(self) __weakSelf = self;//__block或者没有修饰符
dispatch_async(dispatch_get_main_queue(), ^{
    sleep(2);
    NSLog(@&quot;obj:%@&quot;,__weakSelf-&gt;_obj);
});
</code></pre><p>//perosn :0x0<br>```</p>
<p>当<code>self</code>不持用<code>block</code>的时候，<code>block</code>可以强引用<code>self</code>,<code>block</code>执行完毕自己释放，也会释放<code>self</code>，当<code>self</code>持有<code>block</code>，<code>block</code>必须弱引用<code>self</code>,则释放<code>self</code>,<code>block</code>也会释放，否则会循环引用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>block</code>本质是一个封装了函数调用以及调用环境的<code>结构体</code>对象</li>
<li><code>__block</code>修饰的变量会被封装成<code>结构体</code>对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决<code>auto</code>对象在<code>block</code>内部无法修改的问题，在<code>MRC</code>环境下,<code>__block</code>不会对变量产生强引用.</li>
<li><code>block</code>不使用<code>copy</code>则不会从全局或者栈区域移动到堆上，使用<code>copy</code>之后有由发者管理</li>
<li>使用<code>block</code>要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。</li>
<li><code>__weak</code>修饰的对象，<code>block</code>不会对对象强引用，在执行<code>block</code>的时候有可能会值已经被系统置为<code>nil</code>,<code>__unsafe_unretained</code>修饰的销毁之后内存不会及时重置为空。</li>
</ul>
<p>我们看的<code>cpp</code>是编译之后的代码，<code>runtime</code>是否和我们看到的一致呢？请听下回分解。</p>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
</li>
</ul>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/0.jpeg#/images/avatar.gif"
                alt="兜兜转转"/>
            
              <p class="site-author-name" itemprop="name">兜兜转转</p>
              <div class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ifgyong" title="GitHub &rarr; https://github.com/ifgyong" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">兜兜转转</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
