<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/0.jpeg?v=7.1.0">


  <link rel="mask-icon" href="/0.jpeg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="看完本文章你将了解到   DisplayLink和timer的使用和原理 内存分配和内存管理 自动释放池原理 weak指针原理和释放时机 引用计数原理   / DisplayLinkCADisplayLink是将任务添加到runloop中，loop每次循环便会调用target的selector，使用这个也能监测卡顿问题。首先介绍下API 1234567+ (CADisplayLink *)disp">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="看完本文章你将了解到   DisplayLink和timer的使用和原理 内存分配和内存管理 自动释放池原理 weak指针原理和释放时机 引用计数原理   / DisplayLinkCADisplayLink是将任务添加到runloop中，loop每次循环便会调用target的selector，使用这个也能监测卡顿问题。首先介绍下API 1234567+ (CADisplayLink *)disp">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="og:updated_time" content="2019-12-04T04:29:00.439Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)">
<meta name="twitter:description" content="看完本文章你将了解到   DisplayLink和timer的使用和原理 内存分配和内存管理 自动释放池原理 weak指针原理和释放时机 引用计数原理   / DisplayLinkCADisplayLink是将任务添加到runloop中，loop每次循环便会调用target的selector，使用这个也能监测卡顿问题。首先介绍下API 1234567+ (CADisplayLink *)disp">
<meta name="twitter:image" content="http://fgyong.cn/images/0.png">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://fgyong.cn/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理  内存管理 那些你不知道的原理汇总 --(12) | fgyong的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    
      
    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    
      
    

    <a href="/archives/" rel="section">归档<span class="badge">43</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    

    
      
    

    <a href="/tags/" rel="section">标签<span class="badge">23</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    

    
      
    

    <a href="/categories/" rel="section">分类<span class="badge">7</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    
      
    

    <a href="/about/" rel="section">关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/ifgyong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:22:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:22:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 12:29:00" itemprop="dateModified" datetime="2019-12-04T12:29:00+08:00">2019-12-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>看完本文章你将了解到</p>
<blockquote>
<ol>
<li>DisplayLink和timer的使用和原理</li>
<li>内存分配和内存管理</li>
<li>自动释放池原理</li>
<li>weak指针原理和释放时机</li>
<li>引用计数原理</li>
</ol>
</blockquote>
<p>/</p>
<h3 id="DisplayLink"><a href="#DisplayLink" class="headerlink" title="DisplayLink"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div><div class="line">//runloop没循环一圈都会调用</div><div class="line">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class="line">//从runloop中删除</div><div class="line">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class="line">//取消</div><div class="line">- (void)invalidate;</div></pre></td></tr></table></figure>
<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) CADisplayLink *link;</div><div class="line"></div><div class="line">//初始化</div><div class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">	@synchronized (self) &#123;</div><div class="line">		NSLog(@&quot;FPS:%d&quot;,fps);</div><div class="line">		fps = 0;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">dispatch_resume(timer);</div><div class="line">//全局变量</div><div class="line">dispatch_source_t timer;</div><div class="line">static int fps;</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">	</div><div class="line">	@synchronized (self) &#123;</div><div class="line">		fps += 1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	[self.link invalidate];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</div><div class="line">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</div><div class="line">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</div></pre></td></tr></table></figure>
<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface FYTimerTarget : NSObject</div><div class="line">@property (nonatomic,weak) id target;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYTimerTarget</div><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	return self.target;</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">FYProxy *proxy=[FYProxy proxyWithTarget:self];</div><div class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 17:59:04.339934 -[ViewController test]</div><div class="line">2019-07-30 17:59:04.356292 -[ViewController test]</div><div class="line">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</div><div class="line">2019-07-30 17:59:04.371634 -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@interface FYProxy : NSProxy</div><div class="line">@property (nonatomic,weak) id target;</div><div class="line"></div><div class="line">+(instancetype)proxyWithTarget:(id)target;</div><div class="line">@end</div><div class="line">@implementation FYProxy</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</div><div class="line">	FYProxy *obj=[FYProxy alloc];</div><div class="line">	obj.target = target;</div><div class="line">	return obj;</div><div class="line">&#125;</div><div class="line">//转发</div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</div><div class="line">	[invocation invokeWithTarget:self.target];</div><div class="line">&#125;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</div><div class="line">	return [self.target methodSignatureForSelector:sel];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	return self.target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FYTimerTarget *obj =[FYTimerTarget new];</div><div class="line">obj.target = self;</div><div class="line"></div><div class="line">self.timer = [NSTimer timerWithTimeInterval:1.0f</div><div class="line">									target:obj</div><div class="line">								   selector:@selector(test)</div><div class="line">								   userInfo:nil</div><div class="line">									repeats:YES];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class="line">[self.timer setFireDate:[NSDate distantPast]];</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class="line">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class="line">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</div><div class="line">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">	NSLog(@&quot;123&quot;);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">//log</div><div class="line">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</div><div class="line">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</div><div class="line">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</div></pre></td></tr></table></figure>
<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>
<h3 id="GCD中timer"><a href="#GCD中timer" class="headerlink" title="GCD中timer"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//timer 需要强引用 或者设置成全局变量</div><div class="line">    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">    //设置</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">  //code 定时器执行的代码</div><div class="line"> </div><div class="line">    &#125;);</div><div class="line">    //开始定时器</div><div class="line">    dispatch_resume(timer);</div></pre></td></tr></table></figure>
<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_source_set_event_handler_f(timer, function_t);</div><div class="line">void function_t(void * p)&#123;</div><div class="line">    //code here    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>
<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)exeTask:(dispatch_block_t)block</div><div class="line">    	  start:(NSTimeInterval)time</div><div class="line">       interval:(NSTimeInterval)interval</div><div class="line">    	 repeat:(BOOL)repeat</div><div class="line">    	  async:(BOOL)async;</div><div class="line">+ (NSString *)exeTask:(id)target</div><div class="line">		  sel:(SEL)aciton</div><div class="line">		start:(NSTimeInterval)time</div><div class="line">	 interval:(NSTimeInterval)interval</div><div class="line">	   repeat:(BOOL)repeat</div><div class="line">		async:(BOOL)async;</div><div class="line">//取消</div><div class="line">+ (void)exeCancelTask:(NSString *)key;</div></pre></td></tr></table></figure>
<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</div><div class="line">	if (block == nil) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class="line">	//主队列</div><div class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line">	if (async) &#123;</div><div class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	&#125;</div><div class="line">	//创建定时器</div><div class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">	//设置启动时间</div><div class="line">	dispatch_source_set_timer(_timer,</div><div class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class="line">	//设定回调</div><div class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">		block();</div><div class="line">		if (repeat == NO) &#123;</div><div class="line">			dispatch_source_cancel(_timer);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	//启动定时器</div><div class="line">	dispatch_resume(_timer);</div><div class="line">	//存放到字典</div><div class="line">	if (name.length &amp;&amp; _timer) &#123;</div><div class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">		timers[name] = _timer;</div><div class="line">		dispatch_semaphore_signal(samephore);</div><div class="line">	&#125;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+ (NSString *)exeTask:(id)target</div><div class="line">				  sel:(SEL)aciton</div><div class="line">				start:(NSTimeInterval)time</div><div class="line">			 interval:(NSTimeInterval)interval</div><div class="line">			   repeat:(BOOL)repeat</div><div class="line">				async:(BOOL)async&#123;</div><div class="line">	if (target == nil || aciton == NULL) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class="line">		return nil;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class="line">	//主队列</div><div class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line">	if (async) &#123;</div><div class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">	&#125;</div><div class="line">	//创建定时器</div><div class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">	//设置启动时间</div><div class="line">	dispatch_source_set_timer(_timer,</div><div class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class="line">	//设定回调</div><div class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</div><div class="line">		//这里是会报警告的代码</div><div class="line">		if ([target respondsToSelector:aciton]) &#123;</div><div class="line">			[target performSelector:aciton];</div><div class="line">		&#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line"></div><div class="line">		if (repeat == NO) &#123;</div><div class="line">			dispatch_source_cancel(_timer);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	//启动定时器</div><div class="line">	dispatch_resume(_timer);</div><div class="line">	//存放到字典</div><div class="line">	if (name.length &amp;&amp; _timer) &#123;</div><div class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">		timers[name] = _timer;</div><div class="line">		dispatch_semaphore_signal(samephore);</div><div class="line">	&#125;</div><div class="line">	return name;</div><div class="line">&#125;</div><div class="line">+ (void)exeCancelTask:(NSString *)key&#123;</div><div class="line">	if (key.length == 0) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class="line">	if ([timers.allKeys containsObject:key]) &#123;</div><div class="line">		dispatch_source_cancel(timers[key]);</div><div class="line">		[timers removeObjectForKey:key];</div><div class="line">	&#125;</div><div class="line">	dispatch_semaphore_signal(samephore);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用的时候很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">key = [FYTimer exeTask:^&#123;</div><div class="line">        NSLog(@&quot;123&quot;);</div><div class="line">    &#125; start:1</div><div class="line">    interval:1 </div><div class="line">    repeat:YES </div><div class="line">    async:NO];</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div></pre></td></tr></table></figure>
<p>取消执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[FYTimer exeCancelTask:key];</div></pre></td></tr></table></figure>
<p>测试封装的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div><div class="line">&#125;</div><div class="line">-(void)test&#123;</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	[FYTimer exeCancelTask:key];</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</div></pre></td></tr></table></figure>
<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>
<h3 id="NSProxy实战"><a href="#NSProxy实战" class="headerlink" title="NSProxy实战"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>
<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ViewController *vc1 =[[ViewController alloc]init];</div><div class="line">FYProxy *pro1 =[FYProxy proxyWithTarget:vc1];</div><div class="line"></div><div class="line">FYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];</div><div class="line">BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</div><div class="line">BOOL ret2 = [tar isKindOfClass:ViewController.class];</div><div class="line">NSLog(@&quot;%d %d&quot;,ret1,ret2);</div></pre></td></tr></table></figure>
<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>
<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>
<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>
<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>
<p>数据段包括</p>
<ul>
<li>字符串常量：比如NSString * str = @”11”</li>
<li>已初始化数据：已初始化的全局变量、静态变量等</li>
<li>未初始化数据：未初始化的全局变量、静态变量等</li>
</ul>
<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>
<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b ;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        static int c = 20;</div><div class="line">        static int d;</div><div class="line">        int e = 10;</div><div class="line">        int f;</div><div class="line">        NSString * str = @&quot;123&quot;;</div><div class="line">        NSObject *obj =[[NSObject alloc]init];</div><div class="line">        NSLog(@&quot;\na:%p \nb:%p \nc:%p \nd:%p \ne:%p \nf:%p \nobj:%p\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">a:0x1063e0d98 </div><div class="line">b:0x1063e0e64 </div><div class="line">c:0x1063e0d9c </div><div class="line">d:0x1063e0e60 </div><div class="line">e:0x7ffee9820efc </div><div class="line">f:0x7ffee9820ef8 </div><div class="line">obj:0x6000013541a0</div><div class="line">str:0x1063e0068</div></pre></td></tr></table></figure>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static inline void * _Nonnull</div><div class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</div><div class="line">&#123;</div><div class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们拿来这个可以判断对象是否使用了优化技术。</p>
<h4 id="NSNumbe-Tagged-Pointer"><a href="#NSNumbe-Tagged-Pointer" class="headerlink" title="NSNumbe Tagged Pointer"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ //mac开发</div><div class="line">// 64-bit Mac - tag bit is LSB</div><div class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</div><div class="line">#else</div><div class="line">// Everything else - tag bit is MSB</div><div class="line">#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发</div><div class="line">#endif</div><div class="line"></div><div class="line">#if OBJC_MSB_TAGGED_POINTERS</div><div class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</div><div class="line">#else</div><div class="line">#   define _OBJC_TAG_MASK 1UL</div><div class="line">#endif</div><div class="line">bool objc_isTaggedPointer(const void * _Nullable ptr)</div><div class="line">&#123;</div><div class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</div><div class="line">&#125;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSNumber *n1 = @2;</div><div class="line">        NSNumber *n2 = @3;</div><div class="line">        NSNumber *n3 = @(4);</div><div class="line">        NSNumber *n4 = @(0x4fffffffff);</div><div class="line">        NSLog(@&quot;\n%p \n%p \n%p \n%p&quot;,n1,n2,n3,n4);</div><div class="line">        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</div><div class="line">        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</div><div class="line">        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</div><div class="line">        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</div><div class="line"></div><div class="line">        NSLog(@&quot;\nn1:%d \nn2:%d \nn3:%d \nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">0xbf4071e2657ccb95 </div><div class="line">0xbf4071e2657ccb85 </div><div class="line">0xbf4071e2657ccbf5 </div><div class="line">0xbf40751d9a833444</div><div class="line">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </div><div class="line">n1:1 </div><div class="line">n2:1 </div><div class="line">n3:1 </div><div class="line">n4:0</div></pre></td></tr></table></figure>
<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>
<h4 id="NSString-Tagged-Pointer"><a href="#NSString-Tagged-Pointer" class="headerlink" title="NSString Tagged Pointer"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)test1&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先不运行，先分析一下。</p>
<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread: EXC_BAD_ACCESS(code = 1)</div></pre></td></tr></table></figure>
<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>
<p>验证<code>NSString Tagged Pointer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)test&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">			NSLog(@&quot;test1 class:%@&quot;,self.name.class);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class="line">		dispatch_async(queue, ^&#123;</div><div class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class="line">			NSLog(@&quot;test2 class:%@&quot;,self.name.class);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">test1 class:NSTaggedPointerString</div><div class="line">test2 class:__NSCFString</div></pre></td></tr></table></figure>
<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>
<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>
<p> iOS提供了2中拷贝方法</p>
<ol>
<li>copy 拷贝出来不可变对象</li>
<li>mutableCopy 拷贝出来可变对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void test1()&#123;</div><div class="line">	NSString *str = @&quot;strstrstrstr&quot;;</div><div class="line">	NSMutableString *mut1 =[str mutableCopy];</div><div class="line">	[mut1 appendFormat:@&quot;123&quot;];</div><div class="line">	NSString *str2 = [str copy];</div><div class="line">	NSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">str:0x100001040 </div><div class="line">mut1:0x1007385f0 </div><div class="line">str2:0x100001040</div></pre></td></tr></table></figure>
<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>
<p>我们把字符串换成其他常用的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void test2()&#123;</div><div class="line">	NSArray *array = @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</div><div class="line">	NSMutableArray *mut =[array mutableCopy];</div><div class="line">	NSString *array2 = [array copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">0x102840800 </div><div class="line">0x1028408a0</div><div class="line">0x102840800</div><div class="line"></div><div class="line">void test3()&#123;</div><div class="line">	NSArray *array = [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</div><div class="line">	NSMutableArray *mut =[array mutableCopy];</div><div class="line">	NSString *array2 = [array copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">0x102808720 </div><div class="line">0x1028088a0</div><div class="line">0x1028089a0</div></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>
<p>我们再换成其他的常用的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void test4()&#123;</div><div class="line">	NSDictionary *item = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</div><div class="line">	NSMutableDictionary *mut =[item mutableCopy];</div><div class="line">	NSDictionary *item2 = [item copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line">0x1007789c0 </div><div class="line">0x100779190</div><div class="line">0x1007789c0</div><div class="line"></div><div class="line">void test5()&#123;</div><div class="line">	NSDictionary *item = [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</div><div class="line">	NSMutableDictionary *mut =[item mutableCopy];</div><div class="line">	NSDictionary *item2 = [item copy];</div><div class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">0x1007041d0 </div><div class="line">0x1007042b0</div><div class="line">0x1007043a0</div></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>
<p>由这几个看出来，总结出来下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">copy</th>
<th style="text-align:center">mutableCopy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NSString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSArray</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableArray</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSDictionary</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableDictionary</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
</tbody>
</table>
<h4 id="自定义对象实现协议NSCoping"><a href="#自定义对象实现协议NSCoping" class="headerlink" title="自定义对象实现协议NSCoping"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@protocol NSCopying</div><div class="line"></div><div class="line">- (id)copyWithZone:(nullable NSZone *)zone;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@protocol NSMutableCopying</div><div class="line"></div><div class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">@property (nonatomic,assign) int age;</div><div class="line">@property (nonatomic,assign) int level;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface FYPerson()&lt;NSCopying&gt;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FYPerson</div><div class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class="line">	FYPerson *p=[[FYPerson alloc]init];</div><div class="line">	p.age = self.age;</div><div class="line">	p.level = self.level;</div><div class="line">	return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">FYPerson *p =[[FYPerson alloc]init];</div><div class="line">p.age = 10;</div><div class="line">p.level = 11;</div><div class="line">FYPerson *p2 =[p copy];</div><div class="line">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</div><div class="line">//log</div><div class="line">10 11</div></pre></td></tr></table></figure>
<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>
<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@implementation NSObject (add)</div><div class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    Class cls = [self class];</div><div class="line">    NSObject * p=[cls new];</div><div class="line">    //成员变量个数</div><div class="line">    unsigned int count;</div><div class="line">    //赋值成员变量数组</div><div class="line">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);</div><div class="line">    //遍历数组</div><div class="line">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">        Ivar var = ivars[i];</div><div class="line">        //获取成员变量名字</div><div class="line">        const char * name = ivar_getName(var);</div><div class="line">        if (name != nil) &#123;</div><div class="line">            NSString *v = [NSString stringWithUTF8String:name];</div><div class="line">            id value = [self valueForKey:v];</div><div class="line">            //给新的对象赋值</div><div class="line">            if (value != NULL) &#123;</div><div class="line">                [p setValue:value forKey:v];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">FYPerson *p =[[FYPerson alloc]init];</div><div class="line">p.age = 10;</div><div class="line">p.level = 11;</div><div class="line">p.name = @&quot;xiaowang&quot;;</div><div class="line">FYPerson *p2 =[p copy];</div><div class="line">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</div><div class="line">		</div><div class="line">//log</div><div class="line">10 </div><div class="line">11 </div><div class="line">xiaowang</div></pre></td></tr></table></figure>
<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>
<h3 id="引用计数原理"><a href="#引用计数原理" class="headerlink" title="引用计数原理"></a>引用计数原理</h3><p>摘自<a href="https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin" target="_blank" rel="external">百度百科</a></p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>
</blockquote>
<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>
<p>在MRC中我们经常都是这样子使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FYPerson *p=[[FYPerson alloc]init];</div><div class="line">FYPerson *p2 =[p retain];</div><div class="line">//code here</div><div class="line">[p release];</div><div class="line">[p2 release];</div></pre></td></tr></table></figure>
<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>
<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>
<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//大概率x==1 提高读取指令的效率</div><div class="line">#define fastpath(x) (__builtin_expect(bool(x), 1))</div><div class="line">//大概率x==0 提高读取指令的效率</div><div class="line">#define slowpath(x) (__builtin_expect(bool(x), 0))</div><div class="line"></div><div class="line"></div><div class="line">//引用计数+1</div><div class="line">//tryRetain 尝试+1</div><div class="line">//handleOverflow 是否覆盖</div><div class="line">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</div><div class="line">&#123;</div><div class="line">	//优化的指针 返回this</div><div class="line">    if (isTaggedPointer()) return (id)this;</div><div class="line"></div><div class="line">    bool sideTableLocked = false;</div><div class="line">    bool transcribeToSideTable = false;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line">    do &#123;</div><div class="line">        transcribeToSideTable = false;</div><div class="line">		//old bits</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">		//使用联合体技术</div><div class="line">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);//nothing</div><div class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();//解锁</div><div class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</div><div class="line">			else return sidetable_retain();////sidetable 引用计数+1</div><div class="line">        &#125;</div><div class="line">        // don&apos;t check newisa.fast_rr; we already called any RR overrides</div><div class="line">		//不尝试retain 和 正在销毁 什么都不做 返回 nil</div><div class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        uintptr_t carry;</div><div class="line">		//引用计数+1 (bits.extra_rc++;)</div><div class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</div><div class="line"></div><div class="line">        if (slowpath(carry)) &#123;</div><div class="line">            // newisa.extra_rc++ 溢出处理</div><div class="line">            if (!handleOverflow) &#123;</div><div class="line">                ClearExclusive(&amp;isa.bits);</div><div class="line">                return rootRetain_overflow(tryRetain);</div><div class="line">            &#125;</div><div class="line">			//为拷贝到side table 做准备</div><div class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class="line">            sideTableLocked = true;</div><div class="line">            transcribeToSideTable = true;</div><div class="line">            newisa.extra_rc = RC_HALF;</div><div class="line">            newisa.has_sidetable_rc = true;</div><div class="line">        &#125;</div><div class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    if (slowpath(transcribeToSideTable)) &#123;</div><div class="line">		//拷贝 平外一半的 引用计数到 side table</div><div class="line">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class="line">    return (id)this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//sidetable 引用计数+1</div><div class="line">id objc_object::sidetable_retain()</div><div class="line">&#123;</div><div class="line">#if SUPPORT_NONPOINTER_ISA</div><div class="line">    assert(!isa.nonpointer);</div><div class="line">#endif</div><div class="line">	//取出table key=this</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    </div><div class="line">    table.lock();</div><div class="line">    size_t&amp; refcntStorage = table.refcnts[this];</div><div class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line"></div><div class="line">    return (id)this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>
<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</div><div class="line">&#123;</div><div class="line">    if (isTaggedPointer()) return false;//指针优化的不存在计数器</div><div class="line"></div><div class="line">    bool sideTableLocked = false;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line"> retry:</div><div class="line">    do &#123;//isa</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            if (sideTableLocked) sidetable_unlock();</div><div class="line">			//side table -1</div><div class="line">            return sidetable_release(performDealloc);</div><div class="line">        &#125;</div><div class="line">        uintptr_t carry;</div><div class="line">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</div><div class="line">        if (slowpath(carry)) &#123;</div><div class="line">            // don&apos;t ClearExclusive()</div><div class="line">            goto underflow;</div><div class="line">        &#125;</div><div class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                             oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line">    return false;</div><div class="line"></div><div class="line"> underflow:</div><div class="line">    newisa = oldisa;</div><div class="line"></div><div class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class="line">        if (!handleUnderflow) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            return rootRelease_underflow(performDealloc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!sideTableLocked) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            sidetable_lock();</div><div class="line">            sideTableLocked = true;</div><div class="line">            goto retry;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		//side table 引用计数-1</div><div class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class="line"></div><div class="line">        if (borrowed &gt; 0) &#123;</div><div class="line">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</div><div class="line">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                                oldisa.bits, newisa.bits);</div><div class="line">            if (!stored) &#123;</div><div class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class="line">                isa_t newisa2 = oldisa2;</div><div class="line">                if (newisa2.nonpointer) &#123;</div><div class="line">                    uintptr_t overflow;</div><div class="line">                    newisa2.bits = </div><div class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</div><div class="line">                    if (!overflow) &#123;</div><div class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class="line">                                                       newisa2.bits);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!stored) &#123;</div><div class="line">                // Inline update failed.</div><div class="line">                // Put the retains back in the side table.</div><div class="line">                sidetable_addExtraRC_nolock(borrowed);</div><div class="line">                goto retry;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sidetable_unlock();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Side table is empty after all. Fall-through to the dealloc path.</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//真正的销毁</div><div class="line"></div><div class="line">    if (slowpath(newisa.deallocating)) &#123;</div><div class="line">        ClearExclusive(&amp;isa.bits);</div><div class="line">        if (sideTableLocked) sidetable_unlock();</div><div class="line">        return overrelease_error();</div><div class="line">        // does not actually return</div><div class="line">    &#125;</div><div class="line">	//设置正在销毁</div><div class="line">    newisa.deallocating = true;</div><div class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</div><div class="line"></div><div class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line"></div><div class="line">    __sync_synchronize();</div><div class="line">    if (performDealloc) &#123;</div><div class="line">		//销毁</div><div class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">inline uintptr_t  objc_object::rootRetainCount()</div><div class="line">&#123;</div><div class="line">	//优化指针 直接返回</div><div class="line">    if (isTaggedPointer()) return (uintptr_t)this;</div><div class="line">//没优化则 到SideTable 读取</div><div class="line">    sidetable_lock();</div><div class="line">	//isa指针</div><div class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</div><div class="line">    ClearExclusive(&amp;isa.bits);//啥都没做</div><div class="line">    if (bits.nonpointer) &#123;//使用联合体存储更多的数据 </div><div class="line">        uintptr_t rc = 1 + bits.extra_rc;//计数数量</div><div class="line">        if (bits.has_sidetable_rc) &#123;//当大过于 联合体存储的值 则另外在SideTable读取数据</div><div class="line">	//读取table的值 相加</div><div class="line">            rc += sidetable_getExtraRC_nolock();</div><div class="line">        &#125;</div><div class="line">        sidetable_unlock();</div><div class="line">        return rc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sidetable_unlock();</div><div class="line">	//在sidetable 中存储的count</div><div class="line">    return sidetable_retainCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="external">使用联合体存储更多的数据</a>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//使用联合体</div><div class="line">size_t  objc_object::sidetable_getExtraRC_nolock()</div><div class="line">&#123;</div><div class="line">	//不是联合体技术 则报错</div><div class="line">    assert(isa.nonpointer);</div><div class="line">	//key是 this，存储了每个对象的table</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">	//找到 it 否则返回0</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class="line">    if (it == table.refcnts.end()) return 0;</div><div class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有优化的是直接读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//未使用联合体的情况，</div><div class="line">uintptr_t objc_object::sidetable_retainCount()</div><div class="line">&#123;//没有联合体存储的计数器则直接在table中取出来</div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    size_t refcnt_result = 1;</div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class="line">    if (it != table.refcnts.end()) &#123;</div><div class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    return refcnt_result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="weak指针原理"><a href="#weak指针原理" class="headerlink" title="weak指针原理"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">		//c++析构函数</div><div class="line">        bool cxx = obj-&gt;hasCxxDtor();</div><div class="line">		//关联函数</div><div class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//正在清除side table 和weakly referenced</div><div class="line">inline void </div><div class="line">objc_object::clearDeallocating()</div><div class="line">&#123;</div><div class="line">    if (slowpath(!isa.nonpointer)) &#123;</div><div class="line">        // Slow path for raw pointer isa.</div><div class="line">		//释放weak</div><div class="line">        sidetable_clearDeallocating();</div><div class="line">    &#125;</div><div class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</div><div class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</div><div class="line">		//释放weak 和引用计数</div><div class="line">        clearDeallocating_slow();</div><div class="line">    &#125;</div><div class="line">    assert(!sidetable_present());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NEVER_INLINE void</div><div class="line">objc_object::clearDeallocating_slow()</div><div class="line">&#123;</div><div class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</div><div class="line"></div><div class="line">    SideTable&amp; table = SideTables()[this];</div><div class="line">    table.lock();</div><div class="line">	//清除weak</div><div class="line">    if (isa.weakly_referenced) &#123;</div><div class="line">		//table.weak_table 弱引用表</div><div class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</div><div class="line">    &#125;</div><div class="line">	//引用计数</div><div class="line">    if (isa.has_sidetable_rc) &#123;</div><div class="line">		//擦除 this</div><div class="line">        table.refcnts.erase(this);</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>
<h3 id="Autoreleasepool-原理"><a href="#Autoreleasepool-原理" class="headerlink" title="Autoreleasepool 原理"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">		FYPerson *p = [[FYPerson alloc]init];</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line"> __AtAutoreleasePool __autoreleasepool;</div><div class="line"> FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">	__AtAutoreleasePool() &#123;//构造函数 生成结构体变量的时候调用</div><div class="line">		atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">	&#125;</div><div class="line">	~__AtAutoreleasePool() &#123;//析构函数 销毁的时候调用</div><div class="line">		objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">	&#125;</div><div class="line">	void * atautoreleasepoolobj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后将上边的代码和c++整合到一起就是这样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    __AtAutoreleasePool pool = objc_autoreleasePoolPush();</div><div class="line">    FYPerson *p = [[FYPerson alloc]init];</div><div class="line">    objc_autoreleasePoolPop(pool)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>
<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class AutoreleasePoolPage &#123;</div><div class="line">    magic_t const magic;</div><div class="line">    id *next;//下一个存放aotoreleass对象的地址</div><div class="line">    pthread_t const thread;//线程</div><div class="line">    AutoreleasePoolPage * const parent; //父节点</div><div class="line">    AutoreleasePoolPage *child;//子节点</div><div class="line">    uint32_t const depth;//深度</div><div class="line">    uint32_t hiwat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>
<ul>
<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>
<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>
<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>
<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>
<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>
</ul>
<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">extern void _objc_autoreleasePoolPrint(void);</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;//r1 = push()</div><div class="line"></div><div class="line">		FYPerson *p = [[FYPerson alloc]init];</div><div class="line">		_objc_autoreleasePoolPrint();</div><div class="line">		printf(&quot;\n--------------\n&quot;);</div><div class="line">	&#125;//pop(r1)</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line"></div><div class="line">objc[23958]: ##############</div><div class="line">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class="line">objc[23958]: 3 releases pending.</div><div class="line">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</div><div class="line">objc[23958]: [0x101000038]  ################  POOL 0x101000038</div><div class="line">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</div><div class="line">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</div><div class="line">objc[23958]: ##############</div><div class="line"></div><div class="line">--------------</div></pre></td></tr></table></figure>
<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">	@autoreleasepool &#123;//r1 = push()</div><div class="line"></div><div class="line">		FYPerson *p = [[[FYPerson alloc]init] autorelease];</div><div class="line">		FYPerson *p2 = [[[FYPerson alloc]init] autorelease];</div><div class="line">		@autoreleasepool &#123;//r1 = push()</div><div class="line">			</div><div class="line">			FYPerson *p3 = [[[FYPerson alloc]init] autorelease];</div><div class="line">			FYPerson *p4 = [[[FYPerson alloc]init] autorelease];</div><div class="line">			</div><div class="line">			_objc_autoreleasePoolPrint();</div><div class="line">			printf(&quot;\n--------------\n&quot;);</div><div class="line">		&#125;//pop(r1)</div><div class="line">	&#125;//pop(r1)</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">objc[24025]: ##############</div><div class="line">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class="line">objc[24025]: 6 releases pending.</div><div class="line">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</div><div class="line">objc[24025]: [0x100803038]  ################  POOL 0x100803038</div><div class="line">objc[24025]: [0x100803040]       0x100721580  FYPerson</div><div class="line">objc[24025]: [0x100803048]       0x100721b10  FYPerson</div><div class="line">objc[24025]: [0x100803050]  ################  POOL 0x100803050</div><div class="line">objc[24025]: [0x100803058]       0x100721390  FYPerson</div><div class="line">objc[24025]: [0x100803060]       0x100717620  FYPerson</div><div class="line">objc[24025]: ##############</div></pre></td></tr></table></figure>
<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>
<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line"> &#123;</div><div class="line">     AutoreleasePoolPage *page = hotPage();</div><div class="line">     //当有分页而且分页没有满就添加</div><div class="line">     if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">         return page-&gt;add(obj);</div><div class="line">     &#125; else if (page) &#123;</div><div class="line">         //满则新建一个page进行添加obj和设置hotpage</div><div class="line">         return autoreleaseFullPage(obj, page);</div><div class="line">     &#125; else &#123;</div><div class="line">         //没有page则新建page进行添加</div><div class="line">         return autoreleaseNoPage(obj);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//activities = 0xa0转化成二进制 0b101 0000</div><div class="line">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</div><div class="line">//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</div><div class="line"></div><div class="line">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid = Yes, activities = 0xa0, </div><div class="line">repeats = Yes, order = 2147483647, </div><div class="line">callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </div><div class="line">context = &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type = mutable-small, count = 1, </div><div class="line">values = (\n\t0 : &lt;0x7fb6dc004058&gt;\n)&#125;&#125;&quot;</div></pre></td></tr></table></figure>
<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void test()&#123;</div><div class="line">    FYPerson *p =[[FYPerson alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>
<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>
<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>
<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>
<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>
<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease
</a></li>
<li>小码哥视频</li>
<li>iOS和OS多线程与内存管理</li>
<li>iOS和macOS性能优化<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt=""></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/" rel="next" title="iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)">
                <i class="fa fa-chevron-left"></i> iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/" rel="prev" title="MVC、MVP、MVVM、分层设计浅谈 — (13)">
                MVC、MVP、MVVM、分层设计浅谈 — (13) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/0.jpeg"
                alt="fgyong"/>
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <div class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://github.com/ifgyong" title="GitHub &rarr; https://github.com/ifgyong" rel="noopener" target="_blank">GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" title="掘金 &rarr; https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" rel="noopener" target="_blank">掘金</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#DisplayLink"><span class="nav-number">1.</span> <span class="nav-text">DisplayLink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer"><span class="nav-number">2.</span> <span class="nav-text">NSTimer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD中timer"><span class="nav-number">3.</span> <span class="nav-text">GCD中timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSProxy实战"><span class="nav-number">4.</span> <span class="nav-text">NSProxy实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配"><span class="nav-number">5.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">6.</span> <span class="nav-text">Tagged Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSNumbe-Tagged-Pointer"><span class="nav-number">6.1.</span> <span class="nav-text">NSNumbe Tagged Pointer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSString-Tagged-Pointer"><span class="nav-number">6.2.</span> <span class="nav-text">NSString Tagged Pointer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">7.</span> <span class="nav-text">copy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义对象实现协议NSCoping"><span class="nav-number">7.1.</span> <span class="nav-text">自定义对象实现协议NSCoping</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数原理"><span class="nav-number">8.</span> <span class="nav-text">引用计数原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak指针原理"><span class="nav-number">9.</span> <span class="nav-text">weak指针原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autoreleasepool-原理"><span class="nav-number">10.</span> <span class="nav-text">Autoreleasepool 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">12.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料下载"><span class="nav-number">13.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">豫ICP备17045226号-1 </a>&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  
  <script src="/js/js.cookie.js?v=7.1.0"></script>
  <script src="/js/scroll-cookie.js?v=7.1.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'a7800c37057fc3ce83df',
    clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
    repo: 'ifgyong.github.io',
    owner: 'ifgyong',
    admin: ['ifgyong'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'false'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
