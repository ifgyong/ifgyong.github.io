<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/0.jpeg?v=7.1.0">


  <link rel="mask-icon" href="/0.jpeg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="今天我们再看一下Category的底层原理。 先看一下Category的简单使用，首先新增一个类的Category，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下: 1234567891011121314151617181920212223242526272829@interface FYPerson : NSObject- (void)run;@end@implement">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理 Category与关联对象本质--(4)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="今天我们再看一下Category的底层原理。 先看一下Category的简单使用，首先新增一个类的Category，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下: 1234567891011121314151617181920212223242526272829@interface FYPerson : NSObject- (void)run;@end@implement">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="og:updated_time" content="2019-12-04T04:28:47.852Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS底层原理 Category与关联对象本质--(4)">
<meta name="twitter:description" content="今天我们再看一下Category的底层原理。 先看一下Category的简单使用，首先新增一个类的Category，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下: 1234567891011121314151617181920212223242526272829@interface FYPerson : NSObject- (void)run;@end@implement">
<meta name="twitter:image" content="http://fgyong.cn/images/0.png">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://fgyong.cn/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理 Category与关联对象本质--(4) | fgyong的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    
      
    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    
      
    

    <a href="/archives/" rel="section">归档<span class="badge">43</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    

    
      
    

    <a href="/tags/" rel="section">标签<span class="badge">23</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    

    
      
    

    <a href="/categories/" rel="section">分类<span class="badge">7</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    
      
    

    <a href="/about/" rel="section">关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/ifgyong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理 Category与关联对象本质--(4)

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:14:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:14:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 12:28:47" itemprop="dateModified" datetime="2019-12-04T12:28:47+08:00">2019-12-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> 今天我们再看一下<code>Category</code>的底层原理。<br> 先看一下<code>Category</code>的简单使用，首先新增一个类的<code>Category</code>，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line">- (void)run;</div><div class="line">@end</div><div class="line">@implementation FYPerson</div><div class="line">-(void)run&#123;</div><div class="line">	NSLog(@&quot;run is run&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//类别</div><div class="line">@interface FYPerson (test)</div><div class="line">- (void)test;</div><div class="line">@end</div><div class="line">@implementation FYPerson (test)</div><div class="line">- (void)test&#123;</div><div class="line">	NSLog(@&quot;test is run&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//使用</div><div class="line">#import &quot;FYPerson.h&quot;</div><div class="line">#import &quot;FYPerson+test.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">FYPerson *person=[[FYPerson alloc]init];</div><div class="line">[person test];</div><div class="line">[person run];</div></pre></td></tr></table></figure>
<p>  类别使用就是这么简单。<br>  那么类别的本质是什么呢？类的方法是存储在什么地方呢？<br>  第一篇<a href="https://juejin.im/post/5d15887ee51d45108126d28d" target="_blank" rel="external">类的本质</a>已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体<code>fy_objc_class</code>中的<code>class_data_bits_t-&gt;data()-&gt;method_list_t</code>中的，那么类别方法也是存储在<code>method_list_t</code>和取元类对象的<code>method_list_t</code>中的。编译的时候类别编译成结构体<code>_category_t</code>,然后<code>runtime</code>在运行时动态将方法添加到<code>method_list_t</code>中。运行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp</code>进入到<code>FYPerson+test.cpp</code>内部查看编译之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">  struct _category_t &#123;</div><div class="line">	const char *name; //&quot;FYPerson&quot;</div><div class="line">	struct _class_t *cls;</div><div class="line">	const struct _method_list_t *instance_methods;</div><div class="line">	const struct _method_list_t *class_methods;</div><div class="line">	const struct _protocol_list_t *protocols;</div><div class="line">	const struct _prop_list_t *properties;</div><div class="line">&#125;;</div><div class="line">//存储 test方法</div><div class="line">static struct /*_method_list_t*/ &#123;</div><div class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</div><div class="line">	unsigned int method_count;</div><div class="line">	struct _objc_method method_list[1];</div><div class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class="line">	sizeof(_objc_method),</div><div class="line">	1,</div><div class="line">	&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_FYPerson_test_test&#125;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;</div><div class="line"></div><div class="line">//_category_t 存储FYPerson的分类的数据</div><div class="line">static struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </div><div class="line">&#123;</div><div class="line">	&quot;FYPerson&quot;,</div><div class="line">	0, // &amp;OBJC_CLASS_$_FYPerson,</div><div class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法</div><div class="line">	0,//类方法</div><div class="line">	0,//协议方法</div><div class="line">	0,//属性</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>存储在<code>_category_t</code>中的数据是什么时间加载到<code>FYPerson</code>的<code>class_data_bits_t.data</code>呢？我们探究一下，打开<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码</a>下载打开工程阅读源码找到<code>objc-os.mm</code>,通过查找函数运行顺序得到<code>_objec_init-&gt;map_images-&gt;map_images_noljock-&gt;_read_images-&gt;remethodizeClass(cls)-&gt;attachCategories(cls, cats, true /*flush caches*/)</code>，最终进入到<code>attachCategories</code>关键函数内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">  // Attach method lists and properties and protocols from categories to a class.</div><div class="line">// Assumes the categories in cats are all loaded and sorted by load order, </div><div class="line">// oldest categories first.</div><div class="line">static void </div><div class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // fixme rearrange to remove these intermediate allocations</div><div class="line">	//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">	//属性数组</div><div class="line">    property_list_t **proplists = (property_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">	//协议数组</div><div class="line">    protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int propcount = 0;</div><div class="line">    int protocount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    bool fromBundle = NO;</div><div class="line">    //最后的编译文件放到最前边</div><div class="line">    while (i--) &#123;</div><div class="line">		//取出某个分类</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line">//取出分类 的 instance方法或者class方法</div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有分类属性</div><div class="line">        property_list_t *proplist = </div><div class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">        if (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有协议方法</div><div class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">        if (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//收集了所有协议 分类方法</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">	//追加所有分类方法</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">	//释放数组</div><div class="line">    free(mlists);</div><div class="line">	//刷新该类的缓存</div><div class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">//追加所有分类属性</div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    free(proplists);//释放数组</div><div class="line">//追加所有分类协议</div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    free(protolists);//释放数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>attachCategories</code>是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到<code>rw-&gt;protocols.attachLists</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">        if (addedCount == 0) return;</div><div class="line">        if (hasArray()) &#123;</div><div class="line">            // many lists -&gt; many lists</div><div class="line">            uint32_t oldCount = array()-&gt;count;</div><div class="line">			//一共需要的数量</div><div class="line">            uint32_t newCount = oldCount + addedCount;</div><div class="line">			//分配内存 内存不够用了，需要扩容</div><div class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">			//赋值count</div><div class="line">            array()-&gt;count = newCount;</div><div class="line">			// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class="line">            memmove(array()-&gt;lists + addedCount/*指针移动到数组末尾*/, array()-&gt;lists/*数组*/,</div><div class="line">                    oldCount * sizeof(array()-&gt;lists[0])/*移动数据的大小*/);</div><div class="line">			//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class="line">            memcpy(array()-&gt;lists, addedLists, </div><div class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">			/*</div><div class="line">			图示讲解：</div><div class="line">			array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">		addedCount:3</div><div class="line">		addedLists:P-&gt;L-&gt;V</div><div class="line">			memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">			然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class="line">			P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">			 */</div><div class="line">        &#125;</div><div class="line">        else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">            // 0 lists -&gt; 1 list</div><div class="line">            list = addedLists[0];</div><div class="line">        &#125; </div><div class="line">        else &#123;</div><div class="line">            // 1 list -&gt; many lists</div><div class="line">            List* oldList = list;</div><div class="line">            uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">            uint32_t newCount = oldCount + addedCount;</div><div class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">            array()-&gt;count = newCount;</div><div class="line">            if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">            memcpy(array()-&gt;lists, addedLists, </div><div class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出来：</p>
<ol>
<li>首先通过<code>runtime</code>加载某个类的所有Category数据</li>
<li>把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边</li>
<li>将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。</li>
</ol>
<p>具体的编译顺序是project文件中-&gt;Build Phases-&gt;Complile Sources的顺序。</p>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><h4 id="load加载顺序"><a href="#load加载顺序" class="headerlink" title="+load加载顺序"></a>+load加载顺序</h4><p>每个类和分类都会加载的时候调用<code>+load</code>方法，具体是怎么调用呢？我们查看源码<code>_objc_init-&gt;load_images-&gt;call_load_methods</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void call_load_methods(void)</div><div class="line">&#123;</div><div class="line">    static bool loading = NO;</div><div class="line">    bool more_categories;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</div><div class="line">    if (loading) return;</div><div class="line">    loading = YES;</div><div class="line"></div><div class="line">    void *pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line">    do &#123;</div><div class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</div><div class="line">        //执行class+load直到完成</div><div class="line">        while (loadable_classes_used &gt; 0) &#123;</div><div class="line">            call_class_loads();</div><div class="line">        &#125;</div><div class="line">//执行Category +load 一次</div><div class="line">        // 2. Call category +loads ONCE</div><div class="line">        more_categories = call_category_loads();</div><div class="line"></div><div class="line">        // 3. Run more +loads if there are classes OR more untried categories</div><div class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</div><div class="line"></div><div class="line">    objc_autoreleasePoolPop(pool);</div><div class="line"></div><div class="line">    loading = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类<code>+load</code>在<code>Category+load</code>前边执行，当类的<code>+load</code>执行完毕然后再去执行<code>Category+load</code>,而且只有一次。<br>当class有子类的时候加载顺序呢？其实所有类都是基于<code>NSObject</code>，那么我们假设按照编译顺序加载<code>Class+load</code>，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类<code>+load</code>中的操作是第一个执行的，其他子类是按照<code>superclass-&gt;class-&gt;sonclass</code>的顺序执行的。<br>查看源码<code>_objc_init-&gt;load_images-&gt;prepare_load_methods((const headerType *)mh)-&gt;schedule_class_load</code>在<code>objc-runtime-new.mm</code>2856行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* Schedule +load for classes in this image, any un-+load-ed </div><div class="line">* superclasses in other images, and any categories in this image.</div><div class="line">**********************************************************************/</div><div class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</div><div class="line">// cls must already be connected.</div><div class="line">static void schedule_class_load(Class cls)</div><div class="line">&#123;</div><div class="line">    if (!cls) return;</div><div class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</div><div class="line"></div><div class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</div><div class="line"></div><div class="line">    // Ensure superclass-first ordering</div><div class="line">    //递归调用自己直到调用clas-&gt;self</div><div class="line">    schedule_class_load(cls-&gt;superclass);</div><div class="line">//添加class</div><div class="line">    add_class_to_loadable_list(cls);</div><div class="line">    cls-&gt;setInfo(RW_LOADED); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以了解到该函数递归调用自己，直到<code>+load</code>方法已经调用过为止，所以不管编译顺序是高低，<code>+load</code>的加载顺序始终是<code>NSObject-&gt;FYPrson-&gt;FYStudent</code>。多个类平行关系的话，按照编译顺序加载。<br>下边是稍微复杂点的类关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSObject</div><div class="line">    Person</div><div class="line">        Student</div><div class="line">NSObjet</div><div class="line">    Car</div><div class="line">        BigCar</div><div class="line">            BigOrSmallCar</div></pre></td></tr></table></figure>
<p>编译顺序是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person</div><div class="line">Student</div><div class="line">Car</div><div class="line">BigOrSmallCar</div></pre></td></tr></table></figure>
<p>那么他们<code>+load</code>的加载顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSobject-&gt;Person-&gt;Student-&gt;Car-&gt;BigCar-&gt;BigOrSmallCar</div></pre></td></tr></table></figure>
<p>看着不是很明白的 可以再看一下刚才的<code>schedule_class_load</code>函数。<br>加载成功之后，是按照<code>objc_msgsend()</code>流程发送的吗？我们进入到<code>call_class_loads</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void call_class_loads(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    // Detach current loadable list.</div><div class="line">    struct loadable_class *classes = loadable_classes;</div><div class="line">    int used = loadable_classes_used;</div><div class="line">    loadable_classes = nil;</div><div class="line">    loadable_classes_allocated = 0;</div><div class="line">    loadable_classes_used = 0;</div><div class="line">    </div><div class="line">    // Call all +loads for the detached list.</div><div class="line">    for (i = 0; i &lt; used; i++) &#123;</div><div class="line">        Class cls = classes[i].cls;</div><div class="line">        load_method_t load_method = (load_method_t)classes[i].method;</div><div class="line">        if (!cls) continue; </div><div class="line"></div><div class="line">        if (PrintLoading) &#123;</div><div class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</div><div class="line">        &#125;</div><div class="line">        (*load_method)(cls, SEL_load);</div><div class="line">    &#125;</div><div class="line">    if (classes) free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以找到<code>(*load_method)(cls, SEL_load);</code>该函数，该函数是直接使用<code>IMP</code>执行的，<code>IMP</code>就是函数地址，可以直接访问函数而不用消息的转发流程。</p>
<h4 id="initialize调用"><a href="#initialize调用" class="headerlink" title="+initialize调用"></a>+initialize调用</h4><ul>
<li>+initialize方法会在类第一次接收到消息时调用</li>
<li>先调用父类的+initialize，再调用子类的+initialize</li>
<li>先初始化父类，再初始化子类，每个类只会初始化1次</li>
</ul>
<p><code>objc</code>源码解读过程<code>objc-msg-arm64.x-&gt;objc_msgSend-&gt;objc-&gt;runtime-new-&gt;class_getinstanceMethod-&gt;lookUpImpOrNil-&gt;lookUpImpOrForward-&gt;_clas_initialize-&gt;callInitialize-&gt;objc_msgSend(cls,SEL_Initialize)</code><br>在<code>runtime-new.h</code>4819行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Method class_getInstanceMethod(Class cls, SEL sel)</div><div class="line">&#123;</div><div class="line">    if (!cls  ||  !sel) return nil;</div><div class="line"></div><div class="line">    lookUpImpOrNil(cls, sel, nil, </div><div class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class="line"></div><div class="line"></div><div class="line">    return _class_getMethod(cls, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据<code>lookUpImpOrNil</code>查看4916行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class="line">                       bool initialize, bool cache, bool resolver)</div><div class="line">&#123;</div><div class="line">    IMP imp = nil;</div><div class="line">    bool triedResolver = NO;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line"></div><div class="line">    // Optimistic cache lookup</div><div class="line">    if (cache) &#123;</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        if (imp) return imp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.lock();</div><div class="line">    checkIsKnownClass(cls);</div><div class="line"></div><div class="line">    if (!cls-&gt;isRealized()) &#123;</div><div class="line">        realizeClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">        runtimeLock.lock();</div><div class="line">      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化</div><div class="line">      &#125;</div><div class="line"> retry:    </div><div class="line">    runtimeLock.assertLocked();</div><div class="line">    imp = cache_getImp(cls, sel);</div><div class="line">    if (imp) goto done;</div><div class="line">   // Try this class&apos;s method lists.</div><div class="line">    //在本类中查找method</div><div class="line">    &#123;</div><div class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">        if (meth) &#123;</div><div class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Try superclass caches and method lists.</div><div class="line">    &#123;</div><div class="line">        unsigned attempts = unreasonableClassCount();</div><div class="line">        for (Class curClass = cls-&gt;superclass;</div><div class="line">             curClass != nil;</div><div class="line">             curClass = curClass-&gt;superclass)</div><div class="line">        &#123;</div><div class="line">            // Halt if there is a cycle in the superclass chain.</div><div class="line">            if (--attempts == 0) &#123;</div><div class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass cache.</div><div class="line">            imp = cache_getImp(curClass, sel);</div><div class="line">            if (imp) &#123;</div><div class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">                    // Found the method in a superclass. Cache it in this class.</div><div class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">                    goto done;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    // Found a forward:: entry in a superclass.</div><div class="line">                    // Stop searching, but don&apos;t cache yet; call method </div><div class="line">                    // resolver for this class first.</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass method list.</div><div class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">            if (meth) &#123;</div><div class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">                imp = meth-&gt;imp;</div><div class="line">                goto done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // No implementation found. Try method resolver once.</div><div class="line"></div><div class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_resolveMethod(cls, sel, inst);</div><div class="line">        runtimeLock.lock();</div><div class="line">        // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </div><div class="line">        // changed already. Re-do the search from scratch instead.</div><div class="line">        triedResolver = YES;</div><div class="line">        goto retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // No implementation found, and method resolver didn&apos;t help. </div><div class="line">    // Use forwarding.</div><div class="line"></div><div class="line">    imp = (IMP)_objc_msgForward_impcache;</div><div class="line">    cache_fill(cls, sel, imp, inst);</div><div class="line"></div><div class="line"> done:</div><div class="line">    runtimeLock.unlock();</div><div class="line"></div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次收到消息，cls没有初始化，则调用<code>_class_initialize</code>进行初始化<br>我们进入到<code>_class_initialize</code>内部<code>objc-initialize.mm</code>484行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">void _class_initialize(Class cls)</div><div class="line">&#123;</div><div class="line">    assert(!cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">    Class supercls;</div><div class="line">    bool reallyInitialize = NO;</div><div class="line"></div><div class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</div><div class="line">    // See note about deadlock above.</div><div class="line">    //递归调用父类是否有初始化和是否有父类</div><div class="line">    supercls = cls-&gt;superclass;</div><div class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</div><div class="line">        _class_initialize(supercls);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Try to atomically set CLS_INITIALIZING.</div><div class="line">    &#123;</div><div class="line">        monitor_locker_t lock(classInitLock);</div><div class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</div><div class="line">            cls-&gt;setInitializing();</div><div class="line">            reallyInitialize = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (reallyInitialize) &#123;</div><div class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</div><div class="line">        </div><div class="line">        // Record that we&apos;re initializing this class so we can message it.</div><div class="line">        _setThisThreadIsInitializingClass(cls);</div><div class="line"></div><div class="line">        if (MultithreadedForkChild) &#123;</div><div class="line">            // LOL JK we don&apos;t really call +initialize methods after fork().</div><div class="line">            performForkChildInitialize(cls, supercls);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // Send the +initialize message.</div><div class="line">        // Note that +initialize is sent to the superclass (again) if </div><div class="line">        // this class doesn&apos;t implement +initialize. 2157218</div><div class="line">        if (PrintInitializing) &#123;</div><div class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</div><div class="line">                         pthread_self(), cls-&gt;nameForLogging());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Exceptions: A +initialize call that throws an exception </div><div class="line">        // is deemed to be a complete and successful +initialize.</div><div class="line">        //</div><div class="line">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</div><div class="line">        // bootstrapping problem of this versus CF&apos;s call to</div><div class="line">        // objc_exception_set_functions().</div><div class="line">#if __OBJC2__</div><div class="line">        @try</div><div class="line">#endif</div><div class="line">        &#123;</div><div class="line">            callInitialize(cls);</div><div class="line"></div><div class="line">            if (PrintInitializing) &#123;</div><div class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</div><div class="line">                             pthread_self(), cls-&gt;nameForLogging());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#if __OBJC2__</div><div class="line">        @catch (...) &#123;</div><div class="line">            if (PrintInitializing) &#123;</div><div class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</div><div class="line">                             &quot;threw an exception&quot;,</div><div class="line">                             pthread_self(), cls-&gt;nameForLogging());</div><div class="line">            &#125;</div><div class="line">            @throw;</div><div class="line">        &#125;</div><div class="line">        @finally</div><div class="line">#endif</div><div class="line">        &#123;</div><div class="line">            // Done initializing.</div><div class="line">            lockAndFinishInitializing(cls, supercls);</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (cls-&gt;isInitializing()) &#123;</div><div class="line">        // We couldn&apos;t set INITIALIZING because INITIALIZING was already set.</div><div class="line">        // If this thread set it earlier, continue normally.</div><div class="line">        // If some other thread set it, block until initialize is done.</div><div class="line">        // It&apos;s ok if INITIALIZING changes to INITIALIZED while we&apos;re here, </div><div class="line">        //   because we safely check for INITIALIZED inside the lock </div><div class="line">        //   before blocking.</div><div class="line">        if (_thisThreadIsInitializingClass(cls)) &#123;</div><div class="line">            return;</div><div class="line">        &#125; else if (!MultithreadedForkChild) &#123;</div><div class="line">            waitForInitializeToComplete(cls);</div><div class="line">            return;</div><div class="line">        &#125; else &#123;</div><div class="line">            // We&apos;re on the child side of fork(), facing a class that</div><div class="line">            // was initializing by some other thread when fork() was called.</div><div class="line">            _setThisThreadIsInitializingClass(cls);</div><div class="line">            performForkChildInitialize(cls, supercls);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (cls-&gt;isInitialized()) &#123;</div><div class="line">        // Set CLS_INITIALIZING failed because someone else already </div><div class="line">        //   initialized the class. Continue normally.</div><div class="line">        // NOTE this check must come AFTER the ISINITIALIZING case.</div><div class="line">        // Otherwise: Another thread is initializing this class. ISINITIALIZED </div><div class="line">        //   is false. Skip this clause. Then the other thread finishes </div><div class="line">        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. </div><div class="line">        //   Skip the ISINITIALIZING clause. Die horribly.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else &#123;</div><div class="line">        // We shouldn&apos;t be here. </div><div class="line">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来，和<code>+load</code>方法一样，先父类后子类。然后赋值<code>reallyInitialize = YES;</code>，后边使用<code>try</code>主动调用<code>callInitialize(cls);</code>，来到<code>callInitialize(cls);</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void callInitialize(Class cls)</div><div class="line">&#123;</div><div class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</div><div class="line">    asm(&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最终还是使用<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</code>主动调用了该函数。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点<br>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>可能会被调用多次）<br>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用</p>
<p>用伪代码实现以下思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(class 没有初始化)&#123;</div><div class="line">    父类初始化</div><div class="line">    子类初始化</div><div class="line">    调用initialize</div><div class="line">&#125;</div><div class="line">如果子类没有实现initialize，则去调用父类initialize。</div></pre></td></tr></table></figure>
<p>至于子类没有实现的话是直接调用父类的<code>initialize</code>，是使用<code>objc-msgsend</code>的原因。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface FYPerson : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line">+(void)initialize&#123;</div><div class="line">	printf(&quot;\n%s&quot;,__func__);</div><div class="line"></div><div class="line">&#125;</div><div class="line">+(void)load&#123;</div><div class="line">	printf(&quot;\n%s&quot;,__func__);</div><div class="line"></div><div class="line">&#125;</div><div class="line">@interface FYPerson (test1)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">+(void)initialize&#123;</div><div class="line">	printf(&quot;\n%s&quot;,__func__);</div><div class="line"></div><div class="line">&#125;</div><div class="line">+(void)load&#123;</div><div class="line">	printf(&quot;\n%s&quot;,__func__);</div><div class="line"></div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">+[FYPerson load]</div><div class="line">+[FYPerson(test2) load]</div><div class="line">+[FYPerson(test1) load]</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>+load</code>是根据函数地址直接调用，<code>initialize</code>是通过<code>objc_msgSend</code>调用</li>
<li><code>+load</code>是runtime加载类、分类时候调用（只会调用一次）</li>
<li><code>initialize</code>是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）</li>
<li><code>+load</code>调用优先于<code>initialize</code>,子类调用<code>+load</code>之前会调用父类的<code>+load</code>，再调用分类的<code>+load</code>,分类之间先编译，先调用。</li>
<li><code>initialize</code>先初始化父类，再初始化子类（可能最终调用父类的<code>initialize</code>）</li>
</ul>
<h3 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h3><h4 id="关联对象的本质-结构体"><a href="#关联对象的本质-结构体" class="headerlink" title="关联对象的本质-结构体"></a>关联对象的本质-结构体</h4><p>继承<code>NSObject</code>是可以可以直接使用<code>@property (nonatomic,assign) int age;</code>，但是在<code>Category</code>中会报错，那么怎么实现和继承基类一样的效果呢？<br>我们查看<code>Category</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  struct _category_t &#123;</div><div class="line">	const char *name; //&quot;FYPerson&quot;</div><div class="line">	struct _class_t *cls;</div><div class="line">	const struct _method_list_t *instance_methods;</div><div class="line">	const struct _method_list_t *class_methods;</div><div class="line">	const struct _protocol_list_t *protocols;</div><div class="line">	const struct _prop_list_t *properties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>const struct _prop_list_t *properties;</code>是存储属性的，但是缺少成员变量，而我们也不能主动在<code>_category_t</code>插入<code>ivar</code>，那么我们可以使用<code>objc_setAssociatedObject</code>将属性的值存储全局的<code>AssociationsHashMap</code>中，使用的时候<code>objc_getAssociatedObject(id object, const void *key)</code>,不使用的时候删除使用<code>objc_removeAssociatedObjects</code>删除。</p>
<p>我们进入到<code>objc_setAssociatedObject</code>内部,<code>objc-references.mm</code>275行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class="line">    // retain the new value (if any) outside the lock.</div><div class="line">    ObjcAssociation old_association(0, nil);</div><div class="line">	//根据key value 处理</div><div class="line">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">		//生成一个全局的 HashMap</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">		//有value 就处理</div><div class="line">        if (new_value) &#123;</div><div class="line">            // break any existing association.</div><div class="line">//			遍历 hashMap是否有该obj</div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            if (i != associations.end()) &#123;</div><div class="line">                // secondary table exists</div><div class="line">				//有的话 更新其 value</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                if (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; else &#123;</div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // create the new association (first time).</div><div class="line">				//没有的话 赋值给 refs</div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // setting the association to nil breaks the association.</div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            if (i !=  associations.end()) &#123;</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                if (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    //删除refs </div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // release the old value (outside of the lock).</div><div class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过该函数我们了解到</p>
<ul>
<li>关联对象并不是存储在关联对象的本身内存中</li>
<li>关联对象是存储在全局统一的<code>AssociationsManager</code>管理的<code>AssociationsHashMap</code>中</li>
<li>传入value =nil，会移除该关联对线<br><code>AssociationsManager</code>其实是管理了已<code>key为id object</code>对应的<code>AssociationsHashMap</code>，<code>AssociationsHashMap</code>存储了<code>key</code>对应的<code>ObjcAssociation</code>，<code>ObjcAssociation</code>是存储了<code>value</code> 和<code>policy</code>，<code>ObjcAssociation</code>的数据结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ObjcAssociation &#123;</div><div class="line">        uintptr_t _policy;</div><div class="line">        id _value;</div><div class="line">        *****</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>具体抽象关系见下图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AssociationsManager --&gt; AssociationsHashMap --&gt; ObjectAssociationMap</div><div class="line">--&gt;void * ObjectAssociation --&gt;uintprt_t _policy ,id _value;</div></pre></td></tr></table></figure>
<p>简单来讲就是一个全局变量保存了以<code>class</code>为<code>key</code>对应的<code>AssociationsHashMap</code>，这个<code>AssociationsHashMap</code>存储了一个<code>key</code>对应的<code>ObjectAssociation</code>，<code>ObjectAssociation</code>包含了<code>value</code>和<code>_policy</code>。通过2层map保存了数据。</p>
<h4 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h4><table>
<thead>
<tr>
<th>objc_setAssociatedObject</th>
<th>obj,key,value,policy</th>
</tr>
</thead>
<tbody>
<tr>
<td>objc_getAssociatedObject</td>
<td>根据 obj 和 key获取值</td>
</tr>
<tr>
<td>void objc_removeAssociatedObjects(id object)</td>
<td>根据obj 删除关联函数</td>
</tr>
</tbody>
</table>
<p><code>objc_AssociationPolicy</code>的类型：</p>
<table>
<thead>
<tr>
<th>OBJC_ASSOCIATION_ASSIGN</th>
<th>weak 引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>非原子强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>非原子相当于copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>原子操作，相当于copy</td>
</tr>
</tbody>
</table>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (test)</div><div class="line">@property (nonatomic,assign) NSString * name;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;NSObject+test.h&quot;</div><div class="line">#import &quot;objc/runtime.h&quot;</div><div class="line">@implementation NSObject (test)</div><div class="line">-(void)setName:(NSString *)name&#123;</div><div class="line">	objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line">- (NSString *)name&#123;</div><div class="line">	return  objc_getAssociatedObject(self, @selector(name));</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">NSObject *obj =[[NSObject alloc]init];</div><div class="line">obj.name = @&quot;老弟来了&quot;;</div><div class="line">printf(&quot;%s&quot;,obj.name.UTF8String);</div><div class="line">//老弟来了</div></pre></td></tr></table></figure>
<p>这段代码我们实现了给基类添加一个成员变量<code>name</code>，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Category <code>+load</code>在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。</li>
<li>Category <code>+initialize</code>在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用<code>objc-msgsend</code>机制调用。</li>
<li>Category 可以利用<code>Associative</code>添加和读取属性的值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
</li>
</ul>
<p><img src="/images/0.png" alt=""></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 KVO和KVC本质与联系 --(3)/" rel="next" title="iOS底层原理  KVO和KVC本质与联系 --(3)">
                <i class="fa fa-chevron-left"></i> iOS底层原理  KVO和KVC本质与联系 --(3)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理  block本质 --(5)/" rel="prev" title="iOS底层原理  block本质 --(5)">
                iOS底层原理  block本质 --(5) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/0.jpeg"
                alt="fgyong"/>
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <div class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://github.com/ifgyong" title="GitHub &rarr; https://github.com/ifgyong" rel="noopener" target="_blank">GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" title="掘金 &rarr; https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" rel="noopener" target="_blank">掘金</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用顺序"><span class="nav-number">1.</span> <span class="nav-text">调用顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#load加载顺序"><span class="nav-number">1.1.</span> <span class="nav-text">+load加载顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initialize调用"><span class="nav-number">1.2.</span> <span class="nav-text">+initialize调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-number">2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">3.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联对象本质"><span class="nav-number">5.</span> <span class="nav-text">关联对象本质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关联对象的本质-结构体"><span class="nav-number">5.1.</span> <span class="nav-text">关联对象的本质-结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关联对象的使用"><span class="nav-number">5.2.</span> <span class="nav-text">关联对象的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例"><span class="nav-number">5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资料下载"><span class="nav-number">6.1.</span> <span class="nav-text">资料下载</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">豫ICP备17045226号-1 </a>&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  
  <script src="/js/js.cookie.js?v=7.1.0"></script>
  <script src="/js/scroll-cookie.js?v=7.1.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'a7800c37057fc3ce83df',
    clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
    repo: 'ifgyong.github.io',
    owner: 'ifgyong',
    admin: ['ifgyong'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'false'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
