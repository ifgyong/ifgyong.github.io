<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/0.jpeg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/0.jpeg?v=7.1.0">


  <link rel="mask-icon" href="/0.jpeg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://fgyong.cn/2019/12/01/images/9-1.png">
<meta property="og:image" content="http://fgyong.cn/2019/12/01/images/9-2.png">
<meta property="og:image" content="http://fgyong.cn/2019/12/01/images/0.png">
<meta property="og:updated_time" content="2019-12-03T05:04:59.281Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)">
<meta name="twitter:description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta name="twitter:image" content="http://fgyong.cn/2019/12/01/images/9-1.png">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9) | fgyong的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    
      
    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    
      
    

    <a href="/archives/" rel="section">归档<span class="badge">42</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    

    
      
    

    <a href="/tags/" rel="section">标签<span class="badge">22</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    

    
      
    

    <a href="/categories/" rel="section">分类<span class="badge">7</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    
      
    

    <a href="/about/" rel="section">关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/ifgyong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/0.jpeg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:19:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:19:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-03 13:04:59" itemprop="dateModified" datetime="2019-12-03T13:04:59+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>
<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int ret = 0;</div><div class="line">do &#123;</div><div class="line">    //睡眠中等待消息</div><div class="line">    int messgae = sleep_and_wait();</div><div class="line">    //处理消息</div><div class="line">    ret = process_message(messgae);</div><div class="line">&#125; while (ret == 0);</div></pre></td></tr></table></figure>
<h3 id="获取runloop"><a href="#获取runloop" class="headerlink" title="获取runloop"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</div><div class="line">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</div><div class="line"></div><div class="line">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</div><div class="line">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</div><div class="line">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</div><div class="line">NSLog(@&quot;%@&quot;,runloop1);</div><div class="line">//打印</div><div class="line">runlopp1:0x600001bc58c0 </div><div class="line">mainloop1:0x600001bc58c0 </div><div class="line">runloop2:0x6000003cc300 </div><div class="line">mainloop1:0x6000003cc300</div><div class="line"></div><div class="line">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</div></pre></td></tr></table></figure>
<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>
<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;			/* model list 锁 */</div><div class="line">    __CFPort _wakeUpPort;			// 接受 CFRunLoopWakeUp的端口</div><div class="line">    Boolean _unused;//是否使用</div><div class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class="line">    pthread_t _pthread; //线程</div><div class="line">    uint32_t _winthread;//win线程</div><div class="line">    CFMutableSetRef _commonModes; //modes</div><div class="line">    CFMutableSetRef _commonModeItems; //modeItems</div><div class="line">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class="line">    CFMutableSetRef _modes; //所有的modes</div><div class="line">    struct _block_item *_blocks_head; //待执行的block列表头部</div><div class="line">    struct _block_item *_blocks_tail; //待执行的block 尾部</div><div class="line">    CFAbsoluteTime _runTime; //runtime</div><div class="line">    CFAbsoluteTime _sleepTime; //sleeptime</div><div class="line">    CFTypeRef _counterpart; //</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过简化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    pthread_t _pthread; //线程</div><div class="line">    CFMutableSetRef _commonModes; //modes</div><div class="line">    CFMutableSetRef _commonModeItems; //modeItems</div><div class="line">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class="line">    CFMutableSetRef _modes; //所有的modes</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>
<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>
<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>
</ol>
<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过简化之后是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;//当前mode的名字</div><div class="line">    CFMutableSetRef _sources0;//souces0</div><div class="line">    CFMutableSetRef _sources1;//sources1</div><div class="line">    CFMutableArrayRef _observers;//observers</div><div class="line">    CFMutableArrayRef _timers;//timers</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>
<p><img src="../images/9-1.png" alt=""></p>
<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>
<h4 id="souces0"><a href="#souces0" class="headerlink" title="souces0"></a>souces0</h4><ul>
<li>触摸事件</li>
<li>performSelector:onThread:</li>
</ul>
<p>测试下点击事件处理源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);//此处断点</div><div class="line">&#125;</div><div class="line"></div><div class="line">(LLDB) bt //输出当前调用栈</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class="line">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</div><div class="line">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</div><div class="line">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</div><div class="line">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</div><div class="line">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</div><div class="line">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</div><div class="line">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</div><div class="line">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</div><div class="line">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</div><div class="line">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</div><div class="line">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</div><div class="line">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</div><div class="line">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</div><div class="line">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</div><div class="line">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</div><div class="line">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</div><div class="line">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>
<h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class="line">	static int count = 5;</div><div class="line">	dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class="line">	dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">		NSLog(@&quot;-------：%d \n&quot;,count++);</div><div class="line">	&#125;);</div><div class="line">	dispatch_resume(timer);</div><div class="line">	//log</div><div class="line">	(lldb) bt</div><div class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class="line">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</div><div class="line">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</div><div class="line">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</div><div class="line">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</div><div class="line">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</div><div class="line">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</div><div class="line">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</div><div class="line">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</div></pre></td></tr></table></figure>
<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</div><div class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</div></pre></td></tr></table></figure>
<p>那么这两个Mode都是在什么情况下运行的呢？</p>
<ol>
<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>
</ol>
<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="external">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>
<p>现在我们了解到：</p>
<ol>
<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>
<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>
<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>
</ol>
<h5 id="runloop切换Mode"><a href="#runloop切换Mode" class="headerlink" title="runloop切换Mode"></a>runloop切换Mode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">    switch (activity) &#123;</div><div class="line">    	case kCFRunLoopEntry:&#123;</div><div class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class="line">    		NSLog(@&quot;即将进入 mode:%@&quot;,m);</div><div class="line">    		CFRelease(m);</div><div class="line">    		break;</div><div class="line">    	&#125;</div><div class="line">    		</div><div class="line">    	case kCFRunLoopExit:</div><div class="line">    	&#123;</div><div class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class="line">    		NSLog(@&quot;即将退出 mode:%@&quot;,m);</div><div class="line">    		CFRelease(m);</div><div class="line">    		break;</div><div class="line">    	&#125;</div><div class="line">    	default:</div><div class="line">    		break;</div><div class="line">    &#125;</div><div class="line">	&#125;);</div><div class="line">	CFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</div><div class="line">	CFRelease(obs);</div><div class="line">	</div><div class="line">	//当滑动tb的时候log</div><div class="line">	</div><div class="line">即将退出 mode:kCFRunLoopDefaultMode</div><div class="line">即将进入 mode:UITrackingRunLoopMode</div><div class="line">即将退出 mode:UITrackingRunLoopMode</div><div class="line">即将进入 mode:kCFRunLoopDefaultMode</div></pre></td></tr></table></figure>
<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>
<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">//	//获取loop</div><div class="line">	CFRunLoopRef ref = CFRunLoopGetMain();</div><div class="line">	//获取obs</div><div class="line">	CFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</div><div class="line">	//添加监听</div><div class="line">	CFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</div><div class="line">	CFRelease(obs);</div><div class="line">	</div><div class="line">	</div><div class="line">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</div><div class="line">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</div><div class="line">	printf(&quot;- &quot;);</div><div class="line">	count ++;</div><div class="line">	printf(&quot;%d&quot;,count);</div><div class="line">	switch (activity) &#123;</div><div class="line">		case kCFRunLoopEntry:</div><div class="line">			printf(&quot;即将进入 \n&quot;);</div><div class="line">			count = 0;</div><div class="line">			break;</div><div class="line">		case kCFRunLoopExit:</div><div class="line">			printf(&quot;即将退出 \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopAfterWaiting:</div><div class="line">			printf(&quot;即将从休眠中唤醒 \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeTimers:</div><div class="line">			printf(&quot;即将进入处理 timers \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeSources:</div><div class="line">			printf(&quot;即将进入 sources \n&quot;);</div><div class="line">			break;</div><div class="line">		case kCFRunLoopBeforeWaiting:</div><div class="line">			printf(&quot;即将进入 休眠 \n&quot;);</div><div class="line">			count = 0;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//点击的时候 会出发loop来处理触摸事件</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">- 4即将进入处理 timers </div><div class="line">- 5即将进入 sources </div><div class="line">- 6即将进入处理 timers </div><div class="line">- 7即将进入 sources </div><div class="line">- 8即将进入处理 timers </div><div class="line">- 9即将进入 sources </div><div class="line">- 10即将进入 休眠 </div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">- 4即将进入处理 timers </div><div class="line">- 5即将进入 sources </div><div class="line">- 6即将进入 休眠 </div><div class="line">- 1即将从休眠中唤醒 </div><div class="line">- 2即将进入处理 timers </div><div class="line">- 3即将进入 sources </div><div class="line">- 4即将进入 休眠</div></pre></td></tr></table></figure>
<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>
<h5 id="RunLoop在不获取的时候不存在-获取才生成"><a href="#RunLoop在不获取的时候不存在-获取才生成" class="headerlink" title="RunLoop在不获取的时候不存在,获取才生成"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>
<p>首先看官方给的图：</p>
<p><img src="../images/9-2.png" alt=""><br>那我又整理了一个表格来更直观的了解状态运转<br>|步骤|任务|<br>|:-:|:-:|<br>|1|通知Observers:进入Loop|<br>|2|通知Observers:即将处理Timers|<br>|3|通知Observers:即将处理Sources|<br>|4|处理blocks|<br>|5|处理Source0(可能再处理Blocks)|<br>|6|如果存在Source1，跳转第8步|<br>|7|通知Observers:开始休眠|<br>|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|<br>|9|处理Blocks|<br>|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|<br>|11|通知Observers:退出Loop|</p>
<p>查看<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">runloop源码</a>中<code>runloop.c</code>2333行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div></pre></td><td class="code"><pre><div class="line">//入口函数</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line"></div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">	timeout_context-&gt;ds = timeout_timer;</div><div class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</div><div class="line">        voucher_t voucherCopy = NULL;</div><div class="line">#endif</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">#endif</div><div class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line"></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">//通知即将处理Timers</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">//通知即将处理Sources</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">//处理Blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">//处理Source0</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">	//处理Block</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	&#125;</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line"></div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">	//y判断是否有Source1</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">	//有则去 handle_msg</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">        didDispatchPortLastTime = false;</div><div class="line">//即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	//开始休眠</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line"></div><div class="line">    __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">	__CFRunLoopModeUnlock(rlm);</div><div class="line">	__CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class="line"></div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line"></div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //等待消息来唤醒当前线程</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">			</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line"></div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class="line"></div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line"></div><div class="line">        // user callouts now OK again</div><div class="line">	__CFRunLoopUnsetSleeping(rl);</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">	//结束休眠</div><div class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">//标签 handle_msg</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">		</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">			</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">	//被timer唤醒</div><div class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">	//被GCD换醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">	//处理GCD</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">	//处理Source1</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">			</div><div class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class="line"></div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            if (rls) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">		mach_msg_header_t *reply = NULL;</div><div class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">		if (NULL != reply) &#123;</div><div class="line">		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">		&#125;</div><div class="line">#endif</div><div class="line">	    &#125;</div><div class="line">            </div><div class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">        &#125;</div><div class="line">        //处理bBlock</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">//设置返回值</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        voucher_mach_msg_revert(voucherState);</div><div class="line">        os_release(voucherCopy);</div><div class="line">#endif</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过及进一步精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">//入口函数</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line"></div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	rlm-&gt;_stopped = false;</div><div class="line">	return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">//通知即将处理Timers</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">//通知即将处理Sources</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">//处理Blocks</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">//处理Source0</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">	//处理Block</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">	&#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">	//y判断是否有Source1</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class="line">	//有则去 handle_msg</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">//即将进入休眠</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">	//开始休眠</div><div class="line">	__CFRunLoopSetSleeping(rl);</div><div class="line">        do &#123;</div><div class="line">    //等待消息来唤醒当前线程</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">	//结束休眠</div><div class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">//标签 handle_msg</div><div class="line">        handle_msg:;</div><div class="line">	//被timer唤醒</div><div class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">	//被GCD换醒</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">	//处理GCD</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">	//处理Source1</div><div class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">            // Restore the previous voucher</div><div class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class="line">        &#125;</div><div class="line">        //处理bBlock</div><div class="line">	__CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">    //设置返回值</div><div class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">	    retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">	    rlm-&gt;_stopped = false;</div><div class="line">	    retVal = kCFRunLoopRunStopped;</div><div class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">	    retVal = kCFRunLoopRunFinished;</div><div class="line">	&#125;</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="external">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>
<h5 id="timer保活和多mode运行"><a href="#timer保活和多mode运行" class="headerlink" title="timer保活和多mode运行"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static int i = 0;</div><div class="line">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">	NSLog(@&quot;%d&quot;,++i);</div><div class="line">&#125;];</div><div class="line">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</div><div class="line">//timer在设置为common模式下能运行</div><div class="line">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</div><div class="line">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">//log</div><div class="line">	</div><div class="line">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</div><div class="line">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</div><div class="line">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</div><div class="line">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</div><div class="line">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</div><div class="line">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</div><div class="line">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</div><div class="line">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</div></pre></td></tr></table></figure>
<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	CFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</div><div class="line">	dispatch_source_cancel(timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>
<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>
<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class="line">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">    &#125; else &#123;</div><div class="line">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>
<h5 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </div><div class="line">                            forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>
<p>验证线程保活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) FYThread *thread;</div><div class="line"></div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class="line">	_thread.name = @&quot;test thread&quot;;</div><div class="line">	[_thread start];</div><div class="line">&#125;</div><div class="line">- (void)test &#123;</div><div class="line">//添加端口</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	[[NSRunLoop currentRunLoop] run];</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//log</div><div class="line">//注释掉添加端口代码</div><div class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">--end--</div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">执行完毕了子线程</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//注释放开的时候点击触发log</div><div class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line"></div><div class="line">-[ViewController touchesBegan:withEvent:]</div><div class="line">执行完毕了子线程</div><div class="line">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</div></pre></td></tr></table></figure>
<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>
<p>那我们测试下该线程声明周期多长？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[super viewDidLoad];</div><div class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class="line">	_thread.name = @&quot;test thread&quot;;</div><div class="line">	[_thread start];</div><div class="line">&#125;</div><div class="line">- (void)test &#123;</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	//获取obs</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	/*</div><div class="line">	 If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</div><div class="line">	 */</div><div class="line">	[[NSRunLoop currentRunLoop] run];</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//返回上页</div><div class="line">- (IBAction)popVC:(id)sender &#123;</div><div class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">-[ViewController stop]</div></pre></td></tr></table></figure>
<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>
<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BOOL shouldKeepRunning = YES; // global</div><div class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure>
<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">	//获取obs</div><div class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">	NSLog(@&quot;--start--&quot;);</div><div class="line">	self.shouldKeepRunning = YES;//默认运行</div><div class="line">	NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">	while (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">	NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class="line">&#125;</div><div class="line">//返回上页</div><div class="line">- (IBAction)popVC:(id)sender &#123;</div><div class="line">	self.shouldKeepRunning = NO;</div><div class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">//测试子线程是否还活着</div><div class="line">- (void)alive&#123;</div><div class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;</div><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">- (void)pop&#123;</div><div class="line">	[self.navigationController popViewControllerAnimated:YES];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (void)dealloc&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//log</div><div class="line"></div><div class="line">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">--end--</div><div class="line">-[ViewController dealloc]</div><div class="line">-[FYThread dealloc]</div></pre></td></tr></table></figure>
<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//停止子线程线程</div><div class="line">- (void)stop&#123;</div><div class="line">    if (self.thread == nil) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">- (void)stopThread&#123;</div><div class="line">    self.shouldKeepRunning = NO;</div><div class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc&#123;</div><div class="line">    [self stop];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) __weakSelf = self;</div><div class="line">self.thread = [[FYThread alloc]initWithBlock:^&#123;</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">    NSLog(@&quot;--start--&quot;);</div><div class="line">    __weakSelf.shouldKeepRunning = YES;//默认运行</div><div class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</div><div class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">    &#125;;</div><div class="line">    NSLog(@&quot;--end--&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>测试下崩溃了，崩溃到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (__weakSelf.shouldKeepRunning  )&#123;</div><div class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//log</div><div class="line"></div><div class="line">--start--</div><div class="line">-[ViewController stop]</div><div class="line">-[ViewController dealloc]</div><div class="line">--end--</div><div class="line">-[FYThread dealloc]</div></pre></td></tr></table></figure>
<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">runloop源码</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="external">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="external">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">libdispatch</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80" target="_blank" rel="external">thread保活c语言版本</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85" target="_blank" rel="external">thread 保活</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/" rel="next" title="iOS底层原理 runtime - super、hook、以及简单应用--(8)">
                <i class="fa fa-chevron-left"></i> iOS底层原理 runtime - super、hook、以及简单应用--(8)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/" rel="prev" title="iOS底层原理  多线程之GCD看我就够了 --(10)">
                iOS底层原理  多线程之GCD看我就够了 --(10) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/0.jpeg"
                alt="fgyong"/>
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <div class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://github.com/ifgyong" title="GitHub &rarr; https://github.com/ifgyong" rel="noopener" target="_blank">GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                  <a href="https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" title="掘金 &rarr; https://juejin.im/user/5693a77b60b2c2974cdd7f7f/posts" rel="noopener" target="_blank">掘金</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是runloop"><span class="nav-number">1.</span> <span class="nav-text">什么是runloop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取runloop"><span class="nav-number">2.</span> <span class="nav-text">获取runloop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#souces0"><span class="nav-number">2.1.</span> <span class="nav-text">souces0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Source1"><span class="nav-number">2.2.</span> <span class="nav-text">Source1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timers"><span class="nav-number">2.3.</span> <span class="nav-text">Timers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observers"><span class="nav-number">2.4.</span> <span class="nav-text">Observers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#runloop切换Mode"><span class="nav-number">2.4.1.</span> <span class="nav-text">runloop切换Mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RunLoop在不获取的时候不存在-获取才生成"><span class="nav-number">2.4.2.</span> <span class="nav-text">RunLoop在不获取的时候不存在,获取才生成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保活机制"><span class="nav-number">2.5.</span> <span class="nav-text">保活机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#timer保活和多mode运行"><span class="nav-number">2.5.1.</span> <span class="nav-text">timer保活和多mode运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程保活"><span class="nav-number">2.5.2.</span> <span class="nav-text">线程保活</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料参考"><span class="nav-number">3.</span> <span class="nav-text">资料参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料下载"><span class="nav-number">4.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">豫ICP备17045226号-1 </a>&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  
  <script src="/js/js.cookie.js?v=7.1.0"></script>
  <script src="/js/scroll-cookie.js?v=7.1.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'a7800c37057fc3ce83df',
    clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
    repo: 'ifgyong.github.io',
    owner: 'ifgyong',
    admin: ['ifgyong'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'false'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
