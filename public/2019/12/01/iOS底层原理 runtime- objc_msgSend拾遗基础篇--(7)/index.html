<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，objc_class-&amp;gt;cache_t cache是一个是缓存最近调用class的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的method_t扩容之后之后被清空。今天我们在了解runtime的消息转发机制。 基础知识OC中的方法调用，其实都是转换为objc_msgSen">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/index.html">
<meta property="og:site_name" content="兜兜转转的技术博客">
<meta property="og:description" content="arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，objc_class-&amp;gt;cache_t cache是一个是缓存最近调用class的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的method_t扩容之后之后被清空。今天我们在了解runtime的消息转发机制。 基础知识OC中的方法调用，其实都是转换为objc_msgSen">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fgyong.cn/2019/12/01/images/7-1.png">
<meta property="og:image" content="http://fgyong.cn/2019/12/01/images/0.png">
<meta property="og:updated_time" content="2019-12-03T05:03:16.790Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)">
<meta name="twitter:description" content="arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，objc_class-&amp;gt;cache_t cache是一个是缓存最近调用class的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的method_t扩容之后之后被清空。今天我们在了解runtime的消息转发机制。 基础知识OC中的方法调用，其实都是转换为objc_msgSen">
<meta name="twitter:image" content="http://fgyong.cn/2019/12/01/images/7-1.png">





  
  
  <link rel="canonical" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7) | 兜兜转转的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">兜兜转转的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不忘初心 方得始终</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="兜兜转转"/>
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兜兜转转的技术博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 11:17:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:17:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-03 13:03:16" itemprop="dateModified" datetime="2019-12-03T13:03:16+08:00">2019-12-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ol>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">objc-msg-arm64.s</div><div class="line">ENTRY _objc_msgSend</div><div class="line">b.le	LNilOrTagged //&lt;0则返回</div><div class="line">CacheLookup NORMAL //缓存查找 未命中则继续查找</div><div class="line">.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp</div><div class="line">.macro CheckMiss //miss 则跳转__objc_msgSend_uncached</div><div class="line">STATIC_ENTRY __objc_msgSend_uncached </div><div class="line">.macro MethodTableLookup//方法中查找</div><div class="line">__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class="line"></div><div class="line"></div><div class="line">objc-runtime-new.mm</div><div class="line">_class_lookupMethodAndLoadCache3</div><div class="line">lookUpImpOrForward</div><div class="line">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</div><div class="line">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</div><div class="line">_class_resolveInstanceMethod</div><div class="line">_objc_msgForward_impcache</div><div class="line"></div><div class="line"></div><div class="line">objc-msg-arm64.s</div><div class="line">STATIC_ENTRY __objc_msgForward_impcache</div><div class="line">ENTRY __objc_msgForward</div><div class="line"></div><div class="line">Core Foundation</div><div class="line">__forwarding__（不开源）</div></pre></td></tr></table></figure>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">	ENTRY _objc_msgSend // _objc_msgSend 开始</div><div class="line">	UNWIND _objc_msgSend, NoFrame</div><div class="line"></div><div class="line">	cmp	p0, #0			// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">	b.le	LNilOrTagged		// if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</div><div class="line">#else</div><div class="line">	b.eq	LReturnZero // if le == 0 -&gt;  跳转到标签  LReturnZero</div><div class="line">#endif</div><div class="line">	ldr	p13, [x0]		// p13 = isa</div><div class="line">	GetClassFromIsa_p16 p13		// p16 = class</div><div class="line">LGetIsaDone:</div><div class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</div><div class="line"></div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">LNilOrTagged:</div><div class="line">	b.eq	LReturnZero		// 如果==0 -&gt; LReturnZero</div><div class="line"></div><div class="line">	// tagged</div><div class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</div><div class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</div><div class="line">	ubfx	x11, x0, #60, #4</div><div class="line">	ldr	x16, [x10, x11, LSL #3]</div><div class="line">	adrp	x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</div><div class="line">	add	x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</div><div class="line">	cmp	x10, x16</div><div class="line">	b.ne	LGetIsaDone</div><div class="line"></div><div class="line">	// ext tagged</div><div class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</div><div class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</div><div class="line">	ubfx	x11, x0, #52, #8</div><div class="line">	ldr	x16, [x10, x11, LSL #3]</div><div class="line">	b	LGetIsaDone</div><div class="line">// SUPPORT_TAGGED_POINTERS</div><div class="line">#endif</div><div class="line"></div><div class="line">LReturnZero:</div><div class="line">	// x0 is already zero</div><div class="line">	mov	x1, #0</div><div class="line">	movi	d0, #0</div><div class="line">	movi	d1, #0</div><div class="line">	movi	d2, #0</div><div class="line">	movi	d3, #0</div><div class="line">	ret //return 返回结束掉</div><div class="line"></div><div class="line">	END_ENTRY _objc_msgSend // _objc_msgSend 结束</div></pre></td></tr></table></figure>
<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class="line">	// p1 = SEL, p16 = isa</div><div class="line">	ldp	p10, p11, [x16, #CACHE]	// p10 = buckets, p11 = occupied|mask</div><div class="line">#if !__LP64__</div><div class="line">	and	w11, w11, 0xffff	// p11 = mask</div><div class="line">#endif</div><div class="line">	and	w12, w1, w11		// x12 = _cmd &amp; mask</div><div class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</div><div class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp 命中 调用或者返回imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket 没有命中</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// wrap: p12 = first bucket, w11 = mask</div><div class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class="line">		                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class="line"></div><div class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class="line">	// The slow path may detect any corruption and halt later.</div><div class="line"></div><div class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</div><div class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</div><div class="line">	b.ne	2f			//     scan more</div><div class="line">	CacheHit $0			// call or return imp</div><div class="line">	</div><div class="line">2:	// not hit: p12 = not-hit bucket</div><div class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</div><div class="line">	cmp	p12, p10		// wrap if bucket == buckets</div><div class="line">	b.eq	3f</div><div class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</div><div class="line">	b	1b			// loop</div><div class="line"></div><div class="line">3:	// double wrap</div><div class="line">	JumpMiss $0</div><div class="line">	</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.macro CheckMiss</div><div class="line">	// miss if bucket-&gt;sel == 0</div><div class="line">.if $0 == GETIMP</div><div class="line">	cbz	p9, LGetImpMiss</div><div class="line">.elseif $0 == NORMAL</div><div class="line">	cbz	p9, __objc_msgSend_uncached</div><div class="line">.elseif $0 == LOOKUP</div><div class="line">	cbz	p9, __objc_msgLookup_uncached</div><div class="line">.else</div><div class="line">.abort oops</div><div class="line">.endif</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">STATIC_ENTRY __objc_msgSend_uncached</div><div class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class="line">MethodTableLookup</div><div class="line">TailCallFunctionPointer x17</div><div class="line">END_ENTRY __objc_msgSend_uncached</div></pre></td></tr></table></figure>
<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line">	// push frame</div><div class="line">	SignLR</div><div class="line">	stp	fp, lr, [sp, #-16]!</div><div class="line">	mov	fp, sp</div><div class="line"></div><div class="line">	// save parameter registers: x0..x8, q0..q7</div><div class="line">	sub	sp, sp, #(10*8 + 8*16)</div><div class="line">	stp	q0, q1, [sp, #(0*16)]</div><div class="line">	stp	q2, q3, [sp, #(2*16)]</div><div class="line">	stp	q4, q5, [sp, #(4*16)]</div><div class="line">	stp	q6, q7, [sp, #(6*16)]</div><div class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">	str	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">	// receiver and selector already in x0 and x1</div><div class="line">	mov	x2, x16</div><div class="line">	bl	__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class="line"></div><div class="line">	// IMP in x0</div><div class="line">	mov	x17, x0</div><div class="line">	</div><div class="line">	// restore registers and return</div><div class="line">	ldp	q0, q1, [sp, #(0*16)]</div><div class="line">	ldp	q2, q3, [sp, #(2*16)]</div><div class="line">	ldp	q4, q5, [sp, #(4*16)]</div><div class="line">	ldp	q6, q7, [sp, #(6*16)]</div><div class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</div><div class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</div><div class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</div><div class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</div><div class="line">	ldr	x8,     [sp, #(8*16+8*8)]</div><div class="line"></div><div class="line">	mov	sp, fp</div><div class="line">	ldp	fp, lr, [sp], #16</div><div class="line">	AuthenticateLR</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* lookUpImpOrForward.</div><div class="line">* initialize==NO 尽量避免调用，有时可能也会调用。</div><div class="line">* cache==NO 跳过缓存查找，其他地方可能会不调过</div><div class="line">* 大多数人会传值 initialize==YES and cache==YES</div><div class="line">*   如果cls是非初始化的元类，则非Non-nil会快点</div><div class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class="line">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</div><div class="line">**********************************************************************/</div><div class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class="line">                       bool initialize, bool cache, bool resolver)</div><div class="line">&#123;</div><div class="line">    IMP imp = nil;</div><div class="line">    bool triedResolver = NO;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line">    // Optimistic cache lookup</div><div class="line">    if (cache) &#123; //从汇编过来是NO</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        if (imp) return imp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    runtimeLock.lock();</div><div class="line">    checkIsKnownClass(cls);</div><div class="line"></div><div class="line">    if (!cls-&gt;isRealized()) &#123;</div><div class="line">        realizeClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">		//当cls需要初始化和没有初始化的时候 进行cls初始化，</div><div class="line">		//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</div><div class="line">		//数据的大小最小是4，扩容规则是：n*2+1;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">        runtimeLock.lock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line"> retry:    </div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">//再次获取imp</div><div class="line">    imp = cache_getImp(cls, sel);</div><div class="line">    if (imp) goto done;</div><div class="line"></div><div class="line">    //尝试在本类中查找method</div><div class="line">    &#123;//从cls-&gt;data()-&gt;methods查找method</div><div class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">        if (meth) &#123;//找到添加到cache中</div><div class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Try superclass caches and method lists.</div><div class="line">	//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</div><div class="line">    &#123;</div><div class="line">        unsigned attempts = unreasonableClassCount();</div><div class="line">        for (Class curClass = cls-&gt;superclass;</div><div class="line">             curClass != nil;</div><div class="line">             curClass = curClass-&gt;superclass)</div><div class="line">        &#123;</div><div class="line">            // Halt if there is a cycle in the superclass chain.</div><div class="line">            if (--attempts == 0) &#123;</div><div class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass cache.</div><div class="line">            imp = cache_getImp(curClass, sel);</div><div class="line">            if (imp) &#123;</div><div class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">                    // Found the method in a superclass. Cache it in this class.</div><div class="line">					//将父类添加到 子类的缓存中</div><div class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">                    goto done;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    // Found a forward:: entry in a superclass.</div><div class="line">                    // Stop searching, but don&apos;t cache yet; call method </div><div class="line">                    // resolver for this class first.</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Superclass method list.</div><div class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">            if (meth) &#123;</div><div class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">                imp = meth-&gt;imp;</div><div class="line">                goto done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//如果还没有找到imp，进入动态方法解析阶段</div><div class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        runtimeLock.unlock();</div><div class="line">        _class_resolveMethod(cls, sel, inst);</div><div class="line">        runtimeLock.lock();</div><div class="line">        triedResolver = YES;</div><div class="line">        goto retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果没找到resolveInstanceMethod 和resolveClassMethod，</div><div class="line">//	进行消息转发 阶段</div><div class="line">    imp = (IMP)_objc_msgForward_impcache;</div><div class="line">	//填充 cache</div><div class="line">    cache_fill(cls, sel, imp, inst);</div><div class="line"> done:</div><div class="line">    runtimeLock.unlock();</div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </div><div class="line">// field as an index into a class table.</div><div class="line">// Note, keep this in sync with any .s files which also define it.</div><div class="line">// Be sure to edit objc-abi.h as well.</div><div class="line">// __ARM_ARCH_7K__ 处理器架构指令集版本</div><div class="line">//__arm64__ 架构</div><div class="line">//__LP64__ uinx 和uinx  mac os</div><div class="line">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</div><div class="line">#   define SUPPORT_INDEXED_ISA 1</div><div class="line">#else</div><div class="line">#   define SUPPORT_INDEXED_ISA 0</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>
<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>
<p>借用网上找一个图， 可以更直观的看出流程运转。</p>
<p><img src="../images/7-1.png" alt=""></p>
<h4 id="realizeClass-解析"><a href="#realizeClass-解析" class="headerlink" title="realizeClass()解析"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* realizeClass</div><div class="line"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</div><div class="line"> runtimelock 必须有调用者把写入锁锁起来</div><div class="line">**********************************************************************/</div><div class="line">static Class realizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line">    class_rw_t *rw;</div><div class="line">    Class supercls;</div><div class="line">    Class metacls;</div><div class="line">    bool isMeta;</div><div class="line"></div><div class="line">    if (!cls) return nil;</div><div class="line">    if (cls-&gt;isRealized()) return cls;</div><div class="line">    assert(cls == remapClass(cls));</div><div class="line"></div><div class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class="line">//首先将tw赋值给to，因为数据结构一样可以直接强制转化</div><div class="line">    ro = (const class_ro_t *)cls-&gt;data();</div><div class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</div><div class="line">        rw = cls-&gt;data();</div><div class="line">        ro = cls-&gt;data()-&gt;ro;</div><div class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 正常情况下 申请class_rw_t空间</div><div class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class="line">        rw-&gt;ro = ro;//cls-&gt;rw-&gt;ro 指向现在的ro</div><div class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1</div><div class="line">        cls-&gt;setData(rw);//赋值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isMeta = ro-&gt;flags &amp; RO_META;//是否是元类</div><div class="line">	</div><div class="line"></div><div class="line">    rw-&gt;version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0</div><div class="line"></div><div class="line"></div><div class="line">    // Choose an index for this class.</div><div class="line">//设置cls的索引</div><div class="line">	cls-&gt;chooseClassArrayIndex();</div><div class="line"></div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        _objc_inform(&quot;CLASS: realizing class &apos;%s&apos;%s %p %p #%u&quot;, </div><div class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </div><div class="line">                     (void*)cls, ro, cls-&gt;classArrayIndex());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果父类没有初始化则进行初始化</div><div class="line">    // root_class 做完需要设置RW_REALIZED=1，</div><div class="line">    // root metaclasses 需要执行完.</div><div class="line">	//从NXMapTable 获取cls ，然后进行初始化</div><div class="line">	//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</div><div class="line">    supercls = realizeClass(remapClass(cls-&gt;superclass));</div><div class="line">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</div><div class="line">//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。</div><div class="line">#if SUPPORT_NONPOINTER_ISA</div><div class="line">    // Disable non-pointer isa for some classes and/or platforms.</div><div class="line">    // Set instancesRequireRawIsa.</div><div class="line">    bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</div><div class="line">    bool rawIsaIsInherited = false;</div><div class="line">    static bool hackedDispatch = false;</div><div class="line"></div><div class="line">    if (DisableNonpointerIsa) &#123;</div><div class="line">        // Non-pointer isa disabled by environment or app SDK version</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">    &#125;</div><div class="line">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </div><div class="line">             0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)) </div><div class="line">    &#123;</div><div class="line">        // hack for libdispatch et al - isa also acts as vtable pointer</div><div class="line">        hackedDispatch = true;</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">    &#125;</div><div class="line">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </div><div class="line">             supercls-&gt;instancesRequireRawIsa()) </div><div class="line">    &#123;</div><div class="line">        // This is also propagated by addSubclass() </div><div class="line">        // but nonpointer isa setup needs it earlier.</div><div class="line">        // Special case: instancesRequireRawIsa does not propagate </div><div class="line">        // from root class to root metaclass</div><div class="line">        instancesRequireRawIsa = true;</div><div class="line">        rawIsaIsInherited = true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (instancesRequireRawIsa) &#123;</div><div class="line">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</div><div class="line">    &#125;</div><div class="line">// SUPPORT_NONPOINTER_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line">    // Update superclass and metaclass in case of remapping</div><div class="line">    cls-&gt;superclass = supercls;</div><div class="line">    cls-&gt;initClassIsa(metacls);</div><div class="line"></div><div class="line">	// 协调实例变量偏移/布局</div><div class="line">	//可能重新申请空间 class_ro_t,更新我们的class_ro_t</div><div class="line">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</div><div class="line"></div><div class="line">    // 设置setInstanceSize 从ro-&gt;instanceSize</div><div class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</div><div class="line"></div><div class="line">	//拷贝flags 从ro到rw中</div><div class="line">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</div><div class="line">        cls-&gt;setHasCxxDtor();</div><div class="line">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</div><div class="line">            cls-&gt;setHasCxxCtor();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//添加superclass指针</div><div class="line">    if (supercls) &#123;</div><div class="line">        addSubclass(supercls, cls);</div><div class="line">    &#125; else &#123;</div><div class="line">        addRootClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attach categories</div><div class="line">	//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</div><div class="line">    methodizeClass(cls);</div><div class="line"></div><div class="line">    return cls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* methodizeClass</div><div class="line"> 修复cls方法列表想，协议列表和属性列表</div><div class="line">* 加锁</div><div class="line">**********************************************************************/</div><div class="line">static void methodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    runtimeLock.assertLocked();</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line">    auto ro = rw-&gt;ro;</div><div class="line"></div><div class="line">    // Methodizing for the first time</div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        _objc_inform(&quot;CLASS: methodizing class &apos;%s&apos; %s&quot;, </div><div class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//方法列表</div><div class="line">    method_list_t *list = ro-&gt;baseMethods();</div><div class="line">    if (list) &#123;</div><div class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</div><div class="line">	//将对象的方法追加到cls-&gt;rw-&gt;methods后面</div><div class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class="line">    if (proplist) &#123;</div><div class="line">	//将对象的属性追加到rw-&gt;properties后面</div><div class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class="line">    if (protolist) &#123;</div><div class="line">	//将对象的协议追加到rw-&gt;protocols后面</div><div class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Root classes get bonus method implementations if they don&apos;t have </div><div class="line">    // them already. These apply before category replacements.</div><div class="line">    if (cls-&gt;isRootMetaclass()) &#123;</div><div class="line">        // root metaclass</div><div class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attach categories.</div><div class="line">	//类别 从全局NXMapTable *category_map 已经加载过了。</div><div class="line">    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);</div><div class="line">	//收集所有的cats到cls -&gt; rw中</div><div class="line">    attachCategories(cls, cats, false /*don&apos;t flush caches*/);</div><div class="line"></div><div class="line">    if (PrintConnecting) &#123;</div><div class="line">        if (cats) &#123;</div><div class="line">            for (uint32_t i = 0; i &lt; cats-&gt;count; i++) &#123;</div><div class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </div><div class="line">                             isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (cats) free(cats);//释放cats</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">    // Debug: sanity-check all SELs; log method list contents</div><div class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</div><div class="line">        if (PrintConnecting) &#123;</div><div class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</div><div class="line">        &#125;</div><div class="line">        assert(sel_registerName(sel_getName(meth.name)) == meth.name); </div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="attachCategories-解析"><a href="#attachCategories-解析" class="headerlink" title="attachCategories()解析"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // fixme rearrange to remove these intermediate allocations</div><div class="line">	//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">	//属性数组</div><div class="line">    property_list_t **proplists = (property_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">	//协议数组</div><div class="line">    protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int propcount = 0;</div><div class="line">    int protocount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    bool fromBundle = NO;</div><div class="line">    while (i--) &#123;</div><div class="line">		//取出某个分类</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line">//取出分类 的 instance方法或者class方法</div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有分类属性</div><div class="line">        property_list_t *proplist = </div><div class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">        if (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line">//proplist 接受所有协议方法</div><div class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">        if (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//收集了所有协议 分类方法</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">	//追加所有分类方法</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">	//释放数组</div><div class="line">    free(mlists);</div><div class="line">	//刷新该类的缓存</div><div class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">//追加所有分类属性</div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    free(proplists);//释放数组</div><div class="line">//追加所有分类协议</div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    free(protolists);//释放数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="rw-gt-list-gt-attachLists-解析"><a href="#rw-gt-list-gt-attachLists-解析" class="headerlink" title="rw-&gt;list-&gt;attachLists()解析"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">       if (addedCount == 0) return;</div><div class="line"></div><div class="line">       if (hasArray()) &#123;</div><div class="line">           // many lists -&gt; many lists</div><div class="line">           uint32_t oldCount = array()-&gt;count;</div><div class="line">		//一共需要的数量</div><div class="line">           uint32_t newCount = oldCount + addedCount;</div><div class="line">		//分配内存 内存不够用了，需要扩容</div><div class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">		//赋值count</div><div class="line">           array()-&gt;count = newCount;</div><div class="line">		// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class="line">           memmove(array()-&gt;lists + addedCount/*数组末尾*/, array()-&gt;lists/*数组*/,</div><div class="line">                   oldCount * sizeof(array()-&gt;lists[0])/*移动的大小*/);</div><div class="line">		//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class="line">           memcpy(array()-&gt;lists, addedLists, </div><div class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">		/*</div><div class="line">		图示讲解：</div><div class="line">		array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">	addedCount:3</div><div class="line">	addedLists:P-&gt;L-&gt;V</div><div class="line">		memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">		然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class="line">		P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class="line">		 */</div><div class="line">       &#125;</div><div class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">           // 0 lists -&gt; 1 list</div><div class="line">           list = addedLists[0];</div><div class="line">       &#125; </div><div class="line">       else &#123;</div><div class="line">           // 1 list -&gt; many lists</div><div class="line">           List* oldList = list;</div><div class="line">           uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">           uint32_t newCount = oldCount + addedCount;</div><div class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">           array()-&gt;count = newCount;</div><div class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">           memcpy(array()-&gt;lists, addedLists, </div><div class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>
<h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_resolveMethod</div><div class="line">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</div><div class="line">* 如果存在了则不检查</div><div class="line">**********************************************************************/</div><div class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    if (! cls-&gt;isMetaClass()) &#123;//不是元类则调用 实例的</div><div class="line">	//首先调用</div><div class="line">		_class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // try [nonMetaClass resolveClassMethod:sel]</div><div class="line">        // and [cls resolveInstanceMethod:sel]</div><div class="line">		//寻找classMethod</div><div class="line">        _class_resolveClassMethod(cls, sel, inst);</div><div class="line">        if (!lookUpImpOrNil(cls, sel, inst, </div><div class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">        &#123;</div><div class="line">            _class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_resolveInstanceMethod</div><div class="line">* 调用 class添加的函数 +resolveInstanceMethod</div><div class="line">* 有可能是元类</div><div class="line">* 如果方法存在则不检查</div><div class="line">**********************************************************************/</div><div class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </div><div class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">    &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class="line"></div><div class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class="line">        if (imp) &#123;</div><div class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class="line">                         &quot;dynamically resolved to %p&quot;, </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Method resolver didn&apos;t add anything?</div><div class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</div><div class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    assert(cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </div><div class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">    &#123;</div><div class="line">        // Resolver not implemented.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class="line">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </div><div class="line">                        SEL_resolveClassMethod, sel);</div><div class="line"></div><div class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class="line"></div><div class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class="line">        if (imp) &#123;</div><div class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class="line">                         &quot;dynamically resolved to %p&quot;, </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Method resolver didn&apos;t add anything?</div><div class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</div><div class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态解析至此完成。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">STATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache</div><div class="line">	// No stret specialization.</div><div class="line">	b	__objc_msgForward//跳转-&gt;__objc_msgForward</div><div class="line">	END_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache</div><div class="line"></div><div class="line">	</div><div class="line">	ENTRY __objc_msgForward // 开始 __objc_msgForward</div><div class="line"></div><div class="line">	adrp	x17, __objc_forward_handler@PAGE</div><div class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和</div><div class="line">	TailCallFunctionPointer x17 //跳转-&gt; TailCallFunctionPointer</div><div class="line"></div><div class="line">	END_ENTRY __objc_msgForward//结束 __objc_msgForward</div></pre></td></tr></table></figure>
<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__attribute__((noreturn)) void </div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>
<p>网上有大神总结的点我们先参考下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">// 伪代码</div><div class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</div><div class="line">    id receiver = *(id *)frameStackPointer;</div><div class="line">    SEL sel = *(SEL *)(frameStackPointer + 8);</div><div class="line">    const char *selName = sel_getName(sel);</div><div class="line">    Class receiverClass = object_getClass(receiver);</div><div class="line"></div><div class="line">    // 调用 forwardingTargetForSelector:</div><div class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</div><div class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</div><div class="line">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</div><div class="line">            if (isStret == 1) &#123;</div><div class="line">                int ret;</div><div class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</div><div class="line">                return ret;</div><div class="line">            &#125;</div><div class="line">            return objc_msgSend(forwardingTarget, sel, ...);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 僵尸对象</div><div class="line">    const char *className = class_getName(receiverClass);</div><div class="line">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</div><div class="line">    size_t prefixLen = strlen(zombiePrefix); // 0xa</div><div class="line">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</div><div class="line">        CFLog(kCFLogLevelError,</div><div class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</div><div class="line">              className + prefixLen,</div><div class="line">              selName,</div><div class="line">              receiver);</div><div class="line">        &lt;breakpoint-interrupt&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</div><div class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</div><div class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</div><div class="line">        if (methodSignature) &#123;</div><div class="line">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</div><div class="line">            if (signatureIsStret != isStret) &#123;</div><div class="line">                CFLog(kCFLogLevelWarning ,</div><div class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</div><div class="line">                      selName,</div><div class="line">                      signatureIsStret ? &quot;&quot; : not,</div><div class="line">                      isStret ? &quot;&quot; : not);</div><div class="line">            &#125;</div><div class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</div><div class="line">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</div><div class="line"></div><div class="line">                [receiver forwardInvocation:invocation];</div><div class="line"></div><div class="line">                void *returnValue = NULL;</div><div class="line">                [invocation getReturnValue:&amp;value];</div><div class="line">                return returnValue;</div><div class="line">            &#125; else &#123;</div><div class="line">                CFLog(kCFLogLevelWarning ,</div><div class="line">                      @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;,</div><div class="line">                      receiver,</div><div class="line">                      className);</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SEL *registeredSel = sel_getUid(selName);</div><div class="line"></div><div class="line">    // selector 是否已经在 Runtime 注册过</div><div class="line">    if (sel != registeredSel) &#123;</div><div class="line">        CFLog(kCFLogLevelWarning ,</div><div class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;,</div><div class="line">              sel,</div><div class="line">              selName,</div><div class="line">              registeredSel);</div><div class="line">    &#125; // doesNotRecognizeSelector</div><div class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</div><div class="line">        [receiver doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        CFLog(kCFLogLevelWarning ,</div><div class="line">              @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement doesNotRecognizeSelector: -- abort&quot;,</div><div class="line">              receiver,</div><div class="line">              className);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // The point of no return.</div><div class="line">    kill(getpid(), 9);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="验证动态解析"><a href="#验证动态解析" class="headerlink" title="验证动态解析"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (void)test;</div><div class="line">@end</div><div class="line">@implementation Person</div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	if (sel == @selector(test)) &#123;</div><div class="line">		Method me = class_getInstanceMethod(self, @selector(test2));</div><div class="line">		class_addMethod(self, sel,</div><div class="line">						method_getImplementation(me),</div><div class="line">						method_getTypeEncoding(me));</div><div class="line">		return YES;</div><div class="line">	&#125;</div><div class="line">	return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">-(void)test2&#123;</div><div class="line">	NSLog(@&quot;来了，老弟&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">Person *p = [[Person alloc]init];</div><div class="line">[p test];</div><div class="line">[p test];</div><div class="line"> //输出</div><div class="line">+[FYPerson resolveInstanceMethod:]</div><div class="line"> -[FYPerson test3]</div><div class="line"> -[FYPerson test3]</div></pre></td></tr></table></figure>
<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>
<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">+ (void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">+ (void)test3&#123;</div><div class="line">	NSLog(@&quot;来了，老弟&quot;);</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">	if (sel == @selector(test)) &#123;</div><div class="line">		Method me = class_getClassMethod(self, @selector(test3));//获取method</div><div class="line">		//给sel 添加方法实现 @selecter(test3)</div><div class="line">		class_addMethod(object_getClass(self), sel,</div><div class="line">						method_getImplementation(me),</div><div class="line">						method_getTypeEncoding(me));</div><div class="line">		return YES;</div><div class="line">	&#125;</div><div class="line">	return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">[Person test];</div><div class="line"></div><div class="line">//输出</div><div class="line">+[Person resolveClassMethod:]</div><div class="line">来了，老弟</div></pre></td></tr></table></figure>
<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    if (sel == @selector(test)) &#123;</div><div class="line">//        Method me = class_getInstanceMethod(self, @selector(test3));</div><div class="line">//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</div><div class="line">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">void test3(id self,SEL sel)&#123;</div><div class="line">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">+[FYPerson resolveInstanceMethod:]</div><div class="line">test3:test</div><div class="line">test3:test</div></pre></td></tr></table></figure>
<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>
<h3 id="验证消息转发"><a href="#验证消息转发" class="headerlink" title="验证消息转发"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Student.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [[Struent alloc]init];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">//输出</div><div class="line">-[Student test]</div></pre></td></tr></table></figure>
<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>
<p>第一步没拦截，可以在第二步拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//消息转发第二步 没有对象来处理方法，那将函数签名来实现</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	if (aSelector == @selector(test)) &#123;</div><div class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class="line">		return sign;</div><div class="line">	&#125;</div><div class="line">	return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">// 函数签名已返回，到了函数调用的地方</div><div class="line">//selector 函数的sel</div><div class="line">//target   函数调用者</div><div class="line">//methodSignature 函数签名</div><div class="line">//NSInvocation  封装数据的对象</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">-[Person forwardInvocation:]</div></pre></td></tr></table></figure></p>
<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, retain) NSMethodSignature *methodSignature;//只读</div><div class="line">- (void)retainArguments;</div><div class="line">@property (readonly) BOOL argumentsRetained;</div><div class="line">@property (nullable, assign) id target;//读写</div><div class="line">@property SEL selector;//读写</div></pre></td></tr></table></figure>
<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//class 转发</div><div class="line">// 消息转发第一步 拦截是否有转发的class对象处理方法</div><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [Student class];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)test3&#123;</div><div class="line">//	NSLog(@&quot;+[Student test3]&quot;);</div><div class="line">//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错</div><div class="line">//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</div><div class="line">//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</div><div class="line">&#125;</div><div class="line">- (void)test2&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 输出</div><div class="line">-[Student test2]</div></pre></td></tr></table></figure>
<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		//objc_msgSend([[Struent alloc]init],test)</div><div class="line">		return [[Student alloc]init];</div><div class="line">	&#125;</div><div class="line">	return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test3&#123;</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">-[Student test3]</div></pre></td></tr></table></figure>
<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//消息转发第二步 没有class来处理方法，那将函数签名来实现</div><div class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	if (aSelector == @selector(test3)) &#123;</div><div class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class="line">		return sign;</div><div class="line">	&#125;</div><div class="line">	return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">// 函数签名已返回，到了函数调用的地方</div><div class="line">//selector 函数的sel</div><div class="line">//target   函数调用者</div><div class="line">//methodSignature 函数签名</div><div class="line">//NSInvocation  封装数据的对象</div><div class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">//	anInvocation.selector = @selector(test2);</div><div class="line">//此处换成[Student class]同样可以</div><div class="line">//	anInvocation.target = (id)[[Student alloc]init];</div><div class="line"></div><div class="line">//	[anInvocation invoke];</div><div class="line">	NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">+[Person forwardInvocation:]</div></pre></td></tr></table></figure>
<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>
<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>
<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>
<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>
<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="external">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="external">demo code</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="external">runtime可运行的源码</a></li>
</ul>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="../images/0.png" alt=""></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/" rel="next" title="iOS底层原理 runtime-object_class拾遗基础篇--(6)">
                <i class="fa fa-chevron-left"></i> iOS底层原理 runtime-object_class拾遗基础篇--(6)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/" rel="prev" title="iOS底层原理 runtime - super、hook、以及简单应用--(8)">
                iOS底层原理 runtime - super、hook、以及简单应用--(8) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">兜兜转转</p>
              <div class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息发送"><span class="nav-number"></span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#realizeClass-解析"><span class="nav-number">1.</span> <span class="nav-text">realizeClass()解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#attachCategories-解析"><span class="nav-number">2.</span> <span class="nav-text">attachCategories()解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rw-gt-list-gt-attachLists-解析"><span class="nav-number">3.</span> <span class="nav-text">rw->list->attachLists()解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息动态解析"><span class="nav-number"></span> <span class="nav-text">消息动态解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发"><span class="nav-number"></span> <span class="nav-text">消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证动态解析"><span class="nav-number"></span> <span class="nav-text">验证动态解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证消息转发"><span class="nav-number"></span> <span class="nav-text">验证消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number"></span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资料下载"><span class="nav-number">1.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">兜兜转转</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
