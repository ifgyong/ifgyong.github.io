<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:type" content="website">
<meta property="og:title" content="fgyong的技术博客">
<meta property="og:url" content="http://fgyong.cn/page/2/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fgyong的技术博客">
<meta name="twitter:description" content="在学习的路上，不忘初心 方得始终">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml">




  <link rel="canonical" href="http://fgyong.cn/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不忘初心 方得始终</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理 runtime-object_class拾遗基础篇--(6)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:16:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:16:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="runtime-基础知识"><a href="#runtime-基础知识" class="headerlink" title="runtime 基础知识"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line">    // getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    //****</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;isa.h&quot;</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  // defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                         </span><br><span class="line">      uintptr_t nonpointer        : 1;                              </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                 </span><br><span class="line">      uintptr_t nonpointer        : 1;                                  </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span><br><span class="line"># else</span><br><span class="line">#   error unknown architecture for packed isa</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure>
<p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    struct &#123;</span><br><span class="line">      uintptr_t nonpointer        : 1;                                </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p>
<h4 id="共用体基础知识"><a href="#共用体基础知识" class="headerlink" title="共用体基础知识"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) BOOL rich;</span><br><span class="line">@property (nonatomic,assign) BOOL tell;</span><br><span class="line">@property (nonatomic,assign) BOOL handsome;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后查看该类的实例占用空间大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">		p.handsome = YES;</span><br><span class="line">		p.rich = NO;</span><br><span class="line">		NSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</span><br><span class="line">		//16</span><br></pre></td></tr></table></figure>
<p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line"></span><br><span class="line">//实现：</span><br><span class="line">//使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</span><br><span class="line">//#define FYHandsomeMask 0b00000001</span><br><span class="line">//#define FYTallMask 0b00000010</span><br><span class="line">//#define FYRichMask 0b00000001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FYHandsomeMask (1&lt;&lt;0)</span><br><span class="line">#define FYTallMask (1&lt;&lt;1)</span><br><span class="line">#define FYRichMask (1&lt;&lt;2)</span><br><span class="line"></span><br><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">	char _richTellHandsome;//0000 0000 rich tall handsome</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome|FYRichMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome&amp;~FYRichMask;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome|FYTallMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome&amp;~FYTallMask;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome|FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">//	char _richTellHandsome;//0000 0000 rich tall handsome</span><br><span class="line">	//位域</span><br><span class="line">	struct&#123;</span><br><span class="line">		char tall : 1;//高度</span><br><span class="line">		char rich : 1;//富有</span><br><span class="line">		char handsome : 1; //帅</span><br><span class="line">	&#125; _richTellHandsome; // 0b0000 0000</span><br><span class="line">	//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</span><br><span class="line">	//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.rich = tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.handsome = tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!_richTellHandsome.rich;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!_richTellHandsome.tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return !!_richTellHandsome.handsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (tall) &#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome|FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">	union &#123;</span><br><span class="line">		char bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间</span><br><span class="line">		struct&#123;</span><br><span class="line">			char tall : 1;//高度</span><br><span class="line">			char rich : 1;//富有</span><br><span class="line">			char handsome : 1; //帅</span><br><span class="line">		&#125;; // 0b0000 0000</span><br><span class="line">	&#125;_richTellHandsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |= FYRichMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;= ~FYRichMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |= FYTallMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;= ~FYTallMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |= FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;= ~FYHandsomeMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!(_richTellHandsome.bits &amp; FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!(_richTellHandsome.bits &amp; FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return (_richTellHandsome.bits &amp; FYHandsomeMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</span><br><span class="line">        NSKeyValueObservingOptionNew = 0x01,</span><br><span class="line">    NSKeyValueObservingOptionOld = 0x02,</span><br><span class="line">    NSKeyValueObservingOptionInitial = 0x04,</span><br><span class="line">    NSKeyValueObservingOptionPrior = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">	FYOne = 1,//  0b 0001</span><br><span class="line">	FYTwo = 2,//  0b 0010</span><br><span class="line">	FYTHree = 4,//0b 0100</span><br><span class="line">	FYFour = 8,// 0b 1000</span><br><span class="line">&#125;FYOptions;</span><br><span class="line"></span><br><span class="line">- (void)setOptions:(FYOptions )ops&#123;</span><br><span class="line">	if (ops &amp;FYOne) &#123;</span><br><span class="line">		NSLog(@&quot;FYOne is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYTwo) &#123;</span><br><span class="line">		NSLog(@&quot;FYTwo is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYTHree) &#123;</span><br><span class="line">		NSLog(@&quot;FYTHree is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYFour) &#123;</span><br><span class="line">		NSLog(@&quot;FYFour is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self setOptions:FYOne|FYTwo|FYTHree];</span><br><span class="line"></span><br><span class="line">//输出是：</span><br><span class="line">FYOne is show</span><br><span class="line">FYTwo is show</span><br><span class="line">FYTHree is show</span><br></pre></td></tr></table></figure>
<p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p>
<h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nonpointer</td>
<td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td>
</tr>
<tr>
<td>has_assoc</td>
<td>是否有设置过关联对象，如果没有，释放时会更快</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>存储着Class、Meta-Class对象的内存地址信息</td>
</tr>
<tr>
<td>magic</td>
<td>用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>是否有被弱引用指向过，如果没有，释放时会更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>对象是否正在释放</td>
</tr>
<tr>
<td>extra_rc</td>
<td>里面存储的值是引用计数器减1</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>引用计数器是否过大无法存储在isa中</td>
</tr>
</tbody>
</table>
<p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p>
<p>class结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct fy_objc_class : xx_objc_object &#123;</span><br><span class="line">	Class superclass;</span><br><span class="line">	cache_t cache;</span><br><span class="line">	class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">	class_rw_t* data() &#123;</span><br><span class="line">		return bits.data();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</span><br><span class="line">		// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span><br><span class="line">		return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t version;</span><br><span class="line">	const class_ro_t *ro;//只读 数据</span><br><span class="line">	method_list_t * methods;    // 方法列表</span><br><span class="line">	property_list_t *properties;    // 属性列表</span><br><span class="line">	const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">	Class firstSubclass;</span><br><span class="line">	Class nextSiblingClass;</span><br><span class="line">	char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t instanceStart;</span><br><span class="line">	uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">	uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">	const uint8_t * ivarLayout;</span><br><span class="line">	const char * name;  // 类名</span><br><span class="line">	method_list_t * baseMethodList;</span><br><span class="line">	protocol_list_t * baseProtocols;</span><br><span class="line">	const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">	const uint8_t * weakIvarLayout;</span><br><span class="line">	property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    //如果已注册 就返回</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">//只读ro</span><br><span class="line">    ro = (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        // This was a future class. rw data is already allocated.</span><br><span class="line">        rw = cls-&gt;data();//初始化ro</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Normal class. Allocate writeable class data.</span><br><span class="line">        //初始化 rw </span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro = ro;</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">        //指针指向rw 一开始是指向ro的</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version = isMeta ? 7 : 0;  // old runtime went up to 6</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_list_t **beginCategoryMethodLists() &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    method_list_t **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    method_array_t duplicate() &#123;</span><br><span class="line">        return Super::duplicate&lt;method_array_t&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><ul>
<li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似</li>
<li>可以通过@selector()和sel_registerName()获得</li>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
<h5 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">官方网站插件encodeing</a></p>
<table>
<thead>
<tr>
<th>code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>A char</td>
</tr>
<tr>
<td>i</td>
<td>An int</td>
</tr>
<tr>
<td>s</td>
<td>A short</td>
</tr>
<tr>
<td>l</td>
<td>A long</td>
</tr>
<tr>
<td>l</td>
<td>is treated as a 32-bit quantity on 64-bit programs.</td>
</tr>
<tr>
<td>q</td>
<td>A long long</td>
</tr>
<tr>
<td>C</td>
<td>An unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>An unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>An unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>An unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>An unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>A float</td>
</tr>
<tr>
<td>d</td>
<td>A double</td>
</tr>
<tr>
<td>B</td>
<td>A C++ bool or a C99 _Bool</td>
</tr>
<tr>
<td>v</td>
<td>A void</td>
</tr>
<tr>
<td>*</td>
<td>A character string (char *)</td>
</tr>
<tr>
<td>@</td>
<td>An object (whether statically typed or typed id)</td>
</tr>
<tr>
<td>#</td>
<td>A class object (Class)</td>
</tr>
<tr>
<td>:</td>
<td>A method selector (SEL)</td>
</tr>
<tr>
<td>[array type]</td>
<td>An array</td>
</tr>
<tr>
<td>{name=type…}</td>
<td>A structure</td>
</tr>
<tr>
<td>(name=type…)</td>
<td>A union</td>
</tr>
<tr>
<td>bnum</td>
<td>A bit field of num bits</td>
</tr>
<tr>
<td>^type</td>
<td>A pointer to type</td>
</tr>
<tr>
<td>?</td>
<td>An unknown type (among other things, this code is used for function pointers)</td>
</tr>
</tbody>
</table>
<p>我们通过一个例子来了解encode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)test:(int)age heiht:(float)height&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">	SEL sel = @selector(test:heiht:);</span><br><span class="line">	Method m1= class_getInstanceMethod(p.class, sel);</span><br><span class="line">	const char *type = method_getTypeEncoding(m1);</span><br><span class="line">	NSLog(@&quot;%s&quot;,type);</span><br><span class="line">	</span><br><span class="line">	//输出</span><br><span class="line">	v24@0:8i16f20</span><br><span class="line">	//0id 8 SEL 16 int 20 float = 24</span><br></pre></td></tr></table></figure>
<p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p>
<h4 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;//散列表</span><br><span class="line">    mask_t _mask;//散列表长度-1</span><br><span class="line">    mask_t _occupied;//已经存储的方法数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">#if __arm64__</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">#else</span><br><span class="line">    cache_key_t _key;//SEL作为key </span><br><span class="line">    MethodCacheIMP _imp; //函数地址</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列表的数据结构表格所示</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>bucket_t</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>1</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>2</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>3</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>4</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = mask();</span><br><span class="line">	//key&amp;mask 得到索引</span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    // hack</span><br><span class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span><br><span class="line">// Caches are never built in the dyld shared cache.</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef MJClassInfo_h</span><br><span class="line">#define MJClassInfo_h</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">#if __arm__  ||  __x86_64__  ||  __i386__</span><br><span class="line">// objc_msgSend has few registers available.</span><br><span class="line">// Cache scan increments and wraps at special end-marking bucket.</span><br><span class="line">#define CACHE_END_MARKER 1</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif __arm64__</span><br><span class="line">// objc_msgSend has lots of registers available.</span><br><span class="line">// Cache scan decrements. No end marker needed.</span><br><span class="line">#define CACHE_END_MARKER 0</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#error unknown architecture</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">    </span><br><span class="line">    IMP imp(SEL selector)</span><br><span class="line">    &#123;</span><br><span class="line">        mask_t begin = _mask &amp; (long long)selector;</span><br><span class="line">        mask_t i = begin;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) &#123;</span><br><span class="line">                return _buckets[i]._imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ((i = cache_next(i, _mask)) != begin);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">    method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *type;</span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">    ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">    property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">    chained_property_list *next;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  // 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    // 方法列表</span><br><span class="line">    property_list_t *properties;    // 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct mj_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct mj_objc_class : mj_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mj_objc_class* metaClass() &#123;</span><br><span class="line">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>测试代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p = [[FYPerson alloc]init];</span><br><span class="line">		Method test1Method = class_getInstanceMethod(p.class, @selector(test));</span><br><span class="line">		Method test2Method = class_getInstanceMethod(p.class, @selector(test2));</span><br><span class="line">		IMP imp1= method_getImplementation(test1Method);</span><br><span class="line">		IMP imp2= method_getImplementation(test2Method);</span><br><span class="line"></span><br><span class="line">		mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</span><br><span class="line">		NSLog(@&quot;-----&quot;);</span><br><span class="line">		[p test];</span><br><span class="line">		[p test2];</span><br><span class="line">		cache_t cache = cls-&gt;cache;</span><br><span class="line">		bucket_t *buck = cache._buckets;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		for (int i = 0; i &lt;= cache._mask; i ++) &#123;</span><br><span class="line">			bucket_t item = buck[i];</span><br><span class="line">			if (item._key != 0) &#123;</span><br><span class="line">				NSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//输出</span><br><span class="line">p imp1</span><br><span class="line">(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)</span><br><span class="line">(lldb) p imp2</span><br><span class="line">(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)</span><br><span class="line">p/d @selector(test)             //输出 test方法的sel地址</span><br><span class="line">(SEL) $6 = 140734025103231 &quot;test&quot;</span><br><span class="line">(lldb) p/d @selector(test2)     //输出 test2方法的sel地址</span><br><span class="line">(SEL) $7 = 4294971267 &quot;test2&quot;</span><br><span class="line"></span><br><span class="line">key1:140733954181041 imp1:0x7fff59fc4cd1</span><br><span class="line">key2:4294971267 imp2:0x100000e20         //对应test2</span><br><span class="line">key3:140734025103231 imp3:0x100000df0    //对应test1</span><br></pre></td></tr></table></figure>
<p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    //当initialized 没有执行完毕的时候不缓存</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    // Make sure the entry wasn&apos;t added to the cache by some other thread </span><br><span class="line">    // before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line">    cache_key_t key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    // Use the cache as-is if it is less than 3/4 full</span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        // Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</span><br><span class="line">        // Cache &lt;= 3/4 </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        扩容 之后，缓存清空</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line">//bucket_t 最小是4，当&gt;3/4时候，扩容，空间扩容之后是之前的2️倍。</span><br><span class="line">    bucket_t *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p = [[FYPerson alloc]init];</span><br><span class="line">mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</span><br><span class="line">NSLog(@&quot;-----&quot;);</span><br><span class="line">[p test];</span><br><span class="line">/*</span><br><span class="line"> key:init imp:0x7fff58807c2d</span><br><span class="line"> key:class imp:0x7fff588084b7</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test imp:0x100000bf0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br><span class="line">[p test2]; //当执行该函数的时候</span><br><span class="line">/*</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test2 imp:0x100000c20</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">cache_t cache = cls-&gt;cache;</span><br><span class="line">bucket_t *buck = cache._buckets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;= cache._mask; i ++) &#123;</span><br><span class="line">	bucket_t item = buck[i];</span><br><span class="line">//            if (item._key != 0) &#123;</span><br><span class="line">////                printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line">//            &#125;</span><br><span class="line">    printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li>
<li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li>
<li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li>
<li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li>
<li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码</a></p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
</li>
</ul>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理  block本质 --(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理  block本质 --(5)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理  block本质 --(5)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:15:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。</p>
<h3 id="block本质"><a href="#block本质" class="headerlink" title="block本质"></a>block本质</h3><p>前几篇文章讲过了，<code>class</code>是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？<code>block</code>具有这几个特点：/</p>
<ul>
<li>block本质上也是一个OC对象，它内部也有isa指针</li>
<li>block是封装了函数调用以及函数调用环境的oc对象</li>
</ul>
<p>先简单来看一下<code>block</code>编译之后的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (^block)(void) = ^(void)&#123;</span><br><span class="line">            NSLog(@&quot;hello word&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp</code>,来到<code>main.cpp</code>内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">    //构造函数 类似OC init函数</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;//block类型</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;// 执行函数的地址</span><br><span class="line">    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    //block 内部代码封装成函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;//存储结构体占用空间的大小</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">//定义block</span><br><span class="line">        void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">        //执行block</span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终<code>block</code>转化成<code>__main_block_impl_0</code>结构体，赋值给变量<code>block</code>，传入参数是<code>__main_block_func_0</code>和<code>__main_block_desc_0_DATA</code>来执行<code>__main_block_impl_0</code>的构造函数，<code>__main_block_desc_0_DATA</code>函数赋值给<code>__main_block_impl_0-&gt;FuncPtr</code>，执行函数是<code>block-&gt;FuncPtr(block)</code>，删除冗余代码之前是<code>((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code>，那么为什么<code>block</code>可以直接强制转化成<code>__block_impl</code>呢？因为<code>__main_block_impl_0</code>结构体的第一行变量是<code>__block_impl</code>，相当于<code>__main_block_impl_0</code>的内存地址和<code>__block_impl</code>的内存地址一样，强制转化也不会有问题。</p>
<h3 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h3><p>变量捕获分为3种：</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>是否会捕获到block内部</th>
<th>访问方式</th>
<th>内部变量假定是a</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量 auto</td>
<td>会</td>
<td>值传递</td>
<td>a</td>
</tr>
<tr>
<td>局部变量 static</td>
<td>会</td>
<td>指针传递</td>
<td>*a</td>
</tr>
<tr>
<td>全局变量</td>
<td>不会</td>
<td>直接访问</td>
<td>空</td>
</tr>
</tbody>
</table>
<h4 id="auto变量捕获"><a href="#auto变量捕获" class="headerlink" title="auto变量捕获"></a>auto变量捕获</h4><p><code>auto</code> 变量，一般<code>auto</code>是省略不写的，访问方式是值传递，关于值传递不懂的话可以看<a href="https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&amp;oq=%E5%80%BC%E4%BC%A0%E9%80%92&amp;aqs=chrome..69i57.5169j0j4&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">这篇博客</a>，<br>看下这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int age = 10;</span><br><span class="line">void (^block)(void) = ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = 20;</span><br><span class="line">block();</span><br><span class="line">//实际输出是 age is 10</span><br></pre></td></tr></table></figure>
<p>有没有疑问呢？在<code>block</code>执行之前<code>age =20</code>，为什么输出是10呢？<br>将这段代码转化成<code>c/c++</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;//多了一个变量age,存储值是10</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age = __cself-&gt;age; // bound by copy</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        int age = 10;</span><br><span class="line">        void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">        age = 20;</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体<code>__main_block_impl_0</code>多了一个变量<code>age</code>，在<code>block</code>转化成<code>c</code>函数的时候<code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)</code>直接将age的值存储在<code>__main_block_impl_0.age</code>中，此时<code>__main_block_impl_0.age</code>是存储在堆上的，之前的<code>age</code>是存储在数据段的，执行<code>block</code>访问的变量是堆上的<code>`__main_block_impl_0.age</code>,所以最终输出来<code>age is 10</code>。</p>
<h4 id="static变量捕获"><a href="#static变量捕获" class="headerlink" title="static变量捕获"></a>static变量捕获</h4><p>我们通过一个例子来讲解static和auto区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void);</span><br><span class="line">void test()&#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    static int level = 12;</span><br><span class="line">    block = ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;age is %d,level is %d&quot;,age,level);</span><br><span class="line">    &#125;;</span><br><span class="line">    age = 20;</span><br><span class="line">    level = 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        test();</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出：age is 10,level is 13</span><br></pre></td></tr></table></figure>
<p>转化成源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void);</span><br><span class="line"></span><br><span class="line">struct __test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __test_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  int *level;</span><br><span class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age = __cself-&gt;age; // bound by copy</span><br><span class="line">  int *level = __cself-&gt;level; // bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    static int level = 12;</span><br><span class="line">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, age, &amp;level));</span><br><span class="line">    age = 20;</span><br><span class="line">    level = 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        test();</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完<code>test()</code>函数，<code>age</code>变量已经被收回，但是<code>age</code>的值存储在<code>block</code>结构体中，<code>level</code>的地址存储在<code>__test_block_impl_0.level</code>,可以看到<code>level</code>类型是指针类型，读取值的时候也是<code>*level</code>，则不管什么时间改动<code>level</code>的值，读<code>level</code>的值都是最新的，因为它是从地址直接读的。所以结果是<code>age is 10,level is 13</code>。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局不用捕获的，访问的时候直接访问。我们来测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int age = 10;</span><br><span class="line">static int level = 12;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        void(^block)(void) = ^(void)&#123;</span><br><span class="line">            NSLog(@&quot;age is %d,level is %d&quot;,age,level);</span><br><span class="line">        &#125;;</span><br><span class="line">        age = 20;</span><br><span class="line">        level = 13;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化成<code>c/c++</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int age = 10;</span><br><span class="line">static int level = 12;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">        age = 20;</span><br><span class="line">        level = 13;</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来编译之后仅仅是多了两行<code>int age = 10;
static int level = 12;</code>，结构体<code>__main_block_impl_0</code>内部和构造函数并没有专门来存储值或者指针，原因是当执行<code>__main_block_func_0</code>，可以直接访问变量<code>age</code>和 <code>level</code>，因为全局变量有效区域是全局，不会出了<code>main</code>函数就消失。<br><strong>基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。</strong></p>
<p>我们再看下更复杂的情况，对象类型的引用是如何处理的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    void (^block)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;person is %@&quot;,self);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    void (^block2)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;name is %@&quot;,_name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __FYPerson__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __FYPerson__test_block_desc_0* Desc;</span><br><span class="line">  FYPerson *self;</span><br><span class="line">  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  FYPerson *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);</span><br><span class="line">    &#125;</span><br><span class="line">static void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __FYPerson__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __FYPerson__test_block_impl_0*);</span><br><span class="line">&#125; __FYPerson__test_block_desc_0_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">struct __FYPerson__test_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __FYPerson__test_block_desc_1* Desc;</span><br><span class="line">  FYPerson *self;</span><br><span class="line">  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) &#123;</span><br><span class="line">  FYPerson *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));</span><br><span class="line">    &#125;</span><br><span class="line">static void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __FYPerson__test_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __FYPerson__test_block_impl_1*);</span><br><span class="line">&#125; __FYPerson__test_block_desc_1_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_FYPerson_test(FYPerson * self, SEL _cmd) &#123;</span><br><span class="line">    void (*block)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &amp;__FYPerson__test_block_desc_0_DATA, self, 570425344));</span><br><span class="line"></span><br><span class="line">    void (*block2)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &amp;__FYPerson__test_block_desc_1_DATA, self, 570425344));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>block</code>和<code>block2</code>都是结构体<code>__FYPerson__test_block_impl_1</code>内部引用了一个<code>FYPerson</code>对象指针，<code>FYPerson</code>对象属于局部变量，需要捕获。第2个<code>block</code>访问<code>_name</code>捕捉的也是<code>FYPerson</code>对象，访问<code>_name</code>，需要先访问<code>FYPerson</code>对象，然后再访问<code>_name</code>，本质上是访问<code>person.name</code>,所以捕捉的是<code>FYPerson</code>对象。</p>
<h4 id="验证block是对象类型："><a href="#验证block是对象类型：" class="headerlink" title="验证block是对象类型："></a>验证block是对象类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//ARC环境下</span><br><span class="line">void(^block)(void)=^&#123;</span><br><span class="line">			NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">		&#125;;</span><br><span class="line">		NSLog(@&quot;自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@&quot;,[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);</span><br><span class="line">		//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject</span><br></pre></td></tr></table></figure>
<p>可以了解到<code>block</code>是继承与基类的，所以<code>block</code>也是OC对象。</p>
<h4 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h4><p><code>block</code>有3种类型，如下所示，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承来自<code>NSBlock</code>类型。</p>
<ul>
<li><strong>NSGlobalBLock</strong>（_NSConcreteGLobalBlock）</li>
<li><strong>NSStackBlock</strong>（_NSConcreteStackBlock）</li>
<li><strong>NSMallocBLock</strong>（_NSConcreteMallocBlock）</li>
</ul>
<p>在应用程序中内存分配是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------------</span><br><span class="line">程序区域 .text区</span><br><span class="line">---------------</span><br><span class="line">数据区域 .data区     &lt;--------- _NSConcreteGlobalBlock(存储全局变量)</span><br><span class="line">---------------</span><br><span class="line">堆                  &lt;--------- _NSConcreteMallocBlock(动态申请释放内存区域)</span><br><span class="line">---------------</span><br><span class="line">栈                  &lt;--------- _NSConcreteStackBlock(存储存局部变量)</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>block类型</th>
<th>环境</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NSGlobalBLock</strong></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>访问auto变量</td>
</tr>
<tr>
<td><strong>NSMallocBLock</strong></td>
<td><strong>NSStackBlock</strong> 调用copy</td>
</tr>
</tbody>
</table>
<p>验证需要设置成MRC，找到工程文件，设置<code>project-&gt;Object-C Automatic Reference Counting=</code>为<code>NO</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int age = 10;</span><br><span class="line"></span><br><span class="line">void(^block1)(void)=^&#123;</span><br><span class="line">	NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">void(^block2)(void)=^&#123;</span><br><span class="line">	NSLog(@&quot;block2 %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">void(^block3)(void)=[block2 copy];</span><br><span class="line">NSLog(@&quot;block1:%@   block2:%@ block3:%@ &quot;,[block1 class],[block2 class],[block3 class]);</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">block1:__NSGlobalBlock__   </span><br><span class="line">block2:__NSStackBlock__ </span><br><span class="line">block3:__NSMallocBlock__</span><br></pre></td></tr></table></figure>
<p>没有访问<code>auto</code>变量的<code>block</code>属于<code>__NSGlobalBlock__</code>，访问了auto变量的是<code>__NSStackBlock__</code>，手动调用了<code>copy</code>的<code>block</code>属于<code>__NSMallocBlock__</code>。<code>__NSMallocBlock__</code>是在堆上，需要程序员手动释放<code>[block3 release];</code>，不释放会造成内存泄露。</p>
<p>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下</p>
<table>
<thead>
<tr>
<th>block类型</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NSGlobalBLock</strong></td>
<td>堆</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td><strong>NSMallocBLock</strong></td>
<td>堆</td>
<td>引用计数+1</td>
</tr>
</tbody>
</table>
<h4 id="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"><a href="#在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况" class="headerlink" title="在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况"></a>在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况</h4><ul>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<p>在ARC环境下测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^FYBlock)(void);</span><br><span class="line">typedef void (^FYBlockInt)(int);</span><br><span class="line">FYBlock myBlock()&#123;</span><br><span class="line">	return ^&#123;</span><br><span class="line">		NSLog(@&quot;哈哈&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">FYBlock myBlock2()&#123;</span><br><span class="line">	int age = 10;</span><br><span class="line">	return ^&#123;</span><br><span class="line">		NSLog(@&quot;哈哈 %d&quot;,age);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">		FYBlock block = myBlock();</span><br><span class="line">		FYBlock block2 = myBlock2();</span><br><span class="line">		int age = 10;</span><br><span class="line">		FYBlock block3= ^&#123;</span><br><span class="line">			NSLog(@&quot;强指针block %d&quot;,age);</span><br><span class="line">		&#125;;</span><br><span class="line">		NSLog(@&quot;没访问变量:%@ 访问布局变量：%@ 强指针:%@&quot;,[block class],[block2 class],[block3 class]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">没访问变量:__NSGlobalBlock__ </span><br><span class="line">访问局部变量：__NSMallocBlock__ </span><br><span class="line">强指针:__NSMallocBlock__</span><br></pre></td></tr></table></figure>
<p><code>arc</code>环境下，没访问变量的<code>block</code>是<code>__NSGlobalBlock__</code>，访问了局部变量是<code>__NSMallocBlock__</code>,有强指针引用的是<code>__NSMallocBlock__</code>,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。</p>
<p><strong>所以有以下建议：</strong></p>
<p>MRC下block属性的建议写法</p>
<ul>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<p>ARC下block属性的建议写法</p>
<ul>
<li>@property (strong, nonatomic) void (^block)(void);</li>
<li>@property (copy, nonatomic) void (^block)(void);</li>
</ul>
<h3 id="对象类型数据和block交互"><a href="#对象类型数据和block交互" class="headerlink" title="对象类型数据和block交互"></a>对象类型数据和block交互</h3><p>平时我们使用<code>block</code>，对象类型来传递数据的比较多，对象类型读取到<code>block</code>中用<code>__block</code>修饰符，会把对象地址直接读取到<code>block</code>结构体内，<code>__weak</code>修饰的对象是弱引用，默认是强引用，我们看下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//FYPerson.h</span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//FYPerson.m</span><br><span class="line">@implementation FYPerson</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//main.m</span><br><span class="line">typedef void (^FYBlock)(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">		FYBlock block ;</span><br><span class="line">			FYPerson *person = [[FYPerson alloc]init];</span><br><span class="line">			person.age = 10;</span><br><span class="line">		__weak typeof(person) __weakPerson = person;</span><br><span class="line">			block = ^&#123;</span><br><span class="line">				NSLog(@&quot; %d&quot;,__weakPerson.age);</span><br><span class="line">			&#125;;</span><br><span class="line">		</span><br><span class="line">		block();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下面该命令转化成<code>cpp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp</span><br></pre></td></tr></table></figure>
<p>摘取关键结构体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  FYPerson *__weak __weakPerson;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  FYPerson *__weak __weakPerson = __cself-&gt;__weakPerson; // bound by copy</span><br><span class="line"></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(&quot;age&quot;)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>FYPerson *__weak __weakPerson</code>是<code>__weak</code>修饰的对象<br>当block内部换成<code>block = ^{
                NSLog(@&quot; %d&quot;,person.age);
            };</code>，转换源码之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  FYPerson *__strong person;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>person</code>默认是使用<code>__storng</code>来修饰的，<code>arc</code>中，<code>block</code>引用外界变量，系统执行了<code>copy</code>操作，将<code>block</code> <code>copy</code>到堆上，由开发者自己管理，转<code>c/c++</code>中结构体描述为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;__weakPerson, (void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br></pre></td></tr></table></figure>
<p>有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数<code>void (*copy)</code>和<code>void (*dispose)</code>就是对block的引用计数的<code>+1</code>和<code>-1</code>。</p>
<p>如果block被拷贝到堆上</p>
<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li>
</ul>
<p>如果block从堆上移除</p>
<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">copy函数</td>
<td style="text-align:center">栈上的Block复制到堆时</td>
</tr>
<tr>
<td style="text-align:center">dispose函数</td>
<td style="text-align:center">堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>person什么时间释放？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">FYPerson *person = [[FYPerson alloc]init];</span><br><span class="line">person.age = 10;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3s后释放，<code>dispatch</code>对<code>block</code>强引用，<code>block</code>强引用<code>person</code>，在<code>block</code>释放的时候，<code>person</code>没其他的引用，就释放掉了。</p>
<p>变换1：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person = [[FYPerson alloc]init];</span><br><span class="line">person.age = 10;</span><br><span class="line">__weak FYPerson *__weakPerosn = person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	NSLog(@&quot;---%d&quot;,__weakPerosn.age);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>__weak</code>没有对<code>perosn</code>进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。<br>变换2：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person = [[FYPerson alloc]init];</span><br><span class="line">person.age = 10;</span><br><span class="line">__weak typeof(person) __weakPerson = person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	NSLog(@&quot;---%d&quot;,__weakPerson.age);</span><br><span class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>person</code>被内部<code>block</code>强引用，则<code>block</code>销毁之前<code>person</code>不会释放，<code>__weakPerson</code>执行完<code>person</code>不会销毁，<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。答案是4秒之后<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。</p>
<p>变换3：<code>person</code>什么时间释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *person = [[FYPerson alloc]init];</span><br><span class="line">person.age = 10;</span><br><span class="line">__weak typeof(person) __weakPerson = person;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	NSLog(@&quot;---%d&quot;,person.age);</span><br><span class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		NSLog(@&quot;---%d&quot;,__weakPerson.age);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>person</code>被强引用于第一层<code>block</code>，第二层弱引用<code>person</code>，仅仅当第一层block执行完毕的时候，<code>person</code>释放。</p>
<h4 id="修改block外部变量"><a href="#修改block外部变量" class="headerlink" title="修改block外部变量"></a>修改block外部变量</h4><p>想要修改变量，首先要变量的有效区域，或者block持有变量的地址。<br>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 10;</span><br><span class="line">FYBlock block = ^&#123;</span><br><span class="line">    age = 20;//会报错</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>报错的原因是<code>age</code>是值传递，想要不报错只需要将<code>int age = 10</code>改成<code>static int age = 10</code>，就由值传递变成地址传递，有了<code>age</code>的地址，在<code>block</code>的内部就可以更改<code>age</code>的值了。或者将<code>int age = 10</code>改成全局变量，全局变量在<code>block</code>中不用捕获，<code>block</code>本质会编译成<code>c</code>函数，<code>c</code>函数访问全局变量在任意地方都可以直接访问。</p>
<h4 id="block本质-1"><a href="#block本质-1" class="headerlink" title="__block本质"></a>__block本质</h4><p><code>__block</code>本质上是修饰的对象或基本类型，编译之后会生成一个结构体<code>__Block_byref_age_0</code>,结构体中<code>*__forwarding</code>指向结构体自己，通过<br><code>(age-&gt;__forwarding-&gt;age) = 20</code>来修改变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;//10</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</span><br><span class="line">            (age-&gt;__forwarding-&gt;age) = 20;</span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>age</code>在<code>block</code>外部有一个，在<code>block</code>内部有一个，他们是同一个吗？我们来探究一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">typedef   void (^FYBlock)(void);</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    struct __Block_byref_age_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int age;//10</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    struct __Block_byref_age_0 *age; // by ref</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">	    // insert code here...</span><br><span class="line">	__block	int age = 10;</span><br><span class="line">        NSLog(@&quot; age1:%p&quot;,&amp;age);</span><br><span class="line">        FYBlock block = ^&#123;</span><br><span class="line">            age = 20;</span><br><span class="line">            NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">        &#125;;</span><br><span class="line">        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;</span><br><span class="line">        NSLog(@&quot; age1:%p age2:%p&quot;,&amp;age,&amp;(main-&gt;age-&gt;__forwarding-&gt;age));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">age1:0x7ffeefbff548</span><br><span class="line">age1:0x100605358 age2:0x100605358</span><br></pre></td></tr></table></figure>
<p>经过<code>__block</code>修饰之后，之后访问的<code>age</code>和结构体<code>__Block_byref_age_0</code>中的<code>age</code>地址是一样的，可以判定<code>age</code>被系统<code>copy</code>了一份。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block	int age = 10;</span><br><span class="line">       NSLog(@&quot; age1:%p&quot;,&amp;age);</span><br><span class="line">       NSObject *obj=[[NSObject alloc]init];</span><br><span class="line">       FYBlock block = ^&#123;</span><br><span class="line">           </span><br><span class="line">           NSLog(@&quot;age is %d,obj is %p&quot;,age,&amp;obj);</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>
<p>使用命令编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</span><br></pre></td></tr></table></figure>
<p>摘录主要函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *__strong obj;</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0-&gt;__forwarding-&gt;age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。</span><br></pre></td></tr></table></figure>
<p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {<br>    _Block_object_assign((void<em>)&amp;dst-&gt;age, (void</em>)src-&gt;age, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>    _Block_object_assign((void<em>)&amp;dst-&gt;obj, (void</em>)src-&gt;obj, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/);}</p>
<pre><code>static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);
_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。</span><br><span class="line"></span><br><span class="line">看一下循环引用是反面教材</span><br></pre></td></tr></table></figure>
<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject</p>
<p>@property (nonatomic,copy) FYBlock blcok;<br>@end</p>
<p>@implementation FYPerson</p>
<ul>
<li>(void)dealloc{<br>  NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end</li>
</ul>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSLog(@” age1:%p”,&amp;age);<br>        FYPerson </em>obj=[[FYPerson alloc]init];<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;obj);<br>        }];<br>        NSLog(@”————–”);<br>    }<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出是：</span><br></pre></td></tr></table></figure></p>
<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A&lt;----&gt;B`，相互引用导致执行结束应该释放的时候无法释放。</span><br><span class="line">将`main`改成</span><br></pre></td></tr></table></figure></p>
<p>FYPerson *obj=[[FYPerson alloc]init];<br>        __weak typeof(obj) weakObj = obj;<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;weakObj);<br>        }];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果是</span><br></pre></td></tr></table></figure></p>
<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br>-[FYPerson dealloc]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。</span><br><span class="line">#### `__weak`和`__unsafe__unretain`</span><br><span class="line">`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。</span><br><span class="line">下面我们来具体验证一下该结论：</span><br></pre></td></tr></table></figure></p>
<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject<br>@property (nonatomic,assign) int age ;<br>@end<br>@implementation FYPerson<br>-(void)dealloc{<br>    NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end<br>struct <strong>Block_byref_age_0 {<br>    void *</strong>isa;<br>    struct <strong>Block_byref_age_0 *</strong>forwarding;<br>    int <strong>flags;<br>    int </strong>size;<br>    int age;<br>};<br>struct <strong>block_impl {<br>    void <em>isa;<br>    int Flags;<br>    int Reserved;<br>    void </em>FuncPtr;<br>};<br>struct </strong>main_block_desc_0 {<br>    size_t reserved;<br>    size_t Block_size;<br>    void (<em>copy)(void);<br>    void (</em>dispose)(void);<br>};<br>struct <strong>main_block_impl_0 {<br>    struct </strong>block_impl impl;<br>    struct <strong>main_block_desc_0<em> Desc;<br>    FYPerson </em></strong>unsafe_unretained __unsafe_obj;<br>};</p>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        // insert code here…<br>        FYBlock block;<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            obj.age = 5;<br>            <strong>weak typeof(obj) </strong>unsafe_obj = obj;<br>            block = ^{</p>
<pre><code>            NSLog(@&quot;obj-&gt;age is %d obj:%p&quot;,__unsafe_obj.age,&amp;__unsafe_obj);
        };
        struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;
        NSLog(@&quot;inside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点1
    }
    struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;
    NSLog(@&quot;outside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点2
    block();
    NSLog(@&quot;----end------&quot;);
}
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据文中提示断点1处使用`lldb`打印`obj`命令</span><br></pre></td></tr></table></figure></p>
<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5 //年龄5还是存储在这里的<br>inside struct-&gt;obj:0x102929d80</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在断点2处再次查看`obj`的值，报错不可读取该内存</span><br></pre></td></tr></table></figure>
<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x0<br>p suct-&gt;__unsafe_obj-&gt;_age<br>error: Couldn’t apply expression side effects : Couldn’t dematerialize a result variable: couldn’t read its memory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。</span><br><span class="line">上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：</span><br></pre></td></tr></table></figure></p>
<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5<br>inside struct-&gt;obj:0x10078c0c0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在断点2出再次查看地址并查看`age`的值</span><br></pre></td></tr></table></figure>
<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x10078c0c0<br>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $1 = 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们离开某个页面需要再执行的操作，那么我们改怎么办？</span><br><span class="line">实际应用A:</span><br></pre></td></tr></table></figure></p>
<p>-(void)test{<br>    <strong>weak typeof(self) </strong>weakself = self;<br>    [self setBlcok:^{<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>            NSLog(@”perosn :%p”,__weakself);<br>        });<br>    }];<br>    self.blcok();<br>}</p>
<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            [obj test];<br>            NSLog(@”block 执行完毕————–”);<br>        }<br>        NSLog(@”person 死了”);<br>    }<br>    return 0;<br>}<br>输出：<br>block 执行完毕————–<br>-[FYPerson dealloc]<br>person 死了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。</span><br><span class="line">那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：</span><br></pre></td></tr></table></figure></p>
<pre><code>__block typeof(self) __weakSelf = self;//__block或者没有修饰符
dispatch_async(dispatch_get_main_queue(), ^{
    sleep(2);
    NSLog(@&quot;obj:%@&quot;,__weakSelf-&gt;_obj);
});
</code></pre><p>//perosn :0x0<br>```</p>
<p>当<code>self</code>不持用<code>block</code>的时候，<code>block</code>可以强引用<code>self</code>,<code>block</code>执行完毕自己释放，也会释放<code>self</code>，当<code>self</code>持有<code>block</code>，<code>block</code>必须弱引用<code>self</code>,则释放<code>self</code>,<code>block</code>也会释放，否则会循环引用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>block</code>本质是一个封装了函数调用以及调用环境的<code>结构体</code>对象</li>
<li><code>__block</code>修饰的变量会被封装成<code>结构体</code>对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决<code>auto</code>对象在<code>block</code>内部无法修改的问题，在<code>MRC</code>环境下,<code>__block</code>不会对变量产生强引用.</li>
<li><code>block</code>不使用<code>copy</code>则不会从全局或者栈区域移动到堆上，使用<code>copy</code>之后有由发者管理</li>
<li>使用<code>block</code>要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。</li>
<li><code>__weak</code>修饰的对象，<code>block</code>不会对对象强引用，在执行<code>block</code>的时候有可能会值已经被系统置为<code>nil</code>,<code>__unsafe_unretained</code>修饰的销毁之后内存不会及时重置为空。</li>
</ul>
<p>我们看的<code>cpp</code>是编译之后的代码，<code>runtime</code>是否和我们看到的一致呢？请听下回分解。</p>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码</a></p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
</li>
</ul>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理 Category与关联对象本质--(4)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:14:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:14:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 今天我们再看一下<code>Category</code>的底层原理。<br> 先看一下<code>Category</code>的简单使用，首先新增一个类的<code>Category</code>，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">- (void)run;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(void)run&#123;</span><br><span class="line">	NSLog(@&quot;run is run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//类别</span><br><span class="line">@interface FYPerson (test)</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson (test)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">	NSLog(@&quot;test is run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">#import &quot;FYPerson.h&quot;</span><br><span class="line">#import &quot;FYPerson+test.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *person=[[FYPerson alloc]init];</span><br><span class="line">[person test];</span><br><span class="line">[person run];</span><br></pre></td></tr></table></figure>
<p>  类别使用就是这么简单。<br>  那么类别的本质是什么呢？类的方法是存储在什么地方呢？<br>  第一篇<a href="https://juejin.im/post/5d15887ee51d45108126d28d" target="_blank" rel="noopener">类的本质</a>已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体<code>fy_objc_class</code>中的<code>class_data_bits_t-&gt;data()-&gt;method_list_t</code>中的，那么类别方法也是存储在<code>method_list_t</code>和取元类对象的<code>method_list_t</code>中的。编译的时候类别编译成结构体<code>_category_t</code>,然后<code>runtime</code>在运行时动态将方法添加到<code>method_list_t</code>中。运行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp</code>进入到<code>FYPerson+test.cpp</code>内部查看编译之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  struct _category_t &#123;</span><br><span class="line">	const char *name; //&quot;FYPerson&quot;</span><br><span class="line">	struct _class_t *cls;</span><br><span class="line">	const struct _method_list_t *instance_methods;</span><br><span class="line">	const struct _method_list_t *class_methods;</span><br><span class="line">	const struct _protocol_list_t *protocols;</span><br><span class="line">	const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line">//存储 test方法</span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_FYPerson_test_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;</span><br><span class="line"></span><br><span class="line">//_category_t 存储FYPerson的分类的数据</span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">	&quot;FYPerson&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_FYPerson,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法</span><br><span class="line">	0,//类方法</span><br><span class="line">	0,//协议方法</span><br><span class="line">	0,//属性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>存储在<code>_category_t</code>中的数据是什么时间加载到<code>FYPerson</code>的<code>class_data_bits_t.data</code>呢？我们探究一下，打开<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">源码</a>下载打开工程阅读源码找到<code>objc-os.mm</code>,通过查找函数运行顺序得到<code>_objec_init-&gt;map_images-&gt;map_images_noljock-&gt;_read_images-&gt;remethodizeClass(cls)-&gt;attachCategories(cls, cats, true /*flush caches*/)</code>，最终进入到<code>attachCategories</code>关键函数内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  // Attach method lists and properties and protocols from categories to a class.</span><br><span class="line">// Assumes the categories in cats are all loaded and sorted by load order, </span><br><span class="line">// oldest categories first.</span><br><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">	//方法数组[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">	//属性数组</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">	//协议数组</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    //最后的编译文件放到最前边</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">		//取出某个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">//取出分类 的 instance方法或者class方法</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">//proplist 接受所有分类属性</span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">//proplist 接受所有协议方法</span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//收集了所有协议 分类方法</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	//追加所有分类方法</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	//释放数组</span><br><span class="line">    free(mlists);</span><br><span class="line">	//刷新该类的缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">//追加所有分类属性</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);//释放数组</span><br><span class="line">//追加所有分类协议</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);//释放数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>attachCategories</code>是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到<code>rw-&gt;protocols.attachLists</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">        if (addedCount == 0) return;</span><br><span class="line">        if (hasArray()) &#123;</span><br><span class="line">            // many lists -&gt; many lists</span><br><span class="line">            uint32_t oldCount = array()-&gt;count;</span><br><span class="line">			//一共需要的数量</span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">			//分配内存 内存不够用了，需要扩容</span><br><span class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">			//赋值count</span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line">			// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br><span class="line">            memmove(array()-&gt;lists + addedCount/*指针移动到数组末尾*/, array()-&gt;lists/*数组*/,</span><br><span class="line">                    oldCount * sizeof(array()-&gt;lists[0])/*移动数据的大小*/);</span><br><span class="line">			//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">			/*</span><br><span class="line">			图示讲解：</span><br><span class="line">			array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">		addedCount:3</span><br><span class="line">		addedLists:P-&gt;L-&gt;V</span><br><span class="line">			memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">			然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</span><br><span class="line">			P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">			 */</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">            // 0 lists -&gt; 1 list</span><br><span class="line">            list = addedLists[0];</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            // 1 list -&gt; many lists</span><br><span class="line">            List* oldList = list;</span><br><span class="line">            uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line">            if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来：</p>
<ol>
<li>首先通过<code>runtime</code>加载某个类的所有Category数据</li>
<li>把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边</li>
<li>将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。</li>
</ol>
<p>具体的编译顺序是project文件中-&gt;Build Phases-&gt;Complile Sources的顺序。</p>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><h4 id="load加载顺序"><a href="#load加载顺序" class="headerlink" title="+load加载顺序"></a>+load加载顺序</h4><p>每个类和分类都会加载的时候调用<code>+load</code>方法，具体是怎么调用呢？我们查看源码<code>_objc_init-&gt;load_images-&gt;call_load_methods</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        //执行class+load直到完成</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">//执行Category +load 一次</span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>+load</code>在<code>Category+load</code>前边执行，当类的<code>+load</code>执行完毕然后再去执行<code>Category+load</code>,而且只有一次。<br>当class有子类的时候加载顺序呢？其实所有类都是基于<code>NSObject</code>，那么我们假设按照编译顺序加载<code>Class+load</code>，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类<code>+load</code>中的操作是第一个执行的，其他子类是按照<code>superclass-&gt;class-&gt;sonclass</code>的顺序执行的。<br>查看源码<code>_objc_init-&gt;load_images-&gt;prepare_load_methods((const headerType *)mh)-&gt;schedule_class_load</code>在<code>objc-runtime-new.mm</code>2856行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************/</span><br><span class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">// cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    //递归调用自己直到调用clas-&gt;self</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">//添加class</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以了解到该函数递归调用自己，直到<code>+load</code>方法已经调用过为止，所以不管编译顺序是高低，<code>+load</code>的加载顺序始终是<code>NSObject-&gt;FYPrson-&gt;FYStudent</code>。多个类平行关系的话，按照编译顺序加载。<br>下边是稍微复杂点的类关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSObject</span><br><span class="line">    Person</span><br><span class="line">        Student</span><br><span class="line">NSObjet</span><br><span class="line">    Car</span><br><span class="line">        BigCar</span><br><span class="line">            BigOrSmallCar</span><br></pre></td></tr></table></figure>
<p>编译顺序是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">Student</span><br><span class="line">Car</span><br><span class="line">BigOrSmallCar</span><br></pre></td></tr></table></figure>
<p>那么他们<code>+load</code>的加载顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSobject-&gt;Person-&gt;Student-&gt;Car-&gt;BigCar-&gt;BigOrSmallCar</span><br></pre></td></tr></table></figure>
<p>看着不是很明白的 可以再看一下刚才的<code>schedule_class_load</code>函数。<br>加载成功之后，是按照<code>objc_msgsend()</code>流程发送的吗？我们进入到<code>call_class_loads</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以找到<code>(*load_method)(cls, SEL_load);</code>该函数，该函数是直接使用<code>IMP</code>执行的，<code>IMP</code>就是函数地址，可以直接访问函数而不用消息的转发流程。</p>
<h4 id="initialize调用"><a href="#initialize调用" class="headerlink" title="+initialize调用"></a>+initialize调用</h4><ul>
<li>+initialize方法会在类第一次接收到消息时调用</li>
<li>先调用父类的+initialize，再调用子类的+initialize</li>
<li>先初始化父类，再初始化子类，每个类只会初始化1次</li>
</ul>
<p><code>objc</code>源码解读过程<code>objc-msg-arm64.x-&gt;objc_msgSend-&gt;objc-&gt;runtime-new-&gt;class_getinstanceMethod-&gt;lookUpImpOrNil-&gt;lookUpImpOrForward-&gt;_clas_initialize-&gt;callInitialize-&gt;objc_msgSend(cls,SEL_Initialize)</code><br>在<code>runtime-new.h</code>4819行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>lookUpImpOrNil</code>查看4916行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    // Optimistic cache lookup</span><br><span class="line">    if (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化</span><br><span class="line">      &#125;</span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line">   // Try this class&apos;s method lists.</span><br><span class="line">    //在本类中查找method</span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try superclass caches and method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        for (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            // Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts == 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass cache.</span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    // Found the method in a superclass. Cache it in this class.</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // Found a forward:: entry in a superclass.</span><br><span class="line">                    // Stop searching, but don&apos;t cache yet; call method </span><br><span class="line">                    // resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass method list.</span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </span><br><span class="line">        // changed already. Re-do the search from scratch instead.</span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // No implementation found, and method resolver didn&apos;t help. </span><br><span class="line">    // Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当第一次收到消息，cls没有初始化，则调用<code>_class_initialize</code>进行初始化<br>我们进入到<code>_class_initialize</code>内部<code>objc-initialize.mm</code>484行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    //递归调用父类是否有初始化和是否有父类</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            // LOL JK we don&apos;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Exceptions: A +initialize call that throws an exception </span><br><span class="line">        // is deemed to be a complete and successful +initialize.</span><br><span class="line">        //</span><br><span class="line">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        // bootstrapping problem of this versus CF&apos;s call to</span><br><span class="line">        // objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            // Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitializing()) &#123;</span><br><span class="line">        // We couldn&apos;t set INITIALIZING because INITIALIZING was already set.</span><br><span class="line">        // If this thread set it earlier, continue normally.</span><br><span class="line">        // If some other thread set it, block until initialize is done.</span><br><span class="line">        // It&apos;s ok if INITIALIZING changes to INITIALIZED while we&apos;re here, </span><br><span class="line">        //   because we safely check for INITIALIZED inside the lock </span><br><span class="line">        //   before blocking.</span><br><span class="line">        if (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (!MultithreadedForkChild) &#123;</span><br><span class="line">            waitForInitializeToComplete(cls);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // We&apos;re on the child side of fork(), facing a class that</span><br><span class="line">            // was initializing by some other thread when fork() was called.</span><br><span class="line">            _setThisThreadIsInitializingClass(cls);</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        // Set CLS_INITIALIZING failed because someone else already </span><br><span class="line">        //   initialized the class. Continue normally.</span><br><span class="line">        // NOTE this check must come AFTER the ISINITIALIZING case.</span><br><span class="line">        // Otherwise: Another thread is initializing this class. ISINITIALIZED </span><br><span class="line">        //   is false. Skip this clause. Then the other thread finishes </span><br><span class="line">        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. </span><br><span class="line">        //   Skip the ISINITIALIZING clause. Die horribly.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else &#123;</span><br><span class="line">        // We shouldn&apos;t be here. </span><br><span class="line">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，和<code>+load</code>方法一样，先父类后子类。然后赋值<code>reallyInitialize = YES;</code>，后边使用<code>try</code>主动调用<code>callInitialize(cls);</code>，来到<code>callInitialize(cls);</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终还是使用<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</code>主动调用了该函数。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点<br>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>可能会被调用多次）<br>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用</p>
<p>用伪代码实现以下思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(class 没有初始化)&#123;</span><br><span class="line">    父类初始化</span><br><span class="line">    子类初始化</span><br><span class="line">    调用initialize</span><br><span class="line">&#125;</span><br><span class="line">如果子类没有实现initialize，则去调用父类initialize。</span><br></pre></td></tr></table></figure>
<p>至于子类没有实现的话是直接调用父类的<code>initialize</code>，是使用<code>objc-msgsend</code>的原因。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">+(void)initialize&#123;</span><br><span class="line">	printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+(void)load&#123;</span><br><span class="line">	printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@interface FYPerson (test1)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+(void)initialize&#123;</span><br><span class="line">	printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+(void)load&#123;</span><br><span class="line">	printf(&quot;\n%s&quot;,__func__);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">+[FYPerson load]</span><br><span class="line">+[FYPerson(test2) load]</span><br><span class="line">+[FYPerson(test1) load]</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>+load</code>是根据函数地址直接调用，<code>initialize</code>是通过<code>objc_msgSend</code>调用</li>
<li><code>+load</code>是runtime加载类、分类时候调用（只会调用一次）</li>
<li><code>initialize</code>是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）</li>
<li><code>+load</code>调用优先于<code>initialize</code>,子类调用<code>+load</code>之前会调用父类的<code>+load</code>，再调用分类的<code>+load</code>,分类之间先编译，先调用。</li>
<li><code>initialize</code>先初始化父类，再初始化子类（可能最终调用父类的<code>initialize</code>）</li>
</ul>
<h3 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h3><h4 id="关联对象的本质-结构体"><a href="#关联对象的本质-结构体" class="headerlink" title="关联对象的本质-结构体"></a>关联对象的本质-结构体</h4><p>继承<code>NSObject</code>是可以可以直接使用<code>@property (nonatomic,assign) int age;</code>，但是在<code>Category</code>中会报错，那么怎么实现和继承基类一样的效果呢？<br>我们查看<code>Category</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  struct _category_t &#123;</span><br><span class="line">	const char *name; //&quot;FYPerson&quot;</span><br><span class="line">	struct _class_t *cls;</span><br><span class="line">	const struct _method_list_t *instance_methods;</span><br><span class="line">	const struct _method_list_t *class_methods;</span><br><span class="line">	const struct _protocol_list_t *protocols;</span><br><span class="line">	const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>const struct _prop_list_t *properties;</code>是存储属性的，但是缺少成员变量，而我们也不能主动在<code>_category_t</code>插入<code>ivar</code>，那么我们可以使用<code>objc_setAssociatedObject</code>将属性的值存储全局的<code>AssociationsHashMap</code>中，使用的时候<code>objc_getAssociatedObject(id object, const void *key)</code>,不使用的时候删除使用<code>objc_removeAssociatedObjects</code>删除。</p>
<p>我们进入到<code>objc_setAssociatedObject</code>内部,<code>objc-references.mm</code>275行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">	//根据key value 处理</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">		//生成一个全局的 HashMap</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">		//有value 就处理</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">//			遍历 hashMap是否有该obj</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">				//有的话 更新其 value</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">				//没有的话 赋值给 refs</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    //删除refs </span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该函数我们了解到</p>
<ul>
<li>关联对象并不是存储在关联对象的本身内存中</li>
<li>关联对象是存储在全局统一的<code>AssociationsManager</code>管理的<code>AssociationsHashMap</code>中</li>
<li>传入value =nil，会移除该关联对线<br><code>AssociationsManager</code>其实是管理了已<code>key为id object</code>对应的<code>AssociationsHashMap</code>，<code>AssociationsHashMap</code>存储了<code>key</code>对应的<code>ObjcAssociation</code>，<code>ObjcAssociation</code>是存储了<code>value</code> 和<code>policy</code>，<code>ObjcAssociation</code>的数据结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">        uintptr_t _policy;</span><br><span class="line">        id _value;</span><br><span class="line">        *****</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>具体抽象关系见下图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager --&gt; AssociationsHashMap --&gt; ObjectAssociationMap</span><br><span class="line">--&gt;void * ObjectAssociation --&gt;uintprt_t _policy ,id _value;</span><br></pre></td></tr></table></figure>
<p>简单来讲就是一个全局变量保存了以<code>class</code>为<code>key</code>对应的<code>AssociationsHashMap</code>，这个<code>AssociationsHashMap</code>存储了一个<code>key</code>对应的<code>ObjectAssociation</code>，<code>ObjectAssociation</code>包含了<code>value</code>和<code>_policy</code>。通过2层map保存了数据。</p>
<h4 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h4><table>
<thead>
<tr>
<th>objc_setAssociatedObject</th>
<th>obj,key,value,policy</th>
</tr>
</thead>
<tbody>
<tr>
<td>objc_getAssociatedObject</td>
<td>根据 obj 和 key获取值</td>
</tr>
<tr>
<td>void objc_removeAssociatedObjects(id object)</td>
<td>根据obj 删除关联函数</td>
</tr>
</tbody>
</table>
<p><code>objc_AssociationPolicy</code>的类型：</p>
<table>
<thead>
<tr>
<th>OBJC_ASSOCIATION_ASSIGN</th>
<th>weak 引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>非原子强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>非原子相当于copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>原子操作，相当于copy</td>
</tr>
</tbody>
</table>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (test)</span><br><span class="line">@property (nonatomic,assign) NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+test.h&quot;</span><br><span class="line">#import &quot;objc/runtime.h&quot;</span><br><span class="line">@implementation NSObject (test)</span><br><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">	objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">	return  objc_getAssociatedObject(self, @selector(name));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSObject *obj =[[NSObject alloc]init];</span><br><span class="line">obj.name = @&quot;老弟来了&quot;;</span><br><span class="line">printf(&quot;%s&quot;,obj.name.UTF8String);</span><br><span class="line">//老弟来了</span><br></pre></td></tr></table></figure>
<p>这段代码我们实现了给基类添加一个成员变量<code>name</code>，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Category <code>+load</code>在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。</li>
<li>Category <code>+initialize</code>在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用<code>objc-msgsend</code>机制调用。</li>
<li>Category 可以利用<code>Associative</code>添加和读取属性的值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
<li><p><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码</a></p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
</li>
</ul>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 KVO和KVC本质与联系 --(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 KVO和KVC本质与联系 --(3)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理  KVO和KVC本质与联系 --(3)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:13:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:13:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道实例实际是存储了成员变量的值和指向类的<code>isa</code>指针，<code>class</code>对象和<code>meta-class</code>对象包含 <code>isa</code>、<code>superclass</code>和<code>class_rw_t</code>这几种结构体，只是数据不一样，<code>isa</code>需要<code>ISA_MASK</code>&amp;之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。</p>
<h3 id="KVO本质"><a href="#KVO本质" class="headerlink" title="KVO本质"></a>KVO本质</h3><p> 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> #import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;FYPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)FYPerson *person;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	// Do any additional setup after loading the view.</span><br><span class="line">	self.person=[FYPerson new];</span><br><span class="line">	self.person.age = 10;</span><br><span class="line">	[self.person addObserver:self</span><br><span class="line">    			  forKeyPath:@&quot;age&quot;</span><br><span class="line">    				 options:NSKeyValueObservingOptionNew</span><br><span class="line">    				 context:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	self.person.age += 1;</span><br><span class="line">&#125;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">	NSLog(@&quot;监听到了age变化： %@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">	[self.person removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//下边是输出结果</span><br><span class="line">监听到了age变化： &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 12;</span><br><span class="line">    old = 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从上述代码可以看出，添加监听之后，当值改变时，会触发函数<code>observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</code>。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">//	self.person.age += 1;</span><br><span class="line">	[self.person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">	[self.person didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当把<code>age</code>具体值的改变，变成手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>的时候，结果如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  监听到了age变化： &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 10;</span><br><span class="line">    old = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>new</code>和<code>old</code>的值竟然一样，经测试只有同时先后调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>，会触发回调函数<code>observeValueForKeyPath</code>，由此可知触发条件是<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>配合使用。</p>
<h4 id="探寻KVO底层实现原理"><a href="#探寻KVO底层实现原理" class="headerlink" title="探寻KVO底层实现原理"></a>探寻KVO底层实现原理</h4><p>通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。<br>我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。<br>说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。<br>KVO底层实现分析<br>首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)FYPerson *person;</span><br><span class="line">@property (nonatomic,strong)FYPerson *person2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	// Do any additional setup after loading the view.</span><br><span class="line">	self.person=[FYPerson new];</span><br><span class="line">	self.person2 =[FYPerson new];</span><br><span class="line">	self.person.age = 10;</span><br><span class="line">	[self.person addObserver:self</span><br><span class="line">					  forKeyPath:@&quot;age&quot;</span><br><span class="line">						 options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</span><br><span class="line">						 context:nil];</span><br><span class="line"> Class superclass = NSStringFromClass( class_getSuperclass(NSClassFromString(@&quot;NSKVONotifying_FYPerson&quot;)));</span><br><span class="line">Class NSKVONotifying_FYPerson = objc_getClass(&quot;NSKVONotifying_FYPerson&quot;);</span><br><span class="line">    fy_objc_class* NSKVONotifying_FYPerson_class = (__bridge fy_objc_class *)NSKVONotifying_FYPerson;</span><br><span class="line">						 //此处打断点</span><br><span class="line"></span><br><span class="line">//p 命令输出isa指针 </span><br><span class="line">(lldb) p self.person2-&gt;isa</span><br><span class="line">(Class) $0 = FYPerson</span><br><span class="line">(lldb) p self.person-&gt;isa</span><br><span class="line">(Class) $1 = NSKVONotifying_FYPerson</span><br><span class="line"></span><br><span class="line">(lldb) p superclass</span><br><span class="line">(Class) $0 = FYPerson</span><br><span class="line"></span><br><span class="line">(lldb) p NSKVONotifying_FYPerson_class-&gt;superclass</span><br><span class="line">(Class) $4 = FYPerson</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从输出的isa指针看来，经过<code>【person addObserver】</code>之后，<code>person</code>的<code>isa</code>指针指向了<code>NSKVONotifying_FYPerson</code>,而<code>person2</code>的<code>isa</code>是<code>FYPerson</code>，可以看出系统是对<code>instance</code>对象的<code>isa</code>进行了赋值操作。通过<code>p NSKVONotifying_FYPerson_class-&gt;superclass==FYPerson</code>可以看出isa是指向了子类，那么子类<code>NSKVONotifying_FYPerson</code>到底做了那些事情呢？</p>
<p>看下边代码查看函数isa改变过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	self.person=[FYPerson new];</span><br><span class="line">	self.person2 =[FYPerson new];</span><br><span class="line">	self.person.age = 10;</span><br><span class="line">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">	[self.person addObserver:self</span><br><span class="line">					  forKeyPath:@&quot;age&quot;</span><br><span class="line">						 options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</span><br><span class="line">						 context:nil];</span><br><span class="line">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x000000010666b720</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x00000001069c63d2</span><br><span class="line"></span><br><span class="line">//查看IMP指针对应地址和内容</span><br><span class="line">(lldb) p (IMP)0x000000010666b720</span><br><span class="line">(IMP) $2 = 0x000000010666b720 (day03-KVO本质`::-[FYPerson setAge:](int) at FYPerson.h:14)</span><br><span class="line">(lldb) p (IMP)0x00000001069c63d2</span><br><span class="line">(IMP) $3 = 0x00000001069c63d2 (Foundation`_NSSetIntValueAndNotify)</span><br></pre></td></tr></table></figure>
<p>可以看出来两次的函数地址不一致，添加KVO之前是<code>[FYPerson setAge:]</code>,添加之后是<code>(Foundation_NSSetIntValueAndNotify)</code>。我们将<code>age</code>的类型改成<code>double</code>，再看一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x00000001080c4710</span><br><span class="line"></span><br><span class="line">(lldb) po [_person methodForSelector:@selector(setAge:)]</span><br><span class="line">0x000000010841f18c</span><br><span class="line"></span><br><span class="line">(lldb) p (IMP)0x00000001080c4710</span><br><span class="line">(IMP) $2 = 0x00000001080c4710 (day03-KVO本质`::-[FYPerson setAge:](double) at FYPerson.h:14)</span><br><span class="line">(lldb) p (IMP)0x000000010841f18c</span><br><span class="line">(IMP) $3 = 0x000000010841f18c (Foundation`_NSSetDoubleValueAndNotify)</span><br></pre></td></tr></table></figure>
<p><code>age</code>是<code>int</code>的时候添加之后是<code>Foundation _NSSetIntValueAndNotify</code>,改成<code>double</code>之后，是<code>Foundation _NSSetDoubleValueAndNotify</code>。那么我们可以推测<code>Foundation</code>框架中还有很多例如<code>_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify</code>等等函数。<br>运行<code>nm Foundation | grep ValueAndNotify</code>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation  | grep ValueAndNotify</span><br><span class="line">__NSSetBoolValueAndNotify</span><br><span class="line">__NSSetCharValueAndNotify</span><br><span class="line">__NSSetDoubleValueAndNotify</span><br><span class="line">__NSSetFloatValueAndNotify</span><br><span class="line">__NSSetIntValueAndNotify</span><br><span class="line">__NSSetLongLongValueAndNotify</span><br><span class="line">__NSSetLongValueAndNotify</span><br><span class="line">__NSSetObjectValueAndNotify</span><br><span class="line">__NSSetPointValueAndNotify</span><br><span class="line">__NSSetRangeValueAndNotify</span><br><span class="line">__NSSetRectValueAndNotify</span><br><span class="line">__NSSetShortValueAndNotify</span><br><span class="line">__NSSetSizeValueAndNotify</span><br></pre></td></tr></table></figure>
<h4 id="另外一种验证方法"><a href="#另外一种验证方法" class="headerlink" title="另外一种验证方法"></a>另外一种验证方法</h4><p>在macOS中可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开始记录日志</span><br><span class="line">instrumentObjcMessageSends(YES);</span><br><span class="line">    // Do stuff.</span><br><span class="line">instrumentObjcMessageSends(NO);//结束记录日志</span><br></pre></td></tr></table></figure>
<p>如果将<code>NSObjCMessageLoggingEnabled</code>环境变量设置为<code>YES</code>，则<code>Objective-C</code>运行时会将所有已分派的<code>Objective-C</code>消息记录到名为<code>/tmp/msgSends-&lt;pid&gt;</code>的文件中。每一次运行会生成一个文件，我们进入到该文件内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">+ FYPerson NSObject initialize</span><br><span class="line">+ FYPerson NSObject new</span><br><span class="line">- FYPerson NSObject init</span><br><span class="line">- FYPerson NSObject addObserver:forKeyPath:options:context:</span><br><span class="line">- FYPerson NSObject _isKVOA</span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//子类设置age [NSKVONotifying_FYPerson setAge:]</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:</span><br><span class="line">- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:</span><br><span class="line">- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:</span><br><span class="line"></span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:</span><br><span class="line"></span><br><span class="line">//will changeValueForKey</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:</span><br><span class="line"> </span><br><span class="line">//FYPerson 设置age</span><br><span class="line">- FYPerson FYPerson setAge:</span><br><span class="line"></span><br><span class="line">// didChangeValueForKeyOrKeys</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</span><br><span class="line">- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath</span><br><span class="line"></span><br><span class="line">//找到key 发送 具体的key对应的value 到observe</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject valueForKeyPath:</span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject valueForKey:</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:</span><br><span class="line">-</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">- NSKVONotifying_FYPerson FYPerson age</span><br><span class="line">+ NSKeyValueMethodGetter NSObject alloc</span><br><span class="line">- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:</span><br><span class="line">- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- NSKVONotifying_FYPerson NSObject respondsToSelector:</span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class</span><br><span class="line">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA</span><br><span class="line">+ FYPerson NSObject class</span><br><span class="line">+ FYPerson NSObject resolveInstanceMethod:</span><br><span class="line">+ FYPerson NSObject resolveInstanceMethod:</span><br><span class="line"></span><br><span class="line">//数据字典</span><br><span class="line">+ NSDictionary NSObject self</span><br><span class="line">+ NSMutableDictionary NSObject self</span><br><span class="line">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:</span><br><span class="line">- NSDictionary NSObject init</span><br><span class="line"></span><br><span class="line">// 执行观察者回调函数</span><br><span class="line">- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ Student NSObject alloc</span><br><span class="line">- Student NSObject init</span><br><span class="line">- Student NSObject dealloc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***//省略一部分代码</span><br><span class="line"> NSKVONotifying_FYPerson NSObject release</span><br><span class="line">- NSKeyValueChangeDictionary NSObject release</span><br><span class="line">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc</span><br><span class="line">- NSDictionary NSObject dealloc</span><br><span class="line">- NSKeyValueObservationInfo NSObject release</span><br><span class="line">- NSKVONotifying_FYPerson NSObject release</span><br></pre></td></tr></table></figure>
<p>经过仔细把重要的函数过滤出来，我们可以了解到<code>person.age = 12</code>的执行过程是<code>NSKVONotifying_FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues</code>-&gt;<code>FYPerson FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</code>-&gt;<code>NSKVONotifying_FYPerson NSObject valueForKeyPath:</code>-&gt;<code>NSMutableDictionary NSObject self</code>-&gt;<code>- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</code>，我们来用伪代码实现一遍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//person.age = 12</span><br><span class="line">[NSKVONotifying_FYPerson setAge:12];</span><br><span class="line">willChangeValueForKey@&quot;age&quot;;</span><br><span class="line">[FYPerson setAge:12];</span><br><span class="line">didChangeValueForKey@&quot;age&quot;;</span><br><span class="line">[[NSMutableDictionary alloc] init];</span><br><span class="line">[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];</span><br></pre></td></tr></table></figure>
<p>NSKVONotifyin_Person内部结构是怎样的？<br>首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。<br>我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.age = 1.0;</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p1.age = 2.0;</span><br><span class="line">    // self 监听 p1的 age属性</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">    [self printMethods: object_getClass(p2)];</span><br><span class="line">    [self printMethods: object_getClass(p1)];</span><br><span class="line"></span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) printMethods:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count ;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        NSString *methodName  = NSStringFromSelector(method_getName(method));</span><br><span class="line">        </span><br><span class="line">        [methodNames appendString: methodName];</span><br><span class="line">        [methodNames appendString:@&quot; &quot;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//结果如下：</span><br><span class="line">NSKVONotifying_FYPerson - setAge: class dealloc _isKVOA</span><br><span class="line">FYPerson - setAge: age</span><br></pre></td></tr></table></figure>
<p> 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。</p>
<p><img src="/images/3-1.png" alt></p>
<p>这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。</p>
<p>如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。</p>
<p>那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (Class) class &#123;</span><br><span class="line">     // 得到类对象，在找到类对象父类</span><br><span class="line">     return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后自己写代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(void)willChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">	NSLog(@&quot;%s 开始&quot;,__func__);</span><br><span class="line">	[super didChangeValueForKey:key];</span><br><span class="line">	NSLog(@&quot;%s 结束&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">	NSLog(@&quot;%s 开始&quot;,__func__);</span><br><span class="line">	[super didChangeValueForKey:key];</span><br><span class="line">	NSLog(@&quot;%s 结束&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setAge:(double)age&#123;</span><br><span class="line">	_age = age;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行之后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-[FYPerson willChangeValueForKey:] 开始</span><br><span class="line">-[FYPerson willChangeValueForKey:] 结束</span><br><span class="line">-[FYPerson setAge:]</span><br><span class="line">-[FYPerson didChangeValueForKey:] 开始</span><br><span class="line"> 监听到了age变化： &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 11;</span><br><span class="line">    old = 10;</span><br><span class="line">&#125;</span><br><span class="line">-[FYPerson didChangeValueForKey:] 结束</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>KVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p>
<h3 id="KVC的本质"><a href="#KVC的本质" class="headerlink" title="KVC的本质"></a>KVC的本质</h3><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。<br>常用的API有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>其实当Obj调用<code>(void)setValue:(id)value forKey:(NSString *)key</code>的时候，<code>obj</code>会主动寻找方法<code>setKey</code>和<code>_setKey</code>两个方法，没有找到这两个方法会再去寻找<code>accessInstanceVariablesDirectly</code>，返回值为<code>NO</code>则抛出异常，返回<code>YES</code>则去按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。<br>我们使用这段代码来验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()&#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">//code1</span><br><span class="line">- (void)setAge:(NSInteger)age&#123;</span><br><span class="line">	NSLog(@&quot;%s %ld&quot;,__func__,(long)age);</span><br><span class="line">&#125;</span><br><span class="line">//code2</span><br><span class="line">- (void)_setAge:(NSInteger)age&#123;</span><br><span class="line">	NSLog(@&quot;%s %ld&quot;,__func__,(long)age);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">[p setValue:@(2) forKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>
<p>当执行<code>code1</code>和<code>code2</code>都有的时候，输出<code>-[FYPerson setAge:] 2</code>，当<code>code1</code>注释掉，输出<code>-[FYPerson _setAge:] 2</code>，可以看出执行顺序是<code>setAge</code>，没有<code>setAge</code>的时候再去执行<code>_setAge</code>。</p>
<p>现在新增<code>FYPerson</code>4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface FYPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">	NSInteger _age;</span><br><span class="line">	NSInteger _isAge;</span><br><span class="line">	NSInteger age;</span><br><span class="line">	NSInteger isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">[p setValue:@(2) forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;age:%d _age:%d isAge:%d _isAge:%d&quot;,(int)p-&gt;age,(int)p-&gt;_age,(int)p-&gt;isAge,(int)p-&gt;_isAge);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>没注释输出 <code>age:0 _age:2 isAge:0 _isAge:0</code></li>
<li>注释<code>_age</code>输出 <code>age:0 isAge:0 _isAge:2</code></li>
<li>注释<code>_isAge</code>输出 <code>age:2 isAge:0</code></li>
<li>注释<code>age</code>输出 <code>isAge:2</code></li>
</ul>
<h4 id="KVC和KVO联系"><a href="#KVC和KVO联系" class="headerlink" title="KVC和KVO联系"></a>KVC和KVO联系</h4><p>我们知道KVC本质也是调用setter方法，那么会出发KVO吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">[p addObserver:p</span><br><span class="line">	forKeyPath:@&quot;age&quot;</span><br><span class="line">	   options:NSKeyValueChangeNewKey</span><br><span class="line">	   context:nil];</span><br><span class="line">[p setValue:@2 forKey:@&quot;age&quot;];</span><br><span class="line">[p removeObserver:p forKeyPath:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">@interface FYPerson()&#123;</span><br><span class="line">	@public</span><br><span class="line">	NSInteger _age;</span><br><span class="line">	NSInteger _isAge;</span><br><span class="line">	NSInteger age;</span><br><span class="line">	NSInteger isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">&#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 2;</span><br><span class="line">    old = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，可以看出KVC能触发KVO的。那么<code>valueForKey:key</code>底层是怎么运行的呢？其实底层是按照顺序查找四个方法<code>_age</code>-&gt;<code>_isAge</code>-&gt;<code>age</code>-&gt;<code>isAge</code>。我们测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">p-&gt;_age = 1;</span><br><span class="line">p-&gt;_isAge = 2;</span><br><span class="line">p-&gt;age = 3;</span><br><span class="line">p-&gt;isAge = 4;</span><br><span class="line">NSLog(@&quot;value:%@&quot;,[p valueForKey:@&quot;age&quot;]);</span><br><span class="line">//依次注释1,2,3，依次输出是1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>KVC其实本质是执行4个set方法和4个get方法，当使用<code>setValue:forKey:key</code>会触发KVO，找不到4个方法的时候会抛出异常。</p>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
</ul>
<p>之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何<code>hook objc_msgsend</code>,感觉这个挺好玩的。</p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p> 广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 类的本质--(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 类的本质--(2)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理  类的本质 --(2)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:12:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:12:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="底层原理-类的本质"><a href="#底层原理-类的本质" class="headerlink" title="底层原理 类的本质"></a>底层原理 类的本质</h3><p>复习一下<a href>IOS 底层原理 对象的本质–(1)</a>，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Person</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	@public</span><br><span class="line">	int _age;//4bytes</span><br><span class="line">	int _level;//4bytes</span><br><span class="line">	int _code;//4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>经过<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后其实<code>Person</code>对象是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	int _age;</span><br><span class="line">	int _level;</span><br><span class="line">	int _code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NSObject_IMPL</code>结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么<code>NSObject</code>在内存中包括</p>
<ul>
<li><code>isa</code>指针</li>
<li>其他成员变量</li>
</ul>
<p><img src="/images/2-1.png" alt></p>
<p><code>isa</code>地址就是<code>instance</code>的地址，其他成员变量排在后边，也就是<code>instance</code>的地址就是<code>isa</code>的地址。</p>
<p>那么这个<code>isa</code>指向的到底是什么呢？<br>请往下继续看：<br>先看下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSObject *ob1=[[NSObject alloc]init];</span><br><span class="line">NSObject *ob2=[[NSObject alloc]init];</span><br><span class="line"></span><br><span class="line">Class cl1 = object_getClass([ob1 class]);</span><br><span class="line">Class cl2 = object_getClass([ob2 class]);</span><br><span class="line"></span><br><span class="line">Class cl3 = ob1.class;</span><br><span class="line">Class cl4 = ob2.class;</span><br><span class="line"></span><br><span class="line">Class cl5 = NSObject.class;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot; %p %p %p %p %p&quot;,cl1,cl2,cl3,cl4,cl5);</span><br><span class="line">//0x7fff8e3ba0f0 0x7fff8e3ba0f0 </span><br><span class="line">//0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140</span><br></pre></td></tr></table></figure>
<p>这代码是输出了几个<code>NSObject</code>的对象的类和<code>NSObject</code>的类对象的地址，可以看到<code>cl1==cl2</code>、<code>cl3==cl4==cl5</code>。</p>
<h4 id="Class的本质"><a href="#Class的本质" class="headerlink" title="Class的本质"></a>Class的本质</h4><p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = [NSObject class];        </span><br><span class="line">Class objectMetaClass = object_getClass([NSObject class]);</span><br></pre></td></tr></table></figure>
<p>点击class来到内部，可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p><code>class</code>对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p>
<p>来到<code>objc_class</code>内部，在源码中经常看到这段源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;//isa</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                    //父类          OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                              //obj名字 OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                            //版本 OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                               //info OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                      // OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars             //成员变量链表     OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;//方法链表</span><br><span class="line">    struct objc_cache * _Nonnull cache      //缓存链表                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols         //协议链表 OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure>
<p>这段代码明显是 已经<code>OBJC2_UNAVAILABLE</code>，说明代码已经不在使用了。那么<code>objc_class</code>结构体内部结构到底是什么呢？通过objc搜寻<code>runtime</code>的内容可以看到<code>objc_class</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setInfo(uint32_t set) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;setFlags(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void clearInfo(uint32_t clear) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;clearFlags(clear);</span><br><span class="line">    &#125;</span><br><span class="line">    //**后边省略</span><br></pre></td></tr></table></figure>
<p>我们发现这个结构体继承 <code>objc_object</code> 并且结构体内有一些函数，因为这是<code>c++</code>结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到<code>objc_object</code>内，截取部分代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    // getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    // initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    // If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    // initInstanceIsa(): objects with no custom RR/AWZ</span><br><span class="line">    // initClassIsa(): class objects</span><br><span class="line">    // initProtocolIsa(): protocol objects</span><br><span class="line">    // initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls /*nonpointer=false*/);</span><br><span class="line">    void initClassIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initProtocolIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br></pre></td></tr></table></figure>
<p>那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取<code>class_rw_t</code>内部实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;//方法列表</span><br><span class="line">    property_array_t properties;//属性列表</span><br><span class="line">    protocol_array_t protocols;//协议列表</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">**</span><br><span class="line">//后边省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>class_rw_t</code>是通过<code>bits.data()</code>获取的，截取<code>bits.data()</code>查看内部实现,而仅仅是<code>bits&amp;FAST_DATA_MASK</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而成员变量则是存储在<code>class_ro_t</code>内部中的，我们来到<code>class_ro_t</code>内部查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;//方法列表</span><br><span class="line">    protocol_list_t * baseProtocols;//协议列表</span><br><span class="line">    const ivar_list_t * ivars;//成员变量列表</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;//属性列表</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后通过一张图总结一下：</p>
<p><img src="/images/2-2.png" alt></p>
<p>那么我们来证明一下：<br>我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。<br>下边代码是我们自定义的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Header.h</span><br><span class="line">//  day02-类的本质1</span><br><span class="line">//</span><br><span class="line">//  Created by Charlie on 2019/7/2.</span><br><span class="line">//  Copyright © 2019 www.fgyong.cn. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifndef Header_h</span><br><span class="line">#define Header_h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">	cache_key_t _key;</span><br><span class="line">	IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">	bucket_t *_buckets;</span><br><span class="line">	mask_t _mask;</span><br><span class="line">	mask_t _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">	uint32_t entsizeAndFlags;</span><br><span class="line">	uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">	SEL name;</span><br><span class="line">	const char *types;</span><br><span class="line">	IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">	method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">	int32_t *offset;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *type;</span><br><span class="line">	uint32_t alignment_raw;</span><br><span class="line">	uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">	ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">	property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">	chained_property_list *next;</span><br><span class="line">	uint32_t count;</span><br><span class="line">	property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">	uintptr_t count;</span><br><span class="line">	protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t instanceStart;</span><br><span class="line">	uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">	uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">	const uint8_t * ivarLayout;</span><br><span class="line">	const char * name;  // 类名</span><br><span class="line">	method_list_t * baseMethodList;</span><br><span class="line">	protocol_list_t * baseProtocols;</span><br><span class="line">	const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">	const uint8_t * weakIvarLayout;</span><br><span class="line">	property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t version;</span><br><span class="line">	const class_ro_t *ro;</span><br><span class="line">	method_list_t * methods;    // 方法列表</span><br><span class="line">	property_list_t *properties;    // 属性列表</span><br><span class="line">	const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">	Class firstSubclass;</span><br><span class="line">	Class nextSiblingClass;</span><br><span class="line">	char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">	uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">	class_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作</span><br><span class="line">		return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct xx_objc_object &#123;</span><br><span class="line">	void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct fy_objc_class : xx_objc_object &#123;</span><br><span class="line">	Class superclass;</span><br><span class="line">	cache_t cache;</span><br><span class="line">	class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">	class_rw_t* data() &#123;</span><br><span class="line">		return bits.data();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</span><br><span class="line">		// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span><br><span class="line">		return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif /* Header_h */</span><br></pre></td></tr></table></figure>
<p>这段代码亲测可用，直接复制自己新建<code>.h</code>文件导入’main.m’即可，将<code>main.m</code>改成<code>main.mm</code>或者将其他某一个<code>.m</code>改成<code>.mm</code>运行就可以运行了。</p>
<p>那么我们再拿出来经典的那张图挨着分析<code>isa</code> 和<code>superclass</code>的指向</p>
<p><img src="/images/2-2.png" alt></p>
<h4 id="instance-对象验证"><a href="#instance-对象验证" class="headerlink" title="instance 对象验证"></a>instance 对象验证</h4><p>使用 <code>p/x</code>输出<code>obj</code>16进制的地址，然后<strong>isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</strong>。实施之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//object</span><br><span class="line"></span><br><span class="line">Printing description of student:</span><br><span class="line">&lt;Student: 0x1021729c0&gt;</span><br><span class="line">(lldb) p/x object-&gt;isa //查看isa指针地址</span><br><span class="line">(Class) $0 = 0x001dffff8e3ba141 NSObject </span><br><span class="line">(lldb) p/x objectClass//输出 objectClass的地址</span><br><span class="line">(fy_objc_class *) $1 = 0x00007fff8e3ba140</span><br><span class="line">(lldb) p/x 0x001dffff8e3ba141&amp;0x00007ffffffffff8//计算得出object-&gt;isa真正的地址</span><br><span class="line">(long) $2 = 0x00007fff8e3ba140 //0x00007fff8e3ba140是 objectClass地址和object-&gt;isa地址一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//person</span><br><span class="line"></span><br><span class="line">Printing description of person: &lt;Person: 0x102175300&gt;</span><br><span class="line">(lldb) p/x person-&gt;isa</span><br><span class="line">(Class) $3 = 0x001d800100002469 Person</span><br><span class="line">(lldb) p/x 0x001d800100002469&amp;0x00007ffffffffff8</span><br><span class="line">(long) $4 = 0x0000000100002468</span><br><span class="line">(lldb) p/x personClass</span><br><span class="line">(fy_objc_class *) $5 = 0x0000000100002468//isa 和personclass地址都是0x0000000100002468</span><br><span class="line"></span><br><span class="line">//student</span><br><span class="line"></span><br><span class="line">(lldb) p/x student-&gt;isa</span><br><span class="line">(Class) $6 = 0x001d8001000024b9 Student</span><br><span class="line">(lldb) p/x 0x001d8001000024b9&amp;0x00007ffffffffff8</span><br><span class="line">(long) $7 = 0x00000001000024b8</span><br><span class="line">(lldb) p/x studentClass</span><br><span class="line">(fy_objc_class *) $8 = 0x00000001000024b8//studentclass 和isa地址都是0x00000001000024b8</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<p>从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。</p>
<h4 id="class-对象验证"><a href="#class-对象验证" class="headerlink" title="class 对象验证"></a>class 对象验证</h4><p>接着我们来看<code>class</code>对象，同样通过上一篇文章，我们明确<code>class</code>对象中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对<code>object</code>源码的分析，我们知道这些信息存储在<code>class</code>对象的<code>class_rw_t</code>中，我们通过强制转化来窥探其中的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//objectClass and objectMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p/x objectClass-&gt;isa</span><br><span class="line">(__NSAtom *) $6 = 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</span><br><span class="line">(long) $7 = 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p/x objectMetaClass</span><br><span class="line">(fy_objc_class *) $8 = 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">//personClass and personMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p/x personClass-&gt;isa</span><br><span class="line">(__NSAtom *) $9 = 0x001d800100002441</span><br><span class="line">(lldb) p/x personMetaClass</span><br><span class="line">(fy_objc_class *) $10 = 0x0000000100002440</span><br><span class="line">(lldb) p/x 0x001d800100002441&amp;0x00007ffffffffff8</span><br><span class="line">(long) $11 = 0x0000000100002440</span><br><span class="line"></span><br><span class="line">//sutdentClass and studentMetaClass</span><br><span class="line"></span><br><span class="line">(lldb) p/x studentClass-&gt;isa</span><br><span class="line">(__NSAtom *) $12 = 0x001d800100002491</span><br><span class="line">(lldb) p/x 0x001d800100002491&amp;0x00007ffffffffff8</span><br><span class="line">(long) $13 = 0x0000000100002490</span><br><span class="line">(lldb) p/x studentMetaClass</span><br><span class="line">(fy_objc_class *) $14 = 0x0000000100002490</span><br></pre></td></tr></table></figure>
<p>有此结果得知<code>objectMetaClass==objectClass-&gt;isa==0x00007fff8e3ba0f0</code>,<code>personClass-&gt;isa==personMetaClass==0x0000000100002440</code>,<code>studentClass-&gt;isa==studentMetaClass==0x0000000100002490</code>。<br>由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。</p>
<h4 id="meta-class对象验证"><a href="#meta-class对象验证" class="headerlink" title="meta-class对象验证"></a>meta-class对象验证</h4><p>最后我们来看<code>meta-class</code>元类对象，上文提到<code>meta-class</code>中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的类方法信息。同时我们知道<code>meta-class</code>元类对象与<code>class</code>类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的<code>isa</code>指针指向基类的元类对象，基类的元类对象的<code>isa</code>指针指向自己。元类对象的<code>superclass</code>指针指向其父类的元类对象，基类的元类对象的<code>superclass</code>指针指向其类对象。<br>与<code>class</code>对象相同，我们同样通过模拟对<code>person</code>元类对象调用<code>.data</code>函数，即对<code>bits</code>进行<code>&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)</code>运算，并转化为<code>class_rw_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</span><br><span class="line">//objectMetaClass-&gt;isa =   0x00007fff8e3ba0f0</span><br><span class="line">//objectMetaClass = 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">(lldb) p/x objectMetaClass-&gt;superclass</span><br><span class="line">(Class) $20 = 0x00007fff8e3ba140 NSObject</span><br><span class="line">(lldb) p/x objectMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $21 = 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</span><br><span class="line">(long) $22 = 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p/x objectMetaClass</span><br><span class="line">(fy_objc_class *) $23 = 0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line">// personMetaClass-&gt;superclas=0x00007fff8e3ba0f0</span><br><span class="line">//personMetaClass-&gt;isa=0x00007fff8e3ba0f0</span><br><span class="line">//personMetaClass = 0x0000000100002440</span><br><span class="line"></span><br><span class="line">(lldb) p/x personMetaClass-&gt;superclass</span><br><span class="line">(Class) $25 = 0x00007fff8e3ba0f0</span><br><span class="line">(lldb) p/x personMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $26 = 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p/x personMetaClass</span><br><span class="line">(fy_objc_class *) $30 = 0x0000000100002440</span><br><span class="line"></span><br><span class="line">// studentMetaClass-&gt;superclas=0x0000000100002440</span><br><span class="line">//studentMetaClass-&gt;isa=0x00007fff8e3ba0f0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(lldb) p/x studentMetaClass-&gt;superclass</span><br><span class="line">(Class) $27 = 0x0000000100002440</span><br><span class="line">(lldb) p/x studentMetaClass-&gt;isa</span><br><span class="line">(__NSAtom *) $28 = 0x001dffff8e3ba0f1</span><br><span class="line">(lldb) p/x 0x001dffff8e3ba0f1 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $29 = 0x00007fff8e3ba0f0</span><br></pre></td></tr></table></figure>
<p>由上面可以看出，<code>studentMetaClass-&gt;isa</code>,<code>personMetaClass-&gt;isa</code>,<code>objectMetaClass-&gt;isa</code>结果<code>mask</code>之后都是<code>0x00007fff8e3ba0f0</code>，与<code>p/x objectMetaClass</code>结果一致，则验证了13，14，15号线，<code>studentMetaClass-&gt;superclass =0x0000000100002440</code>,<code>personMetaClass = 0x0000000100002440</code>验证12号线，<code>personMetaClass-&gt;isa=0x00007fff8e3ba0f0</code>和<code>objectMetaClass = 0x00007fff8e3ba0f0</code>验证了11号线，<code>objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</code>验证10号线。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对象的isa指向哪里？</p>
<ul>
<li>instance对象的isa指向class对象</li>
<li>class对象的isa指向meta-class对象</li>
<li>meta-class对象的isa指向基类的meta-class对象</li>
<li>class和meta-class的内存结构一样的，只是值不一样</li>
</ul>
<p>OC的类信息存放在哪里？</p>
<ul>
<li>对象方法、属性、成员变量、协议信息存放在class对象中</li>
<li>类方法存放在meta-class对象中</li>
<li>成员变量具体值存放在instance对象中</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<p><img src="/images/0.png" alt></p>
<p>/</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/IOS底层原理 对象的本质--(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/IOS底层原理 对象的本质--(1)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS底层原理  对象的本质 --(1)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:11:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:11:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h3><p>探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。<br>那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC/对象的内存布局和内存分配机制。</p>
<p>使用的<a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">代码下载</a><br>要用的工具:</p>
<ul>
<li><a href="https://developer.apple.com/cn/support/xcode/" target="_blank" rel="noopener">Xcode 10.2</a></li>
<li><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">gotoShell</a></li>
<li><a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">linux-glibc-2.29源码</a></li>
<li><a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">libmalloc源码</a></li>
</ul>
<p>首先我们使用最基本的代码验证对象是什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">	    // insert code here...</span><br><span class="line">		NSObject *obj=[[NSObject alloc]init];</span><br><span class="line">	    NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>clang</code>编译器编译成<code>cpp</code>，<br>执行<code>clang -rewrite-objc main.m -o main.cpp</code>之后生成的<code>cpp</code>，这个生成的<code>cpp</code>我们不知道是跑在哪个平台的，现在我们指定<code>iphoeos</code>和<code>arm64</code>重新编译一下。<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>，将<code>main64.cpp</code>拖拽到Xcode中并打开。<br>|clang|编译器|<br>|————–|——-|<br>|xcrun|命令|<br>|sdk|指定编译的平台|<br>|arch|arm64架构|<br>|-rewrite-objc|重写|<br>|main.m|重写的文件|<br>|main64.cpp|导出的文件|<br>|-o|导出|</p>
<p><code>command + F</code>查找<code>int main</code>,找到关键代码，这就是<code>main</code>函数的转化成<code>c/c++</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">  NSObject *obj=((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">     NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么这个结构体是什么呢？<br>其实我们<code>Object-C</code>编译之后对象会编译成结构体，如图所示：<br><img src="/images/1-1.png" alt><br>那么<code>isa</code>是什么吗？通过查看源码得知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p><code>class</code>其实是一个指向结构体的指针，然后<code>com+点击class</code>得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><code>class</code>是一个指针，那么占用多少内存呢？大家都知道<strong>指针在32位是4字节，在64位是8字节。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj=[[NSObject alloc]init];</span><br></pre></td></tr></table></figure>
<p>可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。<br><code>obj</code>就是指向结构体<code>class</code>的一个指针。<br>那么我们来验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">	    // insert code here...</span><br><span class="line">		NSObject *obj=[[NSObject alloc]init];</span><br><span class="line">		//获得NSobject对象实例大小</span><br><span class="line">		size_t size = class_getInstanceSize(obj.class);</span><br><span class="line">		//获取NSObjet指针的指向的内存大小</span><br><span class="line">		//需要导入：#import &lt;malloc/malloc.h&gt;</span><br><span class="line">		size_t size2 = malloc_size((__bridge const void *)(obj));</span><br><span class="line">		NSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:8 size2:16</span><br></pre></td></tr></table></figure>
<p>结论是：<strong>指针是8字节，指针指向的的内存大小为16字节。</strong><br>查看源码得知<code>[[NSObject alloc]init]</code>的函数运行顺序是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_createInstance</span><br><span class="line">    -_class_createInstanceFromZone</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct = true, </span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    **</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    **</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数前边后边省略，取出关键代码，其实<code>size</code>是<code>cls-&gt;instanceSize(extraBytes)</code>执行的结果。那么我们再看下<code>cls-&gt;instanceSize</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//成员变量大小 8bytes</span><br><span class="line">    uint32_t alignedInstanceSize() &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">        size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">        // CF requires all objects be at least 16 bytes.</span><br><span class="line">        if (size &lt; 16) size = 16;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过源码注释得知：CF要求所有的objects 最小是16bytes。</p>
<p><code>class_getInstanceSize</code>函数的内部执行顺序是<code>class_getInstanceSize-&gt;cls-&gt;alignedInstanceSize()</code><br>查阅源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//成员变量大小 8bytes</span><br><span class="line">    uint32_t alignedInstanceSize() &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以最终结论是：<strong>对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes</strong>。</p>
<p>验证：<br>在刚才 的代码打断点和设置<code>Debug-&gt;Debug Workflow-&gt;View Memory</code>,然后运行程序，</p>
<p><img src="/images/1-2.png" alt></p>
<p><img src="/images/1-3.png" alt><br>点击<code>obj-&gt;view *objc</code>得到上图所示的内存布局，从<code>address</code>看出和<code>obj</code>内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.</p>
<p>使用lldb命令<code>memory read 0x100601f30</code>输出内存布局，如下图：<br><img src="/images/1-4.png" alt><br>或者使用<code>x/4xg 0x100601f30</code>输出：</p>
<p><img src="/images/1-5.png" alt><br><code>x/4xg 0x100601f30</code>中<code>4</code>是输出<code>4</code>个数据,<code>x</code> 是16进制,后边<code>g</code>是8字节为单位。可以验证刚才的出的结论。</p>
<p>那么我们再使用复杂的一个对象来验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	int _age;</span><br><span class="line">	int _no;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后对应的源码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line"> Class isa;</span><br><span class="line">&#125;;</span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;// 8 bytes</span><br><span class="line">	int _age;//4 bytes</span><br><span class="line">	int _no;//4 bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Person——IMPL</code><strong>结构体占用16bytes</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *obj=[[Person alloc]init];</span><br><span class="line">		obj-&gt;_age = 15;</span><br><span class="line">		obj-&gt;_no = 14;</span><br></pre></td></tr></table></figure>
<p>使用代码验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *obj=[[Person alloc]init];</span><br><span class="line">obj-&gt;_age = 15;</span><br><span class="line">obj-&gt;_no = 14;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL *p =(__bridge struct Person_IMPL*)obj;</span><br><span class="line">NSLog(@&quot;age:%d no:%d&quot;,p-&gt;_age,p-&gt;_no);</span><br><span class="line"></span><br><span class="line">//age:15 no:14</span><br></pre></td></tr></table></figure>
<p>使用内存布局验证：</p>
<p><img src="/images/1-6.png" alt><br>以十进制输出每个4字节<br><img src="/images/1-7.png" alt><br>使用内存布局查看数据验证，<code>Person</code>占用16 bytes。</p>
<p>下边是一个直观的内存布局图：</p>
<p><img src="/images/1-8.png" alt></p>
<h4 id="再看一下更复杂的继承关系的内存布局："><a href="#再看一下更复杂的继承关系的内存布局：" class="headerlink" title="再看一下更复杂的继承关系的内存布局："></a>再看一下更复杂的继承关系的内存布局：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	@public</span><br><span class="line">	int _age;//4bytes </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Student</span><br><span class="line">@interface Student : Person</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">	int _no;//4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>那小伙伴可能要说这一定是32字节，因为<code>Person</code>上边已经证明是16字节，<code>Student</code>又多了个成员变量<code>_no</code>，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。<br>其实不然，<code>Person</code>是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，<code>Student</code>是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以<code>Student</code>是占用了16字节。</p>
<p>那么我们来证明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student *obj=[[Student alloc]init];</span><br><span class="line">		obj-&gt;_age = 6;</span><br><span class="line">		obj-&gt;_no = 7;</span><br><span class="line">		</span><br><span class="line">		//获得NSobject对象实例成员变量占用的大小 -&gt;8</span><br><span class="line">		size_t size = class_getInstanceSize(obj.class);</span><br><span class="line">		//获取NSObjet指针的指向的内存大小 -&gt;16</span><br><span class="line">		size_t size2 = malloc_size((__bridge const void *)(obj));</span><br><span class="line">		NSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</span><br><span class="line">		//size:16 size2:16</span><br></pre></td></tr></table></figure>
<p>再看一下LLDB查看的内存布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8xw 0x10071ae30</span><br><span class="line">0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007</span><br><span class="line">0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff</span><br><span class="line"></span><br><span class="line">(lldb) memory read 0x10071ae30</span><br><span class="line">0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................</span><br><span class="line">0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....</span><br><span class="line"></span><br><span class="line">(lldb) x/4xg 0x10071ae30</span><br><span class="line">0x10071ae30: 0x001d800100001299 0x0000000700000006</span><br><span class="line">0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0</span><br></pre></td></tr></table></figure>
<p>可以看出来<code>0x00000006</code>和<code>0x00000007</code>就是两个成员变量的值，占用内存是16字节。</p>
<p>我们将<code>Student</code>新增一个成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Student</span><br><span class="line">@interface Student : Person</span><br><span class="line">&#123;</span><br><span class="line">@public</span><br><span class="line">	int _no;//4bytes</span><br><span class="line">	int _no2;//4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后查看内存布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8xg 0x102825db0</span><br><span class="line">0x102825db0: 0x001d8001000012c1 0x0000000700000006</span><br><span class="line">0x102825dc0: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80</span><br><span class="line">0x102825de0: 0x0000000102825c60 0x0000000102825890</span><br></pre></td></tr></table></figure></p>
<p>从<code>LLDB</code>可以看出来，<strong>内存变成了32字节。(0x102825dd0-0x102825db0=0x20)</strong></p>
<p>我们再增加一个属性看下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	@public</span><br><span class="line">	int _age;//4bytes </span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,assign) int level; //4字节</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//InstanceSize:16 malloc_size:16</span><br></pre></td></tr></table></figure></p>
<p>为什么新增了一个属性，内存还是和没有新增的时候一样呢？<br>因为<code>property</code>=<code>setter</code>+<code>getter</code>+<code>ivar</code>,<code>method</code>是存在类对象中的，所以实例<code>Person</code>占用的内存还是<code>_age</code>,<code>_level</code>和一个指向类的指针，最后结果是<code>4+4+8=16bytes</code>。</p>
<p>再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个<code>int</code>成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	@public</span><br><span class="line">	int _age;//4bytes</span><br><span class="line">	int _level;//4bytes</span><br><span class="line">	int _code;//4bytes</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *obj=[[Person alloc]init];</span><br><span class="line">		obj-&gt;_age = 6;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//获得NSobject对象实例成员变量占用的大小 -&gt;24</span><br><span class="line">		Class ocl = obj.class;</span><br><span class="line">		size_t size = class_getInstanceSize(ocl);</span><br><span class="line">		//获取NSObjet指针的指向的内存大小 -&gt;32</span><br><span class="line">		size_t size2 = malloc_size((__bridge const void *)(obj));</span><br><span class="line">		printf(&quot;InstanceSize:%zu malloc_size:%zu \n&quot;,size,size2);</span><br><span class="line">		</span><br><span class="line">InstanceSize:24 malloc_size:32</span><br></pre></td></tr></table></figure>
<p>为什么和我们猜测的不一样呢？<br>那么我们再探究一下：<br>实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码<code>NSObject.mm 2306行</code>得到创建对象函数调用顺序<code>allocWithZone-&gt;_objc_rootAllocWithZone-&gt;_objc_rootAllocWithZone-&gt;class_createInstance-&gt;_class_createInstanceFromZone-&gt;_class_createInstanceFromZone</code>最后查看下<code>_class_createInstanceFromZone</code>的源码，其他已省略，只留关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct = true, </span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">**</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line">    **</span><br><span class="line">    obj = (id)calloc(1, size);</span><br><span class="line">   **</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们在看一下<code>instanceSize</code>中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//对象指针的大小</span><br><span class="line">   uint32_t alignedInstanceSize() &#123;</span><br><span class="line">       return word_align(unalignedInstanceSize());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">       size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">       // CF requires all objects be at least 16 bytes.</span><br><span class="line">       if (size &lt; 16) size = 16;</span><br><span class="line">       return size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后调用的<code>obj = (id)calloc(1, size);</code>传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？<br>因为这是<code>c</code>函数，我们去<a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">苹果开源官网下载源码看下</a>,可以找到这句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define NANO_MAX_SIZE			256 /* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</span><br></pre></td></tr></table></figure>
<p>看来<code>NANO_MAX_SIZE</code>在申请空间的时候做完优化就是16的倍数,并且最大是256。所以<code>size = 24 ;obj = (id)calloc(1, size);</code>申请的结果是32字节。<br>然后再看下<code>Linux</code>空间申请的机制是什么？<br><a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">下载gnu资料</a>，<br>得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _I386_MALLOC_ALIGNMENT_H</span><br><span class="line">#define _I386_MALLOC_ALIGNMENT_H</span><br><span class="line"></span><br><span class="line">#define MALLOC_ALIGNMENT 16</span><br><span class="line"></span><br><span class="line">#endif /* !defined(_I386_MALLOC_ALIGNMENT_H) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&apos;ed chunks.  It</span><br><span class="line">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span><br><span class="line">   which smaller alignments would suffice. It may be defined as larger</span><br><span class="line">   than this though. Note however that code and data structures are</span><br><span class="line">   optimized for the case of 8-byte alignment.  */</span><br><span class="line">   //最少是2倍的SIZE_SZ 或者是__alignof__(long double)</span><br><span class="line">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span><br><span class="line">			  ? __alignof__ (long double) : 2 * SIZE_SZ)</span><br><span class="line">			  </span><br><span class="line">			  </span><br><span class="line">/* The corresponding word size.  */</span><br><span class="line">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span><br><span class="line"></span><br><span class="line">#ifndef INTERNAL_SIZE_T</span><br><span class="line"># define INTERNAL_SIZE_T size_t</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在i386中是16，在其他系统中按照宏定义计算，<br><code>__alignof__ (long double)</code>在iOS中是16,<code>size_t</code>是8，则上面的代码简写为<code>#define MALLOC_ALIGNMENT (2*8 &lt; 16 ? 16:2*8)</code>最终是16字节。</p>
<p>总结：</p>
<blockquote>
<p>实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。</p>
</blockquote>
<ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo 查看</a></li>
</ul>
<hr>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/06/25/iOS 手动做一个自动打包部署神器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/25/iOS 手动做一个自动打包部署神器/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS 手动做一个自动打包部署神器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-25 16:39:24" itemprop="dateCreated datePublished" datetime="2019-06-25T16:39:24+08:00">2019-06-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。</p>
<ul>
<li>打包</li>
<li>导出ipa</li>
<li>上传pgyer</li>
</ul>
<h4 id="打包自动上传pgyer"><a href="#打包自动上传pgyer" class="headerlink" title="打包自动上传pgyer"></a>打包自动上传pgyer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#xcodebuild archive -project &apos;test.xcodeproj&apos; -configuration &apos;Debug&apos; -scheme &apos;BLTSZY&apos; -archivePath &apos;./app.xcarchive&apos; LIBRARY_SEARCH_PATHS=&quot;./Pods/../build/**  ./BLTSZY/**&quot;</span><br><span class="line">proName=&apos;your project name&apos;</span><br><span class="line">proURL=&quot;your project path&quot;#like /Users/Jerry/Desktop/ios_afu</span><br><span class="line">api_key=&apos;&apos;#pgyer api_key</span><br><span class="line">configuration=&apos;Debug&apos; #Release </span><br><span class="line">autoPlus()&#123;</span><br><span class="line">path=$&#123;proURL&#125;/$&#123;proName&#125;/$&#123;proName&#125;/Info.plist</span><br><span class="line">number=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;path&#125;&quot;)</span><br><span class="line">BundleVersion=$(( $number + 1 ))</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set CFBundleVersion $BundleVersion&quot; &quot;$&#123;path&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">#打包</span><br><span class="line">arch()&#123;</span><br><span class="line">    echo &apos;开始编译Pods&apos;</span><br><span class="line">    xcodebuild -project Pods/Pods.xcodeproj build</span><br><span class="line">    echo &apos;开始编译project&apos;</span><br><span class="line"></span><br><span class="line">xcodebuild -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive</span><br><span class="line">autoPlus</span><br><span class="line">&#125;</span><br><span class="line">#导出ipa</span><br><span class="line">exportIPA()&#123;</span><br><span class="line">    echo &apos;开始导出ipa&apos;</span><br><span class="line">    xcodebuild -exportArchive -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -exportPath &apos;./app&apos; -exportOptionsPlist &apos;./ExportOptions.plist&apos;</span><br><span class="line">&#125;</span><br><span class="line">#上传ipa到蒲公英</span><br><span class="line">upload()&#123;</span><br><span class="line">if [ -e &quot;$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &apos;开始上传ipa/apk到蒲公英&apos;</span><br><span class="line">    curl -F &quot;file=@$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; -F &quot;_api_key=$&#123;api_key&#125;&quot; &apos;http://www.pgyer.com/apiv2/app/upload&apos;</span><br><span class="line">else</span><br><span class="line">    echo &quot;在目录：$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa 不存在&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">startarch()&#123;</span><br><span class="line">    arch</span><br><span class="line">    if (($? == 0))</span><br><span class="line">    then</span><br><span class="line">        echo &apos;archive success🍺&apos;</span><br><span class="line">        startExportIPA</span><br><span class="line">    else</span><br><span class="line">        echo &apos;archive faild❌&apos;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">startExportIPA()&#123;</span><br><span class="line">    exportIPA</span><br><span class="line">    if(($? == 0))</span><br><span class="line">    then</span><br><span class="line">        echo &apos;exportIPA success🍺🍺&apos;</span><br><span class="line">        startUPLoadIPA</span><br><span class="line">    else</span><br><span class="line">        echo &apos;exportIPA faild ❌&apos;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">startUPLoadIPA()&#123;</span><br><span class="line">    upload</span><br><span class="line">    if(($? == 0))</span><br><span class="line">    then</span><br><span class="line">        echo &apos;uploadIPA success&apos;</span><br><span class="line">    else</span><br><span class="line">        echo &apos;uploadIPA faild ❌&apos;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (($# == 0))</span><br><span class="line">#then</span><br><span class="line">#    startarch</span><br><span class="line">#elif (($# == 1))</span><br><span class="line">then</span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">        echo &apos;🍺🍺🍺***********************🍺🍺🍺&apos;</span><br><span class="line">        echo  &quot;输入 1 到 4 之间的数字:&quot;</span><br><span class="line">        echo  &quot;输入 1:从编译打包开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 2:从导出IPA开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 3:从上传ipa开始至结束&quot;</span><br><span class="line">        echo  &quot;输入 4:退出&quot;</span><br><span class="line">        read a</span><br><span class="line">        case $a in</span><br><span class="line">            1)startarch</span><br><span class="line">            break;;</span><br><span class="line">            2)startExportIPA</span><br><span class="line">            break;;</span><br><span class="line">            3)startUPLoadIPA</span><br><span class="line">            break;;</span><br><span class="line">            4) break;;</span><br><span class="line">        esac</span><br><span class="line">        done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>将该文件和plis拖到project目录下，然后配置<br>plis文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">	&lt;false/&gt;</span><br><span class="line">	&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;ad-hoc&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;your bundle id&lt;/key&gt;</span><br><span class="line">		&lt;string&gt;your .mobileprovsion&lt;/string&gt;</span><br><span class="line">	&lt;/dict&gt;</span><br><span class="line">	&lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">	&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;your_team_id&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p>
<p>下载<code>setup.sh</code>拖到项目文件夹内，然后<br>运行<code>./setup.sh</code>，即可完成上传到pgyer网站。<br>具体的配置属性见源码下载页面。<br><a href="https://github.com/ifgyong/autoAEU" target="_blank" rel="noopener">查看源码</a></p>
<p>```</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/06/24/iOS 浅析指针、函数、typedef/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/24/iOS 浅析指针、函数、typedef/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">iOS 浅析指针、函数、typedef</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 16:39:24" itemprop="dateCreated datePublished" datetime="2019-06-24T16:39:24+08:00">2019-06-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h4><p>顾名思义，指针函数即返回指针的函数。其一般定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 *函数名(函数参数表列);</span><br></pre></td></tr></table></figure>
<p>其中，后缀运算符括号<code>“()”</code>表示这是一个函数，其前缀运算符星号<code>“*”</code>表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。</p>
<p><code>“(函数参数表列)”</code>中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pfun(int, int);</span><br></pre></td></tr></table></figure>
<p>由于<code>“*”</code>的优先级低于<code>“()”</code>的优先级，因而pfun首先和后面的<code>“()”</code>结合，也就意味着，pfun是一个函数。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *(pfun(int, int));</span><br></pre></td></tr></table></figure>
<p>接着再和前面的<code>“*”</code>结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。<br>我们不妨来再看一看，指针函数与函数指针有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*pfun)(int, int);</span><br></pre></td></tr></table></figure>
<p>通过括号强行将pfun首先与<code>“*”</code>结合，也就意味着，pfun是一个指针，接着与后面的<code>“()”</code>结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。</p>
<p>虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。</p>
<p>用函数指针作为指针函数的返回值<br>在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*ff(int))(int *, int);</span><br></pre></td></tr></table></figure>
<p>我们用上面介绍的方法分析一下，ff首先与后面的<code>“()”</code>结合，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*(ff(int)))(int *, int);</span><br></pre></td></tr></table></figure>
<p>用括号将<code>ff(int)</code>再括起来也就意味着，<code>ff</code>是一个函数。<br>接着与前面的<code>“*”</code>结合，说明<code>ff</code>函数的返回值是一个指针。然后再与后面的<code>“()”</code>结合，也就是说，该指针指向的是一个函数。</p>
<p>这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*PF)(int *, int);</span><br></pre></td></tr></table></figure>
<p>也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针<code>“类型”</code>，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*PF)(int *, int);</span><br></pre></td></tr></table></figure>
<p>这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PF ff(int);</span><br></pre></td></tr></table></figure>
<h4 id="深入理解-typedef"><a href="#深入理解-typedef" class="headerlink" title="深入理解 typedef"></a>深入理解 typedef</h4><p>平时我们在OC中的使用写法，但是对<code>typedef</code>困惑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);//typedefBlock Code Snippets</span><br><span class="line"></span><br><span class="line">typedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过<code>RWAlertViewCompletionBlock</code>当成block类型直接使用了。<br>然后看下<code>libffi</code>的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">  FFI_OK = 0,</span><br><span class="line">  FFI_BAD_TYPEDEF,</span><br><span class="line">  FFI_BAD_ABI</span><br><span class="line">&#125; ffi_status;</span><br><span class="line">typedef int INT64;//INT64 其实是int</span><br></pre></td></tr></table></figure></p>
<p>使用起来的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffi_status status;//声明一个类型是ffi_status的参数</span><br><span class="line">INT64 age;//声明一个age 类型是INT64</span><br></pre></td></tr></table></figure></p>
<p>现在block也可以是函数指针了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*PF)(int *, int);</span><br><span class="line">//也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：</span><br><span class="line">typedef int (*PF)(int *, int);</span><br></pre></td></tr></table></figure></p>
<p><strong>typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。</strong><br>针对经典的const来个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef char * pStr;</span><br><span class="line">char string[4] = &quot;abc&quot;;</span><br><span class="line">const char *p1 = string;</span><br><span class="line">const pStr p2 = string;</span><br><span class="line">p1++;</span><br><span class="line">p2++;//error</span><br></pre></td></tr></table></figure></p>
<p>那么为什么<code>p2++</code>为什么会报错呢？<br>我们来分析一下，<code>const char *p1 = string;</code>是声明了一个<code>const char</code>的指针，不可变的是<code>char</code>,相当于<code>(const char)*p=string</code>,所以<code>p1++</code>不会报错。<code>p2++</code>报错根本原因是<code>p2</code>是不可变的，<code>const pStr p2 = string</code>相当于<code>const (char *) p2 = string</code>,<code>const</code>修饰的是<code>char *</code>，所以<code>p2</code>不可改变。<code>p1</code>是数组，<code>p2</code>是固定的值。</p>
<h4 id="typedef如何使用呢？"><a href="#typedef如何使用呢？" class="headerlink" title="typedef如何使用呢？"></a><code>typedef</code>如何使用呢？</h4><p>我们具体看几个案例分析一下。</p>
<p>案例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*b) (void (*)());</span><br></pre></td></tr></table></figure></p>
<p>简化一下是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef  void (*func)()</span><br><span class="line">typedef  int (*ifunc)(func)</span><br></pre></td></tr></table></figure></p>
<p>最终简化成<code>ifunc b;</code>。可以理解成<code>(void (*)())</code>是一个<code>func</code>,然后替换<code>func</code>成了最终的形参是<code>func</code>，返回值是<code>int</code>。</p>
<p>案例2分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*func)(int *p);</span><br></pre></td></tr></table></figure></p>
<p>首先找到<code>func</code>，<code>func</code>左边是<code>*</code>，说明<code>func</code>是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<br>func是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p>
<p>综合案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL didload = @selector(viewDidLoad);</span><br><span class="line">Method md = class_getInstanceMethod(aclass, didload);</span><br><span class="line">IMP load = method_getImplementation(md);</span><br><span class="line">void(*loadFunc)(id,SEL) = (void *)load;</span><br></pre></td></tr></table></figure></p>
<p>这是将SEL获取了Method之后将IMP转化成<code>void(*loadFunc)(id,SEL)</code>，调用的时候可以直接调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行ViewDidLoad IMP</span><br><span class="line"> loadFunc(aclass,NULL);</span><br></pre></td></tr></table></figure></p>
<p>Method可以这样使用，block同样也可以这样使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (^block)(id _self) = ^(id _self)&#123;</span><br><span class="line">    //code here</span><br><span class="line">&#125;;</span><br><span class="line">void(*func)(id,SEL) = (void*)imp_implementationWithBlock(block);</span><br><span class="line">class_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));</span><br></pre></td></tr></table></figure></p>
<p>这可以直接使用<code>runtime/message.h</code>函数<code>imp_implementationWithBlock</code>将<code>block</code>转化成<code>IMP</code>,使用<code>class_replaceMethod</code>替换某个函数的<code>IMP</code>。那么再调用该函数的时候，则是调用的<code>block</code>的<code>IMP</code>。获取<code>method</code>和<code>block</code>参数后续再分析。</p>
<p>资料参考：</p>
<p><a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">玉令天下博客地址</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2018/05/28/Python3 Flask bootstrap教程(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/28/Python3 Flask bootstrap教程(2)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">Python3 Flask bootstrap教程(2)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-28 12:02:22" itemprop="dateCreated datePublished" datetime="2018-05-28T12:02:22+08:00">2018-05-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.蓝图<br>2.Nav的使用<br>3.mysql使用<br>4.模板的使用</p>
<h3 id="蓝图使用"><a href="#蓝图使用" class="headerlink" title="蓝图使用"></a>蓝图使用</h3><p>新建user文件夹,在user文件夹下变新建tamplates，还有<strong>init</strong>.py和views.py<br><strong>init.py</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">//声明蓝图</span><br><span class="line">user = Blueprint(&apos;user&apos;, __name__,template_folder=&apos;templates&apos;)</span><br><span class="line"></span><br><span class="line">from api.v1.user import views</span><br></pre></td></tr></table></figure></p>
<p>然后在run.py中注册蓝图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先导入</span><br><span class="line">from api.v1.user import user</span><br><span class="line"></span><br><span class="line">app.register_blueprint(user,url_prefix=&apos;/user&apos;) 后边的是路径</span><br></pre></td></tr></table></figure></p>
<p>然后在user的views中就可以写方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, jsonify,render_template</span><br><span class="line">from flask.json import tojson_filter</span><br><span class="line">from api.v1.user import user</span><br><span class="line">from api.v1 import first</span><br><span class="line">import pymysql</span><br><span class="line">import sys</span><br><span class="line">import json</span><br><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line">//路由</span><br><span class="line">@user.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])</span><br><span class="line">//方法</span><br><span class="line">def my_index():</span><br><span class="line">    args = request.args;</span><br><span class="line">    age = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    if args.__contains__(&apos;name&apos;):</span><br><span class="line">        name = request.args.getlist(key=&apos;name&apos;)</span><br><span class="line">    if args.__contains__(&apos;age&apos;):</span><br><span class="line">        age = request.args.__getitem__(&apos;age&apos;)</span><br><span class="line">//返回数据是json</span><br><span class="line">    return jsonify(&#123;&apos;method&apos;:sys._getframe().f_code.co_name,</span><br><span class="line">                    &apos;name&apos;:str(name),</span><br><span class="line">                    &apos;age&apos;:age&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在我们想返回一个html，那么就在tamplates中新建一个index.html<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;helloword&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在views中增加路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@user.route(&apos;/helloword&apos;)</span><br><span class="line">def helloword():</span><br><span class="line">    return render_template(&apos;helloword.html&apos;)</span><br></pre></td></tr></table></figure></p>
<p>运行程序,输入地址<code>127.0.0.1：5000/helloword</code>，出现helloword，就算我们的程序跑起来了。</p>
<h3 id="Nav的使用"><a href="#Nav的使用" class="headerlink" title="Nav的使用"></a>Nav的使用</h3><p>nav就是html的头部或者banner，我们写一个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</span><br><span class="line">           aria-expanded=&quot;false&quot;&gt;</span><br><span class="line">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;dropdown&quot;  &gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</span><br><span class="line">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</span><br><span class="line">            关于</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。</p>
<h3 id="mysql使用"><a href="#mysql使用" class="headerlink" title="mysql使用"></a>mysql使用</h3><p>本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def userList():</span><br><span class="line">    con = pymysql.connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;, charset=&apos;utf8&apos;)  # 添加utf8 否则中文乱码</span><br><span class="line">    cur = con.cursor()</span><br><span class="line">    cur.execute(&apos;select * from user&apos;)</span><br><span class="line">    nums = cur.rownumber</span><br><span class="line">    all = cur.fetchall()</span><br><span class="line">    data = []</span><br><span class="line">    for i in range(len(all)):</span><br><span class="line">        one = all[i]</span><br><span class="line">        data.append(&#123;&apos;name&apos;: str(one[1]),</span><br><span class="line">                     &apos;age&apos;: one[2]&#125;)</span><br><span class="line"></span><br><span class="line">    con.close()</span><br><span class="line">    return data</span><br></pre></td></tr></table></figure></p>
<h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br><span class="line">    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;</span><br><span class="line">    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Bootstrap --&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</span><br><span class="line">    &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</span><br><span class="line">    &lt;!--[if lt IE 9]&gt;</span><br><span class="line">      &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">      &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</span><br><span class="line">           aria-expanded=&quot;false&quot;&gt;</span><br><span class="line">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;dropdown&quot;  &gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</span><br><span class="line">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li role=&quot;presentation&quot;&gt;</span><br><span class="line">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</span><br><span class="line">            关于</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">这下边就是定义的缺少的block</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们在子网页中继承这个模板并且添加上去block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//继承刚才的网页</span><br><span class="line">&#123;% extends &apos;base.html&apos; %&#125;</span><br><span class="line">//下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&lt;div class=&quot;pager&quot;&gt;</span><br><span class="line">    &lt;h1 align=&quot;center&quot;&gt;用户列表&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;table class=&quot;table nav-tabs&quot;&gt;</span><br><span class="line">        &#123;% for i in data %&#125;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;名字：&#123;&#123; i.name &#125;&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;年龄：&#123;&#123; i.age &#125;&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td align=&quot;center&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;add&quot;&gt;</span><br><span class="line">                    &lt;input type=&quot;button&quot; value=&quot;添加用户&quot;  align=&quot;center&quot; style=&quot;width: 200px&quot;&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td align=&quot;center&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;list&quot; &gt;</span><br><span class="line">                    &lt;input type=&quot;button&quot;  value=&quot;用户列表&quot; style=&quot;width: 200px&quot;&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2018/05/27/Python3 Flask bootstrap教程(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/27/Python3 Flask bootstrap教程(1)/" class="post-title-link" itemprop="http://fgyong.cn/page/2/index.html">Python3 Flask bootstrap教程(1)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-27 12:02:22" itemprop="dateCreated datePublished" datetime="2018-05-27T12:02:22+08:00">2018-05-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.安装Flask<br>2.安装bootstrap<br>3.HelloWord</p>
<h3 id="安装Flask"><a href="#安装Flask" class="headerlink" title="安装Flask"></a>安装Flask</h3><p>我用的py3，所以安装命令是：<br><code>pip3 install Flask</code>，安装之后，在Pycharm里边看到是这样子的，<br><img src="https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="py3第三方库列表"></p>
<h3 id="安装bootstrap"><a href="#安装bootstrap" class="headerlink" title="安装bootstrap"></a>安装bootstrap</h3><p>安装bootstrap，看这里<a href="https://v2.bootcss.com/index.html" target="_blank" rel="noopener">官方教程</a>,<br>或者<a href="http://getbootstrap.com/2.3.2/assets/bootstrap.zip" target="_blank" rel="noopener">下载</a>，然后解压，放到Flask的目录下边。我的目录是这样子的<br><img src="https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"></p>
<h3 id="HelloWord"><a href="#HelloWord" class="headerlink" title="HelloWord"></a>HelloWord</h3><p>初始化Flask，<br>新建app.py<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, request, jsonify</span><br><span class="line">import os</span><br><span class="line">from api.v1 import config</span><br><span class="line">from api.v1.user import user</span><br><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">Bootstrap(app)</span><br><span class="line">app.config.from_object(config)</span><br><span class="line">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p>
<p>选中文件，右键-&gt;run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.<br>完整代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">Bootstrap(app)</span><br><span class="line">app.config.from_object(config)</span><br><span class="line">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</span><br><span class="line">@app.route(&apos;/index&apos;)//添加路由</span><br><span class="line">def my_index()://路由执行的函数</span><br><span class="line">    return jsonify(&#123;&quot;key&quot;:&apos;helloWord&apos;&#125;)//返回数据</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()//app运行</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="helloword"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
