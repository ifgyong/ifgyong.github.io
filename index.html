<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:type" content="website">
<meta property="og:title" content="fgyong的技术博客">
<meta property="og:url" content="http://fgyong.cn/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="在学习的路上，不忘初心 方得始终">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fgyong的技术博客">
<meta name="twitter:description" content="在学习的路上，不忘初心 方得始终">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml">




  <link rel="canonical" href="http://fgyong.cn/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不忘初心 方得始终</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/24/macOS AUY一款为开发者某福利的APP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/24/macOS AUY一款为开发者某福利的APP/" class="post-title-link" itemprop="http://fgyong.cn/index.html">macOS 一款自动上传图床的APP</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-24 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-24T11:15:58+08:00">2019-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/macOS/" itemprop="url" rel="index"><span itemprop="name">macOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>macOS开发和iOS有很多相关之处，也有很多不同之处，今天带你使用最优雅的<code>APP.dmg</code>,一款名叫<code>AUY</code>的自动上传图床的APP，没有服务器，不担心数据被盗，可以上传剪切板中的图片，可以拖动文件上传、智能的APP。</p>
<h2 id="AUY-传送门"><a href="#AUY-传送门" class="headerlink" title="AUY 传送门"></a><a href="https://github.com/ifgyong/AUY/releases" target="_blank" rel="noopener">AUY 传送门</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>更少的操作步骤完成目标。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/05/APP资源优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/05/APP资源优化/" class="post-title-link" itemprop="http://fgyong.cn/index.html">APP 资源管理优化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-05 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-05T11:15:58+08:00">2019-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在APP中，使用 X1、X2、X3已经是司空见惯的事情了，网上出了清空不再使用的图片和类，是不是做完这些不能再进一步优化了，答案是否定的，当然可以的，今天再探究一下资源管理优化。</p>
<p>资源大部分是图片，说到图片必须讲一下位图和矢量图</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><blockquote>
<p>位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。</p>
</blockquote>
<h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h3><blockquote>
<p>矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。<br>矢量图是根据几何特性来绘制图形，矢量可以是一个点或一条线，矢量图只能靠软件生成，文件占用内在空间较小，因为这种类型的图像文件包含独立的分离图像，可以自由无限制的重新组合。</p>
</blockquote>
<h3 id="说人话"><a href="#说人话" class="headerlink" title="说人话"></a>说人话</h3><blockquote>
<p>位图就是无数个点组成的图片，基本元素是像素；矢量图有多个图形组成的，基本元素是图像。当相同尺寸的位图和矢量图绘制在大屏幕上，位图的弊端出现了，图像看着像素颗粒很大，而矢量图基本效果还是很好的。</p>
</blockquote>
<p>矢量图在绘制到不同的屏幕上有着天然的优势。</p>
<h2 id="开始使用矢量图"><a href="#开始使用矢量图" class="headerlink" title="开始使用矢量图"></a>开始使用矢量图</h2><p>在Xcdoe 9、iOS11 中已经开始支持了矢量图，只需要设置打钩<code>Preserve Cector Dadta</code>。<br><img src="http://blog.fgyong.cn/FhF6-GTsthDXMlsX9ezQ1PaXalIa.png-a" alt></p>
<p><strong>前提图片格式是矢量图哦</strong></p>
<p>矢量图在资源大小中相比和一倍、两倍、三倍图总和，大小下降<strong>60%</strong>，这算是不错的提升了。</p>
<h2 id="Stretchable-Images"><a href="#Stretchable-Images" class="headerlink" title="Stretchable Images"></a>Stretchable Images</h2><p>从iOS11、Xcode 9就开始支持了该工具，该工具可实现在<code>building</code>中将图片元数据格栅化，儿不是在运行时处理，降低图片在显示时候的CPU压力。<br>当渲染的尺寸大于当前的尺寸的时候才会重新渲染，否则使用优化过的预渲染位图。<br>效果是这样子的</p>
<p><img src="http://blog.fgyong.cn/FpZhgVvqS711QZZnYYptKr40Pc9U-a" alt></p>
<h4 id="Slicing"><a href="#Slicing" class="headerlink" title="Slicing"></a>Slicing</h4><h5 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h5><ul>
<li>None 无</li>
<li>Horizontal 水平</li>
<li>Vertical 竖直</li>
<li>Horizontal and Vertical 水平和竖直 </li>
</ul>
<h5 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h5><ul>
<li>Tiles 平铺</li>
<li>Streches 拉伸</li>
</ul>
<p>使用这两组参数可以达到绝大部分需求了</p>
<p><img src="http://blog.fgyong.cn/FrtLZrygVGyJAqlV6Q412foMQgRk-a" alt></p>
<p>当我们使用下图这种图片，提前和UI讲清楚，作出一个小图，在设备上使用<code>Stretchable Images</code>功能，可以达到大图的效果。</p>
<p><img src="http://blog.fgyong.cn/FvHCZgiiwONF_5Y01HOVP_-d9d3_-a" alt><br>白色部分表示可拉伸和舍弃的<br><img src="http://blog.fgyong.cn/Fh6BK-44VNuB2PDdQUjaA-2iOF_J-a" alt></p>
<p>最终效果是这样的</p>
<p><img src="http://blog.fgyong.cn/1.mp4" alt></p>
<p>👏👏👏👏</p>
<p>更多用法可以参考<a href="https://developer.apple.com/videos/play/wwdc2018/227" target="_blank" rel="noopener">WWDC2018/227</a></p>
<h2 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h2><p>大项目可能会有很多框架，当多个框架使用的图片名字发生重复时，使用<code>Bundle</code>是不错的选择，<code>Bundle</code>相当于文件夹，相同<code>Bundle</code>下边没有重复的文件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Get the app&apos;s main bundle</span><br><span class="line">let mainBundle = Bundle.main</span><br><span class="line"></span><br><span class="line">//获取本地Bundle 图片</span><br><span class="line">let me = Bundle.init(identifier: &quot;me&quot;)</span><br><span class="line">let path = me?.path(forResource: &quot;fgyong.cn 技术博客&quot;, ofType: &quot;png&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>当APP有50个类似的功能，但是每个功能都用类似的图片，那么他们名字也一致，我们使用<code>Namespace</code>来解决这个问题。<br><img src="http://blog.fgyong.cn/FqvcOJHbjHBdE04jl78PlT3pAA4l-a" alt></p>
<p>使用起来也是很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let image = UIImage(named: &quot;me/4.png&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="APP-Thining"><a href="#APP-Thining" class="headerlink" title="APP Thining"></a>APP Thining</h2><h3 id="Memory-Classes-amp-amp-Graphics-Classes"><a href="#Memory-Classes-amp-amp-Graphics-Classes" class="headerlink" title="Memory Classes &amp;&amp; Graphics Classes"></a>Memory Classes &amp;&amp; Graphics Classes</h3><p>使用内存和Metal来适配不同机型，达到最优性能。</p>
<p><img src="http://blog.fgyong.cn/FgJGgpqcA-K_kSKY6e9LDZapOiYT-a" alt></p>
<p>首先机型先去找4GB的资源，4GB没找到，则向下寻找3GB，一直寻找到1GB对应的资源。</p>
<p>内存和GPU相比，内存有着更高的优先级，我们确定内存是表现设备整体性能的标准。</p>
<h2 id="NSSData-set"><a href="#NSSData-set" class="headerlink" title="NSSData set"></a>NSSData set</h2><p><code>Data set</code>容器可以放任何东西。<br>可以是<code>plist</code>文件，可以是<code>video</code>、可以是<code>mp3</code>，可以是其他任何格式的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open class func preloadTextureAtlasesNamed(_ atlasNames: [String], withCompletionHandler completionHandler: @escaping (Error?, [SKTextureAtlas]) -&gt; Void)</span><br></pre></td></tr></table></figure>
<p>使用该函数立刻调用大量I/O和内存来解码或读入数据，预先放在内存中，你需要在紧急需要的时候调用该函数。不要随意调用该API，以为它会按照你说的<strong>立马</strong>去做！⚠️⚠️⚠️当你调用该函数，请确保立即使用资源，否则API会消耗大量的I/O和内存来加载所有这些图像。</p>
<p><code>Sprite Atlases</code>强大之处是会根据不同设备和屏幕来渲染不同的图像，并传送到正确的设备。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://blog.fgyong.cn/Fld0tbjb_RgbF9QWnzTXUYrZJzhG-a" alt></p>
<ul>
<li>在iOS12上采用最新的算法，这些图像资源会减少10%-20%的空间，</li>
<li>使用Xcode的资源目录是不错的选择</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/03/iOS图片优化 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/03/iOS图片优化 /" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS图片优化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-03 11:15:58" itemprop="dateCreated datePublished" datetime="2019-12-03T11:15:58+08:00">2019-12-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基于现在iOS11新生成的图片都是<code>HEIF</code>，该图片使用<code>[UIImage image:name]</code>已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。</p>
<p>既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?</p>
<p>这就要先了解该图片的编码了。</p>
<h2 id="HEIC-HEIF"><a href="#HEIC-HEIF" class="headerlink" title="HEIC HEIF"></a>HEIC HEIF</h2><blockquote>
<p>带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件</p>
</blockquote>
<p><code>heic</code>和<code>heif</code>是广色域图片的格式，广色域比<code>sRGB</code>表示范围大25%，在广色域设备中能显示更广的色彩，<code>sRGB 8bit/dept</code>，广色域达到<code>16bit/dept</code>。广色域只是在硬件支持的情况下才能显示的。<br>其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载<code>image</code>，只是把<strong>文件信息</strong>加载到内存中，下一步就是解码。在代码中体现就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let image = UIImage(contentsOfFile: url.path)</span><br><span class="line">或 加载图片到内存 会常驻内存</span><br><span class="line">let image = UIImage(named: name)!</span><br></pre></td></tr></table></figure></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>其实是发生在添加到要显示的view上面才会解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let imageV = UIImageView.init(image: image)</span><br><span class="line">imageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)</span><br><span class="line">self.view.addSubview(imageV)</span><br></pre></td></tr></table></figure></p>
<p>最后一行不写，则不会解码。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>当<code>view</code>显示出来则是渲染。过程是解码的<code>data buffer</code> 复制到<code>frame buffer</code>,硬件从帧缓冲区读取数据显示到屏幕上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.view.addSubview(imageV)</span><br></pre></td></tr></table></figure></p>
<h2 id="内存暴涨原因"><a href="#内存暴涨原因" class="headerlink" title="内存暴涨原因"></a>内存暴涨原因</h2><p>一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。</p>
<p>首先有请我们准备的素材和设备(6s 64g版本)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:jpg</span><br><span class="line">20M 12000*12000</span><br><span class="line"></span><br><span class="line">B:jpg</span><br><span class="line">2.8M 3024*4032</span><br><span class="line"></span><br><span class="line">C:HEIC</span><br><span class="line">1.8M 3024*4032</span><br></pre></td></tr></table></figure></p>
<p>素材A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.8M</span><br><span class="line">加载Image: 240.3M之后稳定到220M</span><br><span class="line">CPU：峰值5%，随后降低到0%</span><br><span class="line">image占内存：226.5M</span><br></pre></td></tr></table></figure></p>
<p>素材B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.7M</span><br><span class="line">加载Image: 31.5</span><br><span class="line">CPU：峰值5%，随后降低到0%</span><br><span class="line">image占内存：17.8M</span><br></pre></td></tr></table></figure></p>
<p>素材C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APP运行内存：13.8M</span><br><span class="line">加载Image: 32.3</span><br><span class="line">CPU：峰值4%，随后降低到0%</span><br><span class="line">image占内存：18.5M</span><br></pre></td></tr></table></figure></p>
<p>我们猜测是否是<code>imageView</code>的大小影响内存的呢？<br><code>size</code>改为原来的1/10结果运行内存还是和以前一样。</p>
<p>为什么呢？</p>
<blockquote>
<p>内存大小不是取决于<code>view</code>的<code>size</code>，而是原始文件<strong>image size</strong>。</p>
</blockquote>
<p><img src="/images/14-1.png" alt></p>
<h3 id="渲染格式"><a href="#渲染格式" class="headerlink" title="渲染格式"></a>渲染格式</h3><h4 id="SRGB"><a href="#SRGB" class="headerlink" title="SRGB"></a>SRGB</h4><p>每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。</p>
<h4 id="display-p3-宽色域"><a href="#display-p3-宽色域" class="headerlink" title="display p3 宽色域"></a>display p3 宽色域</h4><p>每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。</p>
<h4 id="亮度和透明度"><a href="#亮度和透明度" class="headerlink" title="亮度和透明度"></a>亮度和透明度</h4><p>每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。</p>
<h4 id="Alpha-8-Format"><a href="#Alpha-8-Format" class="headerlink" title="Alpha 8 Format"></a>Alpha 8 Format</h4><p>每个像素1字节，用来表示透明度，一般用作蒙版和文字。<br>相比sRGB容量小了75%，详细 宽色域 容量小了87.5%</p>
<h3 id="渲染图片大小计算"><a href="#渲染图片大小计算" class="headerlink" title="渲染图片大小计算"></a>渲染图片大小计算</h3><p>图片大小 = 图片格式容量 <em> 像素个数<br>当我们把大小是20\</em>20使用<code>Alpha 8 format</code>渲染到20*20的view上面，和40*40的image使用<code>p3</code>渲染到20*20的view中，后着占用内存是前者的8倍。</p>
<p>使用sRGB色域进行渲染所占用的大小为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageWidth*imageHeight*4 字节</span><br></pre></td></tr></table></figure></p>
<p>每个像素占用了4字节，每个字节8位，</p>
<p>使用<code>display p3</code>则每个通道占用16位，那么占用内存大小是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageWidth*imageHeight*8 字节</span><br></pre></td></tr></table></figure></p>
<h3 id="如何选择正确的图片格式"><a href="#如何选择正确的图片格式" class="headerlink" title="如何选择正确的图片格式"></a>如何选择正确的图片格式</h3><blockquote>
<p>不要主动选择图片格式，让格式选择你。</p>
</blockquote>
<p>不要再使用<code>UIGraphicsBeginImageContextWithOptions</code>,该方法总是使用sRGB格式，你想节约内存是不行的，在支持<code>p3</code>的设备上想绘制出来<code>p3</code>色域的图片也是不行的。那么使用<code>UIGraphicsImageRenderer</code>系统可以自动为你选择格式，如果绘制<code>image</code>，自己再添加单色蒙版，是不需要另外单独分配内存的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if let im = imageV &#123;</span><br><span class="line">//第二次添加蒙版</span><br><span class="line">	im.tintColor = UIColor.black</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//绘制一个红色矩形</span><br><span class="line">	let bounds = CGRect(x: 0, y: 0, width: width, height: height)</span><br><span class="line">	let renderer = UIGraphicsImageRenderer(bounds: bounds)</span><br><span class="line">	 let image = renderer.image &#123; (coxt) in</span><br><span class="line">		UIColor.red.setFill()</span><br><span class="line">		let path = UIBezierPath(roundedRect: bounds,</span><br><span class="line">								cornerRadius: 20)</span><br><span class="line">		path.addClip()</span><br><span class="line">		UIRectFill(bounds)</span><br><span class="line">	&#125;</span><br><span class="line">	imageV = UIImageView(image: image)</span><br><span class="line">	imageV?.frame = bounds</span><br><span class="line">	self.view.addSubview(imageV!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>UIImage</code> 直接读出来需要将所有<code>UIImage</code>的<code>data</code>全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用<strong>下采样</strong>。</p>
<h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p>当<code>image</code>素材大小是<code>1000*1000</code>，但是在手机上显示出来只有<code>200*200</code>，我们其实是没必要将<code>1000*1000</code>的数据都解码的，只需要缩小成<code>200*200</code>的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。<br>在<code>UIKit</code>中使用<code>UIGraphicsImageRenderer</code>会有瞬间很高的内存和CPU峰值，那么</p>
<h4 id="1-UIKit-UIGraphicsImageRenderer"><a href="#1-UIKit-UIGraphicsImageRenderer" class="headerlink" title="1.UIKit  UIGraphicsImageRenderer"></a>1.UIKit  UIGraphicsImageRenderer</h4><p>使用素材A下采样技术，使用<code>UIKit</code>中的<code>UIGraphicsImageRenderer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:16.4M</span><br><span class="line">normal:14.8M</span><br><span class="line">CPU:</span><br><span class="line">Hight:29%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</span><br><span class="line">	guard let image = UIImage(contentsOfFile: url.path) else &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	if #available(iOS 10.0, *) &#123;</span><br><span class="line">		let renderer = UIGraphicsImageRenderer(size: size)</span><br><span class="line">	</span><br><span class="line">		return renderer.image &#123; (context) in</span><br><span class="line">			image.draw(in: CGRect(origin: .zero, size: size))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		UIGraphicsBeginImageContext(size)</span><br><span class="line">		image.draw(in: CGRect(origin: .zero, size: size))</span><br><span class="line">		let image = UIGraphicsGetImageFromCurrentImageContext()</span><br><span class="line">		UIGraphicsEndImageContext()</span><br><span class="line">		return image</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用子线程绘制，会出现CPU略微升高，当<code>image size</code>大很多的时候会出现内存飙升然后慢慢恢复到<code>normal</code>。</p>
<h4 id="2-CoreGraphics-CGContext上下文绘制缩略图"><a href="#2-CoreGraphics-CGContext上下文绘制缩略图" class="headerlink" title="2.CoreGraphics CGContext上下文绘制缩略图"></a>2.CoreGraphics CGContext上下文绘制缩略图</h4><p>使用上下文绘制 <code>cpu</code> 和内存变化如下,<code>CPU</code>和内存没有大的变动解决了该问题，也做到省电、顺滑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:42.3M</span><br><span class="line">normal:14.1M</span><br><span class="line">CPU:</span><br><span class="line">Hight:6%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage2(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line">	guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">		let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)</span><br><span class="line">	else&#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	let cxt = CGContext(data: nil,</span><br><span class="line">						width: Int(size.width),</span><br><span class="line">						height: Int(size.height),</span><br><span class="line">						bitsPerComponent: image.bitsPerComponent,</span><br><span class="line">						bytesPerRow: image.bytesPerRow,</span><br><span class="line">						space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!</span><br><span class="line">		,</span><br><span class="line">						bitmapInfo: image.bitmapInfo.rawValue)</span><br><span class="line">	cxt?.interpolationQuality = .high</span><br><span class="line">	cxt?.draw(image, in: CGRect(origin: .zero, size: size))</span><br><span class="line">	guard let scaledImage = cxt?.makeImage() else &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	let ima = UIImage(cgImage: scaledImage)</span><br><span class="line">	return ima</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-ImageIO-创建缩略图"><a href="#3-ImageIO-创建缩略图" class="headerlink" title="3.ImageIO 创建缩略图"></a>3.ImageIO 创建缩略图</h4><p>使用<code>ImageIO</code> 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:320M</span><br><span class="line">normal:221M</span><br><span class="line">CPU:</span><br><span class="line">Hight:73%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage3(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line">	</span><br><span class="line">	let ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,</span><br><span class="line">							  kCGImageSourceCreateThumbnailWithTransform:true,</span><br><span class="line">							  kCGImageSourceShouldCacheImmediately:true,</span><br><span class="line">							  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]</span><br><span class="line">	guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">		let image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else &#123;</span><br><span class="line">			return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	let ima = UIImage(cgImage: image)</span><br><span class="line">	printImageCost(image: ima)</span><br><span class="line">	return ima</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-CoreImage-滤镜"><a href="#4-CoreImage-滤镜" class="headerlink" title="4.CoreImage 滤镜"></a>4.CoreImage 滤镜</h4><p>使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:1.04G</span><br><span class="line">normal:566M</span><br><span class="line">CPU:</span><br><span class="line">Hight:73%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage4(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</span><br><span class="line">	let shareContext = CIContext(options: [.useSoftwareRenderer:false])</span><br><span class="line">	</span><br><span class="line">	 guard let image = CIImage(contentsOf: url) else &#123; return nil &#125;</span><br><span class="line">	let fillter = CIFilter(name: &quot;CILanczosScaleTransform&quot;)</span><br><span class="line">	fillter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">	fillter?.setValue(1, forKey: kCIInputScaleKey)</span><br><span class="line">	guard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else &#123; return nil &#125;</span><br><span class="line">	</span><br><span class="line">	return UIImage(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-使用-vImage-优化图片渲染"><a href="#5-使用-vImage-优化图片渲染" class="headerlink" title="5.使用 vImage 优化图片渲染"></a>5.使用 vImage 优化图片渲染</h4><p>使用<code>vImage</code>创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要<code>crash</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory </span><br><span class="line">High:998.7M</span><br><span class="line">normal:566M</span><br><span class="line">CPU:</span><br><span class="line">Hight:78%</span><br><span class="line">normal:0%</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">func resizedImage5(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</span><br><span class="line">    // 解码源图像</span><br><span class="line">    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</span><br><span class="line">        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),</span><br><span class="line">        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],</span><br><span class="line">        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,</span><br><span class="line">        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义图像格式</span><br><span class="line">    var format = vImage_CGImageFormat(bitsPerComponent: 8,</span><br><span class="line">                                      bitsPerPixel: 32,</span><br><span class="line">                                      colorSpace: nil,</span><br><span class="line">                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),</span><br><span class="line">                                      version: 0,</span><br><span class="line">                                      decode: nil,</span><br><span class="line">                                      renderingIntent: .defaultIntent)</span><br><span class="line"></span><br><span class="line">    var error: vImage_Error</span><br><span class="line"></span><br><span class="line">    // 创建并初始化源缓冲区</span><br><span class="line">    var sourceBuffer = vImage_Buffer()</span><br><span class="line">    defer &#123; sourceBuffer.data.deallocate() &#125;</span><br><span class="line">    error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</span><br><span class="line">                                         &amp;format,</span><br><span class="line">                                         nil,</span><br><span class="line">                                         image,</span><br><span class="line">                                         vImage_Flags(kvImageNoFlags))</span><br><span class="line">    guard error == kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    // 创建并初始化目标缓冲区</span><br><span class="line">    var destinationBuffer = vImage_Buffer()</span><br><span class="line">    error = vImageBuffer_Init(&amp;destinationBuffer,</span><br><span class="line">                              vImagePixelCount(size.height),</span><br><span class="line">                              vImagePixelCount(size.width),</span><br><span class="line">                              format.bitsPerPixel,</span><br><span class="line">                              vImage_Flags(kvImageNoFlags))</span><br><span class="line">    guard error == kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    // 优化缩放图像</span><br><span class="line">    error = vImageScale_ARGB8888(&amp;sourceBuffer,</span><br><span class="line">                                 &amp;destinationBuffer,</span><br><span class="line">                                 nil,</span><br><span class="line">                                 vImage_Flags(kvImageHighQualityResampling))</span><br><span class="line">    guard error == kvImageNoError else &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    // 从目标缓冲区创建一个 CGImage 对象</span><br><span class="line">    guard let resizedImage =</span><br><span class="line">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</span><br><span class="line">                                      &amp;format,</span><br><span class="line">                                      nil,</span><br><span class="line">                                      nil,</span><br><span class="line">                                      vImage_Flags(kvImageNoAllocate),</span><br><span class="line">                                      &amp;error)?.takeRetainedValue(),</span><br><span class="line">        error == kvImageNoError</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return UIImage(cgImage: resizedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。</p>
<p>在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,</span><br><span class="line">									   object: nil,</span><br><span class="line">									   queue: .main)</span><br><span class="line">&#123;[weak self] (note) in</span><br><span class="line">	self?.unloadImage()</span><br><span class="line">&#125;</span><br><span class="line">NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,</span><br><span class="line">									   object: nil,</span><br><span class="line">									   queue: .main)</span><br><span class="line">&#123;[weak self] (note) in</span><br><span class="line">	self?.loadImage()</span><br><span class="line">&#125;</span><br><span class="line"># 2</span><br><span class="line"></span><br><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">	super.viewWillAppear(animated)</span><br><span class="line">	self.loadImage()</span><br><span class="line">&#125;</span><br><span class="line">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class="line">	super.viewWillDisappear(animated)</span><br><span class="line">	self.unloadImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>基于性能综合考虑方法1是最简单最合适的</li>
<li>使用滤镜和<code>vImage</code>略微复杂点，平时开发过程中可以不用考虑了。</li>
<li>图片解码缓存和图片大小有关，适当的下采样是不错的选择。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416" target="_blank" rel="noopener">session 2018 416 iOS Memory Deep Dive</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/219" target="_blank" rel="noopener">219_image_and_graphics_best_practices</a></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">WWDC 中文字幕下载</a></li>
<li><p><a href="https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1" target="_blank" rel="noopener">swift gg 图像优化</a></p>
</li>
<li><p><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></p>
</li>
<li><a href="https://github.com/ifgyong/demo/tree/master" target="_blank" rel="noopener">demo code git</a></li>
</ul>
<h2 id="唯有实践才是检验真理的唯一标准"><a href="#唯有实践才是检验真理的唯一标准" class="headerlink" title="唯有实践才是检验真理的唯一标准"></a><strong>唯有实践才是检验真理的唯一标准</strong></h2><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">MVC、MVP、MVVM、分层设计浅谈 — (13)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:23:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:23:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到</p>
<blockquote>
<ol>
<li>MVC</li>
<li>MVC变种</li>
<li>MVP</li>
<li>MVVM</li>
<li>分层设计的优缺点</li>
</ol>
</blockquote>
<p>没有最好的架构，只有最适合业务的架构。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>苹果版本的<code>MVC</code>是<code>Model</code>和<code>VC</code>和交互，<code>VC</code>和<code>View</code>交互</p>
<ul>
<li><p>优点：<code>View</code>和<code>Model</code>可以重复利用，可以独立使用</p>
</li>
<li><p>缺点：<code>Controller</code>的代码过于臃肿</p>
</li>
</ul>
<p><img src="/images/13-1.png" alt></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self loadData];</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadData&#123;</span><br><span class="line">    self.data=[NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        FYNews *item=[FYNews new];</span><br><span class="line">        item.title =[NSString stringWithFormat:@&quot;title-%d&quot;,i];</span><br><span class="line">        item.name =[NSString stringWithFormat:@&quot;name-%d&quot;,i];</span><br><span class="line">        [self.data addObject:item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">    return self.data.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    // Configure the cell...</span><br><span class="line">    FYNews *item =[self.data objectAtIndex:indexPath.row];</span><br><span class="line">    cell.detailTextLabel.text =item.title;</span><br><span class="line">    cell.textLabel.text = item.name;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//model</span><br><span class="line"></span><br><span class="line">@interface FYNews : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *title;</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这里是<code>VC</code>中组装了<code>tableview</code>，<code>model</code>的数据在<code>VC</code>中在<code>view</code>中显示出来，当需要另外的数据的时候，只需要将<code>model</code>改成需要的<code>model</code>而无需更改<code>tableview</code>的代码兼容性较好。</p>
<h3 id="MVC变种"><a href="#MVC变种" class="headerlink" title="MVC变种"></a>MVC变种</h3><p><code>MVC</code>变种，其实就是将<code>model</code>和<code>view</code>建立了联系，<code>view</code>依据<code>Model</code>来展示数据，<code>VC</code>组装<code>Model</code>，组装展示是在<code>view</code>中实现。</p>
<ul>
<li><p>优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现</p>
</li>
<li><p>缺点：view依赖于Model</p>
</li>
</ul>
<p><img src="/images/13-2.png" alt></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line">@interface FYAppleView()</span><br><span class="line">@property (nonatomic,strong) UILabel *nameLabel;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYAppleView</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    if (self =[super initWithFrame:frame]) &#123;</span><br><span class="line">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</span><br><span class="line">        [self addSubview:_nameLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">  mvc的变种</span><br><span class="line"> */</span><br><span class="line">- (void)setModel:(FYItemModel *)model&#123;</span><br><span class="line">    _model = model;</span><br><span class="line">    _nameLabel.textColor = model.bgColor;</span><br><span class="line">    _nameLabel.text = model.name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//FYItemModel</span><br><span class="line">@interface FYItemModel : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,strong) UIColor *bgColor;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self loadViewOtherMVC];</span><br><span class="line">&#125;</span><br><span class="line">//变种MVC 把View和Model建立起连接</span><br><span class="line">//等以后更新view数据只需要 view.model = item;Controllr少了许多代码</span><br><span class="line">- (void)loadViewOtherMVC&#123;</span><br><span class="line">    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</span><br><span class="line">    FYItemModel *item=[[FYItemModel alloc]init];</span><br><span class="line">    item.name = @&quot;校长来了&quot;;</span><br><span class="line">    item.bgColor = [UIColor redColor];</span><br><span class="line">    view.model = item;</span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>可以看到<code>model</code>组装到<code>view</code>展示内容是在<code>view</code>实现的，外部不知道细节，只需要将<code>model</code>给<code>view</code>即可，但是只能传输过来<code>model</code>或者他子类，业务更改的话，需要修改<code>view</code>的内部<code>model</code>才能将变更过的数据重新展示出来。</p>
<p>想要监听view的点击事件来做一些操作，那么我们可以使用代理和<code>block</code>,这里<code>id</code>是实现了<code>FYAppleViewProtocol</code>协议的，<code>weak</code>修饰防止循环引用，使用协议实现了和<code>VC</code>的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@class FYAppleView;</span><br><span class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>稍作更改还是<code>apple-MVC</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// .h</span><br><span class="line">@class FYItemModel;</span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>将<code>View</code>属性<code>nameLabel</code>暴露出来，但是不允许外界进行更改，去掉<code>model</code>则是<code>MVC</code>。</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><code>MVP</code>和<code>MVC</code>很像，只是将<code>VC</code>换成了<code>Presenter</code>，<code>vc</code>和<code>Present</code>做的事情基本一致，将<code>view</code>和<code>Model</code>通信改到了都和<code>Presenter</code>通信。</p>
<p><img src="/images/13-3.png" alt><br>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//MVP</span><br><span class="line">//.h</span><br><span class="line">@interface FYNewsPresenter : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) UIViewController *vc;</span><br><span class="line">//初始化</span><br><span class="line">- (void)setup;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">.m</span><br><span class="line">#import &quot;FYNewsPresenter.h&quot;</span><br><span class="line">@interface FYNewsPresenter()&lt;FYAppleViewProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYNewsPresenter</span><br><span class="line">- (void)setup&#123;</span><br><span class="line">	FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</span><br><span class="line">	FYItemModel *item=[[FYItemModel alloc]init];</span><br><span class="line">	item.name = @&quot;校长来了&quot;;</span><br><span class="line">	item.bgColor = [UIColor redColor];</span><br><span class="line">	view.model = item;</span><br><span class="line">	[self.vc.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</span><br><span class="line">	NSLog(@&quot;点击了我&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//VC中</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong) FYNewsPresenter *presenter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">	_presenter=[FYNewsPresenter new];</span><br><span class="line">	_presenter.vc = self;</span><br><span class="line">	[_presenter setup];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>再次对<code>VC</code>进行了瘦身，将更多的业务逻辑搬到了<code>FYNewsPresenter</code>处理，其实全部搬过去，意义比不大，<code>FYNewsPresenter</code>也会臃肿，也会出现和<code>VC</code>一样的困惑。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>是将<code>FYNewsPresenter</code>都搬到了<code>FYNewsViewModel</code>中，然后对<code>FYNewsViewModel</code>和<code>View</code>进行了一个双向绑定，双向绑定可以使用代理，<code>block</code>或者<code>KVO</code>实现。<br><img src="/images/13-4.png" alt><br>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNewsViewModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,strong) UIColor *bgColor;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) UIViewController *vc;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithController:(UIViewController *)vc;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;FYNewsViewModel.h&quot;</span><br><span class="line">@interface FYNewsViewModel()&lt;FYAppleViewProtocol&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYNewsViewModel</span><br><span class="line">- (instancetype)initWithController:(UIViewController *)vc&#123;</span><br><span class="line">    if (self =[super init]) &#123;</span><br><span class="line">        self.vc = vc;</span><br><span class="line">        </span><br><span class="line">        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];</span><br><span class="line">        //    view.model = item;</span><br><span class="line">        view.delegate = self;</span><br><span class="line">        view.viewModel = self; //建立kvo</span><br><span class="line">        </span><br><span class="line">        view.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">        [vc.view addSubview:view];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        FYItemModel *item=[[FYItemModel alloc]init];</span><br><span class="line">        item.name = @&quot;校长来了&quot;;</span><br><span class="line">        item.bgColor = [UIColor redColor];</span><br><span class="line">        </span><br><span class="line">        self.name = item.name;</span><br><span class="line">        self.bgColor = item.bgColor;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</span><br><span class="line">	NSLog(@&quot;点击了我&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在<code>view</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@class FYAppleView,FYNewsViewModel;</span><br><span class="line">@protocol FYAppleViewProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)FYAppleViewDidClick:(FYAppleView*)view;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@class FYItemModel;</span><br><span class="line"></span><br><span class="line">@interface FYAppleView : UIView</span><br><span class="line">@property (nonatomic,strong,readonly) UILabel *nameLabel;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</span><br><span class="line">@property (nonatomic,weak) FYNewsViewModel *viewModel;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) FYItemModel *model;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface FYAppleView()</span><br><span class="line">@property (nonatomic,strong) UILabel *nameLabel;</span><br><span class="line">@end</span><br><span class="line">@implementation FYAppleView</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    if (self =[super initWithFrame:frame]) &#123;</span><br><span class="line">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</span><br><span class="line">        [self addSubview:_nameLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">  mvc的变种</span><br><span class="line"> */</span><br><span class="line">- (void)setModel:(FYItemModel *)model&#123;</span><br><span class="line">    _model = model;</span><br><span class="line">    _nameLabel.textColor = model.bgColor;</span><br><span class="line">    _nameLabel.text = model.name;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setViewModel:(FYNewsViewModel *)viewModel&#123;</span><br><span class="line">    _viewModel = viewModel;</span><br><span class="line">   [_viewModel addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">   //使用FBKVO实现 或者自己使用KVO实现</span><br><span class="line">//    __weak typeof(self) waekSelf = self;</span><br><span class="line">//    [self.KVOController observe:viewModel keyPath:@&quot;name&quot;</span><br><span class="line">//                        options:NSKeyValueObservingOptionNew</span><br><span class="line">//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123;</span><br><span class="line">//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];</span><br><span class="line">//    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        self.nameLabel.text = change[NSKeyValueChangeNewKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加点击事件</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	if ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) &#123;</span><br><span class="line">		[self.delegate FYAppleViewDidClick:self];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    [_viewModel removeObserver:self</span><br><span class="line">                    forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用<code>KVO</code>或者<code>FBKVO</code>或者<code>RAC</code>都是可以的，本章节例子给出了<code>FBKVO</code>或者自己使用<code>KVO</code>的实现。</p>
<h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>三层架构：</p>
<blockquote>
<p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层</p>
</blockquote>
<ul>
<li><p>目的: “高内聚，低耦合”的思想 </p>
</li>
<li><p>优点: 降低层与层之间的依赖 标准化 </p>
</li>
<li><p>缺点: 系统架构复杂，不适合小型项目</p>
</li>
</ul>
<h4 id="三层原理"><a href="#三层原理" class="headerlink" title="三层原理"></a>三层原理</h4><blockquote>
<p>3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。<br>所谓三层体系结构，是在客户端与数据库之间加入了一个<code>中间层</code>，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有<code>B/S</code>应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。</p>
<p>三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过<code>COM/DCOM</code>通讯与中间层建立连接，再经由中间层与数据库进行交互。</p>
<p>三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用<code>COM/DCOM</code>通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互</p>
</blockquote>
<p><code>MVC</code>、<code>MVVM</code>、<code>MVP</code>属于界面层，<br>当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了</p>
<p>分层之后，得到了一个三层架构或四层架构</p>
<p><img src="/images/13-5.png" alt="三层架构"></p>
<p>数据层也可以分为两层，分为网络请求和db层。</p>
<p><img src="/images/13-6.png" alt="四层架构"></p>
<p>具体在工程中我们通常这样体现</p>
<p><img src="/images/13-7.png" alt></p>
<p>在<code>vc</code>中获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong) FYDBPool *db;</span><br><span class="line">@property (nonatomic,strong) FYHttpPool *http;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">	//当有业务层</span><br><span class="line">	[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125; fail:^&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;];</span><br><span class="line">	//当没有有业务层</span><br><span class="line">	self.db=[FYDBPool new];</span><br><span class="line">	self.http=[FYHttpPool new];</span><br><span class="line">	[self.db loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">		if ([ret count]) &#123;</span><br><span class="line">			NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">				NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">			&#125; fail:^&#123;</span><br><span class="line">				NSLog(@&quot;数据获取失败&quot;);</span><br><span class="line">			&#125;];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; fail:^&#123;</span><br><span class="line">		[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">			NSLog(@&quot;数据获取成功&quot;);</span><br><span class="line">		&#125; fail:^&#123;</span><br><span class="line">			NSLog(@&quot;数据获取失败&quot;);</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在业务层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNewsService ()</span><br><span class="line">@property (nonatomic,strong) FYDBPool *db;</span><br><span class="line">@property (nonatomic,strong) FYHttpPool *http;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYNewsService</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">		self.db=[FYDBPool new];</span><br><span class="line">		self.http=[FYHttpPool new];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line">				 success:(succcessCallback )succblock</span><br><span class="line">					fail:(dispatch_block_t)failBlock&#123;</span><br><span class="line">	[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">		if ([ret count]) &#123;</span><br><span class="line">			succblock(ret);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">				succblock(ret);</span><br><span class="line">			&#125; fail:failBlock];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; fail:^&#123;</span><br><span class="line">		[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</span><br><span class="line">			succblock(ret);</span><br><span class="line">		&#125; fail:failBlock];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在db层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^succcessCallback)(NSArray *);</span><br><span class="line">@interface FYDBPool : NSObject</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line">				 success:(succcessCallback )succblock</span><br><span class="line">					fail:(dispatch_block_t)failBlock;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在网络请求层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^succcessCallback)(NSArray *);</span><br><span class="line">@interface FYHttpPool : NSObject</span><br><span class="line">- (void)loadNewsWithInfo:(NSDictionary *)info</span><br><span class="line">				 success:(succcessCallback )succblock</span><br><span class="line">					fail:(dispatch_block_t)failBlock;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或<code>db</code>，当<code>db</code>足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。<br>不同的人来处理不同的分层，相互影响也比较小，降低耦合。</p>
<p><strong>当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。</strong></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>优雅的代码总是伴随着各种传统设计模式的搭配</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote>
<p>设计模式（Design Pattern）<br>是一套被反复使用、代码设计经验的总结<br>使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性<br>一般与编程语言无关，是一套比较成熟的编程思想</p>
</blockquote>
<p>设计模式可以分为三大类</p>
<ol>
<li><p>创建型模式：对象实例化的模式，用于解耦对象的实例化过程<br>单例模式、工厂方法模式，等等</p>
</li>
<li><p>结构型模式：把类或对象结合在一起形成一个更大的结构<br>代理模式、适配器模式、组合模式、装饰模式，等等</p>
</li>
<li><p>行为型模式：类或对象之间如何交互，及划分责任和算法<br>观察者模式、命令模式、责任链模式，等等</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>适合项目的才是最好的架构</li>
</ul>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">三层架构</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:22:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:22:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看完本文章你将了解到</p>
<blockquote>
<ol>
<li>DisplayLink和timer的使用和原理</li>
<li>内存分配和内存管理</li>
<li>自动释放池原理</li>
<li>weak指针原理和释放时机</li>
<li>引用计数原理</li>
</ol>
</blockquote>
<p>/</p>
<h3 id="DisplayLink"><a href="#DisplayLink" class="headerlink" title="DisplayLink"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</span><br><span class="line">//runloop没循环一圈都会调用</span><br><span class="line">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">//从runloop中删除</span><br><span class="line">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">//取消</span><br><span class="line">- (void)invalidate;</span><br></pre></td></tr></table></figure>
<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) CADisplayLink *link;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		NSLog(@&quot;FPS:%d&quot;,fps);</span><br><span class="line">		fps = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line">//全局变量</span><br><span class="line">dispatch_source_t timer;</span><br><span class="line">static int fps;</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">	</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		fps += 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	[self.link invalidate];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</span><br><span class="line">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</span><br></pre></td></tr></table></figure>
<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYTimerTarget : NSObject</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYTimerTarget</span><br><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	return self.target;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYProxy *proxy=[FYProxy proxyWithTarget:self];</span><br><span class="line">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">2019-07-30 17:59:04.339934 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.356292 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 17:59:04.371634 -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface FYProxy : NSProxy</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line"></span><br><span class="line">+(instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@end</span><br><span class="line">@implementation FYProxy</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</span><br><span class="line">	FYProxy *obj=[FYProxy alloc];</span><br><span class="line">	obj.target = target;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line">//转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line">	[invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</span><br><span class="line">	return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	return self.target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FYTimerTarget *obj =[FYTimerTarget new];</span><br><span class="line">obj.target = self;</span><br><span class="line"></span><br><span class="line">self.timer = [NSTimer timerWithTimeInterval:1.0f</span><br><span class="line">									target:obj</span><br><span class="line">								   selector:@selector(test)</span><br><span class="line">								   userInfo:nil</span><br><span class="line">									repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">[self.timer setFireDate:[NSDate distantPast]];</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>
<h3 id="GCD中timer"><a href="#GCD中timer" class="headerlink" title="GCD中timer"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//timer 需要强引用 或者设置成全局变量</span><br><span class="line">    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">    //设置</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">  //code 定时器执行的代码</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">    //开始定时器</span><br><span class="line">    dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler_f(timer, function_t);</span><br><span class="line">void function_t(void * p)&#123;</span><br><span class="line">    //code here    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>
<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block</span><br><span class="line">    	  start:(NSTimeInterval)time</span><br><span class="line">       interval:(NSTimeInterval)interval</span><br><span class="line">    	 repeat:(BOOL)repeat</span><br><span class="line">    	  async:(BOOL)async;</span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">		  sel:(SEL)aciton</span><br><span class="line">		start:(NSTimeInterval)time</span><br><span class="line">	 interval:(NSTimeInterval)interval</span><br><span class="line">	   repeat:(BOOL)repeat</span><br><span class="line">		async:(BOOL)async;</span><br><span class="line">//取消</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</span><br><span class="line">	if (block == nil) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">	//主队列</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">	if (async) &#123;</span><br><span class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	&#125;</span><br><span class="line">	//创建定时器</span><br><span class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">	//设置启动时间</span><br><span class="line">	dispatch_source_set_timer(_timer,</span><br><span class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">	//设定回调</span><br><span class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">		block();</span><br><span class="line">		if (repeat == NO) &#123;</span><br><span class="line">			dispatch_source_cancel(_timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	//启动定时器</span><br><span class="line">	dispatch_resume(_timer);</span><br><span class="line">	//存放到字典</span><br><span class="line">	if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">		timers[name] = _timer;</span><br><span class="line">		dispatch_semaphore_signal(samephore);</span><br><span class="line">	&#125;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">				  sel:(SEL)aciton</span><br><span class="line">				start:(NSTimeInterval)time</span><br><span class="line">			 interval:(NSTimeInterval)interval</span><br><span class="line">			   repeat:(BOOL)repeat</span><br><span class="line">				async:(BOOL)async&#123;</span><br><span class="line">	if (target == nil || aciton == NULL) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	if (repeat &amp;&amp; interval &lt;= 0) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	NSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">	//主队列</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">	if (async) &#123;</span><br><span class="line">		queue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	&#125;</span><br><span class="line">	//创建定时器</span><br><span class="line">	dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">	//设置启动时间</span><br><span class="line">	dispatch_source_set_timer(_timer,</span><br><span class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">	//设定回调</span><br><span class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">		//这里是会报警告的代码</span><br><span class="line">		if ([target respondsToSelector:aciton]) &#123;</span><br><span class="line">			[target performSelector:aciton];</span><br><span class="line">		&#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">		if (repeat == NO) &#123;</span><br><span class="line">			dispatch_source_cancel(_timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	//启动定时器</span><br><span class="line">	dispatch_resume(_timer);</span><br><span class="line">	//存放到字典</span><br><span class="line">	if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">		timers[name] = _timer;</span><br><span class="line">		dispatch_semaphore_signal(samephore);</span><br><span class="line">	&#125;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key&#123;</span><br><span class="line">	if (key.length == 0) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	if ([timers.allKeys containsObject:key]) &#123;</span><br><span class="line">		dispatch_source_cancel(timers[key]);</span><br><span class="line">		[timers removeObjectForKey:key];</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_signal(samephore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用的时候很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = [FYTimer exeTask:^&#123;</span><br><span class="line">        NSLog(@&quot;123&quot;);</span><br><span class="line">    &#125; start:1</span><br><span class="line">    interval:1 </span><br><span class="line">    repeat:YES </span><br><span class="line">    async:NO];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br></pre></td></tr></table></figure>
<p>取消执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FYTimer exeCancelTask:key];</span><br></pre></td></tr></table></figure>
<p>测试封装的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test&#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	[FYTimer exeCancelTask:key];</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</span><br></pre></td></tr></table></figure>
<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>
<h3 id="NSProxy实战"><a href="#NSProxy实战" class="headerlink" title="NSProxy实战"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>
<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc1 =[[ViewController alloc]init];</span><br><span class="line">FYProxy *pro1 =[FYProxy proxyWithTarget:vc1];</span><br><span class="line"></span><br><span class="line">FYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];</span><br><span class="line">BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</span><br><span class="line">BOOL ret2 = [tar isKindOfClass:ViewController.class];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,ret1,ret2);</span><br></pre></td></tr></table></figure>
<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>
<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>
<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>
<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>
<p>数据段包括</p>
<ul>
<li>字符串常量：比如NSString * str = @”11”</li>
<li>已初始化数据：已初始化的全局变量、静态变量等</li>
<li>未初始化数据：未初始化的全局变量、静态变量等</li>
</ul>
<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>
<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b ;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static int c = 20;</span><br><span class="line">        static int d;</span><br><span class="line">        int e = 10;</span><br><span class="line">        int f;</span><br><span class="line">        NSString * str = @&quot;123&quot;;</span><br><span class="line">        NSObject *obj =[[NSObject alloc]init];</span><br><span class="line">        NSLog(@&quot;\na:%p \nb:%p \nc:%p \nd:%p \ne:%p \nf:%p \nobj:%p\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">a:0x1063e0d98 </span><br><span class="line">b:0x1063e0e64 </span><br><span class="line">c:0x1063e0d9c </span><br><span class="line">d:0x1063e0e60 </span><br><span class="line">e:0x7ffee9820efc </span><br><span class="line">f:0x7ffee9820ef8 </span><br><span class="line">obj:0x6000013541a0</span><br><span class="line">str:0x1063e0068</span><br></pre></td></tr></table></figure>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们拿来这个可以判断对象是否使用了优化技术。</p>
<h4 id="NSNumbe-Tagged-Pointer"><a href="#NSNumbe-Tagged-Pointer" class="headerlink" title="NSNumbe Tagged Pointer"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ //mac开发</span><br><span class="line">// 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">// Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#endif</span><br><span class="line">bool objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSNumber *n1 = @2;</span><br><span class="line">        NSNumber *n2 = @3;</span><br><span class="line">        NSNumber *n3 = @(4);</span><br><span class="line">        NSNumber *n4 = @(0x4fffffffff);</span><br><span class="line">        NSLog(@&quot;\n%p \n%p \n%p \n%p&quot;,n1,n2,n3,n4);</span><br><span class="line">        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</span><br><span class="line">        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</span><br><span class="line">        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</span><br><span class="line">        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;\nn1:%d \nn2:%d \nn3:%d \nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">0xbf4071e2657ccb95 </span><br><span class="line">0xbf4071e2657ccb85 </span><br><span class="line">0xbf4071e2657ccbf5 </span><br><span class="line">0xbf40751d9a833444</span><br><span class="line">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </span><br><span class="line">n1:1 </span><br><span class="line">n2:1 </span><br><span class="line">n3:1 </span><br><span class="line">n4:0</span><br></pre></td></tr></table></figure>
<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>
<h4 id="NSString-Tagged-Pointer"><a href="#NSString-Tagged-Pointer" class="headerlink" title="NSString Tagged Pointer"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i = 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先不运行，先分析一下。</p>
<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread: EXC_BAD_ACCESS(code = 1)</span><br></pre></td></tr></table></figure>
<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>
<p>验证<code>NSString Tagged Pointer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name = [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">			NSLog(@&quot;test1 class:%@&quot;,self.name.class);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i = 0; i &lt; 1; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">			NSLog(@&quot;test2 class:%@&quot;,self.name.class);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">test1 class:NSTaggedPointerString</span><br><span class="line">test2 class:__NSCFString</span><br></pre></td></tr></table></figure>
<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>
<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>
<p> iOS提供了2中拷贝方法</p>
<ol>
<li>copy 拷贝出来不可变对象</li>
<li>mutableCopy 拷贝出来可变对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test1()&#123;</span><br><span class="line">	NSString *str = @&quot;strstrstrstr&quot;;</span><br><span class="line">	NSMutableString *mut1 =[str mutableCopy];</span><br><span class="line">	[mut1 appendFormat:@&quot;123&quot;];</span><br><span class="line">	NSString *str2 = [str copy];</span><br><span class="line">	NSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">str:0x100001040 </span><br><span class="line">mut1:0x1007385f0 </span><br><span class="line">str2:0x100001040</span><br></pre></td></tr></table></figure>
<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>
<p>我们把字符串换成其他常用的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test2()&#123;</span><br><span class="line">	NSArray *array = @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</span><br><span class="line">	NSMutableArray *mut =[array mutableCopy];</span><br><span class="line">	NSString *array2 = [array copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">0x102840800 </span><br><span class="line">0x1028408a0</span><br><span class="line">0x102840800</span><br><span class="line"></span><br><span class="line">void test3()&#123;</span><br><span class="line">	NSArray *array = [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</span><br><span class="line">	NSMutableArray *mut =[array mutableCopy];</span><br><span class="line">	NSString *array2 = [array copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">0x102808720 </span><br><span class="line">0x1028088a0</span><br><span class="line">0x1028089a0</span><br></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>
<p>我们再换成其他的常用的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void test4()&#123;</span><br><span class="line">	NSDictionary *item = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</span><br><span class="line">	NSMutableDictionary *mut =[item mutableCopy];</span><br><span class="line">	NSDictionary *item2 = [item copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">0x1007789c0 </span><br><span class="line">0x100779190</span><br><span class="line">0x1007789c0</span><br><span class="line"></span><br><span class="line">void test5()&#123;</span><br><span class="line">	NSDictionary *item = [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</span><br><span class="line">	NSMutableDictionary *mut =[item mutableCopy];</span><br><span class="line">	NSDictionary *item2 = [item copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">0x1007041d0 </span><br><span class="line">0x1007042b0</span><br><span class="line">0x1007043a0</span><br></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>
<p>由这几个看出来，总结出来下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">copy</th>
<th style="text-align:center">mutableCopy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NSString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSArray</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableArray</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSDictionary</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableDictionary</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
</tbody>
</table>
<h4 id="自定义对象实现协议NSCoping"><a href="#自定义对象实现协议NSCoping" class="headerlink" title="自定义对象实现协议NSCoping"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCopying</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSMutableCopying</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@property (nonatomic,assign) int level;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FYPerson()&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">	FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">	p.age = self.age;</span><br><span class="line">	p.level = self.level;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p =[[FYPerson alloc]init];</span><br><span class="line">p.age = 10;</span><br><span class="line">p.level = 11;</span><br><span class="line">FYPerson *p2 =[p copy];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</span><br><span class="line">//log</span><br><span class="line">10 11</span><br></pre></td></tr></table></figure>
<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>
<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (add)</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    Class cls = [self class];</span><br><span class="line">    NSObject * p=[cls new];</span><br><span class="line">    //成员变量个数</span><br><span class="line">    unsigned int count;</span><br><span class="line">    //赋值成员变量数组</span><br><span class="line">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);</span><br><span class="line">    //遍历数组</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        Ivar var = ivars[i];</span><br><span class="line">        //获取成员变量名字</span><br><span class="line">        const char * name = ivar_getName(var);</span><br><span class="line">        if (name != nil) &#123;</span><br><span class="line">            NSString *v = [NSString stringWithUTF8String:name];</span><br><span class="line">            id value = [self valueForKey:v];</span><br><span class="line">            //给新的对象赋值</span><br><span class="line">            if (value != NULL) &#123;</span><br><span class="line">                [p setValue:value forKey:v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FYPerson *p =[[FYPerson alloc]init];</span><br><span class="line">p.age = 10;</span><br><span class="line">p.level = 11;</span><br><span class="line">p.name = @&quot;xiaowang&quot;;</span><br><span class="line">FYPerson *p2 =[p copy];</span><br><span class="line">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</span><br><span class="line">		</span><br><span class="line">//log</span><br><span class="line">10 </span><br><span class="line">11 </span><br><span class="line">xiaowang</span><br></pre></td></tr></table></figure>
<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>
<h3 id="引用计数原理"><a href="#引用计数原理" class="headerlink" title="引用计数原理"></a>引用计数原理</h3><p>摘自<a href="https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>
</blockquote>
<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>
<p>在MRC中我们经常都是这样子使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p=[[FYPerson alloc]init];</span><br><span class="line">FYPerson *p2 =[p retain];</span><br><span class="line">//code here</span><br><span class="line">[p release];</span><br><span class="line">[p2 release];</span><br></pre></td></tr></table></figure>
<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>
<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>
<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//大概率x==1 提高读取指令的效率</span><br><span class="line">#define fastpath(x) (__builtin_expect(bool(x), 1))</span><br><span class="line">//大概率x==0 提高读取指令的效率</span><br><span class="line">#define slowpath(x) (__builtin_expect(bool(x), 0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//引用计数+1</span><br><span class="line">//tryRetain 尝试+1</span><br><span class="line">//handleOverflow 是否覆盖</span><br><span class="line">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">	//优化的指针 返回this</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line">    bool transcribeToSideTable = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable = false;</span><br><span class="line">		//old bits</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">		//使用联合体技术</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);//nothing</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();//解锁</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">			else return sidetable_retain();////sidetable 引用计数+1</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">		//不尝试retain 和 正在销毁 什么都不做 返回 nil</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">		//引用计数+1 (bits.extra_rc++;)</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</span><br><span class="line"></span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // newisa.extra_rc++ 溢出处理</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">			//为拷贝到side table 做准备</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            transcribeToSideTable = true;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">		//拷贝 平外一半的 引用计数到 side table</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//sidetable 引用计数+1</span><br><span class="line">id objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">	//取出table key=this</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>
<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;//指针优化的不存在计数器</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;//isa</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">			//side table -1</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // don&apos;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    newisa = oldisa;</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		//side table 引用计数-1</span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</span><br><span class="line">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                // Inline update failed.</span><br><span class="line">                // Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//真正的销毁</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        // does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">	//设置正在销毁</span><br><span class="line">    newisa.deallocating = true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">		//销毁</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline uintptr_t  objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">	//优化指针 直接返回</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line">//没优化则 到SideTable 读取</span><br><span class="line">    sidetable_lock();</span><br><span class="line">	//isa指针</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);//啥都没做</span><br><span class="line">    if (bits.nonpointer) &#123;//使用联合体存储更多的数据 </span><br><span class="line">        uintptr_t rc = 1 + bits.extra_rc;//计数数量</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;//当大过于 联合体存储的值 则另外在SideTable读取数据</span><br><span class="line">	//读取table的值 相加</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">	//在sidetable 中存储的count</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="noopener">使用联合体存储更多的数据</a>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用联合体</span><br><span class="line">size_t  objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">	//不是联合体技术 则报错</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">	//key是 this，存储了每个对象的table</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">	//找到 it 否则返回0</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it == table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有优化的是直接读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//未使用联合体的情况，</span><br><span class="line">uintptr_t objc_object::sidetable_retainCount()</span><br><span class="line">&#123;//没有联合体存储的计数器则直接在table中取出来</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak指针原理"><a href="#weak指针原理" class="headerlink" title="weak指针原理"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">		//c++析构函数</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">		//关联函数</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//正在清除side table 和weakly referenced</span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        // Slow path for raw pointer isa.</span><br><span class="line">		//释放weak</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">		//释放weak 和引用计数</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">	//清除weak</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">		//table.weak_table 弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">	//引用计数</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">		//擦除 this</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>
<h3 id="Autoreleasepool-原理"><a href="#Autoreleasepool-原理" class="headerlink" title="Autoreleasepool 原理"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">		FYPerson *p = [[FYPerson alloc]init];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* @autoreleasepool */ &#123;</span><br><span class="line"> __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"> FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">	__AtAutoreleasePool() &#123;//构造函数 生成结构体变量的时候调用</span><br><span class="line">		atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">	&#125;</span><br><span class="line">	~__AtAutoreleasePool() &#123;//析构函数 销毁的时候调用</span><br><span class="line">		objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">	&#125;</span><br><span class="line">	void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后将上边的代码和c++整合到一起就是这样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __AtAutoreleasePool pool = objc_autoreleasePoolPush();</span><br><span class="line">    FYPerson *p = [[FYPerson alloc]init];</span><br><span class="line">    objc_autoreleasePoolPop(pool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>
<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;//下一个存放aotoreleass对象的地址</span><br><span class="line">    pthread_t const thread;//线程</span><br><span class="line">    AutoreleasePoolPage * const parent; //父节点</span><br><span class="line">    AutoreleasePoolPage *child;//子节点</span><br><span class="line">    uint32_t const depth;//深度</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>
<ul>
<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>
<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>
<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>
<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>
<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>
</ul>
<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;//r1 = push()</span><br><span class="line"></span><br><span class="line">		FYPerson *p = [[FYPerson alloc]init];</span><br><span class="line">		_objc_autoreleasePoolPrint();</span><br><span class="line">		printf(&quot;\n--------------\n&quot;);</span><br><span class="line">	&#125;//pop(r1)</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">objc[23958]: ##############</span><br><span class="line">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[23958]: 3 releases pending.</span><br><span class="line">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[23958]: [0x101000038]  ################  POOL 0x101000038</span><br><span class="line">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</span><br><span class="line">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</span><br><span class="line">objc[23958]: ##############</span><br><span class="line"></span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>
<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;//r1 = push()</span><br><span class="line"></span><br><span class="line">		FYPerson *p = [[[FYPerson alloc]init] autorelease];</span><br><span class="line">		FYPerson *p2 = [[[FYPerson alloc]init] autorelease];</span><br><span class="line">		@autoreleasepool &#123;//r1 = push()</span><br><span class="line">			</span><br><span class="line">			FYPerson *p3 = [[[FYPerson alloc]init] autorelease];</span><br><span class="line">			FYPerson *p4 = [[[FYPerson alloc]init] autorelease];</span><br><span class="line">			</span><br><span class="line">			_objc_autoreleasePoolPrint();</span><br><span class="line">			printf(&quot;\n--------------\n&quot;);</span><br><span class="line">		&#125;//pop(r1)</span><br><span class="line">	&#125;//pop(r1)</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">objc[24025]: ##############</span><br><span class="line">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[24025]: 6 releases pending.</span><br><span class="line">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[24025]: [0x100803038]  ################  POOL 0x100803038</span><br><span class="line">objc[24025]: [0x100803040]       0x100721580  FYPerson</span><br><span class="line">objc[24025]: [0x100803048]       0x100721b10  FYPerson</span><br><span class="line">objc[24025]: [0x100803050]  ################  POOL 0x100803050</span><br><span class="line">objc[24025]: [0x100803058]       0x100721390  FYPerson</span><br><span class="line">objc[24025]: [0x100803060]       0x100717620  FYPerson</span><br><span class="line">objc[24025]: ##############</span><br></pre></td></tr></table></figure>
<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>
<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line"> &#123;</span><br><span class="line">     AutoreleasePoolPage *page = hotPage();</span><br><span class="line">     //当有分页而且分页没有满就添加</span><br><span class="line">     if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">         return page-&gt;add(obj);</span><br><span class="line">     &#125; else if (page) &#123;</span><br><span class="line">         //满则新建一个page进行添加obj和设置hotpage</span><br><span class="line">         return autoreleaseFullPage(obj, page);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         //没有page则新建page进行添加</span><br><span class="line">         return autoreleaseNoPage(obj);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//activities = 0xa0转化成二进制 0b101 0000</span><br><span class="line">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</span><br><span class="line">//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line"></span><br><span class="line">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid = Yes, activities = 0xa0, </span><br><span class="line">repeats = Yes, order = 2147483647, </span><br><span class="line">callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </span><br><span class="line">context = &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type = mutable-small, count = 1, </span><br><span class="line">values = (\n\t0 : &lt;0x7fb6dc004058&gt;\n)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    FYPerson *p =[[FYPerson alloc]init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>
<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>
<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>
<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>
<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>
<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease
</a></li>
<li>小码哥视频</li>
<li>iOS和OS多线程与内存管理</li>
<li>iOS和macOS性能优化<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:21:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:21:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？<br>这篇文章主要讲解线程安全。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是什么呢？摘抄一段<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin" target="_blank" rel="noopener">百度百科</a>的一段话</p>
<blockquote>
<p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
</blockquote>
<h4 id="为什么需要线程安全"><a href="#为什么需要线程安全" class="headerlink" title="为什么需要线程安全"></a>为什么需要线程安全</h4><p>ATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。</p>
<p>那么在iOS中，锁是如何使用的呢？</p>
<h3 id="自旋锁-OS-SPINLOCK"><a href="#自旋锁-OS-SPINLOCK" class="headerlink" title="自旋锁 OS_SPINLOCK"></a>自旋锁 OS_SPINLOCK</h3><h4 id="什么是优先级反转"><a href="#什么是优先级反转" class="headerlink" title="什么是优先级反转"></a>什么是优先级反转</h4><p>简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</p>
<p>假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</p>
<p>首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</p>
<p>其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</p>
<p>第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</p>
<p>第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</p>
<p>第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。</p>
<p><code>OS_SPINLOCK</code>叫做<code>自旋锁</code>，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。</p>
<p><code>OS_SPINLOCK</code>API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化 一般是0，或者直接数字0也是ok的。</span><br><span class="line">#define	OS_SPINLOCK_INIT    0</span><br><span class="line">//锁的初始化</span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">//尝试加锁</span><br><span class="line">bool ret = OSSpinLockTry(&amp;lock);</span><br><span class="line">//加锁</span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">//解锁</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p><code>OSSpinLock</code>简单实现12306如何卖票</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">//基类实现的卖票</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    NSInteger oldCount = self.ticketsCount;</span><br><span class="line">	if (isLog) &#123;</span><br><span class="line">		sleep(sleepTime);</span><br><span class="line">	&#125;</span><br><span class="line">    oldCount --;</span><br><span class="line">    self.ticketsCount = oldCount;</span><br><span class="line">	if (isLog) &#123;</span><br><span class="line">	printf(&quot;还剩% 2ld 张票 - %s \n&quot;,(long)oldCount,[NSThread currentThread].description.UTF8String);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)ticketTest&#123;</span><br><span class="line">    self.ticketsCount = 10000;</span><br><span class="line">	NSInteger count = self.ticketsCount/3;</span><br><span class="line">	dispatch_queue_t queue = dispatch_queue_create(&quot;tick.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">		if (time1 == 0) &#123;</span><br><span class="line">			time1 = CFAbsoluteTimeGetCurrent();</span><br><span class="line">		&#125;</span><br><span class="line">        for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">		if (time1 == 0) &#123;</span><br><span class="line">			time1 = CFAbsoluteTimeGetCurrent();</span><br><span class="line">		&#125;</span><br><span class="line">        for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">		if (time1 == 0) &#123;</span><br><span class="line">			time1 = CFAbsoluteTimeGetCurrent();</span><br><span class="line">		&#125;</span><br><span class="line">        for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">            [self __saleTicket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">		CFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;</span><br><span class="line">		printf(&quot;tick cost time:%f&quot;,time);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __getMonery];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __saveMonery];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    NSInteger oldCount = self.ticketsCount;</span><br><span class="line">    oldCount --;</span><br><span class="line">    self.ticketsCount = oldCount;</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后将睡眠时间设置为600s，方便我们调试。</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);//此行打断点</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了断点进入<code>Debug-&gt;Debug WorkFlow -&gt;Always Show Disassembly</code>，到了汇编界面，在<code>LLDB</code>输入<code>stepi</code>，然后一直按<code>enter</code>，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现<code>ja</code>跳转到地址<code>0x103f3d0f9</code>，每次执行到<code>ja</code>总是跳转到<code>0x103f3d0f9</code>，直到线程睡眠结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  0x103f3d0f9 &lt;+241&gt;: movq   %rcx, (%r8)</span><br><span class="line">0x103f3d0fc &lt;+244&gt;: addq   $0x8, %r8</span><br><span class="line">0x103f3d100 &lt;+248&gt;: cmpq   %r8, %r9</span><br><span class="line">0x103f3d103 &lt;+251&gt;: ja     0x103f3d0f9</span><br></pre></td></tr></table></figure>
<p>可以通过汇编分析了解到<code>自旋锁</code>是真的<code>忙等</code>，闲不住的锁。</p>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的<code>OSSpinLock</code>，而且必须使用<code>OS_UNFAIR_LOCK_INIT</code>来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在<code>__IOS_AVAILABLE(10.0)</code>，锁的数据结构是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OS_UNFAIR_LOCK_AVAILABILITY</span><br><span class="line">typedef struct os_unfair_lock_s &#123;</span><br><span class="line">	uint32_t _os_unfair_lock_opaque;</span><br><span class="line">&#125; os_unfair_lock, *os_unfair_lock_t;</span><br></pre></td></tr></table></figure>
<p><code>os_unfair_lock</code>使用非常简单，只需要在任务前加锁，任务后解锁即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface FYOSUnfairLockDemo : FYBaseDemo</span><br><span class="line">@property (nonatomic,assign) os_unfair_lock lock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYOSUnfairLockDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">		self.lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">	os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">	[super __saveMonery];</span><br><span class="line">	os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">	os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">	[super __getMonery];</span><br><span class="line">	os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">	os_unfair_lock_lock(&amp;_unlock);</span><br><span class="line">	[super __saleTicket];</span><br><span class="line">	os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="汇编分析-1"><a href="#汇编分析-1" class="headerlink" title="汇编分析"></a>汇编分析</h4><p><code>LLDB</code> 中命令<code>stepi</code>遇到函数会进入到函数，<code>nexti</code>会跳过函数。我们将断点打到添加锁的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)__saleTicket&#123;</span><br><span class="line"> 	os_unfair_lock_lock(&amp;_unlock);//断点位置</span><br><span class="line">	[super __saleTicket];</span><br><span class="line">	os_unfair_lock_unlock(&amp;_unlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>si</code>,一直<code>enter</code>，最终是停止该位子，模拟器缺跳出来了，再<code>enter</code>也没用了，因为线程在睡眠了。<code>syscall</code>是调用系统函数的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libsystem_kernel.dylib`__ulock_wait:</span><br><span class="line">    0x107a3b9d4 &lt;+0&gt;:  movl   $0x2000203, %eax          ; imm = 0x2000203 </span><br><span class="line">    0x107a3b9d9 &lt;+5&gt;:  movq   %rcx, %r10</span><br><span class="line">-&gt;  0x107a3b9dc &lt;+8&gt;:  syscall</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁-pthread-mutex-t"><a href="#互斥锁-pthread-mutex-t" class="headerlink" title="互斥锁 pthread_mutex_t"></a>互斥锁 pthread_mutex_t</h3><p><code>mutex</code>叫互斥锁，等待锁的线程会处于休眠状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">	pthread_mutex_destroy(&amp;_plock);</span><br><span class="line">	pthread_mutexattr_destroy(&amp;t);</span><br><span class="line">&#125;</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">	if (self =[super init]) &#123;</span><br><span class="line">		//初始化锁的属性 </span><br><span class="line">//		pthread_mutexattr_init(&amp;t);</span><br><span class="line">//		pthread_mutexattr_settype(&amp;t, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">//		//初始化锁</span><br><span class="line">//		pthread_mutex_init(&amp;_plock, &amp;t);</span><br><span class="line">		</span><br><span class="line">		pthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">		self.plock = plock;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">-(void)__saleTicket&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	[super __saleTicket];</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	[super __getMonery];</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	[super __saveMonery];</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>互斥锁有三个类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Mutex type attributes</span><br><span class="line"> */</span><br><span class="line"> 普通锁</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL		0</span><br><span class="line">//检查错误</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK	1</span><br><span class="line">//递归锁</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE		2</span><br><span class="line">//普通锁</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_NORMAL</span><br></pre></td></tr></table></figure>
<p>当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self otherTest2];</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest2&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">-[FYPthread_mutex2 otherTest]</span><br></pre></td></tr></table></figure>
<p>上面这个需求需要使用两把锁，或者使用递归锁来解决问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self otherTest2];</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest2&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;_plock2);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	pthread_mutex_unlock(&amp;_plock2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">-[FYPthread_mutex2 otherTest]</span><br><span class="line">-[FYPthread_mutex2 otherTest2]</span><br></pre></td></tr></table></figure>
<p>从使用2把锁是可以解决这个问题的。<br>递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。</p>
<h3 id="NSLock、NSRecursiveLosk"><a href="#NSLock、NSRecursiveLosk" class="headerlink" title="NSLock、NSRecursiveLosk"></a>NSLock、NSRecursiveLosk</h3><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p>
<p>使用<code>(LLDB) si</code>可以跟踪<code>[myLock lock];</code>的内部函数最终是<code>pthread_mutex_lock</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foundation`-[NSLock lock]:</span><br><span class="line">    0x1090dfb5a &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x1090dfb5b &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x1090dfb5e &lt;+4&gt;:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars</span><br><span class="line">    0x1090dfb63 &lt;+9&gt;:  movq   %rax, %rdi</span><br><span class="line">    0x1090dfb66 &lt;+12&gt;: popq   %rbp</span><br><span class="line">-&gt;  0x1090dfb67 &lt;+13&gt;: jmp    0x1092ca596   ;</span><br><span class="line">//  symbol stub for: pthread_mutex_lock</span><br></pre></td></tr></table></figure>
<p><code>NSLock API</code>大全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//协议NSLocking</span><br><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">    void *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)tryLock;//尝试加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，</span><br><span class="line">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>用法也很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface FYNSLock()&#123;</span><br><span class="line">	NSLock *_lock;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYNSLock</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">		//封装了mutex的普通锁</span><br><span class="line">		_lock=[[NSLock alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	[super __saveMonery];</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	[super __saleTicket];</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	[super __getMonery];</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tryLock;//尝试加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁</span><br></pre></td></tr></table></figure>
<p>递归锁可以对相同的线程进行反复加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@implementation FYRecursiveLockDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">		//封装了mutex的递归锁</span><br><span class="line">		_lock=[[NSRecursiveLock alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">	static int count = 10;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	while (count &gt; 0) &#123;</span><br><span class="line">		count -= 1;</span><br><span class="line">		printf(&quot;循环% 2d次 - %s \n&quot;,count,[NSThread currentThread].description.UTF8String);</span><br><span class="line">		[self otherTest];</span><br><span class="line">	&#125;</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">循环 9次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 8次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 7次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 6次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 5次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 4次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 3次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 2次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 1次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">循环 0次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSCondition-条件"><a href="#NSCondition-条件" class="headerlink" title="NSCondition 条件"></a>NSCondition 条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)wait;//等待</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</span><br><span class="line">- (void)signal;//唤醒一个线程</span><br><span class="line">- (void)broadcast;//唤醒多个线程</span><br></pre></td></tr></table></figure>
<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">		//遵守的 lock协议 的 条件🔐</span><br><span class="line">		_lock=[[NSCondition alloc]init];</span><br><span class="line">		self.array =[NSMutableArray array];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__add&#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	[self.array addObject:@&quot;Test&quot;];</span><br><span class="line">	NSLog(@&quot;添加成功&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">	[_lock signal];//唤醒一个线程</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)__remove&#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	if (self.array.count == 0) &#123;</span><br><span class="line">		[_lock wait];</span><br><span class="line">	&#125;</span><br><span class="line">	[self.array removeLastObject];</span><br><span class="line">	NSLog(@&quot;删除成功&quot;);</span><br><span class="line"></span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//Log</span><br><span class="line"></span><br><span class="line">2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功</span><br><span class="line">2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功</span><br></pre></td></tr></table></figure>
<p>可以看到时间上差了1秒，正好是我们设定的<code>sleep(1);</code>。优点是可以让线程之间形成依赖，缺点是没有明确的条件。</p>
<h3 id="NSConditionLock-可以实现线程依赖的锁"><a href="#NSConditionLock-可以实现线程依赖的锁" class="headerlink" title="NSConditionLock 可以实现线程依赖的锁"></a>NSConditionLock 可以实现线程依赖的锁</h3><p><code>NSConditionLock</code>是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用<code>NSConditionLock</code>来解决问题。<br>首先看下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) NSInteger condition;//条件值</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住</span><br><span class="line">//尝试加锁</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">//当con为condition进行尝试锁住</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">//当con为condition进行解锁</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">//NSDate 小余 limit进行 加锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">//条件为condition 在limit之前进行加锁</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br></pre></td></tr></table></figure>
<p>条件锁的使用，在<code>lockWhenCondition:(NSInteger)condition</code>的条件到达的时候才能进行正常的加锁和<code>unlockWithCondition:(NSInteger)condition</code>解锁，否则会阻塞线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)otherTest&#123;</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];</span><br><span class="line">	[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)__test1&#123;</span><br><span class="line">	[_lock lockWhenCondition:1];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[_lock unlockWithCondition:2];//解锁 并赋值2</span><br><span class="line">&#125;</span><br><span class="line">- (void)__test2&#123;</span><br><span class="line">	[_lock lockWhenCondition:2];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[_lock unlockWithCondition:3];//解锁 并赋值3</span><br><span class="line">&#125;</span><br><span class="line">- (void)__test3&#123;</span><br><span class="line">	[_lock lockWhenCondition:3];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[_lock unlockWithCondition:4];//解锁 并赋值4</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//log</span><br><span class="line">-[FYCondLockDemo2 __test1]</span><br><span class="line">-[FYCondLockDemo2 __test2]</span><br><span class="line">-[FYCondLockDemo2 __test3]</span><br></pre></td></tr></table></figure>
<p>当<code>con = 1</code>进行<code>test1</code>加锁和执行任务<code>A</code>，任务<code>A</code>执行完毕，进行解锁，并把值2赋值给<code>lock</code>，这是当<code>con = 2</code>的锁开始加锁，进入任务<code>B</code>，开始执行任务<code>B</code>，当任务<code>B</code>执行完毕，进行解锁并赋值为3，然后<code>con=3</code>的锁进行加锁，解锁并赋值4来进行线程之间的依赖。</p>
<h3 id="dispatch-queue-特殊的锁"><a href="#dispatch-queue-特殊的锁" class="headerlink" title="dispatch_queue 特殊的锁"></a>dispatch_queue 特殊的锁</h3><p>其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface FYSerialQueueDemo()&#123;</span><br><span class="line">	dispatch_queue_t _queue;</span><br><span class="line">&#125;@end</span><br><span class="line">@implementation FYSerialQueueDemo</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self =[super init]) &#123;</span><br><span class="line">		_queue = dispatch_queue_create(&quot;fyserial.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">	dispatch_sync(_queue, ^&#123;</span><br><span class="line">		[super __saleTicket];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__getMonery&#123;</span><br><span class="line">	dispatch_sync(_queue, ^&#123;</span><br><span class="line">		[super __getMonery];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMonery&#123;</span><br><span class="line">	dispatch_sync(_queue, ^&#123;</span><br><span class="line">		[super __saveMonery];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-semaphore-信号量控制并发数量"><a href="#dispatch-semaphore-信号量控制并发数量" class="headerlink" title="dispatch_semaphore 信号量控制并发数量"></a>dispatch_semaphore 信号量控制并发数量</h3><p>当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？<code>dispatch_semaphore</code>信号量正好可以满足我们的需求。<br><code>dispatch_semaphore</code>可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//初始化信号量 值为2，就是最多允许同时2个线程执行</span><br><span class="line">_semaphore = dispatch_semaphore_create(2);</span><br><span class="line">//生成多个线程进行并发访问test</span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">	for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test&#123;</span><br><span class="line">//如果信号量&gt;0 ，让信号量-1，继续向下执行。</span><br><span class="line">//如果信号量 &lt;= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER</span><br><span class="line">	dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	sleep(2);//睡眠时间2s</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	//释放一个信号量</span><br><span class="line">	dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] &lt;NSThread: 0x600002c45240&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] &lt;NSThread: 0x600002c45200&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] &lt;NSThread: 0x600002c45540&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] &lt;NSThread: 0x600002c45440&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] &lt;NSThread: 0x600002c45480&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] &lt;NSThread: 0x600002c454c0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] &lt;NSThread: 0x600002c45500&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] &lt;NSThread: 0x600002c45400&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] &lt;NSThread: 0x600002c455c0&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] &lt;NSThread: 0x600002c45580&gt;&#123;number = 11, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>一次最多2个线程同时执行任务，暂停时间是2s。<br>使用信号量实现线程最大并发锁，<br>同时只有2个线程执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">	if (self =[super init]) &#123;</span><br><span class="line">		_semaphore = dispatch_semaphore_create(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">	dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	[super __saleTicket];</span><br><span class="line">	dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p><code>@synchronized(id obj){}</code>锁的是对象<code>obj</code>，使用该锁的时候，底层是对象计算出来的值作为<code>key</code>，生成一把锁，不同的资源的读写可以使用不同<code>obj</code>作为锁对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)__saleTicket&#123;</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		[super __saleTicket];</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //log</span><br><span class="line">还剩 9 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 8 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 7 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 6 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 5 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 4 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">还剩 3 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">还剩 2 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">还剩 1 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="atmoic-原子操作"><a href="#atmoic-原子操作" class="headerlink" title="atmoic 原子操作"></a>atmoic 原子操作</h3><p>给属性添加<code>atmoic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证了<code>setter</code>和<code>getter</code>的内部是线程同步的。<br>原子操作是最终调用了<code>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//设置属性原子操作</span><br><span class="line">void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, true, false, false);</span><br><span class="line">&#125;</span><br><span class="line">//非原子操作设置属性</span><br><span class="line">void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, false, false, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;//偏移量等于0则是class指针</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">//其他的value</span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">    //如果是copy 用copyWithZone:</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        //mutableCopy则调用mutableCopyWithZone:</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //如果赋值和原来的相等 则不操作</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;//非原子操作 直接赋值</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;//原子操作 加锁</span><br><span class="line">    //锁和属性是一一对应的-&gt;自旋锁</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;//赋值</span><br><span class="line">        slotlock.unlock();//解锁</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;//非原子操作 直接返回值</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">	//原子操作 加锁-&gt;自旋锁</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();//加锁</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();//解锁</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以属性的地址为参数计算出key ，锁为value</span><br><span class="line">StripedMap&lt;spinlock_t&gt; PropertyLocks;</span><br></pre></td></tr></table></figure>
<p>从源码了解到设置属性读取是<code>self</code>+属性的偏移量，当<code>copy</code>或<code>mutableCopy</code>会调用到<code>[newValue copyWithZone:nil]</code>或<code>[newValue mutableCopyWithZone:nil]</code>，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取<code>spinlock_t&amp; slotlock = PropertyLocks[slot]</code>进行加锁、赋值、解锁操作。而且<code>PropertyLocks</code>是一个类，类有一个数组属性，使用<code>*p</code>计算出来的值作为<code>key</code>。</p>
<p>我们提取出来关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//原子操作 加锁</span><br><span class="line">spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">slotlock.lock();</span><br><span class="line">oldValue = *slot;</span><br><span class="line">*slot = newValue;//赋值</span><br><span class="line">slotlock.unlock();//解锁</span><br></pre></td></tr></table></figure>
<p>使用自旋锁对赋值操作进行加锁，保证了<code>setter()</code>方法的安全性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//原子操作 加锁 -&gt;自旋锁</span><br><span class="line">spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">slotlock.lock();//加锁</span><br><span class="line">id value = objc_retain(*slot);</span><br><span class="line">slotlock.unlock();//解锁</span><br></pre></td></tr></table></figure>
<p>取值之前进行加锁，取值之后进行解锁，保证了<code>getter()</code>方法的安全。</p>
<p>由上面得知<code>atmoic</code>仅仅是对方法<code>setter()</code>和<code>getter()</code>安全，对成员变量不保证安全，对于属性的读写一般使用<code>nonatomic</code>，性能好，<code>atomic</code>读取频率高的时候会导致线程都在排队，浪费CPU时间。</p>
<p>大概使用者几种锁分别对卖票功能进行了性能测试，<br>性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁类型</th>
<th style="text-align:center">1万次</th>
<th style="text-align:center">100万次</th>
<th style="text-align:center">1000万次</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pthread_mutex_t</td>
<td style="text-align:center">0.000309</td>
<td style="text-align:center">0.027238</td>
<td style="text-align:center">0.284714</td>
</tr>
<tr>
<td style="text-align:center">os_unfair_lock</td>
<td style="text-align:center">0.000274</td>
<td style="text-align:center">0.028266</td>
<td style="text-align:center">0.285685</td>
</tr>
<tr>
<td style="text-align:center">OSSpinLock</td>
<td style="text-align:center">0.030688</td>
<td style="text-align:center">0.410067</td>
<td style="text-align:center">0.437702</td>
</tr>
<tr>
<td style="text-align:center">NSCondition</td>
<td style="text-align:center">0.005067</td>
<td style="text-align:center">0.323492</td>
<td style="text-align:center">1.078636</td>
</tr>
<tr>
<td style="text-align:center">NSLock</td>
<td style="text-align:center">0.038692</td>
<td style="text-align:center">0.151601</td>
<td style="text-align:center">1.322062</td>
</tr>
<tr>
<td style="text-align:center">NSRecursiveLock</td>
<td style="text-align:center">0.007973</td>
<td style="text-align:center">0.151601</td>
<td style="text-align:center">1.673409</td>
</tr>
<tr>
<td style="text-align:center">@synchronized</td>
<td style="text-align:center">0.008953</td>
<td style="text-align:center">0.640234</td>
<td style="text-align:center">2.790291</td>
</tr>
<tr>
<td style="text-align:center">NSConditionLock</td>
<td style="text-align:center">0.229148</td>
<td style="text-align:center">5.325272</td>
<td style="text-align:center">10.681123</td>
</tr>
<tr>
<td style="text-align:center">semaphore</td>
<td style="text-align:center">0.094267</td>
<td style="text-align:center">0.415351</td>
<td style="text-align:center">24.699100</td>
</tr>
<tr>
<td style="text-align:center">SerialQueue</td>
<td style="text-align:center">0.213386</td>
<td style="text-align:center">9.058581</td>
<td style="text-align:center">50.820202</td>
</tr>
</tbody>
</table>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>平时我们简单使用的话没有很大的区别，还是推荐使用<code>NSLock</code>和信号量,最简单的是<code>@synchronized</code>，不用声明和初始化，直接拿来就用。</p>
<h3 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h3><p>自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁在等待时间比较短的时候比较合适</li>
<li>临界区代码经常被调用，但竞争很少发生</li>
<li>CPU不紧张</li>
<li>多核处理器<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4></li>
<li>预计线程等待时间比较长</li>
<li>单核处理器</li>
<li>临界区IO操作</li>
<li>临界区代码比较多、复杂，或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<h2 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h2><h4 id="简单读写锁"><a href="#简单读写锁" class="headerlink" title="简单读写锁"></a>简单读写锁</h4><p>一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	// Do any additional setup after loading the view.</span><br><span class="line">	self.semaphore = dispatch_semaphore_create(1);</span><br><span class="line">	</span><br><span class="line">	for (NSInteger i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];</span><br><span class="line">		[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)read&#123;</span><br><span class="line">	dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br><span class="line">- (void)write&#123;</span><br><span class="line">	dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点</p>
<ol>
<li>同一时间，只能有1个线程进行写操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许读写操作同时进行</li>
</ol>
<p>典型的<code>多读单写</code>，经常用于文件等数据的读写操作，我们实现2种</p>
<h4 id="读写锁-pthread-rwlock"><a href="#读写锁-pthread-rwlock" class="headerlink" title="读写锁 pthread_rwlock"></a>读写锁 pthread_rwlock</h4><p>这是有c语言封装的读写锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//初始化读写锁</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t * __restrict,</span><br><span class="line">		const pthread_rwlockattr_t * _Nullable __restrict)</span><br><span class="line">//读上锁</span><br><span class="line">pthread_rwlock_rdlock(pthread_rwlock_t *)</span><br><span class="line">//尝试加锁读</span><br><span class="line">pthread_rwlock_tryrdlock(pthread_rwlock_t *)</span><br><span class="line">//尝试加锁写</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *)</span><br><span class="line">//写入加锁</span><br><span class="line">pthread_rwlock_wrlock(pthread_rwlock_t *)</span><br><span class="line">//解锁</span><br><span class="line">pthread_rwlock_unlock(pthread_rwlock_t *)</span><br><span class="line">//销毁锁属性</span><br><span class="line">pthread_rwlockattr_destroy(pthread_rwlockattr_t *)</span><br><span class="line">//销毁锁</span><br><span class="line">pthread_rwlock_destroy(pthread_rwlock_t * )</span><br></pre></td></tr></table></figure>
<p><code>pthread_rwlock_t</code>使用很简单，只需要在读之前使用<code>pthread_rwlock_rdlock</code>，读完解锁<code>pthread_rwlock_unlock</code>,写入前需要加锁<code>pthread_rwlock_wrlock</code>，写入完成之后解锁<code>pthread_rwlock_unlock</code>，任务都执行完了可以选择销毁<code>pthread_rwlock_destroy</code>或者等待下次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,assign) pthread_rwlock_t rwlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	pthread_rwlock_destroy(&amp;_rwlock);//销毁锁</span><br><span class="line">&#125;</span><br><span class="line">//初始化读写锁</span><br><span class="line">pthread_rwlock_init(&amp;_rwlock, NULL);</span><br><span class="line">	</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];</span><br><span class="line">			[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">- (void)readPthreadRWLock&#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_rwlock);</span><br><span class="line">    NSLog(@&quot;读文件&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)writePthreadRWLock&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_rwlock);</span><br><span class="line">    NSLog(@&quot; 写入文件&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">2019-07-30 10:47:16 读文件</span><br><span class="line">2019-07-30 10:47:16 读文件</span><br><span class="line">2019-07-30 10:47:17 写入文件</span><br><span class="line">2019-07-30 10:47:18 写入文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:19 读文件</span><br><span class="line">2019-07-30 10:47:20 写入文件</span><br><span class="line">2019-07-30 10:47:21 写入文件</span><br><span class="line">2019-07-30 10:47:22 写入文件</span><br></pre></td></tr></table></figure>
<p>读文件会出现同一秒读多次，写文件同一秒只有一个。</p>
<h4 id="异步栅栏调用-dispatch-barrier-async"><a href="#异步栅栏调用-dispatch-barrier-async" class="headerlink" title="异步栅栏调用 dispatch_barrier_async"></a>异步栅栏调用 dispatch_barrier_async</h4><p>栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">任务</th>
<th style="text-align:center">任务</th>
<th style="text-align:center">任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">读</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
</tr>
</tbody>
</table>
<p>这个函数传入的并发队列必须是通过<code>dispatch_queue_create</code>创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于<code>dispatch_async</code>的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//初始化 异步队列</span><br><span class="line">self.rwqueue = dispatch_queue_create(&quot;rw.thread&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		[self readBarryier];</span><br><span class="line">		[self readBarryier];</span><br><span class="line">		[self readBarryier];</span><br><span class="line">		[self writeBarrier];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)readBarryier&#123;</span><br><span class="line">//添加任务到rwqueue</span><br><span class="line">	dispatch_async(self.rwqueue, ^&#123;</span><br><span class="line">		NSLog(@&quot;读文件 %@&quot;,[NSThread currentThread]);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)writeBarrier&#123;</span><br><span class="line">//barrier_async添加任务到self.rwqueue中</span><br><span class="line">	dispatch_barrier_async(self.rwqueue, ^&#123;</span><br><span class="line">		NSLog(@&quot;写入文件 %@&quot;,[NSThread currentThread]);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae0740&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8500&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8040&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:54 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:55 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2019-07-30 11:16:56 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>读文件会出现同一秒读多个，写文件同一秒只有一个。</p>
<p>读写任务都添加到异步队列<code>rwqueue</code>中，使用栅栏函数<code>dispatch_barrier_async</code>拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>普通线程锁本质就是同步执行</li>
<li><code>atomic</code>原子操作只限制<code>setter</code>和<code>getter</code>方法，不限制成员变量</li>
<li>读写锁高性能可以使用<code>pthread_rwlock_t</code>和<code>dispatch_barrier_async</code><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="https://blog.csdn.net/Fly_as_tadpole/article/details/86436161" target="_blank" rel="noopener">优先级反转</a></li>
<li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="noopener">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="noopener">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a></li>
<li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理  多线程之GCD看我就够了 --(10)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:20:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:20:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>RunLoop</code>和线程的关系，以及<code>Thread</code>如何保活和控制生命周期，今天我们再探究下另外的一个线程<code>GCD</code>，揭开蒙娜丽莎的面纱。</p>
<h3 id="GCD-基础知识"><a href="#GCD-基础知识" class="headerlink" title="GCD 基础知识"></a>GCD 基础知识</h3><p>GCD是什么呢？我们引用<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a>的一段话。</p>
<blockquote>
<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>
</blockquote>
<p>GCD有哪些优点</p>
<ul>
<li>GCD自动管理线程</li>
<li>开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可</li>
<li>GCD 自动管理线程，线程创建，挂起，销毁。</li>
</ul>
<p>那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发</p>
<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。</p>
<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><p>并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活</p>
<p><strong>串行队列</strong>相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。</p>
<p><strong>并行队列</strong>是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。</p>
<p><strong>并发</strong>是多个流水线在同时加工产品。</p>
<h4 id="GCD中的串行队列"><a href="#GCD中的串行队列" class="headerlink" title="GCD中的串行队列()"></a>GCD中的串行队列()</h4><h5 id="串行队列（Serial-Dispatch-Queue）："><a href="#串行队列（Serial-Dispatch-Queue）：" class="headerlink" title="串行队列（Serial Dispatch Queue）："></a>串行队列（Serial Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。</p>
<p><img src="/images/10-1.png" alt></p>
<h5 id="并发队列（Concurrent-Dispatch-Queue）："><a href="#并发队列（Concurrent-Dispatch-Queue）：" class="headerlink" title="并发队列（Concurrent Dispatch Queue）："></a>并发队列（Concurrent Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。</p>
<p><img src="/images/10-2.png" alt></p>
<h3 id="GCD使用步骤"><a href="#GCD使用步骤" class="headerlink" title="GCD使用步骤"></a>GCD使用步骤</h3><p>GCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。</p>
<p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p>
<h4 id="获取主队列"><a href="#获取主队列" class="headerlink" title="获取主队列"></a>获取主队列</h4><p>主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过<code>dispatch_get_main_queue()</code>，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取主队列</span><br><span class="line">dispatch_queue_t main_queue= dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<h4 id="获取全局队列"><a href="#获取全局队列" class="headerlink" title="获取全局队列"></a>获取全局队列</h4><p>全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>,第一个参数是<code>identifier</code>，表示队列的优先级，一般传入<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数<code>flags</code>，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a></p>
<blockquote>
<p>Use the<br>.Fn dispatch_get_global_queue<br>function to obtain the global queue of given priority. The<br>.Fa flags<br>argument is reserved for future use and must be zero. Passing any value other<br>than zero may result in a NULL return value.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取全局队列</span><br><span class="line">dispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<h4 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法的<code>spatch_async</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然是只有同步异步但是他们组合的多变的</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">并发队列</th>
<th style="text-align:center">创建的串行队列</th>
<th style="text-align:center">主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同步(sync)</td>
<td style="text-align:center">没开启新线程，串行执行</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
</tr>
<tr>
<td style="text-align:center">异步(async)</td>
<td style="text-align:center">能开启新线程，并发执行</td>
<td style="text-align:center">能开启新线程，串行执行任务</td>
<td style="text-align:center">没开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<h3 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h3><h4 id="主队列-同步"><a href="#主队列-同步" class="headerlink" title="主队列+同步"></a>主队列+同步</h4><p>在主队列中执行任务，并同步添加任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//主队列+同步</span><br><span class="line">-(void)syn_main&#123;</span><br><span class="line">	NSLog(@&quot;1&quot;);</span><br><span class="line">	dispatch_queue_t main_queue = dispatch_get_main_queue();</span><br><span class="line">	dispatch_sync(main_queue, ^&#123;</span><br><span class="line">		NSLog(@&quot;2&quot;);</span><br><span class="line">	&#125;);</span><br><span class="line">	NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>看到日志只输出了1就崩溃了提示<code>exc_bad_instuction</code>,为什么出问题呢？<br>主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。<br><strong>what</strong>???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句<code>exc_bad_instuction</code>，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。<br>那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//主队列+同步</span><br><span class="line">-(void)syn_main2&#123;</span><br><span class="line">	NSLog(@&quot;1任务执行&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">	NSLog(@&quot;2任务执行&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">	NSLog(@&quot;3任务执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">1任务执行</span><br><span class="line">2任务执行</span><br><span class="line">3任务执行</span><br></pre></td></tr></table></figure>
<p>没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。</p>
<h4 id="主队列-异步"><a href="#主队列-异步" class="headerlink" title="主队列+异步"></a>主队列+异步</h4><p>在主队列中异步添加任务并执行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//主队列+异步</span><br><span class="line">	NSLog(@&quot;start&quot;);</span><br><span class="line">	dispatch_queue_t main_queue = dispatch_get_main_queue();</span><br><span class="line">	dispatch_async(main_queue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(main_queue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(main_queue, ^&#123;</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			NSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	NSLog(@&quot;end&quot;);</span><br><span class="line">//log</span><br><span class="line">2019-07-24 15:12:24.73 start</span><br><span class="line">2019-07-24 15:12:24.73 end</span><br><span class="line"></span><br><span class="line">&lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 2</span><br><span class="line">2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 3</span><br><span class="line">2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 4</span><br><span class="line">2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 5</span><br><span class="line">2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 7</span><br><span class="line">2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 8</span><br><span class="line">2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 9</span><br></pre></td></tr></table></figure>
<p>在主队列异步执行任务，从日志看出来<code>end</code>早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到</p>
<ul>
<li>主线程多个任务异步不能创建新线程</li>
<li>主线程异步也是串行执行</li>
</ul>
<h4 id="全局队列-同步"><a href="#全局队列-同步" class="headerlink" title="全局队列+同步"></a>全局队列+同步</h4><p>全局队列是并行队列，和同步配合就是串行执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//全局队列+同步</span><br><span class="line">-(void)sync_global&#123;</span><br><span class="line">	printf(&quot;\n start&quot;);</span><br><span class="line">	dispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">	dispatch_sync(global_queue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_sync(global_queue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_sync(global_queue, ^&#123;</span><br><span class="line">		NSThread *thread = [NSThread currentThread];</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">start</span><br><span class="line"> 2019-07-24 15:35:36 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line"> 2019-07-24 15:35:37 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line"> 2019-07-24 15:35:38 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 2</span><br><span class="line"> 2019-07-24 15:35:39 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 3</span><br><span class="line"> 2019-07-24 15:35:40 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 4</span><br><span class="line"> 2019-07-24 15:35:41 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 5</span><br><span class="line"> 2019-07-24 15:35:42 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 7</span><br><span class="line"> 2019-07-24 15:35:43 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 8</span><br><span class="line"> 2019-07-24 15:35:44 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 9</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<p>在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。</p>
<h4 id="全局队列-异步"><a href="#全局队列-异步" class="headerlink" title="全局队列+异步"></a>全局队列+异步</h4><p>全局队列有创建子线程的能力，但是需要异步<code>async</code>去执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//全局队列+异步</span><br><span class="line">-(void)async_global&#123;</span><br><span class="line">	printf(&quot;\n start&quot;);</span><br><span class="line">	dispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">	dispatch_async(global_queue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(global_queue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(global_queue, ^&#123;</span><br><span class="line">		NSThread *thread = [NSThread currentThread];</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(NSString *)currentDateString&#123;</span><br><span class="line">	NSDate *date=[NSDate new];</span><br><span class="line">	NSDateFormatter *format = [[NSDateFormatter alloc]init];</span><br><span class="line">	[format setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">	return [format stringFromDate:date];</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line"> start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 3</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 0</span><br><span class="line"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 7</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 1</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 8</span><br><span class="line"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 4</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 9</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 2</span><br><span class="line"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 5</span><br></pre></td></tr></table></figure>
<p>全局队列当搭配<code>async</code>的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。</p>
<h4 id="创建串行队列-同步"><a href="#创建串行队列-同步" class="headerlink" title="创建串行队列+同步"></a>创建串行队列+同步</h4><p>开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//创建串行队列+同步</span><br><span class="line">-(void)sync_cust_queue&#123;</span><br><span class="line">	printf(&quot;\n start&quot;);</span><br><span class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">	dispatch_sync(custQueue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_sync(custQueue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_sync(custQueue, ^&#123;</span><br><span class="line">		NSThread *thread = [NSThread currentThread];</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"> 2019-07-24 15:53:15 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line"> 2019-07-24 15:53:16 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line"> 2019-07-24 15:53:17 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 2</span><br><span class="line"> 2019-07-24 15:53:18 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 3</span><br><span class="line"> 2019-07-24 15:53:19 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 4</span><br><span class="line"> 2019-07-24 15:53:20 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 5</span><br><span class="line"> 2019-07-24 15:53:21 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 7</span><br><span class="line"> 2019-07-24 15:53:22 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 8</span><br><span class="line"> 2019-07-24 15:53:23 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 9</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<p>同步向串行队列添加任务并没有死锁！原因是添加任务是在<code>main_queue</code>执行的，添加的任务是在<code>cust-queue</code>中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在<code>main</code>线程中。</p>
<h4 id="创建串行队列-异步"><a href="#创建串行队列-异步" class="headerlink" title="创建串行队列+异步"></a>创建串行队列+异步</h4><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//创建串行队列+异步</span><br><span class="line">-(void)async_cust_queue&#123;</span><br><span class="line">	printf(&quot;\n start&quot;);</span><br><span class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		NSThread *thread = [NSThread currentThread];</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line"> start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 16:12:57 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:12:58 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:12:59 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:13:00 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:13:01 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:13:02 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 5</span><br><span class="line"> 2019-07-24 16:13:03 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 7</span><br><span class="line"> 2019-07-24 16:13:04 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 8</span><br><span class="line"> 2019-07-24 16:13:05 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 9</span><br></pre></td></tr></table></figure>
<p>在<code>异步 + 串行队列</code>可以看到：</p>
<p>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。<br>所有任务是在打印的<code>end</code>之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<h4 id="创建并行队列-同步"><a href="#创建并行队列-同步" class="headerlink" title="创建并行队列+同步"></a>创建并行队列+同步</h4><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">2019-07-24 16:21:24 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-07-24 16:21:25 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-07-24 16:21:26 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 2</span><br><span class="line">2019-07-24 16:21:27 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 3</span><br><span class="line">2019-07-24 16:21:28 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 4</span><br><span class="line">2019-07-24 16:21:29 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 5</span><br><span class="line">2019-07-24 16:21:30 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 7</span><br><span class="line">2019-07-24 16:21:31 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 8</span><br><span class="line">2019-07-24 16:21:32 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 9</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>全局队列其实就是特殊的并行队列，这里结果和<code>全局队列+同步</code>一致。</p>
<h4 id="创建并行队列-异步"><a href="#创建并行队列-异步" class="headerlink" title="创建并行队列+异步"></a>创建并行队列+异步</h4><p>在当前线程中执行任务，会开启新线程，可以同时执行多个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//创建并行队列+异步</span><br><span class="line">-(void)async_queue&#123;</span><br><span class="line">	printf(&quot;\n start&quot;);</span><br><span class="line">	dispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(custQueue, ^&#123;</span><br><span class="line">		NSThread *thread = [NSThread currentThread];</span><br><span class="line">		for (int i = 7; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">start</span><br><span class="line"> end</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 7</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:22:09 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 8</span><br><span class="line"> 2019-07-24 16:22:10 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 9</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:22:11 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 5</span><br></pre></td></tr></table></figure>
<p><code>并行队列+异步</code>和<code>全局队列+异步</code>一致，也会新建线程执行任务，且是并发执行。</p>
<h3 id="GCD其他高级用法"><a href="#GCD其他高级用法" class="headerlink" title="GCD其他高级用法"></a>GCD其他高级用法</h3><h4 id="子线程执行任务-主线程刷新UI"><a href="#子线程执行任务-主线程刷新UI" class="headerlink" title="子线程执行任务 主线程刷新UI"></a>子线程执行任务 主线程刷新UI</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)backToMain&#123;</span><br><span class="line">	dispatch_queue_t main = dispatch_get_main_queue();</span><br><span class="line">	dispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">	dispatch_async(glo, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">		dispatch_sync(main, ^&#123;</span><br><span class="line">			printf(&quot;\n %s %s 我在刷新UI&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);	</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"> 2019-07-24 16:45:07 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:45:08 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001ef2940&gt;&#123;number = 1, name = main&#125; 我在刷新UI</span><br></pre></td></tr></table></figure>
<h4 id="队列分组-dispatch-group-t"><a href="#队列分组-dispatch-group-t" class="headerlink" title="队列分组 dispatch_group_t"></a>队列分组 dispatch_group_t</h4><h5 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h5><p>GCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过<code>dispatch_group_notify</code>完成回调，第一个参数<code>group</code>是某个分组的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(void)group&#123;</span><br><span class="line">	dispatch_group_t group = dispatch_group_create();</span><br><span class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;cust2.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">		for (int i = 4; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		printf(&quot;\n %s %s ---end1----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">		for (int i = 6; i &lt; 8; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">		for (int i = 8; i &lt; 10; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave"><a href="#dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave" class="headerlink" title="dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave"></a>dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave</h5><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>需要成对使用，否则<code>dispatch_group_wait</code>在缺少<code>leave</code>的情况下会等待到死，造成线程阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static	dispatch_group_t group ;</span><br><span class="line">if (group == nil) &#123;</span><br><span class="line">	group = dispatch_group_create();</span><br><span class="line">&#125;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">//	dispatch_group_enter(group);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[self print];</span><br><span class="line">	[NSThread sleepForTimeInterval:2];</span><br><span class="line">//		dispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	[self print];</span><br><span class="line">	[NSThread sleepForTimeInterval:2];</span><br><span class="line">	dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">//log</span><br><span class="line">2019-07-25 10:58:50 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">2019-07-25 10:58:52 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栅栏函数-dispatch-barrier-sync"><a href="#栅栏函数-dispatch-barrier-sync" class="headerlink" title="栅栏函数 dispatch_barrier_sync"></a>栅栏函数 dispatch_barrier_sync</h4><p>栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)barry&#123;</span><br><span class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">		printf(&quot;\n %s %s ---中间暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		for (int i = 3; i &lt; 6; i ++) &#123;</span><br><span class="line">			[NSThread sleepForTimeInterval:1];</span><br><span class="line">			printf(&quot;\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">		printf(&quot;\n %s %s ---中间第二次暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"> 2019-07-24 16:52:33 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 0</span><br><span class="line"> 2019-07-24 16:52:34 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 1</span><br><span class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 2</span><br><span class="line"> 2019-07-24 16:52:35 &lt;NSThread: 0x6000031293c0&gt;&#123;number = 1, name = main&#125; ---中间暂停一下----</span><br><span class="line"> 2019-07-24 16:52:36 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 3</span><br><span class="line"> 2019-07-24 16:52:37 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 4</span><br><span class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 5</span><br><span class="line"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; ---中间第二次暂停一下----</span><br></pre></td></tr></table></figure>
<h4 id="单例-执行一次的函数-dispatch-once-t"><a href="#单例-执行一次的函数-dispatch-once-t" class="headerlink" title="单例-执行一次的函数 dispatch_once_t"></a>单例-执行一次的函数 dispatch_once_t</h4><p>单例可以通过这个函数实现，只执行一次的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//只执行一次的dispatch_once</span><br><span class="line">-(void)exc_once&#123;</span><br><span class="line">	static dispatch_once_t onceToken;</span><br><span class="line">	static NSObject *obj;</span><br><span class="line">	dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">		obj=[NSObject new];</span><br><span class="line">		printf(&quot;\n just once %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line">调用4次</span><br><span class="line">dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">		[self exc_once];</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">//log</span><br><span class="line">just once 2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br><span class="line">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</span><br></pre></td></tr></table></figure>
<p>当调用4次的时候，日志打印的四次<code>obj</code>均为同一个地址，证明<code>block</code>回调四次但是只执行了一次。</p>
<h4 id="延迟执行-dispatch-after"><a href="#延迟执行-dispatch-after" class="headerlink" title="延迟执行 dispatch_after"></a>延迟执行 dispatch_after</h4><p>当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//延迟执行</span><br><span class="line">-(void)delayTimeExc&#123;</span><br><span class="line">	printf(&quot;\n %s %s begin&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">	</span><br><span class="line">	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	</span><br><span class="line">		printf(&quot;\n %s %s&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">	printf(&quot;\n %s %s end&quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; begin</span><br><span class="line">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; end</span><br><span class="line">2019-07-24 17:07:50 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量-dispatch-semaphore-t"><a href="#信号量-dispatch-semaphore-t" class="headerlink" title="信号量  dispatch_semaphore_t"></a>信号量  dispatch_semaphore_t</h4><p>信号量为1可以作为线程锁来用，当N&gt;1的时候，同时执行的有N个任务。<br><code>dispatch_apply</code>可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//信号量 当信号量为1 可以未做锁来用，当N&gt;1，t通知执行的数量则是数字N。</span><br><span class="line">- (void)semaphore&#123;</span><br><span class="line">	static dispatch_semaphore_t sem;</span><br><span class="line">	if (sem == NULL) &#123;</span><br><span class="line">		sem = dispatch_semaphore_create(1);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">	static int i = 0;</span><br><span class="line">	int currentI = i +2;</span><br><span class="line">	for (; i &lt; currentI; i ++) &#123;</span><br><span class="line">		[NSThread sleepForTimeInterval:1];</span><br><span class="line">		printf(&quot;\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_signal(sem);</span><br><span class="line">&#125;</span><br><span class="line">-(void)asyn_semaphore&#123;</span><br><span class="line">	dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">		[self semaphore];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">2019-07-24 17:25:04 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">2019-07-24 17:25:05 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">2019-07-24 17:25:06 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 2</span><br><span class="line">2019-07-24 17:25:07 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 3</span><br><span class="line">2019-07-24 17:25:08 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 4</span><br><span class="line">2019-07-24 17:25:09 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 5</span><br></pre></td></tr></table></figure>
<p>设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-(void)muchQueueBuyTick&#123;</span><br><span class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">			[self semaphore_buy_ticks:4];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(queue2, ^&#123;</span><br><span class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">			[self semaphore_buy_ticks:2];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)semaphore_buy_ticks:(NSInteger)windowsCount&#123;</span><br><span class="line">	static dispatch_semaphore_t sem;</span><br><span class="line">	if (sem == NULL) &#123;</span><br><span class="line">		sem = dispatch_semaphore_create(windowsCount);</span><br><span class="line">	&#125;</span><br><span class="line">	//信号量-1</span><br><span class="line">	dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">	self.count--;</span><br><span class="line">	if (self.count &gt; 0) &#123;</span><br><span class="line">		printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</span><br><span class="line">		[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">	&#125;</span><br><span class="line">	//信号量+1</span><br><span class="line">	dispatch_semaphore_signal(sem);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">2019-07-24 18:01:44 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:01:44 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第0个人买到票了</span><br></pre></td></tr></table></figure>
<p>两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。<br>当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)muchQueueBuyTick&#123;</span><br><span class="line">	dispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">			[self semaphore_buy_ticks:1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	dispatch_async(queue2, ^&#123;</span><br><span class="line">		for (NSInteger i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">			[self semaphore_buy_ticks:1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">2019-07-24 18:03:56 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第9个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第7个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第5个人买到票了</span><br><span class="line"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第3个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第1个人买到票了</span><br></pre></td></tr></table></figure>
<p>顺序是对了，数量也对了。</p>
<p>再换一种思路实现锁住窗口，我们使用串行队列也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//使用同步队列卖票</span><br><span class="line">- (void)sync_buy_tick&#123;</span><br><span class="line">	dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		self.count--;</span><br><span class="line">		if (self.count &gt; 0) &#123;</span><br><span class="line">			printf(&quot;\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</span><br><span class="line">			[NSThread sleepForTimeInterval:0.2];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第9个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第8个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第7个人买到票了</span><br><span class="line"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第6个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第5个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第4个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第3个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第2个人买到票了</span><br><span class="line"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第1个人买到票了</span><br></pre></td></tr></table></figure>
<p>串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。</p>
<h4 id="快速迭代方法：dispatch-apply"><a href="#快速迭代方法：dispatch-apply" class="headerlink" title="快速迭代方法：dispatch_apply"></a>快速迭代方法：dispatch_apply</h4><p>快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">同时新建了多条线程来做任务</span><br><span class="line">*/</span><br><span class="line">	dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</span><br><span class="line">		printf(&quot;\n %s %s &quot;,[self dateUTF8],[self threadInfo]);</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	//log</span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000979dc0&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000090d3c0&gt;&#123;number = 1, name = main&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x60000095cfc0&gt;&#123;number = 6, name = (null)&#125; </span><br><span class="line">2019-07-25 09:38:38 &lt;NSThread: 0x600000950140&gt;&#123;number = 8, name = (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000095d0c0&gt;&#123;number = 9, name = (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a400&gt;&#123;number = 7, name = (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </span><br><span class="line"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到新建了<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>、<code>main</code>来执行任务。</p>
<h3 id="多线程RunLoop实战"><a href="#多线程RunLoop实战" class="headerlink" title="多线程RunLoop实战"></a>多线程RunLoop实战</h3><p>问题一：请问下边代码输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>猜想1：结果是<code>123</code></li>
<li>猜想2：结果是<code>132</code></li>
</ul>
<p>有没有第三种结果呢？</p>
<p>猜想1分析：<br>因为是延迟<code>0</code>s执行，当然是先执行<code>2</code>，再执行<code>3</code>了。</p>
<p>猜想2分析：</p>
<p>我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出<code>1</code>，然后输出<code>3</code>，最后输出<code>2</code>.</p>
<p>最后验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在<code>runloop.h</code>文件中，我们猜测延迟执行是<code>timer</code>添加到<code>runloop</code>中了，添加进去也应该输出<code>132</code>的。因为在子线程中，没有主动调用不会有<code>runloop</code>的，及时调用了也需要保活技术，那么代码改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        // 相当于[self test];</span><br><span class="line">//       [self performSelector:@selector(test) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>经测试输出了<code>12</code>，这和我们猜想的还是不对，原来输出<code>3</code>放在了最后，导致的问题，<code>RunLoop</code>运行起来，进入了循环，则后面的就不会执行了，除非停止当前<code>RunLoop</code>，我们再改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(que, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        // 相当于[self test];</span><br><span class="line">//       [self performSelector:@selector(test) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">         NSLog(@&quot;3&quot;);</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>最后终于输出了<code>132</code>。缺点是子线程成了<strong>死待</strong>，不死之身，关于怎么杀死<strong>死待</strong>请看<a href="https://juejin.im/post/5d35b347f265da1b8608c49b" target="_blank" rel="noopener">上篇优雅控制RunLoop生命周期</a>。<br>关于<code>performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>中有延迟的，都是添加到当前你线程的<code>RunLoop</code>，如果没有启动<code>RunLoop</code>和保活恐怕也不能一直执行。<code>[self performSelector:@selector(test) withObject:nil]</code>是在<code>Foudation</code>中，源码是直接<code>objc_msgSend()</code>，相当于直接<code>[self test]</code>，不会有延迟。</p>
<p>问题2：请问输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread=[[NSThread alloc]initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br><span class="line">[self performSelector:@selector(test)</span><br><span class="line">             onThread:thread</span><br><span class="line">           withObject:nil</span><br><span class="line">        waitUntilDone:YES];</span><br></pre></td></tr></table></figure>
<p>这个和上面的类似，结果是打印了<code>1</code>就崩溃了，原因是<code>thread start</code>之后执行完<code>block</code>就结束了，没有<code>runloop</code>的支撑。当执行<code>performSelector</code>的时候，线程已经死掉。解决这个问题只需要向子线程中添加<code>RunLoop</code>，而且保证<code>RunLoop</code>不停止就行了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI</li>
<li>队列多任务异步执行最后全局执行完毕可以使用<code>group_notify</code>来监听执行完毕时间</li>
<li>队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用<code>dispatch_barrier_sync</code></li>
<li>当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="noopener">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="noopener">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a></li>
<li>iOS和OS多线程与内存管理<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:19:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:19:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>
<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ret = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    //睡眠中等待消息</span><br><span class="line">    int messgae = sleep_and_wait();</span><br><span class="line">    //处理消息</span><br><span class="line">    ret = process_message(messgae);</span><br><span class="line">&#125; while (ret == 0);</span><br></pre></td></tr></table></figure>
<h3 id="获取runloop"><a href="#获取runloop" class="headerlink" title="获取runloop"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</span><br><span class="line">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</span><br><span class="line"></span><br><span class="line">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</span><br><span class="line">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</span><br><span class="line">NSLog(@&quot;%@&quot;,runloop1);</span><br><span class="line">//打印</span><br><span class="line">runlopp1:0x600001bc58c0 </span><br><span class="line">mainloop1:0x600001bc58c0 </span><br><span class="line">runloop2:0x6000003cc300 </span><br><span class="line">mainloop1:0x6000003cc300</span><br><span class="line"></span><br><span class="line">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</span><br></pre></td></tr></table></figure>
<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>
<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;			/* model list 锁 */</span><br><span class="line">    __CFPort _wakeUpPort;			// 接受 CFRunLoopWakeUp的端口</span><br><span class="line">    Boolean _unused;//是否使用</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread; //线程</span><br><span class="line">    uint32_t _winthread;//win线程</span><br><span class="line">    CFMutableSetRef _commonModes; //modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; //modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; //当前的mode</span><br><span class="line">    CFMutableSetRef _modes; //所有的modes</span><br><span class="line">    struct _block_item *_blocks_head; //待执行的block列表头部</span><br><span class="line">    struct _block_item *_blocks_tail; //待执行的block 尾部</span><br><span class="line">    CFAbsoluteTime _runTime; //runtime</span><br><span class="line">    CFAbsoluteTime _sleepTime; //sleeptime</span><br><span class="line">    CFTypeRef _counterpart; //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过简化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread; //线程</span><br><span class="line">    CFMutableSetRef _commonModes; //modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; //modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; //当前的mode</span><br><span class="line">    CFMutableSetRef _modes; //所有的modes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>
<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>
<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>
</ol>
<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过简化之后是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;//当前mode的名字</span><br><span class="line">    CFMutableSetRef _sources0;//souces0</span><br><span class="line">    CFMutableSetRef _sources1;//sources1</span><br><span class="line">    CFMutableArrayRef _observers;//observers</span><br><span class="line">    CFMutableArrayRef _timers;//timers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>
<p><img src="/images/9-1.png" alt></p>
<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>
<h4 id="souces0"><a href="#souces0" class="headerlink" title="souces0"></a>souces0</h4><ul>
<li>触摸事件</li>
<li>performSelector:onThread:</li>
</ul>
<p>测试下点击事件处理源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);//此处断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(LLDB) bt //输出当前调用栈</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</span><br><span class="line">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</span><br><span class="line">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</span><br><span class="line">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</span><br><span class="line">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</span><br><span class="line">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</span><br><span class="line">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</span><br><span class="line">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</span><br><span class="line">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</span><br><span class="line">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</span><br><span class="line">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</span><br><span class="line">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</span><br><span class="line">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</span><br><span class="line">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</span><br><span class="line">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</span><br><span class="line">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</span><br><span class="line">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</span><br><span class="line">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</span><br></pre></td></tr></table></figure>
<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>
<h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">	static int count = 5;</span><br><span class="line">	dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">	dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">		NSLog(@&quot;-------：%d \n&quot;,count++);</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_resume(timer);</span><br><span class="line">	//log</span><br><span class="line">	(lldb) bt</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</span><br><span class="line">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</span><br><span class="line">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</span><br><span class="line">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</span><br><span class="line">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</span><br><span class="line">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</span><br><span class="line">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</span><br><span class="line">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</span><br><span class="line">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</span><br></pre></td></tr></table></figure>
<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</span><br><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</span><br></pre></td></tr></table></figure>
<p>那么这两个Mode都是在什么情况下运行的呢？</p>
<ol>
<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>
</ol>
<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="noopener">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>
<p>现在我们了解到：</p>
<ol>
<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>
<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>
<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>
</ol>
<h5 id="runloop切换Mode"><a href="#runloop切换Mode" class="headerlink" title="runloop切换Mode"></a>runloop切换Mode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">    	case kCFRunLoopEntry:&#123;</span><br><span class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    		NSLog(@&quot;即将进入 mode:%@&quot;,m);</span><br><span class="line">    		CFRelease(m);</span><br><span class="line">    		break;</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    	case kCFRunLoopExit:</span><br><span class="line">    	&#123;</span><br><span class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    		NSLog(@&quot;即将退出 mode:%@&quot;,m);</span><br><span class="line">    		CFRelease(m);</span><br><span class="line">    		break;</span><br><span class="line">    	&#125;</span><br><span class="line">    	default:</span><br><span class="line">    		break;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	CFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</span><br><span class="line">	CFRelease(obs);</span><br><span class="line">	</span><br><span class="line">	//当滑动tb的时候log</span><br><span class="line">	</span><br><span class="line">即将退出 mode:kCFRunLoopDefaultMode</span><br><span class="line">即将进入 mode:UITrackingRunLoopMode</span><br><span class="line">即将退出 mode:UITrackingRunLoopMode</span><br><span class="line">即将进入 mode:kCFRunLoopDefaultMode</span><br></pre></td></tr></table></figure>
<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>
<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//	//获取loop</span><br><span class="line">	CFRunLoopRef ref = CFRunLoopGetMain();</span><br><span class="line">	//获取obs</span><br><span class="line">	CFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</span><br><span class="line">	//添加监听</span><br><span class="line">	CFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</span><br><span class="line">	CFRelease(obs);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</span><br><span class="line">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line">	printf(&quot;- &quot;);</span><br><span class="line">	count ++;</span><br><span class="line">	printf(&quot;%d&quot;,count);</span><br><span class="line">	switch (activity) &#123;</span><br><span class="line">		case kCFRunLoopEntry:</span><br><span class="line">			printf(&quot;即将进入 \n&quot;);</span><br><span class="line">			count = 0;</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopExit:</span><br><span class="line">			printf(&quot;即将退出 \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopAfterWaiting:</span><br><span class="line">			printf(&quot;即将从休眠中唤醒 \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeTimers:</span><br><span class="line">			printf(&quot;即将进入处理 timers \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeSources:</span><br><span class="line">			printf(&quot;即将进入 sources \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeWaiting:</span><br><span class="line">			printf(&quot;即将进入 休眠 \n&quot;);</span><br><span class="line">			count = 0;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//点击的时候 会出发loop来处理触摸事件</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入处理 timers </span><br><span class="line">- 7即将进入 sources </span><br><span class="line">- 8即将进入处理 timers </span><br><span class="line">- 9即将进入 sources </span><br><span class="line">- 10即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入 休眠</span><br></pre></td></tr></table></figure>
<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>
<h5 id="RunLoop在不获取的时候不存在-获取才生成"><a href="#RunLoop在不获取的时候不存在-获取才生成" class="headerlink" title="RunLoop在不获取的时候不存在,获取才生成"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>
<p>首先看官方给的图：</p>
<p><img src="/images/9-2.png" alt><br>那我又整理了一个表格来更直观的了解状态运转</p>
<table>
<thead>
<tr>
<th style="text-align:center">步骤</th>
<th style="text-align:center">任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">通知Observers:进入Loop</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">通知Observers:即将处理Timers</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">通知Observers:即将处理Sources</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">处理blocks</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">处理Source0(可能再处理Blocks)</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">如果存在Source1，跳转第8步</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">通知Observers:开始休眠</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">处理Blocks</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">根据前面的执行结果，决定如何操作1.返回第2步，2退出loop</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">通知Observers:退出Loop</td>
</tr>
</tbody>
</table>
<p>查看<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">runloop源码</a>中<code>runloop.c</code>2333行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">//入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	rlm-&gt;_stopped = false;</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    if (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        if (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer = NULL;</span><br><span class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</span><br><span class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">        seconds = 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR = 0ULL;</span><br><span class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; // infinite timeout</span><br><span class="line">        seconds = 9999999999.0;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = NULL;</span><br><span class="line">#endif</span><br><span class="line">        uint8_t msg_buffer[3 * 1024];</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        mach_msg_header_t *msg = NULL;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">#endif</span><br><span class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">//通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">//通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">//处理Blocks</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">//处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">	//处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">	//y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">	//有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        didDispatchPortLastTime = false;</span><br><span class="line">//即将进入休眠</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	//开始休眠</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">    __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line"></span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            //等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">			</span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;</span><br><span class="line"></span><br><span class="line">                    rlm-&gt;_timerFired = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">        if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        // user callouts now OK again</span><br><span class="line">	__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">	//结束休眠</span><br><span class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">//标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">		</span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">			</span><br><span class="line">        &#125;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">	//被timer唤醒</span><br><span class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">	//被GCD换醒</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</span><br><span class="line">	//处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = true;</span><br><span class="line">            didDispatchPortLastTime = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">	//处理Source1</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">			</span><br><span class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">		mach_msg_header_t *reply = NULL;</span><br><span class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">		if (NULL != reply) &#123;</span><br><span class="line">		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	    &#125;</span><br><span class="line">            </span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理bBlock</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">//设置返回值</span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过及进一步精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	rlm-&gt;_stopped = false;</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">//通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">//通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">//处理Blocks</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">//处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">	//处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">	//y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">	//有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">//即将进入休眠</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	//开始休眠</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line">        do &#123;</span><br><span class="line">    //等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">	//结束休眠</span><br><span class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">//标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">	//被timer唤醒</span><br><span class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">	//被GCD换醒</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line">	//处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">	//处理Source1</span><br><span class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            // Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理bBlock</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    //设置返回值</span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="noopener">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>
<h5 id="timer保活和多mode运行"><a href="#timer保活和多mode运行" class="headerlink" title="timer保活和多mode运行"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int i = 0;</span><br><span class="line">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	NSLog(@&quot;%d&quot;,++i);</span><br><span class="line">&#125;];</span><br><span class="line">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</span><br><span class="line">//timer在设置为common模式下能运行</span><br><span class="line">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</span><br><span class="line">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">	</span><br><span class="line">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</span><br><span class="line">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</span><br><span class="line">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</span><br><span class="line">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</span><br><span class="line">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</span><br><span class="line">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</span><br><span class="line">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</span><br><span class="line">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</span><br></pre></td></tr></table></figure>
<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	CFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</span><br><span class="line">	dispatch_source_cancel(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>
<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>
<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>
<h5 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </span><br><span class="line">                            forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>
<p>验证线程保活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) FYThread *thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">	_thread.name = @&quot;test thread&quot;;</span><br><span class="line">	[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">//添加端口</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	[[NSRunLoop currentRunLoop] run];</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">//注释掉添加端口代码</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">--end--</span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//注释放开的时候点击触发log</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line"></span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</span><br></pre></td></tr></table></figure>
<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>
<p>那我们测试下该线程声明周期多长？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">	_thread.name = @&quot;test thread&quot;;</span><br><span class="line">	[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	//获取obs</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	/*</span><br><span class="line">	 If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</span><br><span class="line">	 */</span><br><span class="line">	[[NSRunLoop currentRunLoop] run];</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController stop]</span><br></pre></td></tr></table></figure>
<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>
<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL shouldKeepRunning = YES; // global</span><br><span class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br></pre></td></tr></table></figure>
<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	//获取obs</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	self.shouldKeepRunning = YES;//默认运行</span><br><span class="line">	NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">	while (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">	self.shouldKeepRunning = NO;</span><br><span class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)pop&#123;</span><br><span class="line">	[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">--end--</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure>
<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    if (self.thread == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)stopThread&#123;</span><br><span class="line">    self.shouldKeepRunning = NO;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self stop];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) __weakSelf = self;</span><br><span class="line">self.thread = [[FYThread alloc]initWithBlock:^&#123;</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;--start--&quot;);</span><br><span class="line">    __weakSelf.shouldKeepRunning = YES;//默认运行</span><br><span class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>测试下崩溃了，崩溃到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (__weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//log</span><br><span class="line"></span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">--end--</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure>
<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">runloop源码</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="noopener">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="noopener">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">thread保活c语言版本</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85" target="_blank" rel="noopener">thread 保活</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理 runtime - super、hook、以及简单应用--(8)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:18:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:18:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h3><p>关键字<code>super</code>,在调用<code>[super init]</code>的时候，<code>super</code>会转化成结构体<code>__rw_objc_super</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __rw_objc_super &#123; </span><br><span class="line">	struct objc_object *object; //消息接受者</span><br><span class="line">	struct objc_object *superClass; //父类</span><br><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>[super init]</code>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m</code>转化成<code>cpp</code><br>打开<code>cpp</code>大概在底部的位置找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</span><br></pre></td></tr></table></figure>
<p>简化之后是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void *)objc_msgSendSuper((__rw_objc_super)&#123;self, class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</span><br></pre></td></tr></table></figure>
<p><code>void
objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )</code><br>    其实是向父类发送消息，参数是<code>struct objc_super *super, SEL op, ...</code>，我们源码中找到了该函数的实现在<code>objc-msg-arm64.s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line">UNWIND _objc_msgSendSuper, NoFrame</span><br><span class="line">//根据结构体struct __rw_objc_super </span><br><span class="line">&#123; </span><br><span class="line">	//struct objc_object *object; //消息接受者</span><br><span class="line">	//struct objc_object *superClass; //父类</span><br><span class="line">&#125;占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，</span><br><span class="line">//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</span><br><span class="line">ldp	p0, p16, [x0]		// p0 = self , p16 = superclass</span><br><span class="line"></span><br><span class="line">CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure>
<p>将<code>self</code>和<code>superclass</code>赋值给 <code>p0, p16</code>调用<code>CacheLookup NORMAL</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</span><br><span class="line">	// p1 = SEL, p16 = isa</span><br><span class="line">	ldp	p10, p11, [x16, #CACHE]	// p10 = buckets, p11 = occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">	and	w11, w11, 0xffff	// p11 = mask</span><br><span class="line">#endif</span><br><span class="line">	and	w12, w1, w11		// x12 = _cmd &amp; mask</span><br><span class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</span><br><span class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</span><br><span class="line">	b.ne	2f			//     scan more</span><br><span class="line">	CacheHit $0			// call or return imp 命中 调用或者返回imp</span><br><span class="line">	</span><br><span class="line">2:	// not hit: p12 = not-hit bucket 没有命中</span><br><span class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</span><br><span class="line">	cmp	p12, p10		// wrap if bucket == buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">	b	1b			// loop</span><br><span class="line"></span><br><span class="line">3:	// wrap: p12 = first bucket, w11 = mask</span><br><span class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">		                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">	// The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</span><br><span class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</span><br><span class="line">	b.ne	2f			//     scan more</span><br><span class="line">	CacheHit $0			// call or return imp</span><br><span class="line">	</span><br><span class="line">2:	// not hit: p12 = not-hit bucket</span><br><span class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</span><br><span class="line">	cmp	p12, p10		// wrap if bucket == buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">	b	1b			// loop</span><br><span class="line"></span><br><span class="line">3:	// double wrap</span><br><span class="line">	JumpMiss $0</span><br><span class="line">	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>汇编比较多，只看到第二行<code>p1 = SEL, p16 = isa</code>，查找缓存是从<code>p16</code>,也就是<code>superclass</code>开始查找，后边的都和<code>objc_msgSend</code>一样。<br>大致上比较清楚了，<code>super</code>本质上调用了<code>objc_msgSendSuper</code>，<code>objc_msgSendSuper</code>是查找从父类开始查找方法。</p>
<p><code>[super init]</code>就是<code>self</code>直接调用父类<code>init</code>的方法，但是<code>objc_msgSend</code>接受者是<code>self</code>，假如是<code>[self init]</code>则会产生死循环。<code>[super test]</code>则是执行父类的<code>test</code>。<br>使用<code>Debug Workflow-&gt;Always Show Disassemdly</code>发现<code>super</code>其实调用了汇编的<code>objc_msgSendSuper2</code>，进入<code>objc_msgSendSuper2 objc-msg-arm64.s 422 行</code>发现和<code>objc_msgSendSuper</code>其实基本一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//_objc_msgSendSuper 开始</span><br><span class="line">	ENTRY _objc_msgSendSuper</span><br><span class="line">	UNWIND _objc_msgSendSuper, NoFrame</span><br><span class="line">//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</span><br><span class="line">	ldp	p0, p16, [x0]		// p0 = self , p16 = superclass</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br><span class="line">	END_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束</span><br><span class="line">	</span><br><span class="line">//objc_msgLookupSuper2 开始</span><br><span class="line">	ENTRY _objc_msgSendSuper2 </span><br><span class="line">	UNWIND _objc_msgSendSuper2, NoFrame</span><br><span class="line"></span><br><span class="line">	ldp	p0, p16, [x0]		// p0 = real receiver, p16 = class</span><br><span class="line">	//将存储器地址为x16+8的字数据读入寄存器p16。</span><br><span class="line">	ldr	p16, [x16, #SUPERCLASS]	// p16 = class-&gt;superclass</span><br><span class="line">	CacheLookup NORMAL</span><br><span class="line">	END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>LLVM</code>转化成中间代码来查看，<code>clang -emit-llvm -S FYCat.m</code>查看关键函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define internal void @&quot;\01-[FYCat forwardInvocation:]&quot;(%1*, i8*, %2*) #1 &#123;</span><br><span class="line">    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>forwardInvocation</code>函数的调用代码，简化之后是<code>objc_msgSendSuper2(self,struct._objc_super i8*,%2*)</code>，就是<code>objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)</code>。</p>
<p>验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (int)age;</span><br><span class="line">-(void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    ;    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (int)age&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">    return [_name stringByAppendingString:@&quot; eat apple&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface FYStudent : FYPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FYStudent</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    [super test]; //执行父类的test</span><br><span class="line">    int age = [super age]; //获取父类的方法 返回值</span><br><span class="line">    NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值</span><br><span class="line">    NSLog(@&quot;%@&quot;,name);</span><br><span class="line">&#125;</span><br><span class="line">-(int)age&#123;</span><br><span class="line">    return 12;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//输出</span><br><span class="line">-[FYPerson test]</span><br><span class="line">-[FYPerson age]</span><br><span class="line">age is 10</span><br><span class="line">小李子 eat apple</span><br></pre></td></tr></table></figure>
<p><code>test</code>是执行父类的方法，<code>[super age]</code>获取父类中固定的<code>age</code>,<br><code>[self name]</code>从父类开始寻找<code>name</code>的值，但返回的是<code>self.name</code>的值。</p>
<h3 id="isMemberOfClass-amp-isKindOfClass"><a href="#isMemberOfClass-amp-isKindOfClass" class="headerlink" title="isMemberOfClass &amp;  isKindOfClass"></a>isMemberOfClass &amp;  isKindOfClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return object_getClass((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        printf(&quot;%s %s\n&quot;,class_getName(tcls),class_getName(cls));</span><br><span class="line">        if (tcls == cls)</span><br><span class="line">        &#123;return YES;&#125;else&#123;</span><br><span class="line">            printf(&quot;%s&quot;,class_getName(tcls));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot; %s %s\n&quot;,class_getName(tcls),class_getName(cls));</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isSubclassOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>- (BOOL)isMemberOfClass</code>和<code>- (BOOL)isKindOfClass:(Class)cls</code>比较简单，都是判断<code>self.class</code> 和<code>cls</code>，<code>+ (BOOL)isMemberOfClass:(Class)cls</code>是判断<code>self.class-&gt;isa</code>是否和<code>cls</code>相等，<code>+ (BOOL)isKindOfClass:(Class)cls</code>判断<code>cls-&gt;isa</code>和<code>cls-&gt;isa-&gt;isa</code>有没有可能和<code>cls</code>相等？只有基类是，其他的都不是。</p>
<h4 id="验证-实例方法"><a href="#验证-实例方法" class="headerlink" title="验证 实例方法"></a>验证 实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class cls = NSObject.class;</span><br><span class="line">Class pcls = FYPerson.class;</span><br><span class="line">FYPerson *p=[FYPerson new];</span><br><span class="line">NSObject *obj=[NSObject new];</span><br><span class="line">BOOL res11 =[p isKindOfClass:pcls];</span><br><span class="line">BOOL res12 =[p isMemberOfClass:pcls];</span><br><span class="line">BOOL res13 =[obj isKindOfClass:cls];</span><br><span class="line">BOOL res14 =[obj isMemberOfClass:cls];</span><br><span class="line">NSLog(@&quot;instance:%d %d %d %d&quot;,res11,res12,res13,res14);</span><br><span class="line">//log</span><br><span class="line">//instance:1 1 1 1</span><br></pre></td></tr></table></figure>
<p><code>p</code>是<code>pcls</code>的子类，<code>obj</code> 是<code>cls</code>的子类，在明显不过了。</p>
<h4 id="验证-类方法"><a href="#验证-类方法" class="headerlink" title="验证 类方法"></a>验证 类方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//isKindOfClass cls-&gt;isa 和cls/cls-&gt;superclass相等吗?</span><br><span class="line">//元类对象和类对象不相等，但是最后一个元类的isa-&gt;superclass是指向NSObject的class 所以res1 = YES;</span><br><span class="line">//cls-&gt;isa:元类对象 cls-&gt;isa-&gt;superclass: NSObject类对象</span><br><span class="line">//cls:类对象</span><br><span class="line">BOOL res1 =[cls isKindOfClass:cls];</span><br><span class="line">//cls-&gt;isa 和cls相等吗？ 不相等 cls-&gt;isa是元类对象,cls是类对象，不可能相等。</span><br><span class="line">BOOL res2 =[cls isMemberOfClass:cls];</span><br><span class="line">//pcls-&gt;isa:person的元类对象 cls-&gt;isa-&gt;superclass: NSObject元类类对象 -&gt;superclass:NSObject类对象 -&gt;superclass:nil</span><br><span class="line">//pcls:person类对象</span><br><span class="line">BOOL res3 =[pcls isKindOfClass:pcls];</span><br><span class="line">//pcls-&gt;isa:person的元类对象</span><br><span class="line">//pcls:person类对象</span><br><span class="line">BOOL res4 =[pcls isMemberOfClass:pcls];</span><br><span class="line">NSLog(@&quot;%d %d %d %d&quot;,res1,res2,res3,res4);</span><br><span class="line">结果：</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure>
<h3 id="堆栈-对象本质-class本质实战"><a href="#堆栈-对象本质-class本质实战" class="headerlink" title="堆栈 对象本质 class本质实战"></a>堆栈 对象本质 class本质实战</h3><p>网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。<br>其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文<a href="https://juejin.im/post/5d2d200be51d4510a7328161" target="_blank" rel="noopener">obj_msgsend基础</a>、<a href="https://juejin.im/post/5d19c59e6fb9a07f04205f95" target="_blank" rel="noopener">类的本质</a>、<a href="https://juejin.im/post/5d15887ee51d45108126d28d" target="_blank" rel="noopener">对象的本质</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)print&#123;</span><br><span class="line">    NSLog(@&quot;my name is %@&quot;,self.name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030</span><br><span class="line">    id cls  = [FYPerson class];针</span><br><span class="line">    void * obj = &amp;cls; </span><br><span class="line">    [(__bridge id)obj print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题一-能否编译成功？"><a href="#问题一-能否编译成功？" class="headerlink" title="问题一 能否编译成功？"></a>问题一 能否编译成功？</h4><p>当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有<code>id self</code>和<code>SEL sel</code>，现在<code>cls</code>和<code>obj</code>都在栈区，<code>obj</code> 指针指向<code>cls</code>的内存地址，访问<code>obj</code>相当于直接访问<code>cls</code>内存存储的值，<code>cls</code>存储的是<code>Person.class</code>,<code>[obj print]</code> 相当于<code>objc_msgSend(cls,@selector(print))</code>,<code>cls</code>是有<code>print</code>方法的，所以会编译成功。</p>
<h4 id="输出什么？"><a href="#输出什么？" class="headerlink" title="输出什么？"></a>输出什么？</h4><p><code>fix/cls/obj</code>这三个对象都是存储在栈上，<code>fix/cls/obj</code>地址是连续从高到低的，而且他们地址相差都是<code>8</code>字节，一个指针大小是<code>8</code>字节。他们三个地址如下所示：</p>
<p>使用图来表示<code>fix</code>和<code>obj</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">地址</th>
<th style="text-align:center">地址高低</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fix</td>
<td style="text-align:center">0x7ffeec3df920</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">cls</td>
<td style="text-align:center">0x7ffeec3df918</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:center">obj</td>
<td style="text-align:center">0x7ffeec3df910</td>
<td style="text-align:center">低</td>
</tr>
</tbody>
</table>
<p>寻找属性先是寻找<code>isa</code>，然后再在<code>isa</code>地址上+<code>8</code>则是属性的值，所以根据<code>obj</code>寻找<code>cls</code>地址是<code>0x7ffeec3df918</code>,然后<code>cls</code>地址+8字节则是<code>_name</code>的地址，<code>cls</code>地址是<code>0x7ffeec3df918</code>，加上<code>8</code>字节正好是<code>fix</code>的地址<code>0x7ffeec3df920</code>，因为都是指针，所以都是<code>8</code>字节,所以最后输出是结果是<code>fix</code>对象的地址的数据。</p>
<p>情况再复杂一点，<code>FYPerson</code>结构改动一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,copy) NSString *name2;</span><br><span class="line">@property (nonatomic,copy) NSString *name3;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>则他们的<code>_name</code>、<code>_name2</code>、<code>_name3</code>则在<code>cls</code>的地址基础上再向上寻找<code>8*1=8/8*2=16/8*3=24</code>字节，就是向上寻找第1个，第2个，第3个指向对象的指针。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@property (nonatomic,copy) NSString *name2;</span><br><span class="line">@property (nonatomic,copy) NSString *name3;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line">@implementation FYPerson</span><br><span class="line">- (void)print&#123;</span><br><span class="line">    NSLog(@&quot;name1:%@ name2:%@ name3:%@&quot;,self.name1,self.name2,self.name3);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line"></span><br><span class="line">NSObject *fix =[NSObject new];</span><br><span class="line">FYPerson *fix2 =[FYPerson new];</span><br><span class="line"></span><br><span class="line">id cls  = [FYPerson class];</span><br><span class="line">void * obj = &amp;cls; </span><br><span class="line">[(__bridge id)obj print];//objc_msgSend(self,sel);</span><br><span class="line">NSLog(@&quot;fix:%p fix2:%p cls:%p obj:%p&quot;,&amp;fix,&amp;fix2,&amp;cls,&amp;obj);</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">name1:&lt;FYPerson: 0x6000033a38a0&gt; </span><br><span class="line">name2:&lt;NSObject: 0x6000031f5380&gt; </span><br><span class="line">name3:&lt;ViewController: 0x7f8307505580&gt;</span><br><span class="line"></span><br><span class="line">fix: 0x7ffeec3d f9 28 </span><br><span class="line">fix2:0x7ffeec3d f9 20 </span><br><span class="line">cls: 0x7ffeec3d f9 18 </span><br><span class="line">obj: 0x7ffeec3d f9 10</span><br></pre></td></tr></table></figure>
<p>再变形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">	/*</span><br><span class="line">	 objc_msgSuperSend(self,ViewController,sel)</span><br><span class="line">	 */</span><br><span class="line">NSLog(@&quot;self:%p ViewController.class:%p SEL:%p&quot;,self,ViewController.class,@selector(viewDidLoad));</span><br><span class="line">    id cls  = [FYPerson class];//cls 是类指针</span><br><span class="line">    void * obj = &amp;cls; //obj </span><br><span class="line">    [(__bridge id)obj print];//objc_msgSend(self,sel);</span><br><span class="line">    </span><br><span class="line"> NSLog(@&quot;cls:%p obj:%p&quot;,&amp;cls,&amp;obj);</span><br><span class="line"> //log</span><br><span class="line"> </span><br><span class="line"> name1:&lt;ViewController: 0x7fad03e04ea0&gt; </span><br><span class="line"> name2:ViewController</span><br><span class="line"> </span><br><span class="line"> self:                  0x7fad03e04ea0 </span><br><span class="line"> ViewController.class:  0x10d0edf00 </span><br><span class="line"> SEL:                   0x1117d5687</span><br><span class="line"> </span><br><span class="line"> cls:0x7ffee2b11908 </span><br><span class="line"> obj:0x7ffee2b11900</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_name1</code>是<code>cls</code>地址向上+8字节，<code>_name2</code>是向上移动16字节，<code>[super viewDidLoad]</code>本质上是<code>objc_msgSuperSend(self,ViewController.class,sel)</code>，<code>self</code>、<code>ViewController.class</code>、<code>SEL</code>是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，<br>结构体如下图所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">地址高低</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">self</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">ViewController.class</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:center">SEL</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
<h3 id="常用的runtimeAPI"><a href="#常用的runtimeAPI" class="headerlink" title="常用的runtimeAPI"></a>常用的runtimeAPI</h3><table>
<thead>
<tr>
<th style="text-align:center">method</th>
<th style="text-align:center">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</td>
<td style="text-align:center">动态创建一个类（参数：父类，类名，额外的内存空间</td>
</tr>
<tr>
<td style="text-align:center">void objc_registerClassPair(Class cls))</td>
<td style="text-align:center">注册一个类</td>
</tr>
<tr>
<td style="text-align:center">void objc_disposeClassPair(Class cls)</td>
<td style="text-align:center">销毁一个类</td>
</tr>
<tr>
<td style="text-align:center">Class objcect_getClass(id obj)</td>
<td style="text-align:center">获取isa指向的class</td>
</tr>
<tr>
<td style="text-align:center">Class object_setClass (id obj,Class cls)</td>
<td style="text-align:center">设置isa指向的class</td>
</tr>
<tr>
<td style="text-align:center">BOOL object_isClass(id class)</td>
<td style="text-align:center">判断oc对象是否为Class</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_isMetaClass(Class cls)</td>
<td style="text-align:center">是否是元类</td>
</tr>
<tr>
<td style="text-align:center">Class class_getSuperclass(Class cls)</td>
<td style="text-align:center">获取父类</td>
</tr>
<tr>
<td style="text-align:center">Ivar class_getInstanceVariable(Class cls ,const char * name</td>
<td style="text-align:center">获取一个实例变量信息</td>
</tr>
<tr>
<td style="text-align:center">Ivar <em> class_copyIvarList(Class cls,unsigned int </em> outCount)</td>
<td style="text-align:center">拷贝实例变量列表，需要free</td>
</tr>
<tr>
<td style="text-align:center">void object_setIvar(id obj,Ivar ivar,id value</td>
<td style="text-align:center">设置获取实例变量的值</td>
</tr>
<tr>
<td style="text-align:center">id object_getIvar(id obj,Ivar ivar)</td>
<td style="text-align:center">获取实例变量的值</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_addIvar(Class cls,const cahr <em> name ,size_t size,uint_t alignment,const char </em> types)</td>
<td style="text-align:center">动态添加成员变量（已注册的类不能动态添加成员变量）</td>
</tr>
<tr>
<td style="text-align:center">const char * ivar_getName（Ivar v)</td>
<td style="text-align:center">获取变量名字</td>
</tr>
<tr>
<td style="text-align:center">const char * ivar_getTypeEncoding(Ivar v)</td>
<td style="text-align:center">变量的encode</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t class_getProperty(Class cls,const char* name)</td>
<td style="text-align:center">获取一个属性</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t _Nonnull <em> _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)</td>
<td style="text-align:center">拷贝属性列表</td>
</tr>
<tr>
<td style="text-align:center">objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)</td>
<td style="text-align:center">获取属性列表</td>
</tr>
<tr>
<td style="text-align:center">BOOL class_addProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes,unsigned int attributeCount)</td>
<td style="text-align:center">添加属性</td>
</tr>
<tr>
<td style="text-align:center">void class_replaceProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes, unsigned int attributeCount)</td>
<td style="text-align:center">替换属性</td>
</tr>
<tr>
<td style="text-align:center">void class_replaceProperty(Class cls, const char <em>name, const objc_property_attribute_t </em>attributes,unsigned int attributeCount)</td>
<td style="text-align:center">动态替换属性</td>
</tr>
<tr>
<td style="text-align:center">const char * _Nonnull property_getName(objc_property_t _Nonnull property)</td>
<td style="text-align:center">获取name</td>
</tr>
<tr>
<td style="text-align:center">const char * _Nullable property_getAttributes(objc_property_t _Nonnull property)</td>
<td style="text-align:center">获取属性的属性</td>
</tr>
<tr>
<td style="text-align:center">IMP imp_implementationWithBlock(id block)</td>
<td style="text-align:center">获取block的IMP</td>
</tr>
<tr>
<td style="text-align:center">id imp_getBlock(IMP anIMP)</td>
<td style="text-align:center">通过imp 获取block</td>
</tr>
<tr>
<td style="text-align:center">BOOL imp_removeBlock(IMP anIMP)</td>
<td style="text-align:center">IMP是否被删除</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们<br>获取<code>class</code>的所有成员变量,可以获取<code>Ivar</code>查看是否有该变量，然后可以通过<code>KVC</code>来赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface FYCat : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@property (nonatomic,assign) int  age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FYCat *cat=[FYCat new];</span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *vars= class_copyIvarList(cat.class, &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">	Ivar item = vars[i];</span><br><span class="line">	const char *name = ivar_getName(item);</span><br><span class="line">	NSLog(@&quot;%s&quot;,name);</span><br><span class="line">&#125;</span><br><span class="line">free(vars);</span><br><span class="line"></span><br><span class="line">Method *m1= class_copyMethodList(cat.class, &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">	Method item = m1[i];</span><br><span class="line">	SEL name = method_getName(item);</span><br><span class="line">	printf(&quot;method:%s \n&quot;,NSStringFromSelector(name).UTF8String);</span><br><span class="line">&#125;</span><br><span class="line">free(m1);</span><br><span class="line">		</span><br><span class="line">//log</span><br><span class="line">_age</span><br><span class="line">_name</span><br><span class="line"></span><br><span class="line">method:.cxx_destruct </span><br><span class="line">method:name </span><br><span class="line">method:setName: </span><br><span class="line">method:methodSignatureForSelector: </span><br><span class="line">method:forwardInvocation: </span><br><span class="line">method:age </span><br><span class="line">method:setAge:</span><br></pre></td></tr></table></figure>
<p>大家常用的一个功能是<code>JsonToModel</code>，那么我们已经了解到了<code>runtime</code>的基础知识，现在可以自己撸一个<code>JsonToModel</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Json)</span><br><span class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json;</span><br><span class="line">@end</span><br><span class="line">@implementation NSObject (Json)</span><br><span class="line">+ (instancetype)fy_objectWithJson:(NSDictionary *)json&#123;</span><br><span class="line">	id obj = [[self alloc]init];</span><br><span class="line">	unsigned int count = 0;</span><br><span class="line">	Ivar *vars= class_copyIvarList(self, &amp;count);</span><br><span class="line">	for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">		Ivar item = vars[i];</span><br><span class="line">		const char *name = ivar_getName(item);</span><br><span class="line">		NSString * nameOC= [NSString stringWithUTF8String:name];</span><br><span class="line">		if (nameOC.length&gt;1) &#123;</span><br><span class="line">			nameOC = [nameOC substringFromIndex:1];</span><br><span class="line">			NSString * value = json[nameOC];</span><br><span class="line">			if ([value isKindOfClass:NSString.class] &amp;&amp; value.length) &#123;</span><br><span class="line">				[obj setValue:value forKey:nameOC];</span><br><span class="line">			&#125;else if ([value isKindOfClass:NSArray.class])&#123;</span><br><span class="line">				[obj setValue:value forKey:nameOC];</span><br><span class="line">			&#125;else if ([value isKindOfClass:NSDictionary.class])&#123;</span><br><span class="line">				[obj setValue:value forKey:nameOC];</span><br><span class="line">			&#125;else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;%s value is nil or null \n&quot;,name);</span><br><span class="line">			&#125;else if ([value integerValue] &gt; 0)&#123;</span><br><span class="line">				[obj setValue:value forKey:nameOC];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				printf(&quot;未知错误 \n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(vars);</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后自己定义一个字典，来测试一下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface FYCat : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString * name;</span><br><span class="line">@property (nonatomic,assign) int  age;</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSDictionary * info = @&#123;@&quot;age&quot;:@&quot;10&quot;,@&quot;value&quot;:@10,@&quot;name&quot;:@&quot;小明&quot;&#125;;</span><br><span class="line">		FYCat *cat=[FYCat fy_objectWithJson:info];</span><br><span class="line">//log</span><br><span class="line">age:10 name:小明</span><br></pre></td></tr></table></figure>
<h4 id="hook钩子-method-exchangeImplementations"><a href="#hook钩子-method-exchangeImplementations" class="headerlink" title="hook钩子(method_exchangeImplementations)"></a>hook钩子(method_exchangeImplementations)</h4><p>由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIButton (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">	Method m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));</span><br><span class="line">	Method m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));</span><br><span class="line">	static dispatch_once_t onceToken;</span><br><span class="line">	dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">		method_exchangeImplementations(m1, m2);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%@ &quot;,NSStringFromSelector(action));</span><br><span class="line">	/*</span><br><span class="line">	 code here</span><br><span class="line">	 */</span><br><span class="line">	 //sel IMP 已经交换过了，所以不会死循环</span><br><span class="line">	[self fy_sendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>可以在<code>code here</code>添加需要处理的代码，一般记录日志和延迟触发都可以处理。<code>[self fy_sendAction:action to:target forEvent:event];</code>不会产生死循环，原因是在<code>+load</code>中已经将<code>m1</code>和<code>m2</code>已经交换过了<code>IMP</code>。我们进入到<code>method_exchangeImplementations</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line">&#123;</span><br><span class="line">    if (!m1  ||  !m2) return;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">//交换IMP</span><br><span class="line">    IMP m1_imp = m1-&gt;imp;</span><br><span class="line">    m1-&gt;imp = m2-&gt;imp;</span><br><span class="line">    m2-&gt;imp = m1_imp;</span><br><span class="line"></span><br><span class="line">//刷新缓存</span><br><span class="line">    flushCaches(nil);</span><br><span class="line"></span><br><span class="line">    updateCustomRR_AWZ(nil, m1);</span><br><span class="line">    updateCustomRR_AWZ(nil, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;;</span><br><span class="line">using MethodListIMP = IMP;</span><br></pre></td></tr></table></figure>
<p><code>m1</code>和<code>m2</code>交换了<code>IMP</code>，交换的是<code>method_t-&gt;imp</code>，然后刷新缓存(清空缓存)，等下次调用<code>IMP</code>则需要在<code>cls-&gt;rw-&gt;data-&gt;method</code>中去寻找。</p>
<h4 id="数组越界和nil处理"><a href="#数组越界和nil处理" class="headerlink" title="数组越界和nil处理"></a>数组越界和nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSMutableArray (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">	Class cls= NSClassFromString(@&quot;__NSArrayM&quot;);</span><br><span class="line">	Method m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</span><br><span class="line">	SEL sel = @selector(fy_insertObject:atIndex:);</span><br><span class="line">	Method m2= class_getInstanceMethod(cls, sel);</span><br><span class="line">	</span><br><span class="line">	Method m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));</span><br><span class="line">	Method m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));</span><br><span class="line"></span><br><span class="line">	static dispatch_once_t onceToken;</span><br><span class="line">	dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">		method_exchangeImplementations(m1, m2);</span><br><span class="line">		method_exchangeImplementations(m3, m4);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index&#123;</span><br><span class="line">	if (anObject != nil) &#123;</span><br><span class="line">		[self fy_insertObject:anObject atIndex:index];</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		printf(&quot; anObject is nil \n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx&#123;</span><br><span class="line">	if (self.count &gt; idx) &#123;</span><br><span class="line">		return [self fy_objectAtIndexedSubscript:idx];</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		printf(&quot; %ld is outof rang \n&quot;,(long)idx);</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSMutableArray *array=[NSMutableArray array];</span><br><span class="line">id obj = nil;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">array[1];</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"> anObject is nil </span><br><span class="line"> 1 is outof rang</span><br></pre></td></tr></table></figure>
<p><code>NSMutableArray</code>是类簇，使用工厂模式，<code>NSMutableArray</code>不是数组实例，而是生产数组对象的工厂。<br>真实的数组对象是<code>__NSArrayM</code>,然后给<code>__NSArrayM</code>钩子，交换<code>objectAtIndexedSubscript:(NSUInteger)idx</code>和<code>insertObject:(id)anObject atIndex:(NSUInteger)index</code>方法，实现崩溃避免。</p>
<h4 id="字典nil处理"><a href="#字典nil处理" class="headerlink" title="字典nil处理"></a>字典nil处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface NSMutableDictionary (add)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSMutableDictionary (add)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    Class cls= NSClassFromString(@&quot;__NSDictionaryM&quot;);</span><br><span class="line">    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));</span><br><span class="line">//    __NSDictionaryM</span><br><span class="line">    SEL sel = @selector(fy_setObject:forKey:);</span><br><span class="line">    Method m2= class_getInstanceMethod(cls, sel);</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        method_exchangeImplementations(m1, m2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)fy_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey&#123;</span><br><span class="line">    if (anObject) &#123;</span><br><span class="line">        [self fy_setObject:anObject forKey:aKey];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSString * key = (NSString *)aKey;</span><br><span class="line">        printf(&quot;key:%s anobj is nil \n&quot;,key.UTF8String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>利用类别<code>+load</code>给<code>__NSDictionaryM</code>添加方法，然后交换<code>IMP</code>，实现给<code>NSMutableDictionary setObject:Key:</code>的时候进行<code>nil</code>校验,<code>+load</code>虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成<code>IMP</code>和<code>SEL</code>混乱，使用<code>dispatch_once</code>进行单次运行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><code>super</code>本质上是<code>self</code>调用函数，不过查找函数是从<code>sueprclass</code>开始查找的</li>
<li><code>+isKandOfClass</code>是判断<code>self</code>是否是<code>cls</code>的子类，<code>+isMemberOfClass:</code>是判断<code>self</code>是否和<code>cls</code>相同。</li>
<li>了解<code>+load</code>在<code>Category</code>是启动的时候使用运行时编译的，而且只会加载一次,然后利用<code>objc/runtime.h</code>中<code>method_exchangeImplementations</code>实现交换两个函数的<code>IMP</code>，可以实现拦截<code>nil</code>，降低崩溃率。</li>
<li><code>NSMutableDictionary</code>、<code>NSMutableArray</code>是类簇，先找到他们的类然后再交换该类的函数的<code>IMP</code>。</li>
</ol>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="noopener">小码哥视频</a></li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/" class="post-title-link" itemprop="http://fgyong.cn/index.html">iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:17:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:17:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ol>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">objc-msg-arm64.s</span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">b.le	LNilOrTagged //&lt;0则返回</span><br><span class="line">CacheLookup NORMAL //缓存查找 未命中则继续查找</span><br><span class="line">.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp</span><br><span class="line">.macro CheckMiss //miss 则跳转__objc_msgSend_uncached</span><br><span class="line">STATIC_ENTRY __objc_msgSend_uncached </span><br><span class="line">.macro MethodTableLookup//方法中查找</span><br><span class="line">__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-runtime-new.mm</span><br><span class="line">_class_lookupMethodAndLoadCache3</span><br><span class="line">lookUpImpOrForward</span><br><span class="line">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</span><br><span class="line">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</span><br><span class="line">_class_resolveInstanceMethod</span><br><span class="line">_objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-msg-arm64.s</span><br><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line">__forwarding__（不开源）</span><br></pre></td></tr></table></figure>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend // _objc_msgSend 开始</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		// if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</span><br><span class="line">#else</span><br><span class="line">	b.eq	LReturnZero // if le == 0 -&gt;  跳转到标签  LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		// p13 = isa</span><br><span class="line">	GetClassFromIsa_p16 p13		// p16 = class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">LNilOrTagged:</span><br><span class="line">	b.eq	LReturnZero		// 如果==0 -&gt; LReturnZero</span><br><span class="line"></span><br><span class="line">	// tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #60, #4</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	adrp	x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</span><br><span class="line">	add	x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</span><br><span class="line">	cmp	x10, x16</span><br><span class="line">	b.ne	LGetIsaDone</span><br><span class="line"></span><br><span class="line">	// ext tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #52, #8</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">// SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">	// x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	ret //return 返回结束掉</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend // _objc_msgSend 结束</span><br></pre></td></tr></table></figure>
<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</span><br><span class="line">	// p1 = SEL, p16 = isa</span><br><span class="line">	ldp	p10, p11, [x16, #CACHE]	// p10 = buckets, p11 = occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">	and	w11, w11, 0xffff	// p11 = mask</span><br><span class="line">#endif</span><br><span class="line">	and	w12, w1, w11		// x12 = _cmd &amp; mask</span><br><span class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">		             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</span><br><span class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</span><br><span class="line">	b.ne	2f			//     scan more</span><br><span class="line">	CacheHit $0			// call or return imp 命中 调用或者返回imp</span><br><span class="line">	</span><br><span class="line">2:	// not hit: p12 = not-hit bucket 没有命中</span><br><span class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</span><br><span class="line">	cmp	p12, p10		// wrap if bucket == buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">	b	1b			// loop</span><br><span class="line"></span><br><span class="line">3:	// wrap: p12 = first bucket, w11 = mask</span><br><span class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">		                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">	// Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">	// The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		// &#123;imp, sel&#125; = *bucket</span><br><span class="line">1:	cmp	p9, p1			// if (bucket-&gt;sel != _cmd)</span><br><span class="line">	b.ne	2f			//     scan more</span><br><span class="line">	CacheHit $0			// call or return imp</span><br><span class="line">	</span><br><span class="line">2:	// not hit: p12 = not-hit bucket</span><br><span class="line">	CheckMiss $0			// miss if bucket-&gt;sel == 0</span><br><span class="line">	cmp	p12, p10		// wrap if bucket == buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">	b	1b			// loop</span><br><span class="line"></span><br><span class="line">3:	// double wrap</span><br><span class="line">	JumpMiss $0</span><br><span class="line">	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">	// miss if bucket-&gt;sel == 0</span><br><span class="line">.if $0 == GETIMP</span><br><span class="line">	cbz	p9, LGetImpMiss</span><br><span class="line">.elseif $0 == NORMAL</span><br><span class="line">	cbz	p9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 == LOOKUP</span><br><span class="line">	cbz	p9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	// push frame</span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	// save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	// receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line">	// IMP in x0</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	// restore registers and return</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line">	AuthenticateLR</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* initialize==NO 尽量避免调用，有时可能也会调用。</span><br><span class="line">* cache==NO 跳过缓存查找，其他地方可能会不调过</span><br><span class="line">* 大多数人会传值 initialize==YES and cache==YES</span><br><span class="line">*   如果cls是非初始化的元类，则非Non-nil会快点</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</span><br><span class="line">**********************************************************************/</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    // Optimistic cache lookup</span><br><span class="line">    if (cache) &#123; //从汇编过来是NO</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">		//当cls需要初始化和没有初始化的时候 进行cls初始化，</span><br><span class="line">		//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</span><br><span class="line">		//数据的大小最小是4，扩容规则是：n*2+1;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">//再次获取imp</span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line"></span><br><span class="line">    //尝试在本类中查找method</span><br><span class="line">    &#123;//从cls-&gt;data()-&gt;methods查找method</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;//找到添加到cache中</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try superclass caches and method lists.</span><br><span class="line">	//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        for (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            // Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts == 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass cache.</span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    // Found the method in a superclass. Cache it in this class.</span><br><span class="line">					//将父类添加到 子类的缓存中</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // Found a forward:: entry in a superclass.</span><br><span class="line">                    // Stop searching, but don&apos;t cache yet; call method </span><br><span class="line">                    // resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass method list.</span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//如果还没有找到imp，进入动态方法解析阶段</span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="line">//	进行消息转发 阶段</span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">	//填充 cache</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </span><br><span class="line">// field as an index into a class table.</span><br><span class="line">// Note, keep this in sync with any .s files which also define it.</span><br><span class="line">// Be sure to edit objc-abi.h as well.</span><br><span class="line">// __ARM_ARCH_7K__ 处理器架构指令集版本</span><br><span class="line">//__arm64__ 架构</span><br><span class="line">//__LP64__ uinx 和uinx  mac os</span><br><span class="line">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 1</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>
<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>
<p>借用网上找一个图， 可以更直观的看出流程运转。</p>
<p><img src="/images/7-1.png" alt></p>
<h4 id="realizeClass-解析"><a href="#realizeClass-解析" class="headerlink" title="realizeClass()解析"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* realizeClass</span><br><span class="line"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</span><br><span class="line"> runtimelock 必须有调用者把写入锁锁起来</span><br><span class="line">**********************************************************************/</span><br><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    // fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">//首先将tw赋值给to，因为数据结构一样可以直接强制转化</span><br><span class="line">    ro = (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 正常情况下 申请class_rw_t空间</span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro = ro;//cls-&gt;rw-&gt;ro 指向现在的ro</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1</span><br><span class="line">        cls-&gt;setData(rw);//赋值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta = ro-&gt;flags &amp; RO_META;//是否是元类</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    rw-&gt;version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Choose an index for this class.</span><br><span class="line">//设置cls的索引</span><br><span class="line">	cls-&gt;chooseClassArrayIndex();</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: realizing class &apos;%s&apos;%s %p %p #%u&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </span><br><span class="line">                     (void*)cls, ro, cls-&gt;classArrayIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果父类没有初始化则进行初始化</span><br><span class="line">    // root_class 做完需要设置RW_REALIZED=1，</span><br><span class="line">    // root metaclasses 需要执行完.</span><br><span class="line">	//从NXMapTable 获取cls ，然后进行初始化</span><br><span class="line">	//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</span><br><span class="line">    supercls = realizeClass(remapClass(cls-&gt;superclass));</span><br><span class="line">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</span><br><span class="line">//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    // Disable non-pointer isa for some classes and/or platforms.</span><br><span class="line">    // Set instancesRequireRawIsa.</span><br><span class="line">    bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</span><br><span class="line">    bool rawIsaIsInherited = false;</span><br><span class="line">    static bool hackedDispatch = false;</span><br><span class="line"></span><br><span class="line">    if (DisableNonpointerIsa) &#123;</span><br><span class="line">        // Non-pointer isa disabled by environment or app SDK version</span><br><span class="line">        instancesRequireRawIsa = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </span><br><span class="line">             0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)) </span><br><span class="line">    &#123;</span><br><span class="line">        // hack for libdispatch et al - isa also acts as vtable pointer</span><br><span class="line">        hackedDispatch = true;</span><br><span class="line">        instancesRequireRawIsa = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </span><br><span class="line">             supercls-&gt;instancesRequireRawIsa()) </span><br><span class="line">    &#123;</span><br><span class="line">        // This is also propagated by addSubclass() </span><br><span class="line">        // but nonpointer isa setup needs it earlier.</span><br><span class="line">        // Special case: instancesRequireRawIsa does not propagate </span><br><span class="line">        // from root class to root metaclass</span><br><span class="line">        instancesRequireRawIsa = true;</span><br><span class="line">        rawIsaIsInherited = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (instancesRequireRawIsa) &#123;</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</span><br><span class="line">    &#125;</span><br><span class="line">// SUPPORT_NONPOINTER_ISA</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Update superclass and metaclass in case of remapping</span><br><span class="line">    cls-&gt;superclass = supercls;</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">	// 协调实例变量偏移/布局</span><br><span class="line">	//可能重新申请空间 class_ro_t,更新我们的class_ro_t</span><br><span class="line">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    // 设置setInstanceSize 从ro-&gt;instanceSize</span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">	//拷贝flags 从ro到rw中</span><br><span class="line">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//添加superclass指针</span><br><span class="line">    if (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Attach categories</span><br><span class="line">	//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* methodizeClass</span><br><span class="line"> 修复cls方法列表想，协议列表和属性列表</span><br><span class="line">* 加锁</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    // Methodizing for the first time</span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: methodizing class &apos;%s&apos; %s&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//方法列表</span><br><span class="line">    method_list_t *list = ro-&gt;baseMethods();</span><br><span class="line">    if (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</span><br><span class="line">	//将对象的方法追加到cls-&gt;rw-&gt;methods后面</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line">    if (proplist) &#123;</span><br><span class="line">	//将对象的属性追加到rw-&gt;properties后面</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    if (protolist) &#123;</span><br><span class="line">	//将对象的协议追加到rw-&gt;protocols后面</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Root classes get bonus method implementations if they don&apos;t have </span><br><span class="line">    // them already. These apply before category replacements.</span><br><span class="line">    if (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        // root metaclass</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Attach categories.</span><br><span class="line">	//类别 从全局NXMapTable *category_map 已经加载过了。</span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);</span><br><span class="line">	//收集所有的cats到cls -&gt; rw中</span><br><span class="line">    attachCategories(cls, cats, false /*don&apos;t flush caches*/);</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        if (cats) &#123;</span><br><span class="line">            for (uint32_t i = 0; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </span><br><span class="line">                             isMeta ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cats) free(cats);//释放cats</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    // Debug: sanity-check all SELs; log method list contents</span><br><span class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</span><br><span class="line">        &#125;</span><br><span class="line">        assert(sel_registerName(sel_getName(meth.name)) == meth.name); </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="attachCategories-解析"><a href="#attachCategories-解析" class="headerlink" title="attachCategories()解析"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">	//方法数组[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">	//属性数组</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">	//协议数组</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">		//取出某个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">//取出分类 的 instance方法或者class方法</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">//proplist 接受所有分类属性</span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">//proplist 接受所有协议方法</span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//收集了所有协议 分类方法</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	//追加所有分类方法</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	//释放数组</span><br><span class="line">    free(mlists);</span><br><span class="line">	//刷新该类的缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">//追加所有分类属性</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);//释放数组</span><br><span class="line">//追加所有分类协议</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);//释放数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rw-gt-list-gt-attachLists-解析"><a href="#rw-gt-list-gt-attachLists-解析" class="headerlink" title="rw-&gt;list-&gt;attachLists()解析"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           // many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount = array()-&gt;count;</span><br><span class="line">		//一共需要的数量</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">		//分配内存 内存不够用了，需要扩容</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">		//赋值count</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">		// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br><span class="line">           memmove(array()-&gt;lists + addedCount/*数组末尾*/, array()-&gt;lists/*数组*/,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0])/*移动的大小*/);</span><br><span class="line">		//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">		/*</span><br><span class="line">		图示讲解：</span><br><span class="line">		array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">	addedCount:3</span><br><span class="line">	addedLists:P-&gt;L-&gt;V</span><br><span class="line">		memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">		然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</span><br><span class="line">		P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">		 */</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">           // 0 lists -&gt; 1 list</span><br><span class="line">           list = addedLists[0];</span><br><span class="line">       &#125; </span><br><span class="line">       else &#123;</span><br><span class="line">           // 1 list -&gt; many lists</span><br><span class="line">           List* oldList = list;</span><br><span class="line">           uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount = oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count = newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>
<h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _class_resolveMethod</span><br><span class="line">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</span><br><span class="line">* 如果存在了则不检查</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;//不是元类则调用 实例的</span><br><span class="line">	//首先调用</span><br><span class="line">		_class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line">		//寻找classMethod</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _class_resolveInstanceMethod</span><br><span class="line">* 调用 class添加的函数 +resolveInstanceMethod</span><br><span class="line">* 有可能是元类</span><br><span class="line">* 如果方法存在则不检查</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </span><br><span class="line">    &#123;</span><br><span class="line">        // Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</span><br><span class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Method resolver didn&apos;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </span><br><span class="line">    &#123;</span><br><span class="line">        // Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</span><br><span class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Method resolver didn&apos;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态解析至此完成。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache</span><br><span class="line">	// No stret specialization.</span><br><span class="line">	b	__objc_msgForward//跳转-&gt;__objc_msgForward</span><br><span class="line">	END_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY __objc_msgForward // 开始 __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和</span><br><span class="line">	TailCallFunctionPointer x17 //跳转-&gt; TailCallFunctionPointer</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward//结束 __objc_msgForward</span><br></pre></td></tr></table></figure>
<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>
<p>网上有大神总结的点我们先参考下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</span><br><span class="line">    id receiver = *(id *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + 8);</span><br><span class="line">    const char *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    // 调用 forwardingTargetForSelector:</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            if (isStret == 1) &#123;</span><br><span class="line">                int ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;</span><br><span class="line">            return objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 僵尸对象</span><br><span class="line">    const char *className = class_getName(receiverClass);</span><br><span class="line">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</span><br><span class="line">    size_t prefixLen = strlen(zombiePrefix); // 0xa</span><br><span class="line">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</span><br><span class="line">        CFLog(kCFLogLevelError,</span><br><span class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        if (methodSignature) &#123;</span><br><span class="line">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            if (signatureIsStret != isStret) &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">                      isStret ? &quot;&quot; : not);</span><br><span class="line">            &#125;</span><br><span class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                void *returnValue = NULL;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                return returnValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    // selector 是否已经在 Runtime 注册过</span><br><span class="line">    if (sel != registeredSel) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; // doesNotRecognizeSelector</span><br><span class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement doesNotRecognizeSelector: -- abort&quot;,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The point of no return.</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证动态解析"><a href="#验证动态解析" class="headerlink" title="验证动态解析"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	if (sel == @selector(test)) &#123;</span><br><span class="line">		Method me = class_getInstanceMethod(self, @selector(test2));</span><br><span class="line">		class_addMethod(self, sel,</span><br><span class="line">						method_getImplementation(me),</span><br><span class="line">						method_getTypeEncoding(me));</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test2&#123;</span><br><span class="line">	NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">[p test];</span><br><span class="line">[p test];</span><br><span class="line"> //输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line"> -[FYPerson test3]</span><br><span class="line"> -[FYPerson test3]</span><br></pre></td></tr></table></figure>
<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>
<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">+ (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">	NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	if (sel == @selector(test)) &#123;</span><br><span class="line">		Method me = class_getClassMethod(self, @selector(test3));//获取method</span><br><span class="line">		//给sel 添加方法实现 @selecter(test3)</span><br><span class="line">		class_addMethod(object_getClass(self), sel,</span><br><span class="line">						method_getImplementation(me),</span><br><span class="line">						method_getTypeEncoding(me));</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Person test];</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">+[Person resolveClassMethod:]</span><br><span class="line">来了，老弟</span><br></pre></td></tr></table></figure>
<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">//        Method me = class_getInstanceMethod(self, @selector(test3));</span><br><span class="line">//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</span><br><span class="line">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">void test3(id self,SEL sel)&#123;</span><br><span class="line">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line">test3:test</span><br><span class="line">test3:test</span><br></pre></td></tr></table></figure>
<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>
<h3 id="验证消息转发"><a href="#验证消息转发" class="headerlink" title="验证消息转发"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector == @selector(test)) &#123;</span><br><span class="line">		//objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [[Struent alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">//输出</span><br><span class="line">-[Student test]</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>
<p>第一步没拦截，可以在第二步拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//消息转发第二步 没有对象来处理方法，那将函数签名来实现</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if (aSelector == @selector(test)) &#123;</span><br><span class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">		return sign;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">// 函数签名已返回，到了函数调用的地方</span><br><span class="line">//selector 函数的sel</span><br><span class="line">//target   函数调用者</span><br><span class="line">//methodSignature 函数签名</span><br><span class="line">//NSInvocation  封装数据的对象</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">-[Person forwardInvocation:]</span><br></pre></td></tr></table></figure></p>
<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, retain) NSMethodSignature *methodSignature;//只读</span><br><span class="line">- (void)retainArguments;</span><br><span class="line">@property (readonly) BOOL argumentsRetained;</span><br><span class="line">@property (nullable, assign) id target;//读写</span><br><span class="line">@property SEL selector;//读写</span><br></pre></td></tr></table></figure>
<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//class 转发</span><br><span class="line">// 消息转发第一步 拦截是否有转发的class对象处理方法</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector == @selector(test3)) &#123;</span><br><span class="line">		//objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [Student class];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">//	NSLog(@&quot;+[Student test3]&quot;);</span><br><span class="line">//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错</span><br><span class="line">//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</span><br><span class="line">//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">-[Student test2]</span><br></pre></td></tr></table></figure>
<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector == @selector(test3)) &#123;</span><br><span class="line">		//objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [[Student alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">-[Student test3]</span><br></pre></td></tr></table></figure>
<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//消息转发第二步 没有class来处理方法，那将函数签名来实现</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if (aSelector == @selector(test3)) &#123;</span><br><span class="line">		NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">		return sign;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">// 函数签名已返回，到了函数调用的地方</span><br><span class="line">//selector 函数的sel</span><br><span class="line">//target   函数调用者</span><br><span class="line">//methodSignature 函数签名</span><br><span class="line">//NSInvocation  封装数据的对象</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">//	anInvocation.selector = @selector(test2);</span><br><span class="line">//此处换成[Student class]同样可以</span><br><span class="line">//	anInvocation.target = (id)[[Student alloc]init];</span><br><span class="line"></span><br><span class="line">//	[anInvocation invoke];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">+[Person forwardInvocation:]</span><br></pre></td></tr></table></figure>
<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>
<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>
<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>
<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>
<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码</a></li>
</ul>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
