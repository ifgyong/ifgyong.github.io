<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.6.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="看完本文章你将了解到   DisplayLink和timer的使用和原理 内存分配和内存管理 自动释放池原理 weak指针原理和释放时机 引用计数原理   &#x2F; DisplayLinkCADisplayLink是将任务添加到runloop中，loop每次循环便会调用target的selector，使用这个也能监测卡顿问题。首先介绍下API 1234567+ (CADisplayLink *)disp">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/4fd9184d.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="看完本文章你将了解到   DisplayLink和timer的使用和原理 内存分配和内存管理 自动释放池原理 weak指针原理和释放时机 引用计数原理   &#x2F; DisplayLinkCADisplayLink是将任务添加到runloop中，loop每次循环便会调用target的selector，使用这个也能监测卡顿问题。首先介绍下API 1234567+ (CADisplayLink *)disp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="article:published_time" content="2019-12-01T03:22:58.000Z">
<meta property="article:modified_time" content="2020-09-09T00:59:35.137Z">
<meta property="article:author" content="fgyong">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fgyong.cn/images/0.png">


  


  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml" />




  <link rel="canonical" href="http://fgyong.cn/2019/12/01/4fd9184d.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理  内存管理 那些你不知道的原理汇总 --(12) | fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">44</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">8</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">24</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/4fd9184d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:22:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:22:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-09 08:59:35" itemprop="dateModified" datetime="2020-09-09T08:59:35+08:00">2020-09-09</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>看完本文章你将了解到</p>
<blockquote>
<ol>
<li>DisplayLink和timer的使用和原理</li>
<li>内存分配和内存管理</li>
<li>自动释放池原理</li>
<li>weak指针原理和释放时机</li>
<li>引用计数原理</li>
</ol>
</blockquote>
<p>/</p>
<h3 id="DisplayLink"><a href="#DisplayLink" class="headerlink" title="DisplayLink"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</span><br><span class="line">&#x2F;&#x2F;runloop没循环一圈都会调用</span><br><span class="line">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">&#x2F;&#x2F;从runloop中删除</span><br><span class="line">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</span><br><span class="line">&#x2F;&#x2F;取消</span><br><span class="line">- (void)invalidate;</span><br></pre></td></tr></table></figure>
<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) CADisplayLink *link;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">self.link &#x3D; [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		NSLog(@&quot;FPS:%d&quot;,fps);</span><br><span class="line">		fps &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line">&#x2F;&#x2F;全局变量</span><br><span class="line">dispatch_source_t timer;</span><br><span class="line">static int fps;</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">	</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		fps +&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	[self.link invalidate];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</span><br><span class="line">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</span><br><span class="line">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</span><br></pre></td></tr></table></figure>
<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYTimerTarget : NSObject</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYTimerTarget</span><br><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	return self.target;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYProxy *proxy&#x3D;[FYProxy proxyWithTarget:self];</span><br><span class="line">self.link &#x3D; [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 17:59:04.339934 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.356292 -[ViewController test]</span><br><span class="line">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 17:59:04.371634 -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface FYProxy : NSProxy</span><br><span class="line">@property (nonatomic,weak) id target;</span><br><span class="line"></span><br><span class="line">+(instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@end</span><br><span class="line">@implementation FYProxy</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</span><br><span class="line">	FYProxy *obj&#x3D;[FYProxy alloc];</span><br><span class="line">	obj.target &#x3D; target;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line">	[invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</span><br><span class="line">	return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	return self.target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FYTimerTarget *obj &#x3D;[FYTimerTarget new];</span><br><span class="line">obj.target &#x3D; self;</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; [NSTimer timerWithTimeInterval:1.0f</span><br><span class="line">									target:obj</span><br><span class="line">								   selector:@selector(test)</span><br><span class="line">								   userInfo:nil</span><br><span class="line">									repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">[self.timer setFireDate:[NSDate distantPast]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</span><br><span class="line">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</span><br><span class="line">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.timer&#x3D;[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</span><br><span class="line">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</span><br></pre></td></tr></table></figure>
<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>
<h3 id="GCD中timer"><a href="#GCD中timer" class="headerlink" title="GCD中timer"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;timer 需要强引用 或者设置成全局变量</span><br><span class="line">    timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</span><br><span class="line">    &#x2F;&#x2F;设置</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">  &#x2F;&#x2F;code 定时器执行的代码</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;开始定时器</span><br><span class="line">    dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler_f(timer, function_t);</span><br><span class="line">void function_t(void * p)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>
<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block</span><br><span class="line">    	  start:(NSTimeInterval)time</span><br><span class="line">       interval:(NSTimeInterval)interval</span><br><span class="line">    	 repeat:(BOOL)repeat</span><br><span class="line">    	  async:(BOOL)async;</span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">		  sel:(SEL)aciton</span><br><span class="line">		start:(NSTimeInterval)time</span><br><span class="line">	 interval:(NSTimeInterval)interval</span><br><span class="line">	   repeat:(BOOL)repeat</span><br><span class="line">		async:(BOOL)async;</span><br><span class="line">&#x2F;&#x2F;取消</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</span><br><span class="line">	if (block &#x3D;&#x3D; nil) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	if (repeat &amp;&amp; interval &lt;&#x3D; 0) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	NSString *name &#x3D;[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">	&#x2F;&#x2F;主队列</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">	if (async) &#123;</span><br><span class="line">		queue &#x3D; dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建定时器</span><br><span class="line">	dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">	&#x2F;&#x2F;设置启动时间</span><br><span class="line">	dispatch_source_set_timer(_timer,</span><br><span class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">	&#x2F;&#x2F;设定回调</span><br><span class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">		block();</span><br><span class="line">		if (repeat &#x3D;&#x3D; NO) &#123;</span><br><span class="line">			dispatch_source_cancel(_timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	&#x2F;&#x2F;启动定时器</span><br><span class="line">	dispatch_resume(_timer);</span><br><span class="line">	&#x2F;&#x2F;存放到字典</span><br><span class="line">	if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">		timers[name] &#x3D; _timer;</span><br><span class="line">		dispatch_semaphore_signal(samephore);</span><br><span class="line">	&#125;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (NSString *)exeTask:(id)target</span><br><span class="line">				  sel:(SEL)aciton</span><br><span class="line">				start:(NSTimeInterval)time</span><br><span class="line">			 interval:(NSTimeInterval)interval</span><br><span class="line">			   repeat:(BOOL)repeat</span><br><span class="line">				async:(BOOL)async&#123;</span><br><span class="line">	if (target &#x3D;&#x3D; nil || aciton &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	if (repeat &amp;&amp; interval &lt;&#x3D; 0) &#123;</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	NSString *name &#x3D;[NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">	&#x2F;&#x2F;主队列</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">	if (async) &#123;</span><br><span class="line">		queue &#x3D; dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建定时器</span><br><span class="line">	dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">	&#x2F;&#x2F;设置启动时间</span><br><span class="line">	dispatch_source_set_timer(_timer,</span><br><span class="line">							  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</span><br><span class="line">	&#x2F;&#x2F;设定回调</span><br><span class="line">	dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">		&#x2F;&#x2F;这里是会报警告的代码</span><br><span class="line">		if ([target respondsToSelector:aciton]) &#123;</span><br><span class="line">			[target performSelector:aciton];</span><br><span class="line">		&#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">		if (repeat &#x3D;&#x3D; NO) &#123;</span><br><span class="line">			dispatch_source_cancel(_timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	&#x2F;&#x2F;启动定时器</span><br><span class="line">	dispatch_resume(_timer);</span><br><span class="line">	&#x2F;&#x2F;存放到字典</span><br><span class="line">	if (name.length &amp;&amp; _timer) &#123;</span><br><span class="line">		dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">		timers[name] &#x3D; _timer;</span><br><span class="line">		dispatch_semaphore_signal(samephore);</span><br><span class="line">	&#125;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)exeCancelTask:(NSString *)key&#123;</span><br><span class="line">	if (key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</span><br><span class="line">	if ([timers.allKeys containsObject:key]) &#123;</span><br><span class="line">		dispatch_source_cancel(timers[key]);</span><br><span class="line">		[timers removeObjectForKey:key];</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_semaphore_signal(samephore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用的时候很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; [FYTimer exeTask:^&#123;</span><br><span class="line">        NSLog(@&quot;123&quot;);</span><br><span class="line">    &#125; start:1</span><br><span class="line">    interval:1 </span><br><span class="line">    repeat:YES </span><br><span class="line">    async:NO];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br></pre></td></tr></table></figure>
<p>取消执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FYTimer exeCancelTask:key];</span><br></pre></td></tr></table></figure>
<p>测试封装的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	key &#x3D; [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test&#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	[FYTimer exeCancelTask:key];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</span><br></pre></td></tr></table></figure>
<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>
<h3 id="NSProxy实战"><a href="#NSProxy实战" class="headerlink" title="NSProxy实战"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>
<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc1 &#x3D;[[ViewController alloc]init];</span><br><span class="line">FYProxy *pro1 &#x3D;[FYProxy proxyWithTarget:vc1];</span><br><span class="line"></span><br><span class="line">FYTimerTarget *tar &#x3D;[FYTimerTarget proxyWithTarget:vc1];</span><br><span class="line">BOOL ret1 &#x3D; [pro1 isKindOfClass:ViewController.class];</span><br><span class="line">BOOL ret2 &#x3D; [tar isKindOfClass:ViewController.class];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,ret1,ret2);</span><br></pre></td></tr></table></figure>
<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>
<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>
<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>
<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>
<p>数据段包括</p>
<ul>
<li>字符串常量：比如NSString * str = @”11”</li>
<li>已初始化数据：已初始化的全局变量、静态变量等</li>
<li>未初始化数据：未初始化的全局变量、静态变量等</li>
</ul>
<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>
<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">int b ;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static int c &#x3D; 20;</span><br><span class="line">        static int d;</span><br><span class="line">        int e &#x3D; 10;</span><br><span class="line">        int f;</span><br><span class="line">        NSString * str &#x3D; @&quot;123&quot;;</span><br><span class="line">        NSObject *obj &#x3D;[[NSObject alloc]init];</span><br><span class="line">        NSLog(@&quot;\na:%p \nb:%p \nc:%p \nd:%p \ne:%p \nf:%p \nobj:%p\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">a:0x1063e0d98 </span><br><span class="line">b:0x1063e0e64 </span><br><span class="line">c:0x1063e0d9c </span><br><span class="line">d:0x1063e0e60 </span><br><span class="line">e:0x7ffee9820efc </span><br><span class="line">f:0x7ffee9820ef8 </span><br><span class="line">obj:0x6000013541a0</span><br><span class="line">str:0x1063e0068</span><br></pre></td></tr></table></figure>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们拿来这个可以判断对象是否使用了优化技术。</p>
<h4 id="NSNumbe-Tagged-Pointer"><a href="#NSNumbe-Tagged-Pointer" class="headerlink" title="NSNumbe Tagged Pointer"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ &#x2F;&#x2F;mac开发</span><br><span class="line">&#x2F;&#x2F; 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F; Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1&#x2F;&#x2F;iOS开发</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#endif</span><br><span class="line">bool objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSNumber *n1 &#x3D; @2;</span><br><span class="line">        NSNumber *n2 &#x3D; @3;</span><br><span class="line">        NSNumber *n3 &#x3D; @(4);</span><br><span class="line">        NSNumber *n4 &#x3D; @(0x4fffffffff);</span><br><span class="line">        NSLog(@&quot;\n%p \n%p \n%p \n%p&quot;,n1,n2,n3,n4);</span><br><span class="line">        BOOL n1_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</span><br><span class="line">        BOOL n2_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</span><br><span class="line">        BOOL n3_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</span><br><span class="line">        BOOL n4_tag &#x3D; objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;\nn1:%d \nn2:%d \nn3:%d \nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">0xbf4071e2657ccb95 </span><br><span class="line">0xbf4071e2657ccb85 </span><br><span class="line">0xbf4071e2657ccbf5 </span><br><span class="line">0xbf40751d9a833444</span><br><span class="line">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </span><br><span class="line">n1:1 </span><br><span class="line">n2:1 </span><br><span class="line">n3:1 </span><br><span class="line">n4:0</span><br></pre></td></tr></table></figure>
<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>
<h4 id="NSString-Tagged-Pointer"><a href="#NSString-Tagged-Pointer" class="headerlink" title="NSString Tagged Pointer"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i &#x3D; 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name &#x3D; [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i &#x3D; 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name &#x3D; [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先不运行，先分析一下。</p>
<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread: EXC_BAD_ACCESS(code &#x3D; 1)</span><br></pre></td></tr></table></figure>
<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>
<p>验证<code>NSString Tagged Pointer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i &#x3D; 0; i &lt; 1; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name &#x3D; [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">			NSLog(@&quot;test1 class:%@&quot;,self.name.class);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">	for (NSInteger i &#x3D; 0; i &lt; 1; i ++) &#123;</span><br><span class="line">		dispatch_async(queue, ^&#123;</span><br><span class="line">			self.name &#x3D; [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</span><br><span class="line">			NSLog(@&quot;test2 class:%@&quot;,self.name.class);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">test1 class:NSTaggedPointerString</span><br><span class="line">test2 class:__NSCFString</span><br></pre></td></tr></table></figure>
<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>
<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>
<p> iOS提供了2中拷贝方法</p>
<ol>
<li>copy 拷贝出来不可变对象</li>
<li>mutableCopy 拷贝出来可变对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test1()&#123;</span><br><span class="line">	NSString *str &#x3D; @&quot;strstrstrstr&quot;;</span><br><span class="line">	NSMutableString *mut1 &#x3D;[str mutableCopy];</span><br><span class="line">	[mut1 appendFormat:@&quot;123&quot;];</span><br><span class="line">	NSString *str2 &#x3D; [str copy];</span><br><span class="line">	NSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">str:0x100001040 </span><br><span class="line">mut1:0x1007385f0 </span><br><span class="line">str2:0x100001040</span><br></pre></td></tr></table></figure>
<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>
<p>我们把字符串换成其他常用的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test2()&#123;</span><br><span class="line">	NSArray *array &#x3D; @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</span><br><span class="line">	NSMutableArray *mut &#x3D;[array mutableCopy];</span><br><span class="line">	NSString *array2 &#x3D; [array copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x102840800 </span><br><span class="line">0x1028408a0</span><br><span class="line">0x102840800</span><br><span class="line"></span><br><span class="line">void test3()&#123;</span><br><span class="line">	NSArray *array &#x3D; [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</span><br><span class="line">	NSMutableArray *mut &#x3D;[array mutableCopy];</span><br><span class="line">	NSString *array2 &#x3D; [array copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,array,mut,array2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x102808720 </span><br><span class="line">0x1028088a0</span><br><span class="line">0x1028089a0</span><br></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>
<p>我们再换成其他的常用的字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void test4()&#123;</span><br><span class="line">	NSDictionary *item &#x3D; @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</span><br><span class="line">	NSMutableDictionary *mut &#x3D;[item mutableCopy];</span><br><span class="line">	NSDictionary *item2 &#x3D; [item copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">0x1007789c0 </span><br><span class="line">0x100779190</span><br><span class="line">0x1007789c0</span><br><span class="line"></span><br><span class="line">void test5()&#123;</span><br><span class="line">	NSDictionary *item &#x3D; [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</span><br><span class="line">	NSMutableDictionary *mut &#x3D;[item mutableCopy];</span><br><span class="line">	NSDictionary *item2 &#x3D; [item copy];</span><br><span class="line">	NSLog(@&quot;\n%p \n%p\n%p&quot;,item,mut,item2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">0x1007041d0 </span><br><span class="line">0x1007042b0</span><br><span class="line">0x1007043a0</span><br></pre></td></tr></table></figure>
<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>
<p>由这几个看出来，总结出来下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">copy</th>
<th style="text-align:center">mutableCopy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NSString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableString</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSArray</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableArray</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSDictionary</td>
<td style="text-align:center">浅拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
<tr>
<td style="text-align:center">NSMutableDictionary</td>
<td style="text-align:center">深拷贝</td>
<td style="text-align:center">深拷贝</td>
</tr>
</tbody>
</table>
<h4 id="自定义对象实现协议NSCoping"><a href="#自定义对象实现协议NSCoping" class="headerlink" title="自定义对象实现协议NSCoping"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCopying</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSMutableCopying</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@property (nonatomic,assign) int level;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FYPerson()&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">	FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">	p.age &#x3D; self.age;</span><br><span class="line">	p.level &#x3D; self.level;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.age &#x3D; 10;</span><br><span class="line">p.level &#x3D; 11;</span><br><span class="line">FYPerson *p2 &#x3D;[p copy];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">10 11</span><br></pre></td></tr></table></figure>
<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>
<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (add)</span><br><span class="line">-(instancetype)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    Class cls &#x3D; [self class];</span><br><span class="line">    NSObject * p&#x3D;[cls new];</span><br><span class="line">    &#x2F;&#x2F;成员变量个数</span><br><span class="line">    unsigned int count;</span><br><span class="line">    &#x2F;&#x2F;赋值成员变量数组</span><br><span class="line">    Ivar *ivars &#x3D; class_copyIvarList(self.class, &amp;count);</span><br><span class="line">    &#x2F;&#x2F;遍历数组</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i ++) &#123;</span><br><span class="line">        Ivar var &#x3D; ivars[i];</span><br><span class="line">        &#x2F;&#x2F;获取成员变量名字</span><br><span class="line">        const char * name &#x3D; ivar_getName(var);</span><br><span class="line">        if (name !&#x3D; nil) &#123;</span><br><span class="line">            NSString *v &#x3D; [NSString stringWithUTF8String:name];</span><br><span class="line">            id value &#x3D; [self valueForKey:v];</span><br><span class="line">            &#x2F;&#x2F;给新的对象赋值</span><br><span class="line">            if (value !&#x3D; NULL) &#123;</span><br><span class="line">                [p setValue:value forKey:v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">p.age &#x3D; 10;</span><br><span class="line">p.level &#x3D; 11;</span><br><span class="line">p.name &#x3D; @&quot;xiaowang&quot;;</span><br><span class="line">FYPerson *p2 &#x3D;[p copy];</span><br><span class="line">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">10 </span><br><span class="line">11 </span><br><span class="line">xiaowang</span><br></pre></td></tr></table></figure>
<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>
<h3 id="引用计数原理"><a href="#引用计数原理" class="headerlink" title="引用计数原理"></a>引用计数原理</h3><p>摘自<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlOTUlRTclOTQlQTglRTglQUUlQTElRTYlOTUlQjAvMTAyMDU1MDc/ZnI9YWxhZGRpbg==" title="https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin">百度百科<i class="fa fa-external-link"></i></span></p>
<blockquote>
<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>
</blockquote>
<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>
<p>在MRC中我们经常都是这样子使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">FYPerson *p2 &#x3D;[p retain];</span><br><span class="line">&#x2F;&#x2F;code here</span><br><span class="line">[p release];</span><br><span class="line">[p2 release];</span><br></pre></td></tr></table></figure>
<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>
<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>
<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;大概率x&#x3D;&#x3D;1 提高读取指令的效率</span><br><span class="line">#define fastpath(x) (__builtin_expect(bool(x), 1))</span><br><span class="line">&#x2F;&#x2F;大概率x&#x3D;&#x3D;0 提高读取指令的效率</span><br><span class="line">#define slowpath(x) (__builtin_expect(bool(x), 0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引用计数+1</span><br><span class="line">&#x2F;&#x2F;tryRetain 尝试+1</span><br><span class="line">&#x2F;&#x2F;handleOverflow 是否覆盖</span><br><span class="line">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;优化的指针 返回this</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line">    bool transcribeToSideTable &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable &#x3D; false;</span><br><span class="line">		&#x2F;&#x2F;old bits</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">		&#x2F;&#x2F;使用联合体技术</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);&#x2F;&#x2F;nothing</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();&#x2F;&#x2F;解锁</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">			else return sidetable_retain();&#x2F;&#x2F;&#x2F;&#x2F;sidetable 引用计数+1</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; don&#39;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">		&#x2F;&#x2F;不尝试retain 和 正在销毁 什么都不做 返回 nil</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">		&#x2F;&#x2F;引用计数+1 (bits.extra_rc++;)</span><br><span class="line">        newisa.bits &#x3D; addc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc++</span><br><span class="line"></span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; newisa.extra_rc++ 溢出处理</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F;为拷贝到side table 做准备</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            transcribeToSideTable &#x3D; true;</span><br><span class="line">            newisa.extra_rc &#x3D; RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">		&#x2F;&#x2F;拷贝 平外一半的 引用计数到 side table</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sidetable 引用计数+1</span><br><span class="line">id objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">	&#x2F;&#x2F;取出table key&#x3D;this</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage &#x3D; table.refcnts[this];</span><br><span class="line">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage +&#x3D; SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>
<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;&#x2F;&#x2F;指针优化的不存在计数器</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;&#x2F;&#x2F;isa</span><br><span class="line">        oldisa &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa &#x3D; oldisa;</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">			&#x2F;&#x2F;side table -1</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits &#x3D; subc(newisa.bits, RC_ONE, 0, &amp;carry);  &#x2F;&#x2F; extra_rc--</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            &#x2F;&#x2F; don&#39;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    newisa &#x3D; oldisa;</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked &#x3D; true;</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;side table 引用计数-1</span><br><span class="line">        size_t borrowed &#x3D; sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            newisa.extra_rc &#x3D; borrowed - 1;  &#x2F;&#x2F; redo the original decrement too</span><br><span class="line">            bool stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                isa_t oldisa2 &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 &#x3D; oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits &#x3D; </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored &#x3D; StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                &#x2F;&#x2F; Inline update failed.</span><br><span class="line">                &#x2F;&#x2F; Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;真正的销毁</span><br><span class="line"></span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        &#x2F;&#x2F; does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;设置正在销毁</span><br><span class="line">    newisa.deallocating &#x3D; true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">		&#x2F;&#x2F;销毁</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline uintptr_t  objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;优化指针 直接返回</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line">&#x2F;&#x2F;没优化则 到SideTable 读取</span><br><span class="line">    sidetable_lock();</span><br><span class="line">	&#x2F;&#x2F;isa指针</span><br><span class="line">    isa_t bits &#x3D; LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);&#x2F;&#x2F;啥都没做</span><br><span class="line">    if (bits.nonpointer) &#123;&#x2F;&#x2F;使用联合体存储更多的数据 </span><br><span class="line">        uintptr_t rc &#x3D; 1 + bits.extra_rc;&#x2F;&#x2F;计数数量</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;&#x2F;&#x2F;当大过于 联合体存储的值 则另外在SideTable读取数据</span><br><span class="line">	&#x2F;&#x2F;读取table的值 相加</span><br><span class="line">            rc +&#x3D; sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">	&#x2F;&#x2F;在sidetable 中存储的count</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDJiY2YzZGYyNjVkYTFiNjcyMTNkNjk=" title="https://juejin.im/post/5d2bcf3df265da1b67213d69">使用联合体存储更多的数据<i class="fa fa-external-link"></i></span>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用联合体</span><br><span class="line">size_t  objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;不是联合体技术 则报错</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">	&#x2F;&#x2F;key是 this，存储了每个对象的table</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">	&#x2F;&#x2F;找到 it 否则返回0</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it &#x3D;&#x3D; table.refcnts.end()) return 0;</span><br><span class="line">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有优化的是直接读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未使用联合体的情况，</span><br><span class="line">uintptr_t objc_object::sidetable_retainCount()</span><br><span class="line">&#123;&#x2F;&#x2F;没有联合体存储的计数器则直接在table中取出来</span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    size_t refcnt_result &#x3D; 1;</span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it &#x3D; table.refcnts.find(this);</span><br><span class="line">    if (it !&#x3D; table.refcnts.end()) &#123;</span><br><span class="line">        refcnt_result +&#x3D; it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak指针原理"><a href="#weak指针原理" class="headerlink" title="weak指针原理"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">		&#x2F;&#x2F;c++析构函数</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">		&#x2F;&#x2F;关联函数</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正在清除side table 和weakly referenced</span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for raw pointer isa.</span><br><span class="line">		&#x2F;&#x2F;释放weak</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Slow path for non-pointer isa with weak refs and&#x2F;or side table data.</span><br><span class="line">		&#x2F;&#x2F;释放weak 和引用计数</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">	&#x2F;&#x2F;清除weak</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">		&#x2F;&#x2F;table.weak_table 弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;引用计数</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">		&#x2F;&#x2F;擦除 this</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>
<h3 id="Autoreleasepool-原理"><a href="#Autoreleasepool-原理" class="headerlink" title="Autoreleasepool 原理"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">		FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line"> __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"> FYPerson *p &#x3D; ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__AtAutoreleasePool</code>是一个结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">	__AtAutoreleasePool() &#123;&#x2F;&#x2F;构造函数 生成结构体变量的时候调用</span><br><span class="line">		atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">	&#125;</span><br><span class="line">	~__AtAutoreleasePool() &#123;&#x2F;&#x2F;析构函数 销毁的时候调用</span><br><span class="line">		objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">	&#125;</span><br><span class="line">	void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后将上边的代码和c++整合到一起就是这样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __AtAutoreleasePool pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">    objc_autoreleasePoolPop(pool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>
<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;&#x2F;&#x2F;下一个存放aotoreleass对象的地址</span><br><span class="line">    pthread_t const thread;&#x2F;&#x2F;线程</span><br><span class="line">    AutoreleasePoolPage * const parent; &#x2F;&#x2F;父节点</span><br><span class="line">    AutoreleasePoolPage *child;&#x2F;&#x2F;子节点</span><br><span class="line">    uint32_t const depth;&#x2F;&#x2F;深度</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>
<ul>
<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>
<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>
<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>
<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>
<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>
</ul>
<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line"></span><br><span class="line">		FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">		_objc_autoreleasePoolPrint();</span><br><span class="line">		printf(&quot;\n--------------\n&quot;);</span><br><span class="line">	&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line"></span><br><span class="line">objc[23958]: ##############</span><br><span class="line">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[23958]: 3 releases pending.</span><br><span class="line">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[23958]: [0x101000038]  ################  POOL 0x101000038</span><br><span class="line">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</span><br><span class="line">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</span><br><span class="line">objc[23958]: ##############</span><br><span class="line"></span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>
<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line"></span><br><span class="line">		FYPerson *p &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">		FYPerson *p2 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">		@autoreleasepool &#123;&#x2F;&#x2F;r1 &#x3D; push()</span><br><span class="line">			</span><br><span class="line">			FYPerson *p3 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">			FYPerson *p4 &#x3D; [[[FYPerson alloc]init] autorelease];</span><br><span class="line">			</span><br><span class="line">			_objc_autoreleasePoolPrint();</span><br><span class="line">			printf(&quot;\n--------------\n&quot;);</span><br><span class="line">		&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">	&#125;&#x2F;&#x2F;pop(r1)</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;log</span><br><span class="line">objc[24025]: ##############</span><br><span class="line">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</span><br><span class="line">objc[24025]: 6 releases pending.</span><br><span class="line">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[24025]: [0x100803038]  ################  POOL 0x100803038</span><br><span class="line">objc[24025]: [0x100803040]       0x100721580  FYPerson</span><br><span class="line">objc[24025]: [0x100803048]       0x100721b10  FYPerson</span><br><span class="line">objc[24025]: [0x100803050]  ################  POOL 0x100803050</span><br><span class="line">objc[24025]: [0x100803058]       0x100721390  FYPerson</span><br><span class="line">objc[24025]: [0x100803060]       0x100717620  FYPerson</span><br><span class="line">objc[24025]: ##############</span><br></pre></td></tr></table></figure>
<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>
<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line"> &#123;</span><br><span class="line">     AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">     &#x2F;&#x2F;当有分页而且分页没有满就添加</span><br><span class="line">     if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">         return page-&gt;add(obj);</span><br><span class="line">     &#125; else if (page) &#123;</span><br><span class="line">         &#x2F;&#x2F;满则新建一个page进行添加obj和设置hotpage</span><br><span class="line">         return autoreleaseFullPage(obj, page);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F;没有page则新建page进行添加</span><br><span class="line">         return autoreleaseNoPage(obj);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;activities &#x3D; 0xa0转化成二进制 0b101 0000</span><br><span class="line">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</span><br><span class="line">&#x2F;&#x2F;回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line"></span><br><span class="line">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid &#x3D; Yes, activities &#x3D; 0xa0, </span><br><span class="line">repeats &#x3D; Yes, order &#x3D; 2147483647, </span><br><span class="line">callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </span><br><span class="line">context &#x3D; &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type &#x3D; mutable-small, count &#x3D; 1, </span><br><span class="line">values &#x3D; (\n\t0 : &lt;0x7fb6dc004058&gt;\n)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    FYPerson *p &#x3D;[[FYPerson alloc]init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>
<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>
<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>
<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>
<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>
<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Vubnl4eC5jb20vMjAxNC8xMC8xNS9iZWhpbmQtYXV0b3JlbGVhc2Uv" title="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease
<i class="fa fa-external-link"></i></span></li>
<li>小码哥视频</li>
<li>iOS和OS多线程与内存管理</li>
<li>iOS和macOS性能优化<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载git<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code git<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码git<i class="fa fa-external-link"></i></span></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/77ae3965.html" rel="next" title="iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)">
                <i class="fa fa-chevron-left"></i> iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/d4993be8.html" rel="prev" title="MVC、MVP、MVVM、分层设计浅谈 — (13)">
                MVC、MVP、MVVM、分层设计浅谈 — (13) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container">
    </div>
    
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.ico"
                alt="fgyong" />
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmc=" title="GitHub &rarr; https://github.com/ifgyong"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci8xNzUwMDc4MjM5MjkwOTA5" title="掘金 &rarr; https://juejin.im/user/1750078239290909"><i class="fa fa-fw fa-掘金"></i>掘金</span>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#DisplayLink"><span class="nav-number">1.</span> <span class="nav-text">DisplayLink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer"><span class="nav-number">2.</span> <span class="nav-text">NSTimer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD中timer"><span class="nav-number">3.</span> <span class="nav-text">GCD中timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSProxy实战"><span class="nav-number">4.</span> <span class="nav-text">NSProxy实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配"><span class="nav-number">5.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">6.</span> <span class="nav-text">Tagged Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSNumbe-Tagged-Pointer"><span class="nav-number">6.1.</span> <span class="nav-text">NSNumbe Tagged Pointer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSString-Tagged-Pointer"><span class="nav-number">6.2.</span> <span class="nav-text">NSString Tagged Pointer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">7.</span> <span class="nav-text">copy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义对象实现协议NSCoping"><span class="nav-number">7.1.</span> <span class="nav-text">自定义对象实现协议NSCoping</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数原理"><span class="nav-number">8.</span> <span class="nav-text">引用计数原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak指针原理"><span class="nav-number">9.</span> <span class="nav-text">weak指针原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autoreleasepool-原理"><span class="nav-number">10.</span> <span class="nav-text">Autoreleasepool 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">12.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料下载"><span class="nav-number">13.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8=">豫ICP备17045226号-1 </span>&copy; 2015 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> 强力驱动 v4.2.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Mist</span> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>

  
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css">

  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
    
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'a7800c37057fc3ce83df',
          clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
          repo: 'ifgyong.github.io',
          owner: 'ifgyong',
          admin: ['ifgyong'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  

  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=6.6.0"></script>


  

  

  

</body>
</html>
