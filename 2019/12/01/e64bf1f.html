<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.6.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，objc_class-&gt;cache_t cache是一个是缓存最近调用class的方法，当缓存剩余空间小余1&#x2F;4则进行扩容，扩容为原来的两倍，扩容之后，已存储的method_t扩容之后之后被清空。今天我们在了解runtime的消息转发机制。 基础知识OC中的方法调用，其实都是转换为objc_msgSen">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/e64bf1f.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，objc_class-&gt;cache_t cache是一个是缓存最近调用class的方法，当缓存剩余空间小余1&#x2F;4则进行扩容，扩容为原来的两倍，扩容之后，已存储的method_t扩容之后之后被清空。今天我们在了解runtime的消息转发机制。 基础知识OC中的方法调用，其实都是转换为objc_msgSen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fgyong.cn/images/7-1.png">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="article:published_time" content="2019-12-01T03:17:58.000Z">
<meta property="article:modified_time" content="2020-09-09T00:59:35.135Z">
<meta property="article:author" content="fgyong">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fgyong.cn/images/7-1.png">


  


  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml" />




  <link rel="canonical" href="http://fgyong.cn/2019/12/01/e64bf1f.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7) | fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">44</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">8</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">24</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/e64bf1f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:17:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:17:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-09 08:59:35" itemprop="dateModified" datetime="2020-09-09T08:59:35+08:00">2020-09-09</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>
<p>objc_msgSend的执行流程可以分为3大阶段</p>
<ol>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ol>
<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">objc-msg-arm64.s</span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">b.le	LNilOrTagged &#x2F;&#x2F;&lt;0则返回</span><br><span class="line">CacheLookup NORMAL &#x2F;&#x2F;缓存查找 未命中则继续查找</span><br><span class="line">.macro CacheLookup&#x2F;&#x2F; 通过宏 查找cache，命中直接call or return imp</span><br><span class="line">.macro CheckMiss &#x2F;&#x2F;miss 则跳转__objc_msgSend_uncached</span><br><span class="line">STATIC_ENTRY __objc_msgSend_uncached </span><br><span class="line">.macro MethodTableLookup&#x2F;&#x2F;方法中查找</span><br><span class="line">__class_lookupMethodAndLoadCache3&#x2F;&#x2F;跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-runtime-new.mm</span><br><span class="line">_class_lookupMethodAndLoadCache3</span><br><span class="line">lookUpImpOrForward</span><br><span class="line">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</span><br><span class="line">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</span><br><span class="line">_class_resolveInstanceMethod</span><br><span class="line">_objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc-msg-arm64.s</span><br><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line">__forwarding__（不开源）</span><br></pre></td></tr></table></figure>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend &#x2F;&#x2F; _objc_msgSend 开始</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			&#x2F;&#x2F; 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		&#x2F;&#x2F; if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</span><br><span class="line">#else</span><br><span class="line">	b.eq	LReturnZero &#x2F;&#x2F; if le &#x3D;&#x3D; 0 -&gt;  跳转到标签  LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		&#x2F;&#x2F; p13 &#x3D; isa</span><br><span class="line">	GetClassFromIsa_p16 p13		&#x2F;&#x2F; p16 &#x3D; class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">LNilOrTagged:</span><br><span class="line">	b.eq	LReturnZero		&#x2F;&#x2F; 如果&#x3D;&#x3D;0 -&gt; LReturnZero</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #60, #4</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	adrp	x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</span><br><span class="line">	add	x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</span><br><span class="line">	cmp	x10, x16</span><br><span class="line">	b.ne	LGetIsaDone</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; ext tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #52, #8</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">	&#x2F;&#x2F; x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	ret &#x2F;&#x2F;return 返回结束掉</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend &#x2F;&#x2F; _objc_msgSend 结束</span><br></pre></td></tr></table></figure>
<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup &#x2F;&#x2F;.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</span><br><span class="line">	&#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa</span><br><span class="line">	ldp	p10, p11, [x16, #CACHE]	&#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">	and	w11, w11, 0xffff	&#x2F;&#x2F; p11 &#x3D; mask</span><br><span class="line">#endif</span><br><span class="line">	and	w12, w1, w11		&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">		             &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:	cmp	p9, p1			&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">	b.ne	2f			&#x2F;&#x2F;     scan more</span><br><span class="line">	CacheHit $0			&#x2F;&#x2F; call or return imp 命中 调用或者返回imp</span><br><span class="line">	</span><br><span class="line">2:	&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket 没有命中</span><br><span class="line">	CheckMiss $0			&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">	cmp	p12, p10		&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">	b	1b			&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:	&#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask</span><br><span class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">		                        &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">	&#x2F;&#x2F; The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:	cmp	p9, p1			&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">	b.ne	2f			&#x2F;&#x2F;     scan more</span><br><span class="line">	CacheHit $0			&#x2F;&#x2F; call or return imp</span><br><span class="line">	</span><br><span class="line">2:	&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket</span><br><span class="line">	CheckMiss $0			&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">	cmp	p12, p10		&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">	b	1b			&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:	&#x2F;&#x2F; double wrap</span><br><span class="line">	JumpMiss $0</span><br><span class="line">	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">	&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	cbz	p9, LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	cbz	p9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	cbz	p9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	&#x2F;&#x2F; push frame</span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3&#x2F;&#x2F;跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP in x0</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; restore registers and return</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line">	AuthenticateLR</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* initialize&#x3D;&#x3D;NO 尽量避免调用，有时可能也会调用。</span><br><span class="line">* cache&#x3D;&#x3D;NO 跳过缓存查找，其他地方可能会不调过</span><br><span class="line">* 大多数人会传值 initialize&#x3D;&#x3D;YES and cache&#x3D;&#x3D;YES</span><br><span class="line">*   如果cls是非初始化的元类，则非Non-nil会快点</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    bool triedResolver &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (cache) &#123; &#x2F;&#x2F;从汇编过来是NO</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">		&#x2F;&#x2F;当cls需要初始化和没有初始化的时候 进行cls初始化，</span><br><span class="line">		&#x2F;&#x2F;初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</span><br><span class="line">		&#x2F;&#x2F;数据的大小最小是4，扩容规则是：n*2+1;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再次获取imp</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;尝试在本类中查找method</span><br><span class="line">    &#123;&#x2F;&#x2F;从cls-&gt;data()-&gt;methods查找method</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;&#x2F;&#x2F;找到添加到cache中</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">	&#x2F;&#x2F;从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">        for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">             curClass !&#x3D; nil;</span><br><span class="line">             curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass cache.</span><br><span class="line">            imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">					&#x2F;&#x2F;将父类添加到 子类的缓存中</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                    &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                    &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Superclass method list.</span><br><span class="line">            Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp &#x3D; meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;如果还没有找到imp，进入动态方法解析阶段</span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        triedResolver &#x3D; YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="line">&#x2F;&#x2F;	进行消息转发 阶段</span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">	&#x2F;&#x2F;填充 cache</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Define SUPPORT_INDEXED_ISA&#x3D;1 on platforms that store the class in the isa </span><br><span class="line">&#x2F;&#x2F; field as an index into a class table.</span><br><span class="line">&#x2F;&#x2F; Note, keep this in sync with any .s files which also define it.</span><br><span class="line">&#x2F;&#x2F; Be sure to edit objc-abi.h as well.</span><br><span class="line">&#x2F;&#x2F; __ARM_ARCH_7K__ 处理器架构指令集版本</span><br><span class="line">&#x2F;&#x2F;__arm64__ 架构</span><br><span class="line">&#x2F;&#x2F;__LP64__ uinx 和uinx  mac os</span><br><span class="line">#if __ARM_ARCH_7K__ &gt;&#x3D; 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 1</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>
<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>
<p>借用网上找一个图， 可以更直观的看出流程运转。</p>
<p><img src="/images/7-1.png" alt></p>
<h4 id="realizeClass-解析"><a href="#realizeClass-解析" class="headerlink" title="realizeClass()解析"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));
    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* realizeClass</span><br><span class="line"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</span><br><span class="line"> runtimelock 必须有调用者把写入锁锁起来</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls &#x3D;&#x3D; remapClass(cls));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">&#x2F;&#x2F;首先将tw赋值给to，因为数据结构一样可以直接强制转化</span><br><span class="line">    ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;&#x2F;&#x2F;是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br><span class="line">        rw &#x3D; cls-&gt;data();</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 正常情况下 申请class_rw_t空间</span><br><span class="line">        rw &#x3D; (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro &#x3D; ro;&#x2F;&#x2F;cls-&gt;rw-&gt;ro 指向现在的ro</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING;&#x2F;&#x2F;realized &#x3D; 1 and  realizing &#x3D; 1</span><br><span class="line">        cls-&gt;setData(rw);&#x2F;&#x2F;赋值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta &#x3D; ro-&gt;flags &amp; RO_META;&#x2F;&#x2F;是否是元类</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    rw-&gt;version &#x3D; isMeta ? 7 : 0;  &#x2F;&#x2F; 元类版本是7，旧版的6，否就是0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Choose an index for this class.</span><br><span class="line">&#x2F;&#x2F;设置cls的索引</span><br><span class="line">	cls-&gt;chooseClassArrayIndex();</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: realizing class &#39;%s&#39;%s %p %p #%u&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </span><br><span class="line">                     (void*)cls, ro, cls-&gt;classArrayIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果父类没有初始化则进行初始化</span><br><span class="line">    &#x2F;&#x2F; root_class 做完需要设置RW_REALIZED&#x3D;1，</span><br><span class="line">    &#x2F;&#x2F; root metaclasses 需要执行完.</span><br><span class="line">	&#x2F;&#x2F;从NXMapTable 获取cls ，然后进行初始化</span><br><span class="line">	&#x2F;&#x2F;从NXMapTable 获取cls-&gt;isa ，然后进行初始化</span><br><span class="line">    supercls &#x3D; realizeClass(remapClass(cls-&gt;superclass));</span><br><span class="line">    metacls &#x3D; realizeClass(remapClass(cls-&gt;ISA()));</span><br><span class="line">&#x2F;&#x2F;没有经过优化的isa执行的，现在已经是version&#x3D;7，在arm64上是优化过的，这个先不看了。</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    &#x2F;&#x2F; Disable non-pointer isa for some classes and&#x2F;or platforms.</span><br><span class="line">    &#x2F;&#x2F; Set instancesRequireRawIsa.</span><br><span class="line">    bool instancesRequireRawIsa &#x3D; cls-&gt;instancesRequireRawIsa();</span><br><span class="line">    bool rawIsaIsInherited &#x3D; false;</span><br><span class="line">    static bool hackedDispatch &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (DisableNonpointerIsa) &#123;</span><br><span class="line">        &#x2F;&#x2F; Non-pointer isa disabled by environment or app SDK version</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </span><br><span class="line">             0 &#x3D;&#x3D; strcmp(ro-&gt;name, &quot;OS_object&quot;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; hack for libdispatch et al - isa also acts as vtable pointer</span><br><span class="line">        hackedDispatch &#x3D; true;</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </span><br><span class="line">             supercls-&gt;instancesRequireRawIsa()) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; This is also propagated by addSubclass() </span><br><span class="line">        &#x2F;&#x2F; but nonpointer isa setup needs it earlier.</span><br><span class="line">        &#x2F;&#x2F; Special case: instancesRequireRawIsa does not propagate </span><br><span class="line">        &#x2F;&#x2F; from root class to root metaclass</span><br><span class="line">        instancesRequireRawIsa &#x3D; true;</span><br><span class="line">        rawIsaIsInherited &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (instancesRequireRawIsa) &#123;</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; SUPPORT_NONPOINTER_ISA</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Update superclass and metaclass in case of remapping</span><br><span class="line">    cls-&gt;superclass &#x3D; supercls;</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 协调实例变量偏移&#x2F;布局</span><br><span class="line">	&#x2F;&#x2F;可能重新申请空间 class_ro_t,更新我们的class_ro_t</span><br><span class="line">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置setInstanceSize 从ro-&gt;instanceSize</span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;拷贝flags 从ro到rw中</span><br><span class="line">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;添加superclass指针</span><br><span class="line">    if (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories</span><br><span class="line">	&#x2F;&#x2F;类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* methodizeClass</span><br><span class="line"> 修复cls方法列表想，协议列表和属性列表</span><br><span class="line">* 加锁</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line">    auto ro &#x3D; rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Methodizing for the first time</span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(&quot;CLASS: methodizing class &#39;%s&#39; %s&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;方法列表</span><br><span class="line">    method_list_t *list &#x3D; ro-&gt;baseMethods();</span><br><span class="line">    if (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</span><br><span class="line">	&#x2F;&#x2F;将对象的方法追加到cls-&gt;rw-&gt;methods后面</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist &#x3D; ro-&gt;baseProperties;</span><br><span class="line">    if (proplist) &#123;</span><br><span class="line">	&#x2F;&#x2F;将对象的属性追加到rw-&gt;properties后面</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist &#x3D; ro-&gt;baseProtocols;</span><br><span class="line">    if (protolist) &#123;</span><br><span class="line">	&#x2F;&#x2F;将对象的协议追加到rw-&gt;protocols后面</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Root classes get bonus method implementations if they don&#39;t have </span><br><span class="line">    &#x2F;&#x2F; them already. These apply before category replacements.</span><br><span class="line">    if (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; root metaclass</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attach categories.</span><br><span class="line">	&#x2F;&#x2F;类别 从全局NXMapTable *category_map 已经加载过了。</span><br><span class="line">    category_list *cats &#x3D; unattachedCategoriesForClass(cls, true &#x2F;*realizing*&#x2F;);</span><br><span class="line">	&#x2F;&#x2F;收集所有的cats到cls -&gt; rw中</span><br><span class="line">    attachCategories(cls, cats, false &#x2F;*don&#39;t flush caches*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (PrintConnecting) &#123;</span><br><span class="line">        if (cats) &#123;</span><br><span class="line">            for (uint32_t i &#x3D; 0; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </span><br><span class="line">                             isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cats) free(cats);&#x2F;&#x2F;释放cats</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; Debug: sanity-check all SELs; log method list contents</span><br><span class="line">    for (const auto&amp; meth : rw-&gt;methods) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</span><br><span class="line">        &#125;</span><br><span class="line">        assert(sel_registerName(sel_getName(meth.name)) &#x3D;&#x3D; meth.name); </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="attachCategories-解析"><a href="#attachCategories-解析" class="headerlink" title="attachCategories()解析"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme rearrange to remove these intermediate allocations</span><br><span class="line">	&#x2F;&#x2F;方法数组[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">    method_list_t **mlists &#x3D; (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">	&#x2F;&#x2F;属性数组</span><br><span class="line">    property_list_t **proplists &#x3D; (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">	&#x2F;&#x2F;协议数组</span><br><span class="line">    protocol_list_t **protolists &#x3D; (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount &#x3D; 0;</span><br><span class="line">    int propcount &#x3D; 0;</span><br><span class="line">    int protocount &#x3D; 0;</span><br><span class="line">    int i &#x3D; cats-&gt;count;</span><br><span class="line">    bool fromBundle &#x3D; NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">		&#x2F;&#x2F;取出某个分类</span><br><span class="line">        auto&amp; entry &#x3D; cats-&gt;list[i];</span><br><span class="line">&#x2F;&#x2F;取出分类 的 instance方法或者class方法</span><br><span class="line">        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] &#x3D; mlist; &#x2F;&#x2F;mlists 接受所有分类方法</span><br><span class="line">            fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有分类属性</span><br><span class="line">        property_list_t *proplist &#x3D; </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] &#x3D; proplist;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;proplist 接受所有协议方法</span><br><span class="line">        protocol_list_t *protolist &#x3D; entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] &#x3D; protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;收集了所有协议 分类方法</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">	&#x2F;&#x2F;追加所有分类方法</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	&#x2F;&#x2F;释放数组</span><br><span class="line">    free(mlists);</span><br><span class="line">	&#x2F;&#x2F;刷新该类的缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">&#x2F;&#x2F;追加所有分类属性</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#x2F;&#x2F;追加所有分类协议</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);&#x2F;&#x2F;释放数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rw-gt-list-gt-attachLists-解析"><a href="#rw-gt-list-gt-attachLists-解析" class="headerlink" title="rw-&gt;list-&gt;attachLists()解析"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">       if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">       if (hasArray()) &#123;</span><br><span class="line">           &#x2F;&#x2F; many lists -&gt; many lists</span><br><span class="line">           uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">		&#x2F;&#x2F;一共需要的数量</span><br><span class="line">           uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">		&#x2F;&#x2F;分配内存 内存不够用了，需要扩容</span><br><span class="line">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">		&#x2F;&#x2F;赋值count</span><br><span class="line">           array()-&gt;count &#x3D; newCount;</span><br><span class="line">		&#x2F;&#x2F; array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br><span class="line">           memmove(array()-&gt;lists + addedCount&#x2F;*数组末尾*&#x2F;, array()-&gt;lists&#x2F;*数组*&#x2F;,</span><br><span class="line">                   oldCount * sizeof(array()-&gt;lists[0])&#x2F;*移动的大小*&#x2F;);</span><br><span class="line">		&#x2F;&#x2F;空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">		&#x2F;*</span><br><span class="line">		图示讲解：</span><br><span class="line">		array()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">	addedCount:3</span><br><span class="line">	addedLists:P-&gt;L-&gt;V</span><br><span class="line">		memmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">		然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</span><br><span class="line">		P-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</span><br><span class="line">		 *&#x2F;</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">           &#x2F;&#x2F; 0 lists -&gt; 1 list</span><br><span class="line">           list &#x3D; addedLists[0];</span><br><span class="line">       &#125; </span><br><span class="line">       else &#123;</span><br><span class="line">           &#x2F;&#x2F; 1 list -&gt; many lists</span><br><span class="line">           List* oldList &#x3D; list;</span><br><span class="line">           uint32_t oldCount &#x3D; oldList ? 1 : 0;</span><br><span class="line">           uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">           array()-&gt;count &#x3D; newCount;</span><br><span class="line">           if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;</span><br><span class="line">           memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                  addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>
<h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_resolveMethod</span><br><span class="line">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</span><br><span class="line">* 如果存在了则不检查</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;&#x2F;&#x2F;不是元类则调用 实例的</span><br><span class="line">	&#x2F;&#x2F;首先调用</span><br><span class="line">		_class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">		&#x2F;&#x2F;寻找classMethod</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_resolveInstanceMethod</span><br><span class="line">* 调用 class添加的函数 +resolveInstanceMethod</span><br><span class="line">* 有可能是元类</span><br><span class="line">* 如果方法存在则不检查</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态解析至此完成。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache &#x2F;&#x2F;开始__objc_msgForward_impcache</span><br><span class="line">	&#x2F;&#x2F; No stret specialization.</span><br><span class="line">	b	__objc_msgForward&#x2F;&#x2F;跳转-&gt;__objc_msgForward</span><br><span class="line">	END_ENTRY __objc_msgForward_impcache &#x2F;&#x2F; 结束__objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY __objc_msgForward &#x2F;&#x2F; 开始 __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]&#x2F;&#x2F;p17&#x3D; x17 和 __objc_forward_handler@PAGEOFF的和</span><br><span class="line">	TailCallFunctionPointer x17 &#x2F;&#x2F;跳转-&gt; TailCallFunctionPointer</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgForward&#x2F;&#x2F;结束 __objc_msgForward</span><br></pre></td></tr></table></figure>
<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>
<p>网上有大神总结的点我们先参考下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line">int __forwarding__(void *frameStackPointer, int isStret) &#123;</span><br><span class="line">    id receiver &#x3D; *(id *)frameStackPointer;</span><br><span class="line">    SEL sel &#x3D; *(SEL *)(frameStackPointer + 8);</span><br><span class="line">    const char *selName &#x3D; sel_getName(sel);</span><br><span class="line">    Class receiverClass &#x3D; object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 forwardingTargetForSelector:</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget &#x3D; [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        if (forwardingTarget &amp;&amp; forwardingTarget !&#x3D; receiver) &#123;</span><br><span class="line">            if (isStret &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                int ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;</span><br><span class="line">            return objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 僵尸对象</span><br><span class="line">    const char *className &#x3D; class_getName(receiverClass);</span><br><span class="line">    const char *zombiePrefix &#x3D; &quot;_NSZombie_&quot;;</span><br><span class="line">    size_t prefixLen &#x3D; strlen(zombiePrefix); &#x2F;&#x2F; 0xa</span><br><span class="line">    if (strncmp(className, zombiePrefix, prefixLen) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        CFLog(kCFLogLevelError,</span><br><span class="line">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br><span class="line">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature &#x3D; [receiver methodSignatureForSelector:sel];</span><br><span class="line">        if (methodSignature) &#123;</span><br><span class="line">            BOOL signatureIsStret &#x3D; [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            if (signatureIsStret !&#x3D; isStret) &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#39;%s&#39;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? &quot;&quot; : not,</span><br><span class="line">                      isStret ? &quot;&quot; : not);</span><br><span class="line">            &#125;</span><br><span class="line">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">                NSInvocation *invocation &#x3D; [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                void *returnValue &#x3D; NULL;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                return returnValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @&quot;*** NSForwarding: warning: object %p of class &#39;%s&#39; does not implement forwardInvocation: -- dropping message&quot;,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel &#x3D; sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; selector 是否已经在 Runtime 注册过</span><br><span class="line">    if (sel !&#x3D; registeredSel) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: selector (%p) for message &#39;%s&#39; does not match selector known to Objective C runtime (%p)-- abort&quot;,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; &#x2F;&#x2F; doesNotRecognizeSelector</span><br><span class="line">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @&quot;*** NSForwarding: warning: object %p of class &#39;%s&#39; does not implement doesNotRecognizeSelector: -- abort&quot;,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The point of no return.</span><br><span class="line">    kill(getpid(), 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证动态解析"><a href="#验证动态解析" class="headerlink" title="验证动态解析"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">		Method me &#x3D; class_getInstanceMethod(self, @selector(test2));</span><br><span class="line">		class_addMethod(self, sel,</span><br><span class="line">						method_getImplementation(me),</span><br><span class="line">						method_getTypeEncoding(me));</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test2&#123;</span><br><span class="line">	NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *p &#x3D; [[Person alloc]init];</span><br><span class="line">[p test];</span><br><span class="line">[p test];</span><br><span class="line"> &#x2F;&#x2F;输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line"> -[FYPerson test3]</span><br><span class="line"> -[FYPerson test3]</span><br></pre></td></tr></table></figure>
<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>
<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">+ (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">	NSLog(@&quot;来了，老弟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">		Method me &#x3D; class_getClassMethod(self, @selector(test3));&#x2F;&#x2F;获取method</span><br><span class="line">		&#x2F;&#x2F;给sel 添加方法实现 @selecter(test3)</span><br><span class="line">		class_addMethod(object_getClass(self), sel,</span><br><span class="line">						method_getImplementation(me),</span><br><span class="line">						method_getTypeEncoding(me));</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Person test];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[Person resolveClassMethod:]</span><br><span class="line">来了，老弟</span><br></pre></td></tr></table></figure>
<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">&#x2F;&#x2F;        Method me &#x3D; class_getInstanceMethod(self, @selector(test3));</span><br><span class="line">&#x2F;&#x2F;        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</span><br><span class="line">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">void test3(id self,SEL sel)&#123;</span><br><span class="line">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[FYPerson resolveInstanceMethod:]</span><br><span class="line">test3:test</span><br><span class="line">test3:test</span><br></pre></td></tr></table></figure>
<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>
<h3 id="验证消息转发"><a href="#验证消息转发" class="headerlink" title="验证消息转发"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">		&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [[Struent alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Student test]</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>
<p>第一步没拦截，可以在第二步拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消息转发第二步 没有对象来处理方法，那将函数签名来实现</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if (aSelector &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">		NSMethodSignature *sign &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">		return sign;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数签名已返回，到了函数调用的地方</span><br><span class="line">&#x2F;&#x2F;selector 函数的sel</span><br><span class="line">&#x2F;&#x2F;target   函数调用者</span><br><span class="line">&#x2F;&#x2F;methodSignature 函数签名</span><br><span class="line">&#x2F;&#x2F;NSInvocation  封装数据的对象</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Person forwardInvocation:]</span><br></pre></td></tr></table></figure></p>
<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, retain) NSMethodSignature *methodSignature;&#x2F;&#x2F;只读</span><br><span class="line">- (void)retainArguments;</span><br><span class="line">@property (readonly) BOOL argumentsRetained;</span><br><span class="line">@property (nullable, assign) id target;&#x2F;&#x2F;读写</span><br><span class="line">@property SEL selector;&#x2F;&#x2F;读写</span><br></pre></td></tr></table></figure>
<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;class 转发</span><br><span class="line">&#x2F;&#x2F; 消息转发第一步 拦截是否有转发的class对象处理方法</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">		&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [Student class];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)test3&#123;</span><br><span class="line">&#x2F;&#x2F;	NSLog(@&quot;+[Student test3]&quot;);</span><br><span class="line">&#x2F;&#x2F;当[Person test3]上一行写这么一行，Person *p &#x3D; [[Person alloc]init] 这句报错</span><br><span class="line">&#x2F;&#x2F;暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</span><br><span class="line">&#x2F;&#x2F;注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">-[Student test2]</span><br></pre></td></tr></table></figure>
<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">	if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">		&#x2F;&#x2F;objc_msgSend([[Struent alloc]init],test)</span><br><span class="line">		return [[Student alloc]init];</span><br><span class="line">	&#125;</span><br><span class="line">	return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">-[Student test3]</span><br></pre></td></tr></table></figure>
<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消息转发第二步 没有class来处理方法，那将函数签名来实现</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if (aSelector &#x3D;&#x3D; @selector(test3)) &#123;</span><br><span class="line">		NSMethodSignature *sign &#x3D; [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">		return sign;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数签名已返回，到了函数调用的地方</span><br><span class="line">&#x2F;&#x2F;selector 函数的sel</span><br><span class="line">&#x2F;&#x2F;target   函数调用者</span><br><span class="line">&#x2F;&#x2F;methodSignature 函数签名</span><br><span class="line">&#x2F;&#x2F;NSInvocation  封装数据的对象</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">&#x2F;&#x2F;	anInvocation.selector &#x3D; @selector(test2);</span><br><span class="line">&#x2F;&#x2F;此处换成[Student class]同样可以</span><br><span class="line">&#x2F;&#x2F;	anInvocation.target &#x3D; (id)[[Student alloc]init];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	[anInvocation invoke];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">+[Person forwardInvocation:]</span><br></pre></td></tr></table></figure>
<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>
<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>
<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>
<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>
<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></li>
</ul>
<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/87e5f745.html" rel="next" title="iOS底层原理 runtime-object_class拾遗基础篇--(6)">
                <i class="fa fa-chevron-left"></i> iOS底层原理 runtime-object_class拾遗基础篇--(6)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/fc8d88f4.html" rel="prev" title="iOS底层原理 runtime - super、hook、以及简单应用--(8)">
                iOS底层原理 runtime - super、hook、以及简单应用--(8) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container">
    </div>
    
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.ico"
                alt="fgyong" />
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmc=" title="GitHub &rarr; https://github.com/ifgyong"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci8xNzUwMDc4MjM5MjkwOTA5" title="掘金 &rarr; https://juejin.im/user/1750078239290909"><i class="fa fa-fw fa-掘金"></i>掘金</span>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息发送"><span class="nav-number"></span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#realizeClass-解析"><span class="nav-number">1.</span> <span class="nav-text">realizeClass()解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#attachCategories-解析"><span class="nav-number">2.</span> <span class="nav-text">attachCategories()解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rw-gt-list-gt-attachLists-解析"><span class="nav-number">3.</span> <span class="nav-text">rw-&gt;list-&gt;attachLists()解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息动态解析"><span class="nav-number"></span> <span class="nav-text">消息动态解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发"><span class="nav-number"></span> <span class="nav-text">消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证动态解析"><span class="nav-number"></span> <span class="nav-text">验证动态解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证消息转发"><span class="nav-number"></span> <span class="nav-text">验证消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number"></span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资料下载"><span class="nav-number">1.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <span class="exturl" data-url="aHR0cDovL3d3dy5taWl0YmVpYW4uZ292LmNu">豫ICP备17045226号 </span>&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> 强力驱动 v4.2.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Mist</span> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>

  
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css">

  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
    
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'a7800c37057fc3ce83df',
          clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
          repo: 'ifgyong.github.io',
          owner: 'ifgyong',
          admin: ['ifgyong'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  

  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=6.6.0"></script>


  

  

  

</body>
</html>
