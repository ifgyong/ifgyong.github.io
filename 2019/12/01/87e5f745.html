<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.6.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="runtime 基础知识runtime是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个union共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构： 1234567891011121314151617">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理 runtime-object_class拾遗基础篇--(6)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/87e5f745.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="runtime 基础知识runtime是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个union共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构： 1234567891011121314151617">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="article:published_time" content="2019-12-01T03:16:58.000Z">
<meta property="article:modified_time" content="2020-09-04T07:33:30.841Z">
<meta property="article:author" content="fgyong">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fgyong.cn/images/0.png">


  


  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml" />




  <link rel="canonical" href="http://fgyong.cn/2019/12/01/87e5f745.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理 runtime-object_class拾遗基础篇--(6) | fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">不忘初心 方得始终</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">44</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">8</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">24</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/87e5f745.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS底层原理 runtime-object_class拾遗基础篇--(6)
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:16:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:16:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-04 15:33:30" itemprop="dateModified" datetime="2020-09-04T15:33:30+08:00">2020-09-04</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="runtime-基础知识"><a href="#runtime-基础知识" class="headerlink" title="runtime 基础知识"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line">    &#x2F;&#x2F; getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    &#x2F;&#x2F;****</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;isa.h&quot;</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  &#x2F;&#x2F; defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                         </span><br><span class="line">      uintptr_t nonpointer        : 1;                              </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                 </span><br><span class="line">      uintptr_t nonpointer        : 1;                                  </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;7)</span><br><span class="line"># else</span><br><span class="line">#   error unknown architecture for packed isa</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure>
<p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    struct &#123;</span><br><span class="line">      uintptr_t nonpointer        : 1;                                </span><br><span class="line">      uintptr_t has_assoc         : 1;                                  </span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                  </span><br><span class="line">      uintptr_t shiftcls          : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \</span><br><span class="line">      uintptr_t magic             : 6;                                  </span><br><span class="line">      uintptr_t weakly_referenced : 1;                                  </span><br><span class="line">      uintptr_t deallocating      : 1;                                  </span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                  </span><br><span class="line">      uintptr_t extra_rc          : 8</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p>
<h4 id="共用体基础知识"><a href="#共用体基础知识" class="headerlink" title="共用体基础知识"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson : NSObject</span><br><span class="line">@property (nonatomic,assign) BOOL rich;</span><br><span class="line">@property (nonatomic,assign) BOOL tell;</span><br><span class="line">@property (nonatomic,assign) BOOL handsome;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后查看该类的实例占用空间大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">		p.handsome &#x3D; YES;</span><br><span class="line">		p.rich &#x3D; NO;</span><br><span class="line">		NSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</span><br><span class="line">		&#x2F;&#x2F;16</span><br></pre></td></tr></table></figure>
<p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现：</span><br><span class="line">&#x2F;&#x2F;使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</span><br><span class="line">&#x2F;&#x2F;#define FYHandsomeMask 0b00000001</span><br><span class="line">&#x2F;&#x2F;#define FYTallMask 0b00000010</span><br><span class="line">&#x2F;&#x2F;#define FYRichMask 0b00000001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FYHandsomeMask (1&lt;&lt;0)</span><br><span class="line">#define FYTallMask (1&lt;&lt;1)</span><br><span class="line">#define FYRichMask (1&lt;&lt;2)</span><br><span class="line"></span><br><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">	char _richTellHandsome;&#x2F;&#x2F;0000 0000 rich tall handsome</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome|FYRichMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome&amp;~FYRichMask;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome|FYTallMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome&amp;~FYTallMask;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome|FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome&amp;~FYHandsomeMask;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return !!(_richTellHandsome&amp;FYHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;	char _richTellHandsome;&#x2F;&#x2F;0000 0000 rich tall handsome</span><br><span class="line">	&#x2F;&#x2F;位域</span><br><span class="line">	struct&#123;</span><br><span class="line">		char tall : 1;&#x2F;&#x2F;高度</span><br><span class="line">		char rich : 1;&#x2F;&#x2F;富有</span><br><span class="line">		char handsome : 1; &#x2F;&#x2F;帅</span><br><span class="line">	&#125; _richTellHandsome; &#x2F;&#x2F; 0b0000 0000</span><br><span class="line">	&#x2F;&#x2F;使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</span><br><span class="line">	&#x2F;&#x2F;使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.rich &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.tall &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	_richTellHandsome.handsome &#x3D; tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!_richTellHandsome.rich;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!_richTellHandsome.tall;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return !!_richTellHandsome.handsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (tall) &#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome|FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome &#x3D; _richTellHandsome&amp;~FYHandsomeMask</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface FYPerson()</span><br><span class="line">&#123;</span><br><span class="line">	union &#123;</span><br><span class="line">		char bits; &#x2F;&#x2F;一个字节8位 ricH &#x2F;tall&#x2F;handsome都是占用的bits的内存空间</span><br><span class="line">		struct&#123;</span><br><span class="line">			char tall : 1;&#x2F;&#x2F;高度</span><br><span class="line">			char rich : 1;&#x2F;&#x2F;富有</span><br><span class="line">			char handsome : 1; &#x2F;&#x2F;帅</span><br><span class="line">		&#125;; &#x2F;&#x2F; 0b0000 0000</span><br><span class="line">	&#125;_richTellHandsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation FYPerson</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |&#x3D; FYRichMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;&#x3D; ~FYRichMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setTall:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |&#x3D; FYTallMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;&#x3D; ~FYTallMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setHandsome:(BOOL)tall&#123;</span><br><span class="line">	if (tall) &#123;</span><br><span class="line">		_richTellHandsome.bits |&#x3D; FYHandsomeMask;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		_richTellHandsome.bits &amp;&#x3D; ~FYHandsomeMask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isRich&#123;</span><br><span class="line">	return !!(_richTellHandsome.bits &amp; FYRichMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isTall&#123;</span><br><span class="line">	return !!(_richTellHandsome.bits &amp; FYTallMask);</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isHandsome&#123;</span><br><span class="line">	return (_richTellHandsome.bits &amp; FYHandsomeMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</span><br><span class="line">        NSKeyValueObservingOptionNew &#x3D; 0x01,</span><br><span class="line">    NSKeyValueObservingOptionOld &#x3D; 0x02,</span><br><span class="line">    NSKeyValueObservingOptionInitial &#x3D; 0x04,</span><br><span class="line">    NSKeyValueObservingOptionPrior &#x3D; 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">	FYOne &#x3D; 1,&#x2F;&#x2F;  0b 0001</span><br><span class="line">	FYTwo &#x3D; 2,&#x2F;&#x2F;  0b 0010</span><br><span class="line">	FYTHree &#x3D; 4,&#x2F;&#x2F;0b 0100</span><br><span class="line">	FYFour &#x3D; 8,&#x2F;&#x2F; 0b 1000</span><br><span class="line">&#125;FYOptions;</span><br><span class="line"></span><br><span class="line">- (void)setOptions:(FYOptions )ops&#123;</span><br><span class="line">	if (ops &amp;FYOne) &#123;</span><br><span class="line">		NSLog(@&quot;FYOne is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYTwo) &#123;</span><br><span class="line">		NSLog(@&quot;FYTwo is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYTHree) &#123;</span><br><span class="line">		NSLog(@&quot;FYTHree is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ops &amp;FYFour) &#123;</span><br><span class="line">		NSLog(@&quot;FYFour is show&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self setOptions:FYOne|FYTwo|FYTHree];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出是：</span><br><span class="line">FYOne is show</span><br><span class="line">FYTwo is show</span><br><span class="line">FYTHree is show</span><br></pre></td></tr></table></figure>
<p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p>
<h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nonpointer</td>
<td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td>
</tr>
<tr>
<td>has_assoc</td>
<td>是否有设置过关联对象，如果没有，释放时会更快</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>存储着Class、Meta-Class对象的内存地址信息</td>
</tr>
<tr>
<td>magic</td>
<td>用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>是否有被弱引用指向过，如果没有，释放时会更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>对象是否正在释放</td>
</tr>
<tr>
<td>extra_rc</td>
<td>里面存储的值是引用计数器减1</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>引用计数器是否过大无法存储在isa中</td>
</tr>
</tbody>
</table>
<p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p>
<p>class结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct fy_objc_class : xx_objc_object &#123;</span><br><span class="line">	Class superclass;</span><br><span class="line">	cache_t cache;</span><br><span class="line">	class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">	class_rw_t* data() &#123;</span><br><span class="line">		return bits.data();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fy_objc_class* metaClass() &#123; &#x2F;&#x2F; 提供metaClass函数，获取元类对象</span><br><span class="line">		&#x2F;&#x2F; 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</span><br><span class="line">		return (fy_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t version;</span><br><span class="line">	const class_ro_t *ro;&#x2F;&#x2F;只读 数据</span><br><span class="line">	method_list_t * methods;    &#x2F;&#x2F; 方法列表</span><br><span class="line">	property_list_t *properties;    &#x2F;&#x2F; 属性列表</span><br><span class="line">	const protocol_list_t * protocols;  &#x2F;&#x2F; 协议列表</span><br><span class="line">	Class firstSubclass;</span><br><span class="line">	Class nextSiblingClass;</span><br><span class="line">	char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	uint32_t instanceStart;</span><br><span class="line">	uint32_t instanceSize;  &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">	uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">	const uint8_t * ivarLayout;</span><br><span class="line">	const char * name;  &#x2F;&#x2F; 类名</span><br><span class="line">	method_list_t * baseMethodList;</span><br><span class="line">	protocol_list_t * baseProtocols;</span><br><span class="line">	const ivar_list_t * ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">	const uint8_t * weakIvarLayout;</span><br><span class="line">	property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    &#x2F;&#x2F;如果已注册 就返回</span><br><span class="line">    if (cls-&gt;isRealized()) return cls;</span><br><span class="line">    assert(cls &#x3D;&#x3D; remapClass(cls));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme verify class is not in an un-dlopened part of the shared cache?</span><br><span class="line">&#x2F;&#x2F;只读ro</span><br><span class="line">    ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        &#x2F;&#x2F; This was a future class. rw data is already allocated.</span><br><span class="line">        rw &#x3D; cls-&gt;data();&#x2F;&#x2F;初始化ro</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Normal class. Allocate writeable class data.</span><br><span class="line">        &#x2F;&#x2F;初始化 rw </span><br><span class="line">        rw &#x3D; (class_rw_t *)calloc(sizeof(class_rw_t), 1);</span><br><span class="line">        rw-&gt;ro &#x3D; ro;</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING;</span><br><span class="line">        &#x2F;&#x2F;指针指向rw 一开始是指向ro的</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isMeta &#x3D; ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version &#x3D; isMeta ? 7 : 0;  &#x2F;&#x2F; old runtime went up to 6</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t&gt; </span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_list_t **beginCategoryMethodLists() &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    method_list_t **endCategoryMethodLists(Class cls);</span><br><span class="line"></span><br><span class="line">    method_array_t duplicate() &#123;</span><br><span class="line">        return Super::duplicate&lt;method_array_t&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><ul>
<li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似</li>
<li>可以通过@selector()和sel_registerName()获得</li>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
<h5 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9BcnRpY2xlcy9vY3J0VHlwZUVuY29kaW5ncy5odG1s" title="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">官方网站插件encodeing<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th>code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>A char</td>
</tr>
<tr>
<td>i</td>
<td>An int</td>
</tr>
<tr>
<td>s</td>
<td>A short</td>
</tr>
<tr>
<td>l</td>
<td>A long</td>
</tr>
<tr>
<td>l</td>
<td>is treated as a 32-bit quantity on 64-bit programs.</td>
</tr>
<tr>
<td>q</td>
<td>A long long</td>
</tr>
<tr>
<td>C</td>
<td>An unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>An unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>An unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>An unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>An unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>A float</td>
</tr>
<tr>
<td>d</td>
<td>A double</td>
</tr>
<tr>
<td>B</td>
<td>A C++ bool or a C99 _Bool</td>
</tr>
<tr>
<td>v</td>
<td>A void</td>
</tr>
<tr>
<td>*</td>
<td>A character string (char *)</td>
</tr>
<tr>
<td>@</td>
<td>An object (whether statically typed or typed id)</td>
</tr>
<tr>
<td>#</td>
<td>A class object (Class)</td>
</tr>
<tr>
<td>:</td>
<td>A method selector (SEL)</td>
</tr>
<tr>
<td>[array type]</td>
<td>An array</td>
</tr>
<tr>
<td>{name=type…}</td>
<td>A structure</td>
</tr>
<tr>
<td>(name=type…)</td>
<td>A union</td>
</tr>
<tr>
<td>bnum</td>
<td>A bit field of num bits</td>
</tr>
<tr>
<td>^type</td>
<td>A pointer to type</td>
</tr>
<tr>
<td>?</td>
<td>An unknown type (among other things, this code is used for function pointers)</td>
</tr>
</tbody>
</table>
<p>我们通过一个例子来了解encode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)test:(int)age heiht:(float)height&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FYPerson *p&#x3D;[[FYPerson alloc]init];</span><br><span class="line">	SEL sel &#x3D; @selector(test:heiht:);</span><br><span class="line">	Method m1&#x3D; class_getInstanceMethod(p.class, sel);</span><br><span class="line">	const char *type &#x3D; method_getTypeEncoding(m1);</span><br><span class="line">	NSLog(@&quot;%s&quot;,type);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;输出</span><br><span class="line">	v24@0:8i16f20</span><br><span class="line">	&#x2F;&#x2F;0id 8 SEL 16 int 20 float &#x3D; 24</span><br></pre></td></tr></table></figure>
<p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p>
<h4 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;&#x2F;&#x2F;散列表</span><br><span class="line">    mask_t _mask;&#x2F;&#x2F;散列表长度-1</span><br><span class="line">    mask_t _occupied;&#x2F;&#x2F;已经存储的方法数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">#if __arm64__</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">#else</span><br><span class="line">    cache_key_t _key;&#x2F;&#x2F;SEL作为key </span><br><span class="line">    MethodCacheIMP _imp; &#x2F;&#x2F;函数地址</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列表的数据结构表格所示</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>bucket_t</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>1</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>2</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>3</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>4</td>
<td>bucket_t(_key,_imp)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; mask();</span><br><span class="line">	&#x2F;&#x2F;key&amp;mask 得到索引</span><br><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hack</span><br><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span><br><span class="line">&#x2F;&#x2F; Caches are never built in the dyld shared cache.</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef MJClassInfo_h</span><br><span class="line">#define MJClassInfo_h</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br><span class="line">typedef uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line">#if __arm__  ||  __x86_64__  ||  __i386__</span><br><span class="line">&#x2F;&#x2F; objc_msgSend has few registers available.</span><br><span class="line">&#x2F;&#x2F; Cache scan increments and wraps at special end-marking bucket.</span><br><span class="line">#define CACHE_END_MARKER 1</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif __arm64__</span><br><span class="line">&#x2F;&#x2F; objc_msgSend has lots of registers available.</span><br><span class="line">&#x2F;&#x2F; Cache scan decrements. No end marker needed.</span><br><span class="line">#define CACHE_END_MARKER 0</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#error unknown architecture</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">    </span><br><span class="line">    IMP imp(SEL selector)</span><br><span class="line">    &#123;</span><br><span class="line">        mask_t begin &#x3D; _mask &amp; (long long)selector;</span><br><span class="line">        mask_t i &#x3D; begin;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (_buckets[i]._key &#x3D;&#x3D; 0  ||  _buckets[i]._key &#x3D;&#x3D; (long long)selector) &#123;</span><br><span class="line">                return _buckets[i]._imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ((i &#x3D; cache_next(i, _mask)) !&#x3D; begin);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct method_list_t : entsize_list_tt &#123;</span><br><span class="line">    method_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *type;</span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ivar_list_t : entsize_list_tt &#123;</span><br><span class="line">    ivar_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct property_list_t : entsize_list_tt &#123;</span><br><span class="line">    property_t first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct chained_property_list &#123;</span><br><span class="line">    chained_property_list *next;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    property_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;</span><br><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  &#x2F;&#x2F; 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    &#x2F;&#x2F; 方法列表</span><br><span class="line">    property_list_t *properties;    &#x2F;&#x2F; 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  &#x2F;&#x2F; 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* OC对象 *&#x2F;</span><br><span class="line">struct mj_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 类对象 *&#x2F;</span><br><span class="line">struct mj_objc_class : mj_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mj_objc_class* metaClass() &#123;</span><br><span class="line">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>测试代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">		Method test1Method &#x3D; class_getInstanceMethod(p.class, @selector(test));</span><br><span class="line">		Method test2Method &#x3D; class_getInstanceMethod(p.class, @selector(test2));</span><br><span class="line">		IMP imp1&#x3D; method_getImplementation(test1Method);</span><br><span class="line">		IMP imp2&#x3D; method_getImplementation(test2Method);</span><br><span class="line"></span><br><span class="line">		mj_objc_class *cls &#x3D; (__bridge mj_objc_class *)p.class;</span><br><span class="line">		NSLog(@&quot;-----&quot;);</span><br><span class="line">		[p test];</span><br><span class="line">		[p test2];</span><br><span class="line">		cache_t cache &#x3D; cls-&gt;cache;</span><br><span class="line">		bucket_t *buck &#x3D; cache._buckets;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; cache._mask; i ++) &#123;</span><br><span class="line">			bucket_t item &#x3D; buck[i];</span><br><span class="line">			if (item._key !&#x3D; 0) &#123;</span><br><span class="line">				NSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;输出</span><br><span class="line">p imp1</span><br><span class="line">(IMP) $0 &#x3D; 0x0000000100000df0 (day11-runtime1&#96;-[FYPerson test] at FYPerson.m:12)</span><br><span class="line">(lldb) p imp2</span><br><span class="line">(IMP) $1 &#x3D; 0x0000000100000e20 (day11-runtime1&#96;-[FYPerson test2] at FYPerson.m:15)</span><br><span class="line">p&#x2F;d @selector(test)             &#x2F;&#x2F;输出 test方法的sel地址</span><br><span class="line">(SEL) $6 &#x3D; 140734025103231 &quot;test&quot;</span><br><span class="line">(lldb) p&#x2F;d @selector(test2)     &#x2F;&#x2F;输出 test2方法的sel地址</span><br><span class="line">(SEL) $7 &#x3D; 4294971267 &quot;test2&quot;</span><br><span class="line"></span><br><span class="line">key1:140733954181041 imp1:0x7fff59fc4cd1</span><br><span class="line">key2:4294971267 imp2:0x100000e20         &#x2F;&#x2F;对应test2</span><br><span class="line">key3:140734025103231 imp3:0x100000df0    &#x2F;&#x2F;对应test1</span><br></pre></td></tr></table></figure>
<p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当initialized 没有执行完毕的时候不缓存</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache &lt;&#x3D; 3&#x2F;4 </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        扩容 之后，缓存清空</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;bucket_t 最小是4，当&gt;3&#x2F;4时候，扩容，空间扩容之后是之前的2️倍。</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FYPerson *p &#x3D; [[FYPerson alloc]init];</span><br><span class="line">mj_objc_class *cls &#x3D; (__bridge mj_objc_class *)p.class;</span><br><span class="line">NSLog(@&quot;-----&quot;);</span><br><span class="line">[p test];</span><br><span class="line">&#x2F;*</span><br><span class="line"> key:init imp:0x7fff58807c2d</span><br><span class="line"> key:class imp:0x7fff588084b7</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test imp:0x100000bf0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> *&#x2F;</span><br><span class="line">[p test2]; &#x2F;&#x2F;当执行该函数的时候</span><br><span class="line">&#x2F;*</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> key:test2 imp:0x100000c20</span><br><span class="line"> key:(null) imp:0x0</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">cache_t cache &#x3D; cls-&gt;cache;</span><br><span class="line">bucket_t *buck &#x3D; cache._buckets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; cache._mask; i ++) &#123;</span><br><span class="line">	bucket_t item &#x3D; buck[i];</span><br><span class="line">&#x2F;&#x2F;            if (item._key !&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;                printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">    printf(&quot;key:%s imp:%p \n&quot;,(const char *)item._key,item._imp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li>
<li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li>
<li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li>
<li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li>
<li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li>
</ul>
<h4 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvaU9TRGF0YUZhY3Rvcnk=" title="https://github.com/ifgyong/iOSDataFactory">学习资料下载<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQw==" title="https://github.com/ifgyong/demo/tree/master/OC">demo code<i class="fa fa-external-link"></i></span></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmcvZGVtby90cmVlL21hc3Rlci9PQy9vYmpjNC03NTA=" title="https://github.com/ifgyong/demo/tree/master/OC/objc4-750">runtime可运行的源码<i class="fa fa-external-link"></i></span></p>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
</li>
</ul>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/56eded6e.html" rel="next" title="iOS底层原理  block本质 --(5)">
                <i class="fa fa-chevron-left"></i> iOS底层原理  block本质 --(5)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/e64bf1f.html" rel="prev" title="iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)">
                iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container">
    </div>
    
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/favicon.ico"
                alt="fgyong" />
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lmZ3lvbmc=" title="GitHub &rarr; https://github.com/ifgyong"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci8xNzUwMDc4MjM5MjkwOTA5" title="掘金 &rarr; https://juejin.im/user/1750078239290909"><i class="fa fa-fw fa-掘金"></i>掘金</span>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-基础知识"><span class="nav-number">1.</span> <span class="nav-text">runtime 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共用体基础知识"><span class="nav-number">1.1.</span> <span class="nav-text">共用体基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class的结构"><span class="nav-number">1.2.</span> <span class="nav-text">Class的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SEL"><span class="nav-number">1.2.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Type-Encoding"><span class="nav-number">1.2.2.</span> <span class="nav-text">Type Encoding</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法缓存"><span class="nav-number">1.3.</span> <span class="nav-text">方法缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资料下载"><span class="nav-number">2.1.</span> <span class="nav-text">资料下载</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <span class="exturl" data-url="aHR0cDovL3d3dy5taWl0YmVpYW4uZ292LmNu">豫ICP备17045226号 </span>&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> 强力驱动 v4.2.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Mist</span> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>

  
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css">

  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
    
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'a7800c37057fc3ce83df',
          clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
          repo: 'ifgyong.github.io',
          owner: 'ifgyong',
          admin: ['ifgyong'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  

  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=6.6.0"></script>


  

  

  

</body>
</html>
