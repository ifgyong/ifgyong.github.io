<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=6.6.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)">
<meta property="og:url" content="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/index.html">
<meta property="og:site_name" content="fgyong的技术博客">
<meta property="og:description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://fgyong.cn/images/9-1.png">
<meta property="og:image" content="http://fgyong.cn/images/9-2.png">
<meta property="og:image" content="http://fgyong.cn/images/0.png">
<meta property="og:updated_time" content="2020-09-03T08:24:13.609Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)">
<meta name="twitter:description" content="使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的jsonToModel,iOS除了runtime还有一个东西的叫做runloop，各位看官老爷一定都有了解，那么今天这篇文章初识一下runloop。 什么是runloop简单来讲runloop就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了runloop，保证">
<meta name="twitter:image" content="http://fgyong.cn/images/9-1.png">



  <link rel="alternate" href="/atom.xml" title="fgyong的技术博客" type="application/atom+xml">




  <link rel="canonical" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9) | fgyong的技术博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fgyong的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不忘初心 方得始终</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">44</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">8</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">24</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fgyong.cn/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fgyong">
      <meta itemprop="description" content="在学习的路上，不忘初心 方得始终">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fgyong的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 11:19:58" itemprop="dateCreated datePublished" datetime="2019-12-01T11:19:58+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-03 16:24:13" itemprop="dateModified" datetime="2020-09-03T16:24:13+08:00">2020-09-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>
<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ret = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    //睡眠中等待消息</span><br><span class="line">    int messgae = sleep_and_wait();</span><br><span class="line">    //处理消息</span><br><span class="line">    ret = process_message(messgae);</span><br><span class="line">&#125; while (ret == 0);</span><br></pre></td></tr></table></figure>
<h3 id="获取runloop"><a href="#获取runloop" class="headerlink" title="获取runloop"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</span><br><span class="line">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</span><br><span class="line"></span><br><span class="line">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</span><br><span class="line">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</span><br><span class="line">NSLog(@&quot;%@&quot;,runloop1);</span><br><span class="line">//打印</span><br><span class="line">runlopp1:0x600001bc58c0 </span><br><span class="line">mainloop1:0x600001bc58c0 </span><br><span class="line">runloop2:0x6000003cc300 </span><br><span class="line">mainloop1:0x6000003cc300</span><br><span class="line"></span><br><span class="line">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</span><br></pre></td></tr></table></figure>
<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>
<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;			/* model list 锁 */</span><br><span class="line">    __CFPort _wakeUpPort;			// 接受 CFRunLoopWakeUp的端口</span><br><span class="line">    Boolean _unused;//是否使用</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread; //线程</span><br><span class="line">    uint32_t _winthread;//win线程</span><br><span class="line">    CFMutableSetRef _commonModes; //modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; //modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; //当前的mode</span><br><span class="line">    CFMutableSetRef _modes; //所有的modes</span><br><span class="line">    struct _block_item *_blocks_head; //待执行的block列表头部</span><br><span class="line">    struct _block_item *_blocks_tail; //待执行的block 尾部</span><br><span class="line">    CFAbsoluteTime _runTime; //runtime</span><br><span class="line">    CFAbsoluteTime _sleepTime; //sleeptime</span><br><span class="line">    CFTypeRef _counterpart; //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过简化之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread; //线程</span><br><span class="line">    CFMutableSetRef _commonModes; //modes</span><br><span class="line">    CFMutableSetRef _commonModeItems; //modeItems</span><br><span class="line">    CFRunLoopModeRef _currentMode; //当前的mode</span><br><span class="line">    CFMutableSetRef _modes; //所有的modes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>
<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>
<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>
</ol>
<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过简化之后是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;//当前mode的名字</span><br><span class="line">    CFMutableSetRef _sources0;//souces0</span><br><span class="line">    CFMutableSetRef _sources1;//sources1</span><br><span class="line">    CFMutableArrayRef _observers;//observers</span><br><span class="line">    CFMutableArrayRef _timers;//timers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>
<p><img src="/images/9-1.png" alt></p>
<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>
<h4 id="souces0"><a href="#souces0" class="headerlink" title="souces0"></a>souces0</h4><ul>
<li>触摸事件</li>
<li>performSelector:onThread:</li>
</ul>
<p>测试下点击事件处理源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);//此处断点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(LLDB) bt //输出当前调用栈</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</span><br><span class="line">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</span><br><span class="line">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</span><br><span class="line">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</span><br><span class="line">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</span><br><span class="line">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</span><br><span class="line">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</span><br><span class="line">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</span><br><span class="line">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</span><br><span class="line">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</span><br><span class="line">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</span><br><span class="line">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</span><br><span class="line">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</span><br><span class="line">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</span><br><span class="line">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</span><br><span class="line">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</span><br><span class="line">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</span><br><span class="line">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</span><br></pre></td></tr></table></figure>
<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>
<h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
<h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">	static int count = 5;</span><br><span class="line">	dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">	dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">		NSLog(@&quot;-------：%d \n&quot;,count++);</span><br><span class="line">	&#125;);</span><br><span class="line">	dispatch_resume(timer);</span><br><span class="line">	//log</span><br><span class="line">	(lldb) bt</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</span><br><span class="line">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</span><br><span class="line">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</span><br><span class="line">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</span><br><span class="line">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</span><br><span class="line">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</span><br><span class="line">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</span><br><span class="line">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</span><br><span class="line">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</span><br></pre></td></tr></table></figure>
<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>
<h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</span><br><span class="line">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</span><br></pre></td></tr></table></figure>
<p>那么这两个Mode都是在什么情况下运行的呢？</p>
<ol>
<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>
</ol>
<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href="https://juejin.im/post/5d2bcf3df265da1b67213d69" target="_blank" rel="noopener">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>
<p>现在我们了解到：</p>
<ol>
<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>
<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>
<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>
<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>
</ol>
<h5 id="runloop切换Mode"><a href="#runloop切换Mode" class="headerlink" title="runloop切换Mode"></a>runloop切换Mode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">    	case kCFRunLoopEntry:&#123;</span><br><span class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    		NSLog(@&quot;即将进入 mode:%@&quot;,m);</span><br><span class="line">    		CFRelease(m);</span><br><span class="line">    		break;</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    	case kCFRunLoopExit:</span><br><span class="line">    	&#123;</span><br><span class="line">    		CFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">    		NSLog(@&quot;即将退出 mode:%@&quot;,m);</span><br><span class="line">    		CFRelease(m);</span><br><span class="line">    		break;</span><br><span class="line">    	&#125;</span><br><span class="line">    	default:</span><br><span class="line">    		break;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	CFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</span><br><span class="line">	CFRelease(obs);</span><br><span class="line">	</span><br><span class="line">	//当滑动tb的时候log</span><br><span class="line">	</span><br><span class="line">即将退出 mode:kCFRunLoopDefaultMode</span><br><span class="line">即将进入 mode:UITrackingRunLoopMode</span><br><span class="line">即将退出 mode:UITrackingRunLoopMode</span><br><span class="line">即将进入 mode:kCFRunLoopDefaultMode</span><br></pre></td></tr></table></figure>
<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>
<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//	//获取loop</span><br><span class="line">	CFRunLoopRef ref = CFRunLoopGetMain();</span><br><span class="line">	//获取obs</span><br><span class="line">	CFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</span><br><span class="line">	//添加监听</span><br><span class="line">	CFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</span><br><span class="line">	CFRelease(obs);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</span><br><span class="line">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line">	printf(&quot;- &quot;);</span><br><span class="line">	count ++;</span><br><span class="line">	printf(&quot;%d&quot;,count);</span><br><span class="line">	switch (activity) &#123;</span><br><span class="line">		case kCFRunLoopEntry:</span><br><span class="line">			printf(&quot;即将进入 \n&quot;);</span><br><span class="line">			count = 0;</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopExit:</span><br><span class="line">			printf(&quot;即将退出 \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopAfterWaiting:</span><br><span class="line">			printf(&quot;即将从休眠中唤醒 \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeTimers:</span><br><span class="line">			printf(&quot;即将进入处理 timers \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeSources:</span><br><span class="line">			printf(&quot;即将进入 sources \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case kCFRunLoopBeforeWaiting:</span><br><span class="line">			printf(&quot;即将进入 休眠 \n&quot;);</span><br><span class="line">			count = 0;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//点击的时候 会出发loop来处理触摸事件</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入处理 timers </span><br><span class="line">- 7即将进入 sources </span><br><span class="line">- 8即将进入处理 timers </span><br><span class="line">- 9即将进入 sources </span><br><span class="line">- 10即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入处理 timers </span><br><span class="line">- 5即将进入 sources </span><br><span class="line">- 6即将进入 休眠 </span><br><span class="line">- 1即将从休眠中唤醒 </span><br><span class="line">- 2即将进入处理 timers </span><br><span class="line">- 3即将进入 sources </span><br><span class="line">- 4即将进入 休眠</span><br></pre></td></tr></table></figure>
<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>
<h5 id="RunLoop在不获取的时候不存在-获取才生成"><a href="#RunLoop在不获取的时候不存在-获取才生成" class="headerlink" title="RunLoop在不获取的时候不存在,获取才生成"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>
<p>首先看官方给的图：</p>
<p><img src="/images/9-2.png" alt><br>那我又整理了一个表格来更直观的了解状态运转</p>
<table>
<thead>
<tr>
<th style="text-align:center">步骤</th>
<th style="text-align:center">任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">通知Observers:进入Loop</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">通知Observers:即将处理Timers</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">通知Observers:即将处理Sources</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">处理blocks</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">处理Source0(可能再处理Blocks)</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">如果存在Source1，跳转第8步</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">通知Observers:开始休眠</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">处理Blocks</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">根据前面的执行结果，决定如何操作1.返回第2步，2退出loop</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">通知Observers:退出Loop</td>
</tr>
</tbody>
</table>
<p>查看<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">runloop源码</a>中<code>runloop.c</code>2333行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">//入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	rlm-&gt;_stopped = false;</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    if (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        if (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer = NULL;</span><br><span class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</span><br><span class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">        seconds = 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR = 0ULL;</span><br><span class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">	dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; // infinite timeout</span><br><span class="line">        seconds = 9999999999.0;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        voucher_t voucherCopy = NULL;</span><br><span class="line">#endif</span><br><span class="line">        uint8_t msg_buffer[3 * 1024];</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        mach_msg_header_t *msg = NULL;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">#endif</span><br><span class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">//通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">//通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">//处理Blocks</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">//处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">	//处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">	//y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">	//有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        didDispatchPortLastTime = false;</span><br><span class="line">//即将进入休眠</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	//开始休眠</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">    __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line"></span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            //等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">			</span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;</span><br><span class="line"></span><br><span class="line">                    rlm-&gt;_timerFired = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">        if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        // user callouts now OK again</span><br><span class="line">	__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">	//结束休眠</span><br><span class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">//标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">		</span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">			</span><br><span class="line">        &#125;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">	//被timer唤醒</span><br><span class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">	//被GCD换醒</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</span><br><span class="line">	//处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = true;</span><br><span class="line">            didDispatchPortLastTime = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">	//处理Source1</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">			</span><br><span class="line">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">		mach_msg_header_t *reply = NULL;</span><br><span class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">		if (NULL != reply) &#123;</span><br><span class="line">		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	    &#125;</span><br><span class="line">            </span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理bBlock</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">//设置返回值</span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">#endif</span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过及进一步精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//入口函数</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	rlm-&gt;_stopped = false;</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">//通知即将处理Timers</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">//通知即将处理Sources</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">			__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">//处理Blocks</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">//处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">	//处理Block</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">	//y判断是否有Source1</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">	//有则去 handle_msg</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">//即将进入休眠</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	//开始休眠</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line">        do &#123;</span><br><span class="line">    //等待消息来唤醒当前线程</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">	//结束休眠</span><br><span class="line">		__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">//标签 handle_msg</span><br><span class="line">        handle_msg:;</span><br><span class="line">	//被timer唤醒</span><br><span class="line">			CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">	//被GCD换醒</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line">	//处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">	//处理Source1</span><br><span class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            // Restore the previous voucher</span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理bBlock</span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    //设置返回值</span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="noopener">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>
<h5 id="timer保活和多mode运行"><a href="#timer保活和多mode运行" class="headerlink" title="timer保活和多mode运行"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int i = 0;</span><br><span class="line">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">	NSLog(@&quot;%d&quot;,++i);</span><br><span class="line">&#125;];</span><br><span class="line">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</span><br><span class="line">//timer在设置为common模式下能运行</span><br><span class="line">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</span><br><span class="line">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line">	</span><br><span class="line">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</span><br><span class="line">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</span><br><span class="line">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</span><br><span class="line">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</span><br><span class="line">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</span><br><span class="line">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</span><br><span class="line">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</span><br><span class="line">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</span><br></pre></td></tr></table></figure>
<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	CFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</span><br><span class="line">	dispatch_source_cancel(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>
<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>
<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>
<h5 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </span><br><span class="line">                            forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>
<p>验证线程保活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) FYThread *thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">	_thread.name = @&quot;test thread&quot;;</span><br><span class="line">	[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">//添加端口</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	[[NSRunLoop currentRunLoop] run];</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//log</span><br><span class="line">//注释掉添加端口代码</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">--end--</span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//注释放开的时候点击触发log</span><br><span class="line">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line"></span><br><span class="line">-[ViewController touchesBegan:withEvent:]</span><br><span class="line">执行完毕了子线程</span><br><span class="line">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</span><br></pre></td></tr></table></figure>
<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>
<p>那我们测试下该线程声明周期多长？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">	_thread.name = @&quot;test thread&quot;;</span><br><span class="line">	[_thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	//获取obs</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	/*</span><br><span class="line">	 If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</span><br><span class="line">	 */</span><br><span class="line">	[[NSRunLoop currentRunLoop] run];</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController stop]</span><br></pre></td></tr></table></figure>
<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>
<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
</blockquote>
<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL shouldKeepRunning = YES; // global</span><br><span class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br></pre></td></tr></table></figure>
<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">	[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">	//获取obs</span><br><span class="line">	NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">	NSLog(@&quot;--start--&quot;);</span><br><span class="line">	self.shouldKeepRunning = YES;//默认运行</span><br><span class="line">	NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">	while (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line">	NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">	NSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</span><br><span class="line">&#125;</span><br><span class="line">//返回上页</span><br><span class="line">- (IBAction)popVC:(id)sender &#123;</span><br><span class="line">	self.shouldKeepRunning = NO;</span><br><span class="line">	[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">//测试子线程是否还活着</span><br><span class="line">- (void)alive&#123;</span><br><span class="line">	NSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">	CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)pop&#123;</span><br><span class="line">	[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//log</span><br><span class="line"></span><br><span class="line">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">--end--</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure>
<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//停止子线程线程</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    if (self.thread == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">- (void)stopThread&#123;</span><br><span class="line">    self.shouldKeepRunning = NO;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self stop];</span><br><span class="line">	NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) __weakSelf = self;</span><br><span class="line">self.thread = [[FYThread alloc]initWithBlock:^&#123;</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;--start--&quot;);</span><br><span class="line">    __weakSelf.shouldKeepRunning = YES;//默认运行</span><br><span class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;--end--&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>测试下崩溃了，崩溃到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (__weakSelf.shouldKeepRunning  )&#123;</span><br><span class="line">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//log</span><br><span class="line"></span><br><span class="line">--start--</span><br><span class="line">-[ViewController stop]</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">--end--</span><br><span class="line">-[FYThread dealloc]</span><br></pre></td></tr></table></figure>
<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">runloop源码</a></li>
<li><a href="http://www.520it.com/zt/ios_mj/" target="_blank" rel="noopener">小码哥视频</a></li>
<li><a href="http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html" target="_blank" rel="noopener">任务调度</a></li>
<li><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch</a><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3></li>
<li><a href="https://github.com/ifgyong/iOSDataFactory" target="_blank" rel="noopener">学习资料下载git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC" target="_blank" rel="noopener">demo code git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/objc4-750" target="_blank" rel="noopener">runtime可运行的源码git</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">thread保活c语言版本</a></li>
<li><a href="https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85" target="_blank" rel="noopener">thread 保活</a></li>
</ul>
<hr>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>
<p>广告时间</p>
<p><img src="/images/0.png" alt></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/" rel="next" title="iOS底层原理 runtime - super、hook、以及简单应用--(8)">
                <i class="fa fa-chevron-left"></i> iOS底层原理 runtime - super、hook、以及简单应用--(8)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/" rel="prev" title="iOS底层原理  多线程之GCD看我就够了 --(10)">
                iOS底层原理  多线程之GCD看我就够了 --(10) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div id="gitalk-container">
    </div>
    
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fgyong</p>
              <p class="site-description motion-element" itemprop="description">在学习的路上，不忘初心 方得始终</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ifgyong" title="GitHub &rarr; https://github.com/ifgyong" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://juejin.im/user/1750078239290909" title="掘金 &rarr; https://juejin.im/user/1750078239290909" rel="noopener" target="_blank"><i class="fa fa-fw fa-掘金"></i>掘金</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是runloop"><span class="nav-number">1.</span> <span class="nav-text">什么是runloop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取runloop"><span class="nav-number">2.</span> <span class="nav-text">获取runloop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#souces0"><span class="nav-number">2.1.</span> <span class="nav-text">souces0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Source1"><span class="nav-number">2.2.</span> <span class="nav-text">Source1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timers"><span class="nav-number">2.3.</span> <span class="nav-text">Timers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observers"><span class="nav-number">2.4.</span> <span class="nav-text">Observers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#runloop切换Mode"><span class="nav-number">2.4.1.</span> <span class="nav-text">runloop切换Mode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RunLoop在不获取的时候不存在-获取才生成"><span class="nav-number">2.4.2.</span> <span class="nav-text">RunLoop在不获取的时候不存在,获取才生成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保活机制"><span class="nav-number">2.5.</span> <span class="nav-text">保活机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#timer保活和多mode运行"><span class="nav-number">2.5.1.</span> <span class="nav-text">timer保活和多mode运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程保活"><span class="nav-number">2.5.2.</span> <span class="nav-text">线程保活</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料参考"><span class="nav-number">3.</span> <span class="nav-text">资料参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资料下载"><span class="nav-number">4.</span> <span class="nav-text">资料下载</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fgyong</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>

  
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css">

  
  
  <script type="text/javascript" src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
    
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'a7800c37057fc3ce83df',
          clientSecret: '0de240e28197f071e10fcb67d4337fd8afe8a9c3',
          repo: 'ifgyong.github.io',
          owner: 'ifgyong',
          admin: ['ifgyong'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
