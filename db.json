{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/0.jpeg","path":"0.jpeg","modified":0,"renderable":0},{"_id":"source/1.png","path":"1.png","modified":0,"renderable":0},{"_id":"source/4.png","path":"4.png","modified":0,"renderable":0},{"_id":"source/8.png","path":"8.png","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/pic.png","path":"pic.png","modified":0,"renderable":0},{"_id":"source/2.png","path":"2.png","modified":0,"renderable":0},{"_id":"source/3.png","path":"3.png","modified":0,"renderable":0},{"_id":"source/alipay.png","path":"alipay.png","modified":0,"renderable":0},{"_id":"source/wechatpay.png","path":"wechatpay.png","modified":0,"renderable":0},{"_id":"source/5.png","path":"5.png","modified":0,"renderable":0},{"_id":"source/6.png","path":"6.png","modified":0,"renderable":0},{"_id":"source/images/0.png","path":"images/0.png","modified":0,"renderable":0},{"_id":"source/images/1-1.png","path":"images/1-1.png","modified":0,"renderable":0},{"_id":"source/7.png","path":"7.png","modified":0,"renderable":0},{"_id":"source/images/1-5.png","path":"images/1-5.png","modified":0,"renderable":0},{"_id":"source/images/1-4.png","path":"images/1-4.png","modified":0,"renderable":0},{"_id":"source/images/10-1.png","path":"images/10-1.png","modified":0,"renderable":0},{"_id":"source/images/1-7.png","path":"images/1-7.png","modified":0,"renderable":0},{"_id":"source/images/10-2.png","path":"images/10-2.png","modified":0,"renderable":0},{"_id":"source/images/2-1.png","path":"images/2-1.png","modified":0,"renderable":0},{"_id":"source/images/2-2.png","path":"images/2-2.png","modified":0,"renderable":0},{"_id":"source/images/9-1.png","path":"images/9-1.png","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/1-2.png","path":"images/1-2.png","modified":0,"renderable":0},{"_id":"source/images/1-6.png","path":"images/1-6.png","modified":0,"renderable":0},{"_id":"source/images/1-8.png","path":"images/1-8.png","modified":0,"renderable":0},{"_id":"source/images/9-2.png","path":"images/9-2.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/1-3.png","path":"images/1-3.png","modified":0,"renderable":0},{"_id":"source/images/3-1.png","path":"images/3-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/images/2-3.png","path":"images/2-3.png","modified":0,"renderable":0},{"_id":"source/images/7-1.png","path":"images/7-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"80491aa0afe31ae4f7f1d61dbbeab4fd79dc2a2c","modified":1575420359360},{"_id":"source/0.jpeg","hash":"96c3c8bcfa1b9bd0b0bc0ddc125fbf5baa313b8e","modified":1575348480964},{"_id":"source/1.png","hash":"fff352d17afb0478ba58ce28c45df5d8e3abc0a8","modified":1575348480964},{"_id":"source/4.png","hash":"e3b405a4bdc8707180e510cef38f8f2c51776d64","modified":1575348480966},{"_id":"source/8.png","hash":"9eb272c6b6376c4a8e7e1e8dab18638547325d7c","modified":1575348480970},{"_id":"source/CNAME","hash":"2318763188ad55198aa23388575405546821e276","modified":1575348480970},{"_id":"source/favicon.ico","hash":"6f87159d3797bffe219eeedfd2057e94578cf6dc","modified":1575348480977},{"_id":"source/robots.txt","hash":"db899123e7308a12dc6cb9646c93537db6b6beba","modified":1575348480978},{"_id":"source/pic.png","hash":"fcdfd8ae26fcf9a05c3776b2d28fc664aea9f4c9","modified":1575348480977},{"_id":"themes/next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1554062380000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1554062380000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1554062380000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1554062380000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1554062380000},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1554062380000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1554062380000},{"_id":"themes/next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1554062380000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1554062380000},{"_id":"themes/next/_config.yml","hash":"660a44a6e2c9a28f3a35c4f246ce16d9f73cde49","modified":1575430281877},{"_id":"themes/next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1554062380000},{"_id":"themes/next/package.json","hash":"888bcacea284ec536a1428ad957a78dfb3ec255d","modified":1554062380000},{"_id":"themes/next/bower.json","hash":"8fa4f26f5205cbc64d33318d1be5d35b2667398c","modified":1554062380000},{"_id":"themes/next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1554062380000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1554062380000},{"_id":"source/2.png","hash":"aa1edb6580f89279d491bb1aacd16e3cf755adb7","modified":1575348480965},{"_id":"source/3.png","hash":"fc44ac70397fa2e14a6861b32633cbd6b009ab57","modified":1575348480965},{"_id":"source/alipay.png","hash":"ecf8fc3905c058486e04c89e7d506a7e4c6d0ad0","modified":1575348480977},{"_id":"source/wechatpay.png","hash":"7f20ebc96c3a306f48adff74d171f30f5957d6ae","modified":1575348480979},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1575355577677},{"_id":"source/5.png","hash":"d8d9cd6db4a6af43d096de99bebaa2da9455f55c","modified":1575348480967},{"_id":"source/6.png","hash":"503d57b636ae27c87b0c68916a0ea3f53c46b833","modified":1575348480968},{"_id":"source/_posts/Git到CocoaPods看我就够了.md","hash":"e5c34006d8ebc0b230b97e974439f28225927e4a","modified":1575348480970},{"_id":"source/_posts/Module-version-mismatch.md","hash":"62e1b2e24d31e7341a01456bc147b053bbb227fb","modified":1575348480971},{"_id":"source/_posts/MAC-重置MySQL-root-密码.md","hash":"b74cd18bfaad4f0ef4d44dcce32c390c4e55c51d","modified":1575348480971},{"_id":"source/_posts/Python3 Flask bootstrap教程(1).md","hash":"3f3ce5844effaa8acad6bb5e9701ed02c33b8f90","modified":1575348480971},{"_id":"source/_posts/Python3 Flask bootstrap教程(2).md","hash":"828d43968dde679a5cc9e18096bc6b2df388e04f","modified":1575348480971},{"_id":"source/_posts/IOS底层原理 对象的本质--(1).md","hash":"00b8d22cf8a8d8ee2283e9ccf0664dd318a63980","modified":1575348977289},{"_id":"source/_posts/Python3 PyQt5教程(2).md","hash":"e83d80f6548a82b1bb81c804f7e4142dd7325628","modified":1575348480972},{"_id":"source/_posts/hexo换了电脑处理方法.md","hash":"010cf8304bab7507c072a4c1d35f65ac9094cd2c","modified":1575348480972},{"_id":"source/_posts/Python3 PyQt5教程(1).md","hash":"37483dca1d8048f36bc7b684b61aeb4fc0d37dd3","modified":1575348480971},{"_id":"source/_posts/hexo自定义域名.md","hash":"60a470a3449f635219d14c7c473b00f53cc6a71b","modified":1575348480972},{"_id":"source/_posts/iOS-WebView设置cookie.md","hash":"08b29576e68988b53fd0fffaefcad016612de5c4","modified":1575348480973},{"_id":"source/_posts/iOS 浅析指针、函数、typedef.md","hash":"5625e87433ee990d2a390ec82d9ccaa1b3d13005","modified":1575348480973},{"_id":"source/_posts/iOS 手动做一个自动打包部署神器.md","hash":"e0826192a2181abc1a84f59681bd7530e994459d","modified":1575348480972},{"_id":"source/_posts/iOS-static-const-extern-用法技巧.md","hash":"57f6a6367576d9c1ba960526ea3365a08bd7457c","modified":1575348480973},{"_id":"source/_posts/iOS之Safari之添加到主屏幕应用.md","hash":"757bfa4bf2aef361bf6002d92bc63e7f536dbeed","modified":1575348480973},{"_id":"source/_posts/iOS图片优化 .md","hash":"5a2a293fa9a00e7b7a49a41e2c0e27b5d9a3b123","modified":1575355456859},{"_id":"source/_posts/iOS底层原理  block本质 --(5).md","hash":"7bfeb28a69f6cfe2fa0d22c22027e3e3aa75ca21","modified":1575349334641},{"_id":"source/_posts/iOS底层原理 Category与关联对象本质--(4).md","hash":"866e9590ba61f2fc138e50335d9d4d4de9393732","modified":1575354632675},{"_id":"source/_posts/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13).md","hash":"9d8959c63a1a6846d6f5140ae53e5706d144a9d3","modified":1575342952907},{"_id":"source/_posts/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9).md","hash":"e052d296d5dd782e5b0e64e97f32bd0cf5999ece","modified":1575349499281},{"_id":"source/_posts/iOS底层原理 KVO和KVC本质与联系 --(3).md","hash":"a95ec4823d405d27ee282d80173d6134dc1c3e7d","modified":1575349299835},{"_id":"source/_posts/iOS底层原理 runtime - super、hook、以及简单应用--(8).md","hash":"8419c15e253d8aaf9dbf8e6ea4b09c9636972020","modified":1575349412253},{"_id":"source/_posts/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7).md","hash":"afa6a29b7eebe3831127aa2b44718ef3e9613d75","modified":1575349396790},{"_id":"source/_posts/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12).md","hash":"3bf730c14edb59835bc03e8ea8d1f98096bf5eb7","modified":1575361471205},{"_id":"source/_posts/iOS底层原理 runtime-object_class拾遗基础篇--(6).md","hash":"65a3bb41bf9bdc3934396d4777a42751e89fc936","modified":1575349353456},{"_id":"source/_posts/iOS底层原理 多线程之GCD 看我就够了 --(10).md","hash":"fe8c1fc396210db2368c243c91b9362734a2f63d","modified":1575349601848},{"_id":"source/_posts/iOS线程之GCD初探.md","hash":"258b6b185762f397a329cede267c6192085e5bae","modified":1575348480973},{"_id":"source/_posts/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11).md","hash":"9b9cfcf0befa054654ed0e670c1e7bcf5e52b5bd","modified":1575349616937},{"_id":"source/_posts/iOS底层原理 类的本质--(2).md","hash":"06c1b3dbee5bd399288cde96051d41030e5d1a8f","modified":1575349243294},{"_id":"source/_posts/iOS线程之NSOperation.md","hash":"d736fa7540da6ed6a51e7b2b9b0d38654aed1060","modified":1575348480974},{"_id":"source/_posts/iOS线程之NSThread.md","hash":"11d407fd8a576826e499074830015dc6a2d76dca","modified":1575348480974},{"_id":"source/_posts/iOS自动化打包第一步.md","hash":"60cf295c69edcbbd99b81e060c90a522f26401fd","modified":1575348480974},{"_id":"source/_posts/iOS证书过期解决方案.md","hash":"63749d6abf34744bdbe3ce7473cc7d8a698005f2","modified":1575348480974},{"_id":"source/_posts/iOS高级开发runtime那点事实战（1）.md","hash":"9cda4d6185c95826991ded26a5d41dff4889339d","modified":1575348480974},{"_id":"source/_posts/iOS高级开发runtime那点事实战（2）.md","hash":"ce37a5bbeb988a3c7277b29a19147005b038d66f","modified":1575348480975},{"_id":"source/_posts/iOS高级开发runtime那点事实战（3）.md","hash":"8a5d43c4adbc8a189e126a56cf4c9772c6e96925","modified":1575348480975},{"_id":"source/_posts/iOS高级开发runtime那点事实战（4）.md","hash":"513946e413feb5cf168e6b8ae322143de8139d4b","modified":1575348480975},{"_id":"source/_posts/mac-php5-6+mongdb+Apache环境配置.md","hash":"2a500c850474838a6e2cc96ebbe7a67d93e87c0c","modified":1575348480975},{"_id":"source/_posts/二叉树的4种遍历.md","hash":"d77f2daa707083e86654e8c0cbdf2e723c18d749","modified":1575348480975},{"_id":"source/_posts/微信小程序_02.md","hash":"0dbc6aaf0a00a8af943f23a035d8a2cf1db34486","modified":1575348480976},{"_id":"source/_posts/微信小程序_01.md","hash":"79a56e1f1461ad76e9af5f63ebdad1fdc61fa1f9","modified":1575348480975},{"_id":"source/categories/index.md","hash":"9a9a5a016abcae19c3531f83e239d293dcd288c7","modified":1575348480977},{"_id":"source/_posts/排序算法.md","hash":"0be9f708b09adac6e923d65426ea7f2c9c96e251","modified":1575348480976},{"_id":"source/images/0.png","hash":"bc00a7c69d8aa859ad099bd1df0fa2b5315214d1","modified":1575349157283},{"_id":"source/images/1-1.png","hash":"b67dedeca3fb9483084e61605429ec60cce24662","modified":1575348676252},{"_id":"source/7.png","hash":"00acc51827dab270df376c5684f968339a16a595","modified":1575348480969},{"_id":"source/images/1-5.png","hash":"dd0f1655eed439fade8124bf95ac0e57ec55692d","modified":1575348839171},{"_id":"source/images/1-4.png","hash":"8b0487b29fb5e4bb8e0ba3ea0634204412c14c89","modified":1575348798867},{"_id":"source/images/10-1.png","hash":"c6239f82642f320189d516fb23cb576d907484b4","modified":1575349519561},{"_id":"source/images/1-7.png","hash":"ace9a4c4bbbe956211c7def73c38f84878bd97a5","modified":1575348894989},{"_id":"source/images/10-2.png","hash":"246791289d48ba2f69df3ea5deb59f4d25802cae","modified":1575349560341},{"_id":"source/images/2-1.png","hash":"db10627eb8393d2d0911206212b2b798dd636edf","modified":1575349086913},{"_id":"source/images/2-2.png","hash":"fa5d14fd23a91c8f7a00d0eb9506cbbf59429dfa","modified":1575349183663},{"_id":"source/images/9-1.png","hash":"120f231655563a37e10770f269b24e91af55569e","modified":1575349430189},{"_id":"source/tags/index.md","hash":"18886315caee743f5a79fc07d86e30ec365475b3","modified":1575348480978},{"_id":"source/images/favicon.ico","hash":"6f87159d3797bffe219eeedfd2057e94578cf6dc","modified":1575348480977},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1554062380000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1554062380000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1554062380000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1554062380000},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1554062380000},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1554062380000},{"_id":"themes/next/.github/auto_assign.yml","hash":"031f221ee245be2786d55e82fdd677cf957a4ae9","modified":1554062380000},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1554062380000},{"_id":"themes/next/.github/release-drafter.yml","hash":"ae7ab1405ba19b5715af1b030358baa5b5994c8d","modified":1554062380000},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1554062380000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1554062380000},{"_id":"themes/next/.github/mergeable.yml","hash":"db99f12b64dd37de61e83cbcdd4897c05d625507","modified":1554062380000},{"_id":"themes/next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1554062380000},{"_id":"themes/next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1554062380000},{"_id":"themes/next/layout/_layout.swig","hash":"74701fcf2303d59400587436ab4c244e04df7ad9","modified":1554062380000},{"_id":"themes/next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1554062380000},{"_id":"themes/next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1554062380000},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1554062380000},{"_id":"themes/next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1554062380000},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1554062380000},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1554062380000},{"_id":"themes/next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1554062380000},{"_id":"themes/next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1554062380000},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1554062380000},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1554062380000},{"_id":"themes/next/languages/fr.yml","hash":"d37a5d82b499a2f082fe9bbf3ad9f11b36b6b837","modified":1554062380000},{"_id":"themes/next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1554062380000},{"_id":"themes/next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1554062380000},{"_id":"themes/next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1554062380000},{"_id":"themes/next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1554062380000},{"_id":"themes/next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1554062380000},{"_id":"themes/next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1554062380000},{"_id":"themes/next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1554062380000},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1554062380000},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1554062380000},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1554062380000},{"_id":"themes/next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1554062380000},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1554062380000},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1554062380000},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1554062380000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1554062380000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1554062380000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1554062380000},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1554062380000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1554062380000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1554062380000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1554062380000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1554062380000},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1554062380000},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1554062380000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1554062380000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1554062380000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1554062380000},{"_id":"source/about/index.md","hash":"4d8a2c77d5690dff9a4b829388ca766d45c773f5","modified":1575348480976},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1554062380000},{"_id":"source/images/1-2.png","hash":"0b93462e18f53086ec093359ff46337073f582cf","modified":1575348735459},{"_id":"source/images/1-6.png","hash":"4c62d389cf094a3f8fb1d3bfa62933315802ab14","modified":1575348875082},{"_id":"source/images/1-8.png","hash":"8e80ccc745923b1507db5795b295675969f92375","modified":1575348912693},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1554062380000},{"_id":"source/images/9-2.png","hash":"0a1e44ae6086f6121ae361739cd1391a66be97aa","modified":1575349460780},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1554062380000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1554062380000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1554062380000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1554062380000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"480d93619479dcfcbec6906803bb38b2dfbeae53","modified":1554062380000},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1554062380000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1554062380000},{"_id":"themes/next/layout/_macro/post.swig","hash":"10187fafe566b3e5bfa4e7e10c77ea9026d9081d","modified":1554062380000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1554062380000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1554062380000},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1554062380000},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1554062380000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1554062380000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1554062380000},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1554062380000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1554062380000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5352f96f4544c1520babf1cec7b44ddf2f8057b3","modified":1554062380000},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1554062380000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1554062380000},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1554062380000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1554062380000},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1554062380000},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1554062380000},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"01ded5e1bad89a6f8d64cd063e3e4e42c20d33bc","modified":1554062380000},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1554062380000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1554062380000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1554062380000},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1554062380000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1554062380000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1554062380000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1554062380000},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1554062380000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1554062380000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1554062380000},{"_id":"themes/next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1554062380000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1554062380000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1554062380000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1554062380000},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1554062380000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1554062380000},{"_id":"themes/next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1554062380000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1554062380000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1554062380000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1554062380000},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1554062380000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1554062380000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1554062380000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1554062380000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1554062380000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1554062380000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b76ccbc658024e86639cfa5f8a3817647fc8d651","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1554062380000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1b5bd6ae5781137d81dc8667e912d3df6eeab260","modified":1554062380000},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1554062380000},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1554062380000},{"_id":"themes/next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1554062380000},{"_id":"themes/next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1554062380000},{"_id":"themes/next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1554062380000},{"_id":"themes/next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1554062380000},{"_id":"themes/next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1554062380000},{"_id":"themes/next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1554062380000},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1554062380000},{"_id":"themes/next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1554062380000},{"_id":"themes/next/source/js/utils.js","hash":"703375f367acfbd0596733c34437d1b2681abf72","modified":1554062380000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1554062380000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1554062380000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1554062380000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1554062380000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1554062380000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1554062380000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1554062380000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1554062380000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1554062380000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1554062380000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1554062380000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1554062380000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554062380000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1554062380000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1554062380000},{"_id":"source/_posts/debug.log","hash":"282bdf5057d8d2477153653c9d1ef4b067282bf6","modified":1575348480972},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1554062380000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554062380000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1554062380000},{"_id":"source/images/1-3.png","hash":"eb4def2adc3aa923a0b3903e0c724b3a2bc560d0","modified":1575348767876},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554062380000},{"_id":"source/images/3-1.png","hash":"495a717ea3b0c1f1b28fe9495486603175f2a1ba","modified":1575349269581},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1554062380000},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1554062380000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1554062380000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1554062380000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1554062380000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1554062380000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1554062380000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1554062380000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1554062380000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1554062380000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"36eae78a4d7160a1c5e59ca3f7333f00b43d359b","modified":1554062380000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1554062380000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1554062380000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1554062380000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1554062380000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1554062380000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1554062380000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1554062380000},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1554062380000},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1554062380000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1554062380000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1554062380000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1554062380000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1554062380000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1554062380000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1554062380000},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1554062380000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1554062380000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1554062380000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1554062380000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1554062380000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1554062380000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1554062380000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1554062380000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1554062380000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1554062380000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1554062380000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1554062380000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"bb744c9264e8e79ae96431a5463f65fe8de5828a","modified":1554062380000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1554062380000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1554062380000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1554062380000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d0e97b205d3320421c380f2eee445457430c8152","modified":1554062380000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1554062380000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1554062380000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1554062380000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1554062380000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1554062380000},{"_id":"source/images/2-3.png","hash":"3a9c4ad1657b8be64623994ec29bc8678746e219","modified":1575349208989},{"_id":"source/images/7-1.png","hash":"f4e02c0a804c2583591def0aa3689c303bc09625","modified":1575349371123},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"8175b9a275d04718f6caf6dc6ae483035ad71b0c","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"7729491514f8ccdf96777de8f71420e6873c5423","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"9d71f34fa13a41b8c8cd2fbdf3fdea608385277c","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1554062380000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"bb9b753d3cc3a816340bd697512a83e757f907fb","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1554062380000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"6b3340cf57725b312830b9ce377c9e087ba59297","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1554062380000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"6c4990d375b640ee4551e62c48c1cbe4c3d62212","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a3170630d8e085889a4bdc20eb7f09c5a0479c47","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"e425433b81da2714d6fa17c138e1fa750ad810ec","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1554062380000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1554062380000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1554062380000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1554062380000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1554062380000},{"_id":"public/baidusitemap.xml","hash":"9534cd3daad2d1d2ac6032046fd46b3b5e960a82","modified":1575430240959},{"_id":"public/sitemap.xml","hash":"264bb5afb3c412f56e6f8923026cde0f16ce47b9","modified":1575430240959},{"_id":"public/atom.xml","hash":"f38097b2c9d26a07ff7783ecfb1afddf418b92ee","modified":1575430593348},{"_id":"public/categories/index.html","hash":"00b946f3ac7d17e67e38f4fc69474e4f8200c707","modified":1575430593353},{"_id":"public/archives/page/5/index.html","hash":"5eece24c8fc1c423280b113b36da26806f9d2c77","modified":1575430593353},{"_id":"public/archives/2016/04/index.html","hash":"3d27e21909238fb0d9da64d5b885742aa0158391","modified":1575430593353},{"_id":"public/archives/2017/index.html","hash":"d721402b90736aa5da4cc5db26324b5ab91e5871","modified":1575430593353},{"_id":"public/archives/2017/05/index.html","hash":"23d85901a90239d715c6bf09f14197d7251c953d","modified":1575430593353},{"_id":"public/archives/2018/04/index.html","hash":"c99c9c864bc4e00b6fc01a81fd1463d22be9e9e0","modified":1575430593353},{"_id":"public/archives/2019/06/index.html","hash":"e53413d1d0b9c9e3699a4d1cb4ebc69171de94c6","modified":1575430593353},{"_id":"public/categories/Git/index.html","hash":"ad45cf3451ccdbd9e77a38b63b4e5b9fd271ee66","modified":1575430593353},{"_id":"public/categories/建站/index.html","hash":"cb95fb3f026079f9aebe88207716400f91d8ba45","modified":1575430593353},{"_id":"public/categories/Python3/index.html","hash":"10295828f251264c6ae6f9d41508489cb21e1d45","modified":1575430593354},{"_id":"public/categories/Python/index.html","hash":"14038a0d6645029ea307a0b246035325bf73ae84","modified":1575430593354},{"_id":"public/categories/数据结构/index.html","hash":"0a4d69bc413ec7f700f4abc631a3e5e8f92c139a","modified":1575430593354},{"_id":"public/categories/微信小程序/index.html","hash":"f6e81a09052d035a98758a939e17123d09f0b2df","modified":1575430593354},{"_id":"public/tags/Git/index.html","hash":"a50609a3fcf6a06e5a6eda04d9cbd15400675cf2","modified":1575430593354},{"_id":"public/tags/hexo/index.html","hash":"6b9056ea017d314cd87c992c3e60d46a139fa644","modified":1575430593354},{"_id":"public/tags/Flask/index.html","hash":"3e0b62e10e7bc56446f36754dad4cbfb9d2dde1f","modified":1575430593354},{"_id":"public/tags/PyQt5/index.html","hash":"e85f0ee7aeabb700b36a7fb6bda3bd5009aa3fb5","modified":1575430593354},{"_id":"public/tags/开发/index.html","hash":"cb47fff6655be56c2e8f098668dc321ca0b8b65a","modified":1575430593354},{"_id":"public/tags/自动打包/index.html","hash":"e5c0543bf3b5c1cfea1ec52f671b002e6c211bf3","modified":1575430593355},{"_id":"public/tags/指针/index.html","hash":"48fccae30ac26321cfd9ad4d4068d23666740af0","modified":1575430593355},{"_id":"public/tags/iOS高级/index.html","hash":"fc19360c3773e4ed741bb9d5a24a93c835dbddac","modified":1575430593355},{"_id":"public/tags/Shell/index.html","hash":"28e7908a2fbeb435c68af60556bb2d8ce898e81d","modified":1575430593355},{"_id":"public/tags/iOS自动化打包/index.html","hash":"a3f413889bbdd36a2787432ff0ae9dabe96db561","modified":1575430593355},{"_id":"public/tags/疑难杂症/index.html","hash":"802a5c9b63cb485e7df1b19192ec2364914bdfba","modified":1575430593355},{"_id":"public/tags/PHP环境配置/index.html","hash":"ce05f937acae8a181ff083ed047c727485b5e9f0","modified":1575430593355},{"_id":"public/tags/YII/index.html","hash":"f267b560fd75e3b46a6cf083f9736c530394ece7","modified":1575430593355},{"_id":"public/tags/MongoDB/index.html","hash":"20afc7d26184681b41d0877233bad3be9ed08a4d","modified":1575430593355},{"_id":"public/tags/数据结构/index.html","hash":"5ade111b45dd4f5f9a314f49264d43e7034e68c3","modified":1575430593355},{"_id":"public/tags/二叉树/index.html","hash":"d9593af837acafd84ba44dcc122bf70e77fc1f10","modified":1575430593355},{"_id":"public/tags/微信小程序/index.html","hash":"271e3a5465d89a02202126e61ee32cb9502d0bc4","modified":1575430593355},{"_id":"public/tags/排序/index.html","hash":"743d6d7a4a4096475d93b1a9f56e818295ccf01f","modified":1575430593355},{"_id":"public/about/index.html","hash":"904a911d982fd198e0f4621763ec39a4ad7b5256","modified":1575430593355},{"_id":"public/tags/index.html","hash":"6a7b075e13c74f19d3212aceae9a2cec71b1d724","modified":1575430593356},{"_id":"public/2019/12/13/iOS图片优化 /index.html","hash":"0acdae32ce10a344e19c6de10b47c4ea900ca1e7","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)/index.html","hash":"7f001cbc01b28d34ac32e2639a015679d5420e1c","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)/index.html","hash":"83c770580b020638b27f1a68d81fbbce0ecc1913","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)/index.html","hash":"754e02aec8e55ebf108cb82e3fc506eea58f56e8","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 多线程之GCD 看我就够了 --(10)/index.html","hash":"6790bb3fecf26c88aeeb31fb2f40d90a20cc0c91","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)/index.html","hash":"5fd306c844b1e2decb074cd1cc021bdbb20eb0d7","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 runtime - super、hook、以及简单应用--(8)/index.html","hash":"890b84ee578dae474cbf2e62da3fbed9d33f1702","modified":1575430593356},{"_id":"public/2019/12/01/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)/index.html","hash":"f9f11555e27ffe5c1aa227d4bcedd19397193fb2","modified":1575430593357},{"_id":"public/2019/12/01/iOS底层原理 runtime-object_class拾遗基础篇--(6)/index.html","hash":"78130dc34c4c256d70729f6e744502dcdf85053d","modified":1575430593357},{"_id":"public/2019/12/01/iOS底层原理  block本质 --(5)/index.html","hash":"2296d206613b819c3a6bf59b723cd35eccef26cb","modified":1575430593357},{"_id":"public/2019/12/01/iOS底层原理 Category与关联对象本质--(4)/index.html","hash":"f58621046270c7b709caa86ce2af33f6db2a30e4","modified":1575430593357},{"_id":"public/2019/12/01/iOS底层原理 KVO和KVC本质与联系 --(3)/index.html","hash":"da1ffda3ffa194cc838163cc91bb34659fe95101","modified":1575430593357},{"_id":"public/2019/12/01/iOS底层原理 类的本质--(2)/index.html","hash":"7ac80ebe4099b2af25a57bb4dfa9aec8a1260fe9","modified":1575430593357},{"_id":"public/2019/12/01/IOS底层原理 对象的本质--(1)/index.html","hash":"cefeb49217a36df83f0b4f1c0b19a8a3029c648c","modified":1575430593358},{"_id":"public/2019/06/25/iOS 手动做一个自动打包部署神器/index.html","hash":"873fb9add8d94c0776f383b7ff3bacfee2547939","modified":1575430593358},{"_id":"public/2019/06/24/iOS 浅析指针、函数、typedef/index.html","hash":"233d031205f078e66fc17e54b0c06a3ad539145d","modified":1575430593358},{"_id":"public/2018/05/28/Python3 Flask bootstrap教程(2)/index.html","hash":"1c645552295576b83a23ac82f894bfe998b85d45","modified":1575430593358},{"_id":"public/2018/05/27/Python3 Flask bootstrap教程(1)/index.html","hash":"0cf4228a8dcc071f1358ca13c9424f7e817712a4","modified":1575430593358},{"_id":"public/2018/05/10/Python3 PyQt5教程(2)/index.html","hash":"eb6f77a8ca8031986d323c9b304cecff7f0dbd94","modified":1575430593358},{"_id":"public/2018/05/09/Python3 PyQt5教程(1)/index.html","hash":"98c8fa13437d694f2c35b8b6fda8081841934e5b","modified":1575430593358},{"_id":"public/2018/04/16/mac-php5-6+mongdb+Apache环境配置/index.html","hash":"bc039871376a72eb512b742752f93026c7b3362f","modified":1575430593358},{"_id":"public/2017/05/08/排序算法/index.html","hash":"104599615d2d6a6dc4d60c1e24fc2702f79feb90","modified":1575430593358},{"_id":"public/2017/05/07/二叉树的4种遍历/index.html","hash":"5c5ab47760c2f327245419289168235b8039daf2","modified":1575430593358},{"_id":"public/2016/11/21/iOS之Safari之添加到主屏幕应用/index.html","hash":"2351dac7b2c99854ca96a4e30e2366096de7b28d","modified":1575430593358},{"_id":"public/2016/11/05/微信小程序_02/index.html","hash":"5d0cd145deb00fd7f341435a30df367fe2c75747","modified":1575430593359},{"_id":"public/2016/11/04/微信小程序_01/index.html","hash":"3ac7e6a2cf6ee418c290b8dd48f8a1b1029235ac","modified":1575430593359},{"_id":"public/2016/04/22/Git到CocoaPods看我就够了/index.html","hash":"aeab595e63d6f30ff2792be96c5dab49e82476f3","modified":1575430593359},{"_id":"public/2016/04/13/iOS线程之NSThread/index.html","hash":"3c69f270264bd24c834b9d10552b2de63d2c19ac","modified":1575430593359},{"_id":"public/2016/03/31/iOS线程之NSOperation/index.html","hash":"6797e389e479da5b8632076bd30777486dba05ef","modified":1575430593359},{"_id":"public/2016/03/28/iOS线程之GCD初探/index.html","hash":"f0d2a0116b82390c7be427c98b3e7afe15ce5531","modified":1575430593359},{"_id":"public/2016/03/28/iOS高级开发runtime那点事实战（4）/index.html","hash":"ff7806d7c46189637af8a04fc14d6ce6e5185c3a","modified":1575430593359},{"_id":"public/2016/03/24/iOS高级开发runtime那点事实战（3）/index.html","hash":"6637f47d4f34d07b5ad848d248747e7a04ae0c55","modified":1575430593359},{"_id":"public/2016/03/24/iOS高级开发runtime那点事实战（2）/index.html","hash":"027103cea74c6db65d28d108076c2f21355b63d9","modified":1575430593359},{"_id":"public/2016/03/24/iOS高级开发runtime那点事实战（1）/index.html","hash":"276a62555d660ab09df1861afdc8cae02ff45102","modified":1575430593359},{"_id":"public/2016/01/31/hexo换了电脑处理方法/index.html","hash":"8dcaf0156636f15f66457eb90dec789b3a603c9a","modified":1575430593360},{"_id":"public/2016/01/30/Module-version-mismatch/index.html","hash":"4f929f60e8a5e17e6ec84f894035b042987fcd31","modified":1575430593360},{"_id":"public/2016/01/28/iOS自动化打包第一步/index.html","hash":"62c1b9be1ce06b548b3819f7139cc9092821f7b2","modified":1575430593360},{"_id":"public/2016/01/28/hexo自定义域名/index.html","hash":"7fee3a80b3281e76a1c1376e325d345bdec5c962","modified":1575430593360},{"_id":"public/2016/01/28/MAC-重置MySQL-root-密码/index.html","hash":"23ee8bb1284064eead06d161411bbbc818d84a3d","modified":1575430593360},{"_id":"public/2016/01/28/iOS-WebView设置cookie/index.html","hash":"3a3ebe6e0160f46adeb9b2d71c2d0564d39c1f7b","modified":1575430593360},{"_id":"public/2016/01/28/iOS-static-const-extern-用法技巧/index.html","hash":"786a316f9aeb0aa7c3537bee5f8c61b25c079716","modified":1575430593360},{"_id":"public/2016/01/28/iOS证书过期解决方案/index.html","hash":"80c9cd49c41e93411e1a38c1f188b6647e6c2652","modified":1575430593360},{"_id":"public/archives/index.html","hash":"42c73c237ae3310570e449db60960bbfc4c23cfb","modified":1575430593360},{"_id":"public/archives/page/2/index.html","hash":"08d0c28d699fc97f66548e1a28d5af87af820546","modified":1575430593360},{"_id":"public/archives/page/3/index.html","hash":"86894a5921ef92d0fe153455fd963e2001760e83","modified":1575430593360},{"_id":"public/archives/page/4/index.html","hash":"1c3997e39b380efae6d2395c80a00d0b02945381","modified":1575430593360},{"_id":"public/archives/2016/index.html","hash":"393c9434e59a96feb3e495c249bebf270960808b","modified":1575430593360},{"_id":"public/archives/2016/page/2/index.html","hash":"a5d9af355141f3576820318b32c850c603734d08","modified":1575430593360},{"_id":"public/archives/2016/01/index.html","hash":"7c4301baac08910d4b239a31fb770601d5c83790","modified":1575430593361},{"_id":"public/archives/2016/03/index.html","hash":"5fc5fc50cf096effea04d62cdd33071cd49e0294","modified":1575430593361},{"_id":"public/archives/2016/11/index.html","hash":"d170459c28a5bd01d7df95ff9eaa765a6e068343","modified":1575430593353},{"_id":"public/archives/2018/index.html","hash":"723b53428a8d37c7296db03b9cc669b321032298","modified":1575430593361},{"_id":"public/archives/2018/05/index.html","hash":"7da17be4d98e3b131b8ba59fdf744c0de4a3ba2e","modified":1575430593361},{"_id":"public/archives/2019/index.html","hash":"417d9209ab13910febdc4a06b721ba265741ae1f","modified":1575430593361},{"_id":"public/archives/2019/page/2/index.html","hash":"55fdf228deadde40268121491fe8cdc97e807ecc","modified":1575430593361},{"_id":"public/archives/2019/12/index.html","hash":"f820b2e7c4ca254f39c03cfdd4c08bfae26391f2","modified":1575430593361},{"_id":"public/archives/2019/12/page/2/index.html","hash":"2416c5e950c4c953ed3f606e74ee9275c0a45417","modified":1575430593361},{"_id":"public/index.html","hash":"8520ce24cd97b82dcd7f3f9f93e34827f88e5482","modified":1575430593361},{"_id":"public/page/2/index.html","hash":"d86dd29deac8c323caee396191a6648aa1d273d1","modified":1575430593361},{"_id":"public/page/3/index.html","hash":"cdfca2cf9d3c808101c675434af478e6e63dc158","modified":1575430593362},{"_id":"public/page/4/index.html","hash":"06d053c5fa335ed77206b4d8457e7af767ac67d5","modified":1575430593362},{"_id":"public/page/5/index.html","hash":"95373d9fd52d0aeee7e317994280837e35d479a6","modified":1575430593362},{"_id":"public/categories/iOS/index.html","hash":"c4a09561889c6aa53f3f3d3de55f8d3b93e7e70b","modified":1575430593361},{"_id":"public/categories/iOS/page/2/index.html","hash":"4ed07294c2d09c34eb2d8d6f6fbd29e3c3f354f3","modified":1575430593361},{"_id":"public/categories/iOS/page/3/index.html","hash":"de235ef578d7aec48565b1ddae124bb2fa704d01","modified":1575430593361},{"_id":"public/tags/建站/index.html","hash":"bf8a6ef74475e19b59478a67afb7f7b46302c42c","modified":1575430593354},{"_id":"public/tags/iOS/index.html","hash":"242ac78655b860cda151db9ea5db988dc6b8b095","modified":1575430593362},{"_id":"public/tags/iOS/page/2/index.html","hash":"2bf4b657b509f02384a271624f4c90cb656bc64d","modified":1575430593362},{"_id":"public/tags/iOS/page/3/index.html","hash":"6c8f56b58f865adf0bd8b912975e03b53130a1fe","modified":1575430593362},{"_id":"public/tags/Python3/index.html","hash":"3cc2fac16d79a22dee64a42df2717096febb559d","modified":1575430593354},{"_id":"public/tags/iOS高级开发/index.html","hash":"5973f36779e8ccdb33924fcce0891ffd123e9d7b","modified":1575430593362},{"_id":"public/0.jpeg","hash":"96c3c8bcfa1b9bd0b0bc0ddc125fbf5baa313b8e","modified":1575430240985},{"_id":"public/1.png","hash":"fff352d17afb0478ba58ce28c45df5d8e3abc0a8","modified":1575430240985},{"_id":"public/8.png","hash":"9eb272c6b6376c4a8e7e1e8dab18638547325d7c","modified":1575430240985},{"_id":"public/CNAME","hash":"2318763188ad55198aa23388575405546821e276","modified":1575430240985},{"_id":"public/robots.txt","hash":"db899123e7308a12dc6cb9646c93537db6b6beba","modified":1575430240985},{"_id":"public/favicon.ico","hash":"6f87159d3797bffe219eeedfd2057e94578cf6dc","modified":1575430240985},{"_id":"public/pic.png","hash":"fcdfd8ae26fcf9a05c3776b2d28fc664aea9f4c9","modified":1575430240985},{"_id":"public/images/0.png","hash":"bc00a7c69d8aa859ad099bd1df0fa2b5315214d1","modified":1575430240985},{"_id":"public/images/1-5.png","hash":"dd0f1655eed439fade8124bf95ac0e57ec55692d","modified":1575430240985},{"_id":"public/images/1-4.png","hash":"8b0487b29fb5e4bb8e0ba3ea0634204412c14c89","modified":1575430240985},{"_id":"public/images/10-1.png","hash":"c6239f82642f320189d516fb23cb576d907484b4","modified":1575430240985},{"_id":"public/images/1-7.png","hash":"ace9a4c4bbbe956211c7def73c38f84878bd97a5","modified":1575430240986},{"_id":"public/images/10-2.png","hash":"246791289d48ba2f69df3ea5deb59f4d25802cae","modified":1575430240986},{"_id":"public/images/2-1.png","hash":"db10627eb8393d2d0911206212b2b798dd636edf","modified":1575430240986},{"_id":"public/images/9-1.png","hash":"120f231655563a37e10770f269b24e91af55569e","modified":1575430240986},{"_id":"public/images/favicon.ico","hash":"6f87159d3797bffe219eeedfd2057e94578cf6dc","modified":1575430240986},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1575430240986},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1575430240986},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1575430240986},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1575430240986},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1575430240986},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1575430240986},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1575430240986},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1575430240986},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1575430240986},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1575430240986},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1575430240986},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1575430240986},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1575430240986},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1575430240987},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1575430240987},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1575430240987},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1575430240987},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1575430240987},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1575430240987},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1575430240987},{"_id":"public/4.png","hash":"e3b405a4bdc8707180e510cef38f8f2c51776d64","modified":1575430241475},{"_id":"public/2.png","hash":"aa1edb6580f89279d491bb1aacd16e3cf755adb7","modified":1575430241475},{"_id":"public/3.png","hash":"fc44ac70397fa2e14a6861b32633cbd6b009ab57","modified":1575430241475},{"_id":"public/alipay.png","hash":"ecf8fc3905c058486e04c89e7d506a7e4c6d0ad0","modified":1575430241476},{"_id":"public/images/1-1.png","hash":"b67dedeca3fb9483084e61605429ec60cce24662","modified":1575430241476},{"_id":"public/images/2-2.png","hash":"fa5d14fd23a91c8f7a00d0eb9506cbbf59429dfa","modified":1575430241476},{"_id":"public/images/1-2.png","hash":"0b93462e18f53086ec093359ff46337073f582cf","modified":1575430241476},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1575430241476},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1575430241476},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1575430241483},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1575430241483},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1575430241483},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1575430241484},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1575430241484},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1575430241485},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1575430241486},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1575430241486},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1575430241486},{"_id":"public/js/utils.js","hash":"703375f367acfbd0596733c34437d1b2681abf72","modified":1575430241486},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1575430241486},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1575430241486},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1575430241487},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1575430241487},{"_id":"public/css/main.css","hash":"63f376f86658aa43abbc32305e39dc9b9bf5a3ec","modified":1575430241487},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1575430241487},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1575430241487},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1575430241487},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1575430241488},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1575430241488},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1575430241488},{"_id":"public/images/9-2.png","hash":"0a1e44ae6086f6121ae361739cd1391a66be97aa","modified":1575430241492},{"_id":"public/images/1-8.png","hash":"8e80ccc745923b1507db5795b295675969f92375","modified":1575430241492},{"_id":"public/images/2-3.png","hash":"3a9c4ad1657b8be64623994ec29bc8678746e219","modified":1575430241500},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1575430241500},{"_id":"public/wechatpay.png","hash":"7f20ebc96c3a306f48adff74d171f30f5957d6ae","modified":1575430241509},{"_id":"public/5.png","hash":"d8d9cd6db4a6af43d096de99bebaa2da9455f55c","modified":1575430241509},{"_id":"public/6.png","hash":"503d57b636ae27c87b0c68916a0ea3f53c46b833","modified":1575430241509},{"_id":"public/images/1-6.png","hash":"4c62d389cf094a3f8fb1d3bfa62933315802ab14","modified":1575430241510},{"_id":"public/images/1-3.png","hash":"eb4def2adc3aa923a0b3903e0c724b3a2bc560d0","modified":1575430241515},{"_id":"public/images/3-1.png","hash":"495a717ea3b0c1f1b28fe9495486603175f2a1ba","modified":1575430241515},{"_id":"public/images/7-1.png","hash":"f4e02c0a804c2583591def0aa3689c303bc09625","modified":1575430241526},{"_id":"public/7.png","hash":"00acc51827dab270df376c5684f968339a16a595","modified":1575430241526}],"Category":[{"name":"Git","_id":"ck3qqhi6l000x9zskxw88u5tk"},{"name":"建站","_id":"ck3qqhi6z00159zsk48run40m"},{"name":"iOS","_id":"ck3qqhi7100199zskhah5wkny"},{"name":"Python3","_id":"ck3qqhi74001d9zskurohe737"},{"name":"Python","_id":"ck3qqhi78001l9zsktldjcmno"},{"name":"数据结构","_id":"ck3qqhi8y003i9zsksrhr84ks"},{"name":"微信小程序","_id":"ck3qqhi90003v9zsk82msfha9"}],"Data":[],"Page":[{"title":"分类","date":"2016-01-19T06:34:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: 分类\ndate: 2016-01-19 14:34:37\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-12-03T04:48:00.977Z","path":"categories/index.html","layout":"page","_id":"ck3qqhi6v000z9zsktzo9gpiz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2016-01-19T06:38:56.000Z","_content":"\n### 资料分享\nhttps://github.com/ifgyong/iOSDataFactory \n各种iOS学习资料整理，欢迎一起学习！长期更新。\n包含资料:\n\n\t\t  \t 1.CFNetWork编程指南\n               2.Blosks编程要点\n               3.JS和OC交互\n               4.OpenGL资料\n               5.Swift3.0\n               6.iOS核心动画\n               7.图像识别技术\n               8.多线程编程指南\n               10.性能优化\n               11.相机与滤镜\n               12.算法的乐趣\n             \n### Python3 教程\nhttps://github.com/ifgyong/PYDemo\nhttps://github.com/ifgyong/t66y\n\t\t\t1.Python3+Beaufulsoup+urllib 爬虫\n\t\t\t2.Python3+PyQt5可视化编程\n\t\t\t3.py打包\n\t\t\t4.下载BT到本地\n现在用不着，收藏了，以后再用。欢迎Start,你的start就是我更新的动力。\n\n","source":"about/index.md","raw":"title: about\ndate: 2016-01-19 14:38:56\n---\n\n### 资料分享\nhttps://github.com/ifgyong/iOSDataFactory \n各种iOS学习资料整理，欢迎一起学习！长期更新。\n包含资料:\n\n\t\t  \t 1.CFNetWork编程指南\n               2.Blosks编程要点\n               3.JS和OC交互\n               4.OpenGL资料\n               5.Swift3.0\n               6.iOS核心动画\n               7.图像识别技术\n               8.多线程编程指南\n               10.性能优化\n               11.相机与滤镜\n               12.算法的乐趣\n             \n### Python3 教程\nhttps://github.com/ifgyong/PYDemo\nhttps://github.com/ifgyong/t66y\n\t\t\t1.Python3+Beaufulsoup+urllib 爬虫\n\t\t\t2.Python3+PyQt5可视化编程\n\t\t\t3.py打包\n\t\t\t4.下载BT到本地\n现在用不着，收藏了，以后再用。欢迎Start,你的start就是我更新的动力。\n\n","updated":"2019-12-03T04:48:00.976Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck3qqhi6x00119zskowj1lk7g","content":"<h3 id=\"资料分享\"><a href=\"#资料分享\" class=\"headerlink\" title=\"资料分享\"></a>资料分享</h3><p><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/iOSDataFactory</a><br>各种iOS学习资料整理，欢迎一起学习！长期更新。<br>包含资料:</p>\n<pre><code>1.CFNetWork编程指南\n2.Blosks编程要点\n3.JS和OC交互\n4.OpenGL资料\n5.Swift3.0\n6.iOS核心动画\n7.图像识别技术\n8.多线程编程指南\n10.性能优化\n11.相机与滤镜\n12.算法的乐趣\n</code></pre><h3 id=\"Python3-教程\"><a href=\"#Python3-教程\" class=\"headerlink\" title=\"Python3 教程\"></a>Python3 教程</h3><p><a href=\"https://github.com/ifgyong/PYDemo\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/PYDemo</a><br><a href=\"https://github.com/ifgyong/t66y\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/t66y</a><br>            1.Python3+Beaufulsoup+urllib 爬虫<br>            2.Python3+PyQt5可视化编程<br>            3.py打包<br>            4.下载BT到本地<br>现在用不着，收藏了，以后再用。欢迎Start,你的start就是我更新的动力。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"资料分享\"><a href=\"#资料分享\" class=\"headerlink\" title=\"资料分享\"></a>资料分享</h3><p><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/iOSDataFactory</a><br>各种iOS学习资料整理，欢迎一起学习！长期更新。<br>包含资料:</p>\n<pre><code>1.CFNetWork编程指南\n2.Blosks编程要点\n3.JS和OC交互\n4.OpenGL资料\n5.Swift3.0\n6.iOS核心动画\n7.图像识别技术\n8.多线程编程指南\n10.性能优化\n11.相机与滤镜\n12.算法的乐趣\n</code></pre><h3 id=\"Python3-教程\"><a href=\"#Python3-教程\" class=\"headerlink\" title=\"Python3 教程\"></a>Python3 教程</h3><p><a href=\"https://github.com/ifgyong/PYDemo\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/PYDemo</a><br><a href=\"https://github.com/ifgyong/t66y\" target=\"_blank\" rel=\"external\">https://github.com/ifgyong/t66y</a><br>            1.Python3+Beaufulsoup+urllib 爬虫<br>            2.Python3+PyQt5可视化编程<br>            3.py打包<br>            4.下载BT到本地<br>现在用不着，收藏了，以后再用。欢迎Start,你的start就是我更新的动力。</p>\n"},{"title":"Tagcloud","date":"2016-01-19T03:44:05.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: Tagcloud\ndate: 2016-01-19 11:44:05\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-12-03T04:48:00.978Z","path":"tags/index.html","layout":"page","_id":"ck3qqhi6z00139zsk6k00g07d","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Git到CocoaPods看我就够了","date":"2016-04-22T08:39:24.000Z","_content":"### 看了这篇文章你可能\n+ 学会Git基本使用\n+ 学会在mac上装CocoaPods\n+ 提交代码到CocoaPods\n+ 代码在CocoaPods的版本迭代\n\n### git 基本使用\n在[github](https://github.com)注册账号,然后新建仓库，\n```\ngit clone git@github.com:ifgyong/FYAlbum.git\n//这里git仓库地址分为https和ssh两种，我是用的ssh的地址。\n```\n\n然后 `cd FYAlbum/`目录.这个目录就是仓库了，连着github的地址的仓库。\n\n```\ngit branch -l //查看所有分支\ngit branch 'branchName' 新建本地分支\ngit status //查看文件状态，哪个修改的会显示出来的\ngit add .  //添加所有文件到缓存\ngit commit -m '注释' //把添加到缓存的文件提交到本地 仓库\ngit push origin master //提交本地的master到远程仓库。\ngit tag 'tagName' 设置一个tag\ngit push --tags //把本地 的tags推送到远程仓库\ngit tag  //tag 列表\ngit log //git的日志，每次修改的记录\n\ngit config --global user.name \"YOUR NAME\" //配置全局的name\ngit config --global user.email \"YOUR EMAIL ADDRESS\" //配置全局的email\n以后每次提交的时候都是会用这个账号。\n单独为某个仓库配置账号的时候去掉`--glocal`\n就是\ngit config   user.name \"YOUR NAME\" //配置 name\ngit config   user.email \"YOUR EMAIL ADDRESS\" //配置 email\n\ngit config -l //查看配置\n\n合并分支：\ngit checkout -b dev \n//创建并切换到dev分支 相当于 git branch dev gitcheckout dev 两条命令\n git merge dev //将dev分支合并到当前分支\n这种方式叫快速合并。\ngit branch -d dev //删除分支\n\n用git log --graph命令可以看到分支合并图。\n\n git merge dev --no-ff// 后边加上`--no-ff`是合并的时候有历史记录，比较稳定。\n当然在合并的时候有冲突怎么办？\n\n解决冲突：\ngit status//查看文件状态  冲突文件在这里会有显示的\n\ngit diff 文件一  文件二  //对比两个文件，哪个有问题修改哪个。\n\n修改完成之后就可以合并了。` git merge dev --no-ff`\n\n别人提交的文件更新到本地：\ngit pull \n\n在每个操作后边可以加上 `--verbose`可以观看过程，就是日志了。\n暂时一般常用的就这么多了。\n```\n\n### 在mac上装CocoaPods\n\n```\nsudo gem install cocoapods\n```\n搜索第三方库\n```\npod search AFNetworking\n```\n\n装好了pod 直接`cd /user/工作目录`,新建`Podfile`文件\n\n```\npod init\n```\n新建Podfile\n```\nvi Podfile\n```\n修改podfile文件内容\n```\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'MyApp' do\n  pod 'AFNetworking', '~> 2.6'\n  pod 'ORStackView', '~> 3.0'\n  pod 'SwiftyJSON', '~> 2.3'\nend\n上边的AFNetworking，ORStackView，SwiftyJSON 都是名字，后边是版本号。\n```\n修改完之后保存\n```\n：wq\n```\n\n```\npod setup ///初始化pod仓库\npod update //更新仓库\n```\n### 提交代码到CocoaPods\n#### 注册trunk \n具体步骤看[这里：](https://guides.cocoapods.org/making/getting-setup-with-trunk.html)\n```\npod trunk register fgyong@fgyong.cn 'fgyong' --verbose\n```\n然后检查注册成功了没\n```\npod trunk me\n成功应该是这样的：\n- Name: fgyong \n- Email: fgyong@fgyong.cn\n - Since: xxxxxxx \n- Pods:  \n- Sessions: - xxxxxx \n```\n#### [配置Podspec](https://guides.cocoapods.org/syntax/podspec.html)\n```\npod spec create FYong//新建podSpec文件\n\nvi FYong.podspec //用vi 打开\n\n```\n里面有很多注释，你可以把需要的填写一下或者复制我的修改一下就可以用了。\n文件里面的必要是属性：\n```\nPod::Spec.new do |s|\n\n  s.name          = \"FYAlbum\"\n  s.version       = \"1.0.1\"\n  s.license       = \"MIT\"\n  s.summary       = \"Fast encryption string used on iOS, which implement by Objective-C.\"\n  s.homepage      = \"https://github.com/ifgyong/FYAlbum\"\n  s.author        = { \"fgyong\" => \"fgyong@yeah.net\" } \n  s.source        = { :git => \"https://github.com/ifgyong/FYAlbum.git\", :tag => s.version }\n  s.requires_arc  = true           \n   s.source_files  = \"FYAlbum/*/*\"\n   s.platform      = :ios, '8.0'        \n   s.framework     = 'Foundation', 'UIKit'  \nend\n```\n上边的`s.source_files`容易出错，这个路径是相对于podspec的文件路径。`FYAbul/*`代表FYAbul一级目录下所有文件`FYAlbum/*/*`代表FYAlbum一级和二级目录下所有文件。\n+ tag 和s.version要对应的，不然报错的。\n+ framework直接写上名字就好了。\n+ license是证书类型哦\n\n做完这些可以给仓库打上tag 和version了\n```\ngit tag 1.0.0 // 加上tag\ngit push --tags//推到remote\n```\n```\npod spec lint --verbose  //验证是否成功\npod lib lint --verbose      //验证是否成功\ngit trunk push FYong.spec --verbose //将文件和配置推到trunk上面\n```\n现在验证pod秒就ok了，等到成功了，直接`pod search FYong`就出现了。大功告成！！！\n###   代码在CocoaPods的版本迭代\n中间验证的时候，你的工程修改文件了，那么这个tag要修改才可以了，否则即使你修改了文件也报同样的错误！！！具体的要求看[这里](https://guides.cocoapods.org/)\n```\ngit tag 1.0.1\ngit push --tags\n修改FYong.spec 文件里边的`s.version = 1.0.1`\ngit trunk push FYong.spec --verbose //将文件和配置推到trunk上面\n这次就可以成功了！！！\n```\n我参考的博文：\n+ [廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n+ [guides.cocoapods.org](https://guides.cocoapods.org)\n+ [【原】iOS：手把手教你发布代码到CocoaPods(Trunk方式)](http://www.cnblogs.com/wengzilin/p/4742530.html)\n\n基本到这里就结束了，是不是还是感觉意犹未尽啊！\n有什么问题欢迎留言啊！\n[我的项目](https://github.com/ifgyong/FYAlbum),如果觉得不错，欢迎✨啊。\n 欢迎来吐槽啊！！！\n","source":"_posts/Git到CocoaPods看我就够了.md","raw":"title: Git到CocoaPods看我就够了\ndate: 2016-04-22 16:39:24\ntags: Git\ncategories: Git\n---\n### 看了这篇文章你可能\n+ 学会Git基本使用\n+ 学会在mac上装CocoaPods\n+ 提交代码到CocoaPods\n+ 代码在CocoaPods的版本迭代\n\n### git 基本使用\n在[github](https://github.com)注册账号,然后新建仓库，\n```\ngit clone git@github.com:ifgyong/FYAlbum.git\n//这里git仓库地址分为https和ssh两种，我是用的ssh的地址。\n```\n\n然后 `cd FYAlbum/`目录.这个目录就是仓库了，连着github的地址的仓库。\n\n```\ngit branch -l //查看所有分支\ngit branch 'branchName' 新建本地分支\ngit status //查看文件状态，哪个修改的会显示出来的\ngit add .  //添加所有文件到缓存\ngit commit -m '注释' //把添加到缓存的文件提交到本地 仓库\ngit push origin master //提交本地的master到远程仓库。\ngit tag 'tagName' 设置一个tag\ngit push --tags //把本地 的tags推送到远程仓库\ngit tag  //tag 列表\ngit log //git的日志，每次修改的记录\n\ngit config --global user.name \"YOUR NAME\" //配置全局的name\ngit config --global user.email \"YOUR EMAIL ADDRESS\" //配置全局的email\n以后每次提交的时候都是会用这个账号。\n单独为某个仓库配置账号的时候去掉`--glocal`\n就是\ngit config   user.name \"YOUR NAME\" //配置 name\ngit config   user.email \"YOUR EMAIL ADDRESS\" //配置 email\n\ngit config -l //查看配置\n\n合并分支：\ngit checkout -b dev \n//创建并切换到dev分支 相当于 git branch dev gitcheckout dev 两条命令\n git merge dev //将dev分支合并到当前分支\n这种方式叫快速合并。\ngit branch -d dev //删除分支\n\n用git log --graph命令可以看到分支合并图。\n\n git merge dev --no-ff// 后边加上`--no-ff`是合并的时候有历史记录，比较稳定。\n当然在合并的时候有冲突怎么办？\n\n解决冲突：\ngit status//查看文件状态  冲突文件在这里会有显示的\n\ngit diff 文件一  文件二  //对比两个文件，哪个有问题修改哪个。\n\n修改完成之后就可以合并了。` git merge dev --no-ff`\n\n别人提交的文件更新到本地：\ngit pull \n\n在每个操作后边可以加上 `--verbose`可以观看过程，就是日志了。\n暂时一般常用的就这么多了。\n```\n\n### 在mac上装CocoaPods\n\n```\nsudo gem install cocoapods\n```\n搜索第三方库\n```\npod search AFNetworking\n```\n\n装好了pod 直接`cd /user/工作目录`,新建`Podfile`文件\n\n```\npod init\n```\n新建Podfile\n```\nvi Podfile\n```\n修改podfile文件内容\n```\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'MyApp' do\n  pod 'AFNetworking', '~> 2.6'\n  pod 'ORStackView', '~> 3.0'\n  pod 'SwiftyJSON', '~> 2.3'\nend\n上边的AFNetworking，ORStackView，SwiftyJSON 都是名字，后边是版本号。\n```\n修改完之后保存\n```\n：wq\n```\n\n```\npod setup ///初始化pod仓库\npod update //更新仓库\n```\n### 提交代码到CocoaPods\n#### 注册trunk \n具体步骤看[这里：](https://guides.cocoapods.org/making/getting-setup-with-trunk.html)\n```\npod trunk register fgyong@fgyong.cn 'fgyong' --verbose\n```\n然后检查注册成功了没\n```\npod trunk me\n成功应该是这样的：\n- Name: fgyong \n- Email: fgyong@fgyong.cn\n - Since: xxxxxxx \n- Pods:  \n- Sessions: - xxxxxx \n```\n#### [配置Podspec](https://guides.cocoapods.org/syntax/podspec.html)\n```\npod spec create FYong//新建podSpec文件\n\nvi FYong.podspec //用vi 打开\n\n```\n里面有很多注释，你可以把需要的填写一下或者复制我的修改一下就可以用了。\n文件里面的必要是属性：\n```\nPod::Spec.new do |s|\n\n  s.name          = \"FYAlbum\"\n  s.version       = \"1.0.1\"\n  s.license       = \"MIT\"\n  s.summary       = \"Fast encryption string used on iOS, which implement by Objective-C.\"\n  s.homepage      = \"https://github.com/ifgyong/FYAlbum\"\n  s.author        = { \"fgyong\" => \"fgyong@yeah.net\" } \n  s.source        = { :git => \"https://github.com/ifgyong/FYAlbum.git\", :tag => s.version }\n  s.requires_arc  = true           \n   s.source_files  = \"FYAlbum/*/*\"\n   s.platform      = :ios, '8.0'        \n   s.framework     = 'Foundation', 'UIKit'  \nend\n```\n上边的`s.source_files`容易出错，这个路径是相对于podspec的文件路径。`FYAbul/*`代表FYAbul一级目录下所有文件`FYAlbum/*/*`代表FYAlbum一级和二级目录下所有文件。\n+ tag 和s.version要对应的，不然报错的。\n+ framework直接写上名字就好了。\n+ license是证书类型哦\n\n做完这些可以给仓库打上tag 和version了\n```\ngit tag 1.0.0 // 加上tag\ngit push --tags//推到remote\n```\n```\npod spec lint --verbose  //验证是否成功\npod lib lint --verbose      //验证是否成功\ngit trunk push FYong.spec --verbose //将文件和配置推到trunk上面\n```\n现在验证pod秒就ok了，等到成功了，直接`pod search FYong`就出现了。大功告成！！！\n###   代码在CocoaPods的版本迭代\n中间验证的时候，你的工程修改文件了，那么这个tag要修改才可以了，否则即使你修改了文件也报同样的错误！！！具体的要求看[这里](https://guides.cocoapods.org/)\n```\ngit tag 1.0.1\ngit push --tags\n修改FYong.spec 文件里边的`s.version = 1.0.1`\ngit trunk push FYong.spec --verbose //将文件和配置推到trunk上面\n这次就可以成功了！！！\n```\n我参考的博文：\n+ [廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n+ [guides.cocoapods.org](https://guides.cocoapods.org)\n+ [【原】iOS：手把手教你发布代码到CocoaPods(Trunk方式)](http://www.cnblogs.com/wengzilin/p/4742530.html)\n\n基本到这里就结束了，是不是还是感觉意犹未尽啊！\n有什么问题欢迎留言啊！\n[我的项目](https://github.com/ifgyong/FYAlbum),如果觉得不错，欢迎✨啊。\n 欢迎来吐槽啊！！！\n","slug":"Git到CocoaPods看我就够了","published":1,"updated":"2019-12-03T04:48:00.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2200009zsktithshbb","content":"<h3 id=\"看了这篇文章你可能\"><a href=\"#看了这篇文章你可能\" class=\"headerlink\" title=\"看了这篇文章你可能\"></a>看了这篇文章你可能</h3><ul>\n<li>学会Git基本使用</li>\n<li>学会在mac上装CocoaPods</li>\n<li>提交代码到CocoaPods</li>\n<li>代码在CocoaPods的版本迭代</li>\n</ul>\n<h3 id=\"git-基本使用\"><a href=\"#git-基本使用\" class=\"headerlink\" title=\"git 基本使用\"></a>git 基本使用</h3><p>在<a href=\"https://github.com\" target=\"_blank\" rel=\"external\">github</a>注册账号,然后新建仓库，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ifgyong/FYAlbum.git</div><div class=\"line\">//这里git仓库地址分为https和ssh两种，我是用的ssh的地址。</div></pre></td></tr></table></figure></p>\n<p>然后 <code>cd FYAlbum/</code>目录.这个目录就是仓库了，连着github的地址的仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch -l //查看所有分支</div><div class=\"line\">git branch &apos;branchName&apos; 新建本地分支</div><div class=\"line\">git status //查看文件状态，哪个修改的会显示出来的</div><div class=\"line\">git add .  //添加所有文件到缓存</div><div class=\"line\">git commit -m &apos;注释&apos; //把添加到缓存的文件提交到本地 仓库</div><div class=\"line\">git push origin master //提交本地的master到远程仓库。</div><div class=\"line\">git tag &apos;tagName&apos; 设置一个tag</div><div class=\"line\">git push --tags //把本地 的tags推送到远程仓库</div><div class=\"line\">git tag  //tag 列表</div><div class=\"line\">git log //git的日志，每次修改的记录</div><div class=\"line\"></div><div class=\"line\">git config --global user.name &quot;YOUR NAME&quot; //配置全局的name</div><div class=\"line\">git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; //配置全局的email</div><div class=\"line\">以后每次提交的时候都是会用这个账号。</div><div class=\"line\">单独为某个仓库配置账号的时候去掉`--glocal`</div><div class=\"line\">就是</div><div class=\"line\">git config   user.name &quot;YOUR NAME&quot; //配置 name</div><div class=\"line\">git config   user.email &quot;YOUR EMAIL ADDRESS&quot; //配置 email</div><div class=\"line\"></div><div class=\"line\">git config -l //查看配置</div><div class=\"line\"></div><div class=\"line\">合并分支：</div><div class=\"line\">git checkout -b dev </div><div class=\"line\">//创建并切换到dev分支 相当于 git branch dev gitcheckout dev 两条命令</div><div class=\"line\"> git merge dev //将dev分支合并到当前分支</div><div class=\"line\">这种方式叫快速合并。</div><div class=\"line\">git branch -d dev //删除分支</div><div class=\"line\"></div><div class=\"line\">用git log --graph命令可以看到分支合并图。</div><div class=\"line\"></div><div class=\"line\"> git merge dev --no-ff// 后边加上`--no-ff`是合并的时候有历史记录，比较稳定。</div><div class=\"line\">当然在合并的时候有冲突怎么办？</div><div class=\"line\"></div><div class=\"line\">解决冲突：</div><div class=\"line\">git status//查看文件状态  冲突文件在这里会有显示的</div><div class=\"line\"></div><div class=\"line\">git diff 文件一  文件二  //对比两个文件，哪个有问题修改哪个。</div><div class=\"line\"></div><div class=\"line\">修改完成之后就可以合并了。` git merge dev --no-ff`</div><div class=\"line\"></div><div class=\"line\">别人提交的文件更新到本地：</div><div class=\"line\">git pull </div><div class=\"line\"></div><div class=\"line\">在每个操作后边可以加上 `--verbose`可以观看过程，就是日志了。</div><div class=\"line\">暂时一般常用的就这么多了。</div></pre></td></tr></table></figure>\n<h3 id=\"在mac上装CocoaPods\"><a href=\"#在mac上装CocoaPods\" class=\"headerlink\" title=\"在mac上装CocoaPods\"></a>在mac上装CocoaPods</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo gem install cocoapods</div></pre></td></tr></table></figure>\n<p>搜索第三方库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search AFNetworking</div></pre></td></tr></table></figure></p>\n<p>装好了pod 直接<code>cd /user/工作目录</code>,新建<code>Podfile</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod init</div></pre></td></tr></table></figure>\n<p>新建Podfile<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi Podfile</div></pre></td></tr></table></figure></p>\n<p>修改podfile文件内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">platform :ios, &apos;8.0&apos;</div><div class=\"line\">use_frameworks!</div><div class=\"line\">target &apos;MyApp&apos; do</div><div class=\"line\">  pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;</div><div class=\"line\">  pod &apos;ORStackView&apos;, &apos;~&gt; 3.0&apos;</div><div class=\"line\">  pod &apos;SwiftyJSON&apos;, &apos;~&gt; 2.3&apos;</div><div class=\"line\">end</div><div class=\"line\">上边的AFNetworking，ORStackView，SwiftyJSON 都是名字，后边是版本号。</div></pre></td></tr></table></figure></p>\n<p>修改完之后保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">：wq</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod setup ///初始化pod仓库</div><div class=\"line\">pod update //更新仓库</div></pre></td></tr></table></figure>\n<h3 id=\"提交代码到CocoaPods\"><a href=\"#提交代码到CocoaPods\" class=\"headerlink\" title=\"提交代码到CocoaPods\"></a>提交代码到CocoaPods</h3><h4 id=\"注册trunk\"><a href=\"#注册trunk\" class=\"headerlink\" title=\"注册trunk\"></a>注册trunk</h4><p>具体步骤看<a href=\"https://guides.cocoapods.org/making/getting-setup-with-trunk.html\" target=\"_blank\" rel=\"external\">这里：</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register fgyong@fgyong.cn &apos;fgyong&apos; --verbose</div></pre></td></tr></table></figure></p>\n<p>然后检查注册成功了没<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div><div class=\"line\">成功应该是这样的：</div><div class=\"line\">- Name: fgyong </div><div class=\"line\">- Email: fgyong@fgyong.cn</div><div class=\"line\"> - Since: xxxxxxx </div><div class=\"line\">- Pods:  </div><div class=\"line\">- Sessions: - xxxxxx</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置Podspec\"><a href=\"#配置Podspec\" class=\"headerlink\" title=\"配置Podspec\"></a><a href=\"https://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"external\">配置Podspec</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create FYong//新建podSpec文件</div><div class=\"line\"></div><div class=\"line\">vi FYong.podspec //用vi 打开</div></pre></td></tr></table></figure>\n<p>里面有很多注释，你可以把需要的填写一下或者复制我的修改一下就可以用了。<br>文件里面的必要是属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\"></div><div class=\"line\">  s.name          = &quot;FYAlbum&quot;</div><div class=\"line\">  s.version       = &quot;1.0.1&quot;</div><div class=\"line\">  s.license       = &quot;MIT&quot;</div><div class=\"line\">  s.summary       = &quot;Fast encryption string used on iOS, which implement by Objective-C.&quot;</div><div class=\"line\">  s.homepage      = &quot;https://github.com/ifgyong/FYAlbum&quot;</div><div class=\"line\">  s.author        = &#123; &quot;fgyong&quot; =&gt; &quot;fgyong@yeah.net&quot; &#125; </div><div class=\"line\">  s.source        = &#123; :git =&gt; &quot;https://github.com/ifgyong/FYAlbum.git&quot;, :tag =&gt; s.version &#125;</div><div class=\"line\">  s.requires_arc  = true           </div><div class=\"line\">   s.source_files  = &quot;FYAlbum/*/*&quot;</div><div class=\"line\">   s.platform      = :ios, &apos;8.0&apos;        </div><div class=\"line\">   s.framework     = &apos;Foundation&apos;, &apos;UIKit&apos;  </div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>上边的<code>s.source_files</code>容易出错，这个路径是相对于podspec的文件路径。<code>FYAbul/*</code>代表FYAbul一级目录下所有文件<code>FYAlbum/*/*</code>代表FYAlbum一级和二级目录下所有文件。</p>\n<ul>\n<li>tag 和s.version要对应的，不然报错的。</li>\n<li>framework直接写上名字就好了。</li>\n<li>license是证书类型哦</li>\n</ul>\n<p>做完这些可以给仓库打上tag 和version了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 1.0.0 // 加上tag</div><div class=\"line\">git push --tags//推到remote</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec lint --verbose  //验证是否成功</div><div class=\"line\">pod lib lint --verbose      //验证是否成功</div><div class=\"line\">git trunk push FYong.spec --verbose //将文件和配置推到trunk上面</div></pre></td></tr></table></figure>\n<p>现在验证pod秒就ok了，等到成功了，直接<code>pod search FYong</code>就出现了。大功告成！！！</p>\n<h3 id=\"代码在CocoaPods的版本迭代\"><a href=\"#代码在CocoaPods的版本迭代\" class=\"headerlink\" title=\"代码在CocoaPods的版本迭代\"></a>代码在CocoaPods的版本迭代</h3><p>中间验证的时候，你的工程修改文件了，那么这个tag要修改才可以了，否则即使你修改了文件也报同样的错误！！！具体的要求看<a href=\"https://guides.cocoapods.org/\" target=\"_blank\" rel=\"external\">这里</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 1.0.1</div><div class=\"line\">git push --tags</div><div class=\"line\">修改FYong.spec 文件里边的`s.version = 1.0.1`</div><div class=\"line\">git trunk push FYong.spec --verbose //将文件和配置推到trunk上面</div><div class=\"line\">这次就可以成功了！！！</div></pre></td></tr></table></figure></p>\n<p>我参考的博文：</p>\n<ul>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">廖雪峰</a></li>\n<li><a href=\"https://guides.cocoapods.org\" target=\"_blank\" rel=\"external\">guides.cocoapods.org</a></li>\n<li><a href=\"http://www.cnblogs.com/wengzilin/p/4742530.html\" target=\"_blank\" rel=\"external\">【原】iOS：手把手教你发布代码到CocoaPods(Trunk方式)</a></li>\n</ul>\n<p>基本到这里就结束了，是不是还是感觉意犹未尽啊！<br>有什么问题欢迎留言啊！<br><a href=\"https://github.com/ifgyong/FYAlbum\" target=\"_blank\" rel=\"external\">我的项目</a>,如果觉得不错，欢迎✨啊。<br> 欢迎来吐槽啊！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"看了这篇文章你可能\"><a href=\"#看了这篇文章你可能\" class=\"headerlink\" title=\"看了这篇文章你可能\"></a>看了这篇文章你可能</h3><ul>\n<li>学会Git基本使用</li>\n<li>学会在mac上装CocoaPods</li>\n<li>提交代码到CocoaPods</li>\n<li>代码在CocoaPods的版本迭代</li>\n</ul>\n<h3 id=\"git-基本使用\"><a href=\"#git-基本使用\" class=\"headerlink\" title=\"git 基本使用\"></a>git 基本使用</h3><p>在<a href=\"https://github.com\" target=\"_blank\" rel=\"external\">github</a>注册账号,然后新建仓库，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ifgyong/FYAlbum.git</div><div class=\"line\">//这里git仓库地址分为https和ssh两种，我是用的ssh的地址。</div></pre></td></tr></table></figure></p>\n<p>然后 <code>cd FYAlbum/</code>目录.这个目录就是仓库了，连着github的地址的仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">git branch -l //查看所有分支</div><div class=\"line\">git branch &apos;branchName&apos; 新建本地分支</div><div class=\"line\">git status //查看文件状态，哪个修改的会显示出来的</div><div class=\"line\">git add .  //添加所有文件到缓存</div><div class=\"line\">git commit -m &apos;注释&apos; //把添加到缓存的文件提交到本地 仓库</div><div class=\"line\">git push origin master //提交本地的master到远程仓库。</div><div class=\"line\">git tag &apos;tagName&apos; 设置一个tag</div><div class=\"line\">git push --tags //把本地 的tags推送到远程仓库</div><div class=\"line\">git tag  //tag 列表</div><div class=\"line\">git log //git的日志，每次修改的记录</div><div class=\"line\"></div><div class=\"line\">git config --global user.name &quot;YOUR NAME&quot; //配置全局的name</div><div class=\"line\">git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; //配置全局的email</div><div class=\"line\">以后每次提交的时候都是会用这个账号。</div><div class=\"line\">单独为某个仓库配置账号的时候去掉`--glocal`</div><div class=\"line\">就是</div><div class=\"line\">git config   user.name &quot;YOUR NAME&quot; //配置 name</div><div class=\"line\">git config   user.email &quot;YOUR EMAIL ADDRESS&quot; //配置 email</div><div class=\"line\"></div><div class=\"line\">git config -l //查看配置</div><div class=\"line\"></div><div class=\"line\">合并分支：</div><div class=\"line\">git checkout -b dev </div><div class=\"line\">//创建并切换到dev分支 相当于 git branch dev gitcheckout dev 两条命令</div><div class=\"line\"> git merge dev //将dev分支合并到当前分支</div><div class=\"line\">这种方式叫快速合并。</div><div class=\"line\">git branch -d dev //删除分支</div><div class=\"line\"></div><div class=\"line\">用git log --graph命令可以看到分支合并图。</div><div class=\"line\"></div><div class=\"line\"> git merge dev --no-ff// 后边加上`--no-ff`是合并的时候有历史记录，比较稳定。</div><div class=\"line\">当然在合并的时候有冲突怎么办？</div><div class=\"line\"></div><div class=\"line\">解决冲突：</div><div class=\"line\">git status//查看文件状态  冲突文件在这里会有显示的</div><div class=\"line\"></div><div class=\"line\">git diff 文件一  文件二  //对比两个文件，哪个有问题修改哪个。</div><div class=\"line\"></div><div class=\"line\">修改完成之后就可以合并了。` git merge dev --no-ff`</div><div class=\"line\"></div><div class=\"line\">别人提交的文件更新到本地：</div><div class=\"line\">git pull </div><div class=\"line\"></div><div class=\"line\">在每个操作后边可以加上 `--verbose`可以观看过程，就是日志了。</div><div class=\"line\">暂时一般常用的就这么多了。</div></pre></td></tr></table></figure>\n<h3 id=\"在mac上装CocoaPods\"><a href=\"#在mac上装CocoaPods\" class=\"headerlink\" title=\"在mac上装CocoaPods\"></a>在mac上装CocoaPods</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo gem install cocoapods</div></pre></td></tr></table></figure>\n<p>搜索第三方库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search AFNetworking</div></pre></td></tr></table></figure></p>\n<p>装好了pod 直接<code>cd /user/工作目录</code>,新建<code>Podfile</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod init</div></pre></td></tr></table></figure>\n<p>新建Podfile<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi Podfile</div></pre></td></tr></table></figure></p>\n<p>修改podfile文件内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">platform :ios, &apos;8.0&apos;</div><div class=\"line\">use_frameworks!</div><div class=\"line\">target &apos;MyApp&apos; do</div><div class=\"line\">  pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;</div><div class=\"line\">  pod &apos;ORStackView&apos;, &apos;~&gt; 3.0&apos;</div><div class=\"line\">  pod &apos;SwiftyJSON&apos;, &apos;~&gt; 2.3&apos;</div><div class=\"line\">end</div><div class=\"line\">上边的AFNetworking，ORStackView，SwiftyJSON 都是名字，后边是版本号。</div></pre></td></tr></table></figure></p>\n<p>修改完之后保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">：wq</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod setup ///初始化pod仓库</div><div class=\"line\">pod update //更新仓库</div></pre></td></tr></table></figure>\n<h3 id=\"提交代码到CocoaPods\"><a href=\"#提交代码到CocoaPods\" class=\"headerlink\" title=\"提交代码到CocoaPods\"></a>提交代码到CocoaPods</h3><h4 id=\"注册trunk\"><a href=\"#注册trunk\" class=\"headerlink\" title=\"注册trunk\"></a>注册trunk</h4><p>具体步骤看<a href=\"https://guides.cocoapods.org/making/getting-setup-with-trunk.html\" target=\"_blank\" rel=\"external\">这里：</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register fgyong@fgyong.cn &apos;fgyong&apos; --verbose</div></pre></td></tr></table></figure></p>\n<p>然后检查注册成功了没<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div><div class=\"line\">成功应该是这样的：</div><div class=\"line\">- Name: fgyong </div><div class=\"line\">- Email: fgyong@fgyong.cn</div><div class=\"line\"> - Since: xxxxxxx </div><div class=\"line\">- Pods:  </div><div class=\"line\">- Sessions: - xxxxxx</div></pre></td></tr></table></figure></p>\n<h4 id=\"配置Podspec\"><a href=\"#配置Podspec\" class=\"headerlink\" title=\"配置Podspec\"></a><a href=\"https://guides.cocoapods.org/syntax/podspec.html\" target=\"_blank\" rel=\"external\">配置Podspec</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create FYong//新建podSpec文件</div><div class=\"line\"></div><div class=\"line\">vi FYong.podspec //用vi 打开</div></pre></td></tr></table></figure>\n<p>里面有很多注释，你可以把需要的填写一下或者复制我的修改一下就可以用了。<br>文件里面的必要是属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\"></div><div class=\"line\">  s.name          = &quot;FYAlbum&quot;</div><div class=\"line\">  s.version       = &quot;1.0.1&quot;</div><div class=\"line\">  s.license       = &quot;MIT&quot;</div><div class=\"line\">  s.summary       = &quot;Fast encryption string used on iOS, which implement by Objective-C.&quot;</div><div class=\"line\">  s.homepage      = &quot;https://github.com/ifgyong/FYAlbum&quot;</div><div class=\"line\">  s.author        = &#123; &quot;fgyong&quot; =&gt; &quot;fgyong@yeah.net&quot; &#125; </div><div class=\"line\">  s.source        = &#123; :git =&gt; &quot;https://github.com/ifgyong/FYAlbum.git&quot;, :tag =&gt; s.version &#125;</div><div class=\"line\">  s.requires_arc  = true           </div><div class=\"line\">   s.source_files  = &quot;FYAlbum/*/*&quot;</div><div class=\"line\">   s.platform      = :ios, &apos;8.0&apos;        </div><div class=\"line\">   s.framework     = &apos;Foundation&apos;, &apos;UIKit&apos;  </div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>上边的<code>s.source_files</code>容易出错，这个路径是相对于podspec的文件路径。<code>FYAbul/*</code>代表FYAbul一级目录下所有文件<code>FYAlbum/*/*</code>代表FYAlbum一级和二级目录下所有文件。</p>\n<ul>\n<li>tag 和s.version要对应的，不然报错的。</li>\n<li>framework直接写上名字就好了。</li>\n<li>license是证书类型哦</li>\n</ul>\n<p>做完这些可以给仓库打上tag 和version了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 1.0.0 // 加上tag</div><div class=\"line\">git push --tags//推到remote</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec lint --verbose  //验证是否成功</div><div class=\"line\">pod lib lint --verbose      //验证是否成功</div><div class=\"line\">git trunk push FYong.spec --verbose //将文件和配置推到trunk上面</div></pre></td></tr></table></figure>\n<p>现在验证pod秒就ok了，等到成功了，直接<code>pod search FYong</code>就出现了。大功告成！！！</p>\n<h3 id=\"代码在CocoaPods的版本迭代\"><a href=\"#代码在CocoaPods的版本迭代\" class=\"headerlink\" title=\"代码在CocoaPods的版本迭代\"></a>代码在CocoaPods的版本迭代</h3><p>中间验证的时候，你的工程修改文件了，那么这个tag要修改才可以了，否则即使你修改了文件也报同样的错误！！！具体的要求看<a href=\"https://guides.cocoapods.org/\" target=\"_blank\" rel=\"external\">这里</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag 1.0.1</div><div class=\"line\">git push --tags</div><div class=\"line\">修改FYong.spec 文件里边的`s.version = 1.0.1`</div><div class=\"line\">git trunk push FYong.spec --verbose //将文件和配置推到trunk上面</div><div class=\"line\">这次就可以成功了！！！</div></pre></td></tr></table></figure></p>\n<p>我参考的博文：</p>\n<ul>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">廖雪峰</a></li>\n<li><a href=\"https://guides.cocoapods.org\" target=\"_blank\" rel=\"external\">guides.cocoapods.org</a></li>\n<li><a href=\"http://www.cnblogs.com/wengzilin/p/4742530.html\" target=\"_blank\" rel=\"external\">【原】iOS：手把手教你发布代码到CocoaPods(Trunk方式)</a></li>\n</ul>\n<p>基本到这里就结束了，是不是还是感觉意犹未尽啊！<br>有什么问题欢迎留言啊！<br><a href=\"https://github.com/ifgyong/FYAlbum\" target=\"_blank\" rel=\"external\">我的项目</a>,如果觉得不错，欢迎✨啊。<br> 欢迎来吐槽啊！！！</p>\n"},{"title":"Module version mismatch","date":"2016-01-30T12:32:53.000Z","_content":"# Module version mismatch\n就是模块 版本不匹配了，我这个电脑是很久没用了`npm -v //2.*.*`，我在官网查了一下 npm 都已经3.*了，就索性把npm更新了一下`sudo npm i -g npm //更新npm`。然后在执行 `hexo s` 竟然还报错，错误如下\n\n```\nMacBook:ifgyong.github.io fgy$ hexo -v\n[Error: Module version mismatch. Expected 46, got 47.]\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\nhexo: 3.1.1\nos: Darwin 15.3.0 darwin x64\nhttp_parser: 2.5.0\nnode: 4.2.4\nv8: 4.5.103.35\nuv: 1.7.5\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 46\nopenssl: 1.0.2e\n```\n在Google了好久终于发现一条解决这个问题的命令【出现这个的原因是装hexo的时候有些包没有下载下来】，执行下面的命令在查看hexo 版本的时候就不报错了。\n```\nnpm install hexo --no-optional --save \n```\n\n","source":"_posts/Module-version-mismatch.md","raw":"title: Module version mismatch\ndate: 2016-01-30 20:32:53\ntags:\n- 建站\n- hexo\ncategories: 建站 \n---\n# Module version mismatch\n就是模块 版本不匹配了，我这个电脑是很久没用了`npm -v //2.*.*`，我在官网查了一下 npm 都已经3.*了，就索性把npm更新了一下`sudo npm i -g npm //更新npm`。然后在执行 `hexo s` 竟然还报错，错误如下\n\n```\nMacBook:ifgyong.github.io fgy$ hexo -v\n[Error: Module version mismatch. Expected 46, got 47.]\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\nhexo: 3.1.1\nos: Darwin 15.3.0 darwin x64\nhttp_parser: 2.5.0\nnode: 4.2.4\nv8: 4.5.103.35\nuv: 1.7.5\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 46\nopenssl: 1.0.2e\n```\n在Google了好久终于发现一条解决这个问题的命令【出现这个的原因是装hexo的时候有些包没有下载下来】，执行下面的命令在查看hexo 版本的时候就不报错了。\n```\nnpm install hexo --no-optional --save \n```\n\n","slug":"Module-version-mismatch","published":1,"updated":"2019-12-03T04:48:00.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2500019zsk6vqjvvbu","content":"<h1 id=\"Module-version-mismatch\"><a href=\"#Module-version-mismatch\" class=\"headerlink\" title=\"Module version mismatch\"></a>Module version mismatch</h1><p>就是模块 版本不匹配了，我这个电脑是很久没用了<code>npm -v //2.*.*</code>，我在官网查了一下 npm 都已经3.*了，就索性把npm更新了一下<code>sudo npm i -g npm //更新npm</code>。然后在执行 <code>hexo s</code> 竟然还报错，错误如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">MacBook:ifgyong.github.io fgy$ hexo -v</div><div class=\"line\">[Error: Module version mismatch. Expected 46, got 47.]</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">hexo: 3.1.1</div><div class=\"line\">os: Darwin 15.3.0 darwin x64</div><div class=\"line\">http_parser: 2.5.0</div><div class=\"line\">node: 4.2.4</div><div class=\"line\">v8: 4.5.103.35</div><div class=\"line\">uv: 1.7.5</div><div class=\"line\">zlib: 1.2.8</div><div class=\"line\">ares: 1.10.1-DEV</div><div class=\"line\">icu: 56.1</div><div class=\"line\">modules: 46</div><div class=\"line\">openssl: 1.0.2e</div></pre></td></tr></table></figure>\n<p>在Google了好久终于发现一条解决这个问题的命令【出现这个的原因是装hexo的时候有些包没有下载下来】，执行下面的命令在查看hexo 版本的时候就不报错了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --no-optional --save</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Module-version-mismatch\"><a href=\"#Module-version-mismatch\" class=\"headerlink\" title=\"Module version mismatch\"></a>Module version mismatch</h1><p>就是模块 版本不匹配了，我这个电脑是很久没用了<code>npm -v //2.*.*</code>，我在官网查了一下 npm 都已经3.*了，就索性把npm更新了一下<code>sudo npm i -g npm //更新npm</code>。然后在执行 <code>hexo s</code> 竟然还报错，错误如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">MacBook:ifgyong.github.io fgy$ hexo -v</div><div class=\"line\">[Error: Module version mismatch. Expected 46, got 47.]</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">hexo: 3.1.1</div><div class=\"line\">os: Darwin 15.3.0 darwin x64</div><div class=\"line\">http_parser: 2.5.0</div><div class=\"line\">node: 4.2.4</div><div class=\"line\">v8: 4.5.103.35</div><div class=\"line\">uv: 1.7.5</div><div class=\"line\">zlib: 1.2.8</div><div class=\"line\">ares: 1.10.1-DEV</div><div class=\"line\">icu: 56.1</div><div class=\"line\">modules: 46</div><div class=\"line\">openssl: 1.0.2e</div></pre></td></tr></table></figure>\n<p>在Google了好久终于发现一条解决这个问题的命令【出现这个的原因是装hexo的时候有些包没有下载下来】，执行下面的命令在查看hexo 版本的时候就不报错了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --no-optional --save</div></pre></td></tr></table></figure></p>\n"},{"title":"MAC 重置MySQL root 密码","date":"2016-01-28T03:16:24.000Z","_content":"\n\n重置MySQL root 密码：\n当忘记密码，或者想要强行重置 MySQL 密码的时候，可以像下面这样：\n\n1.停止 MySQL 服务\n```\nsudo /usr/local/mysql/support-files/mysql.server stop\n//当停止失败 见下边 如何用mac 活动指示器停止服务。\n```\n\n2.进入安全模式\n\n```\nsudo mysqld_safe --skip-grant-tables\n```\n这个地方，如果你 alias 了 mysqlld_safe 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 /usr/local/mysql/bin/mysqld/usafe。\n\n说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。\n\n这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。\n\n3.新打开一个终端，进入 MySQL\n```\n-u root -p\n```\n\n\n这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： `/usr/local/mysql/bin/mysql -u root -p`\n\n然后输入任意密码就可以进入 MySQL 了。\n\n修改密码\n进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。\n```\nMySQL 的用户信息是存在 mysql.user 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。\nuse mysql; //切换数据库\ndescribe user; //查看user表的字段\n```\n\n \n\n 然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。\n\n 然后修改密码啊：\n ```\n UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456\n ```\n\n  \n\n  5.刷新权限，使配置生效\n  ```\n  flush privileges;\n  ```\n\n   \n\n   最后再启动 MySQL\n   ```\n   sudo /usr/local/mysql/support-files/mysql.server start\n   ```\n\n   当启动失败的话，可以直接用mac工具活动监视器：\n   搜索mysql 进程名称列表有mysql的话，直接双击出现：这里写图片描述\n   点击退出即可。\n\n   修改完之后记得刷新权限 和重新启动mysql服务才行。\n\n\n","source":"_posts/MAC-重置MySQL-root-密码.md","raw":"title: MAC 重置MySQL root 密码\ndate: 2016-01-28 11:16:24\ntags:\n- iOS\ncategories: iOS\n---\n\n\n重置MySQL root 密码：\n当忘记密码，或者想要强行重置 MySQL 密码的时候，可以像下面这样：\n\n1.停止 MySQL 服务\n```\nsudo /usr/local/mysql/support-files/mysql.server stop\n//当停止失败 见下边 如何用mac 活动指示器停止服务。\n```\n\n2.进入安全模式\n\n```\nsudo mysqld_safe --skip-grant-tables\n```\n这个地方，如果你 alias 了 mysqlld_safe 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 /usr/local/mysql/bin/mysqld/usafe。\n\n说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。\n\n这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。\n\n3.新打开一个终端，进入 MySQL\n```\n-u root -p\n```\n\n\n这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： `/usr/local/mysql/bin/mysql -u root -p`\n\n然后输入任意密码就可以进入 MySQL 了。\n\n修改密码\n进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。\n```\nMySQL 的用户信息是存在 mysql.user 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。\nuse mysql; //切换数据库\ndescribe user; //查看user表的字段\n```\n\n \n\n 然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。\n\n 然后修改密码啊：\n ```\n UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456\n ```\n\n  \n\n  5.刷新权限，使配置生效\n  ```\n  flush privileges;\n  ```\n\n   \n\n   最后再启动 MySQL\n   ```\n   sudo /usr/local/mysql/support-files/mysql.server start\n   ```\n\n   当启动失败的话，可以直接用mac工具活动监视器：\n   搜索mysql 进程名称列表有mysql的话，直接双击出现：这里写图片描述\n   点击退出即可。\n\n   修改完之后记得刷新权限 和重新启动mysql服务才行。\n\n\n","slug":"MAC-重置MySQL-root-密码","published":1,"updated":"2019-12-03T04:48:00.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2600029zskakxu7mt1","content":"<p>重置MySQL root 密码：<br>当忘记密码，或者想要强行重置 MySQL 密码的时候，可以像下面这样：</p>\n<p>1.停止 MySQL 服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/local/mysql/support-files/mysql.server stop</div><div class=\"line\">//当停止失败 见下边 如何用mac 活动指示器停止服务。</div></pre></td></tr></table></figure></p>\n<p>2.进入安全模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mysqld_safe --skip-grant-tables</div></pre></td></tr></table></figure>\n<p>这个地方，如果你 alias 了 mysqlld_safe 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 /usr/local/mysql/bin/mysqld/usafe。</p>\n<p>说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。</p>\n<p>这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。</p>\n<p>3.新打开一个终端，进入 MySQL<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-u root -p</div></pre></td></tr></table></figure></p>\n<p>这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： <code>/usr/local/mysql/bin/mysql -u root -p</code></p>\n<p>然后输入任意密码就可以进入 MySQL 了。</p>\n<p>修改密码<br>进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MySQL 的用户信息是存在 mysql.user 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。</div><div class=\"line\">use mysql; //切换数据库</div><div class=\"line\">describe user; //查看user表的字段</div></pre></td></tr></table></figure></p>\n<p> 然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。</p>\n<p> 然后修改密码啊：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456</div></pre></td></tr></table></figure></p>\n<p>  5.刷新权限，使配置生效<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">flush privileges;</div></pre></td></tr></table></figure></p>\n<p>   最后再启动 MySQL<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/local/mysql/support-files/mysql.server start</div></pre></td></tr></table></figure></p>\n<p>   当启动失败的话，可以直接用mac工具活动监视器：<br>   搜索mysql 进程名称列表有mysql的话，直接双击出现：这里写图片描述<br>   点击退出即可。</p>\n<p>   修改完之后记得刷新权限 和重新启动mysql服务才行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>重置MySQL root 密码：<br>当忘记密码，或者想要强行重置 MySQL 密码的时候，可以像下面这样：</p>\n<p>1.停止 MySQL 服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/local/mysql/support-files/mysql.server stop</div><div class=\"line\">//当停止失败 见下边 如何用mac 活动指示器停止服务。</div></pre></td></tr></table></figure></p>\n<p>2.进入安全模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mysqld_safe --skip-grant-tables</div></pre></td></tr></table></figure>\n<p>这个地方，如果你 alias 了 mysqlld_safe 这个命令，那么可以直接复制粘贴；如果没有，则需要加上正确的路径。在 Linux/OS X 系统下，默认路径是 /usr/local/mysql/bin/mysqld/usafe。</p>\n<p>说是安全模式，其实是超级危险模式！如果你是在本地修改，那没问题；如果是在服务器上，那你得保证这个时候没有任何人登录到系统。因为一旦进入了安全模式，任何人都可以使用任何密码通过 root 用户登录入到 MySQL ，可以执行任何想执行的操作。</p>\n<p>这也是为什么，当我们密码忘记了的时候，我们可以这样来修改密码。凡事有利有弊，你可以用这种方式来做好事；而同样，可以用来做坏事。</p>\n<p>3.新打开一个终端，进入 MySQL<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-u root -p</div></pre></td></tr></table></figure></p>\n<p>这里也和 mysqld_safe 一样。如果你是 OS X 上新装的 MySQL ，那么很有可能并不能直接使用 mysql 这个命令。而是要使用它的绝对路径： <code>/usr/local/mysql/bin/mysql -u root -p</code></p>\n<p>然后输入任意密码就可以进入 MySQL 了。</p>\n<p>修改密码<br>进入了之后先不要急着使用 update 命令修改密码，先看看表中的字段名。不同版本密码的字段名可能不一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MySQL 的用户信息是存在 mysql.user 这个表里面的。于是可以先选择 mysql 这个数据库，再看数据库中 user 表中的字段名称。</div><div class=\"line\">use mysql; //切换数据库</div><div class=\"line\">describe user; //查看user表的字段</div></pre></td></tr></table></figure></p>\n<p> 然后确定密码字段的名称，一般可能是 Password。然而在 OS X 的 MySQL 5.7 这个版本中，密码字段名称是 authentication_string 。记住这个字段名。</p>\n<p> 然后修改密码啊：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where User=’root’; //将root用户密码改成 123456</div></pre></td></tr></table></figure></p>\n<p>  5.刷新权限，使配置生效<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">flush privileges;</div></pre></td></tr></table></figure></p>\n<p>   最后再启动 MySQL<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/local/mysql/support-files/mysql.server start</div></pre></td></tr></table></figure></p>\n<p>   当启动失败的话，可以直接用mac工具活动监视器：<br>   搜索mysql 进程名称列表有mysql的话，直接双击出现：这里写图片描述<br>   点击退出即可。</p>\n<p>   修改完之后记得刷新权限 和重新启动mysql服务才行。</p>\n"},{"title":"Python3 Flask bootstrap教程(1)","date":"2018-05-27T04:02:22.000Z","_content":"\n1.安装Flask\n2.安装bootstrap\n3.HelloWord\n\n### 安装Flask\n我用的py3，所以安装命令是：\n`pip3 install Flask`，安装之后，在Pycharm里边看到是这样子的，\n![py3第三方库列表](https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 安装bootstrap\n安装bootstrap，看这里[官方教程](https://v2.bootcss.com/index.html),\n或者[下载](http://getbootstrap.com/2.3.2/assets/bootstrap.zip\n)，然后解压，放到Flask的目录下边。我的目录是这样子的\n![目录](https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### HelloWord\n初始化Flask，\n新建app.py\n代码如下：\n```\nfrom flask import Flask, request, jsonify\nimport os\nfrom api.v1 import config\nfrom api.v1.user import user\nfrom flask_bootstrap import Bootstrap\n\napp = Flask(__name__)\nBootstrap(app)\napp.config.from_object(config)\napp.register_blueprint(user,url_prefix='/user')\n\nif __name__ == '__main__':\n    app.run()\n```\n选中文件，右键->run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.\n完整代码如下:\n```\napp = Flask(__name__)\nBootstrap(app)\napp.config.from_object(config)\napp.register_blueprint(user,url_prefix='/user')\n@app.route('/index')//添加路由\ndef my_index()://路由执行的函数\n    return jsonify({\"key\":'helloWord'})//返回数据\nif __name__ == '__main__':\n    app.run()//app运行\n```\n![helloword](https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/Python3 Flask bootstrap教程(1).md","raw":"title: Python3 Flask bootstrap教程(1)\ndate: 2018-05-27 12:02:22\ntags:\n- Flask\n- Python3\ncategories: Python3\n---\n\n1.安装Flask\n2.安装bootstrap\n3.HelloWord\n\n### 安装Flask\n我用的py3，所以安装命令是：\n`pip3 install Flask`，安装之后，在Pycharm里边看到是这样子的，\n![py3第三方库列表](https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 安装bootstrap\n安装bootstrap，看这里[官方教程](https://v2.bootcss.com/index.html),\n或者[下载](http://getbootstrap.com/2.3.2/assets/bootstrap.zip\n)，然后解压，放到Flask的目录下边。我的目录是这样子的\n![目录](https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### HelloWord\n初始化Flask，\n新建app.py\n代码如下：\n```\nfrom flask import Flask, request, jsonify\nimport os\nfrom api.v1 import config\nfrom api.v1.user import user\nfrom flask_bootstrap import Bootstrap\n\napp = Flask(__name__)\nBootstrap(app)\napp.config.from_object(config)\napp.register_blueprint(user,url_prefix='/user')\n\nif __name__ == '__main__':\n    app.run()\n```\n选中文件，右键->run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.\n完整代码如下:\n```\napp = Flask(__name__)\nBootstrap(app)\napp.config.from_object(config)\napp.register_blueprint(user,url_prefix='/user')\n@app.route('/index')//添加路由\ndef my_index()://路由执行的函数\n    return jsonify({\"key\":'helloWord'})//返回数据\nif __name__ == '__main__':\n    app.run()//app运行\n```\n![helloword](https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"Python3 Flask bootstrap教程(1)","published":1,"updated":"2019-12-03T04:48:00.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2700039zskaxhyg3je","content":"<p>1.安装Flask<br>2.安装bootstrap<br>3.HelloWord</p>\n<h3 id=\"安装Flask\"><a href=\"#安装Flask\" class=\"headerlink\" title=\"安装Flask\"></a>安装Flask</h3><p>我用的py3，所以安装命令是：<br><code>pip3 install Flask</code>，安装之后，在Pycharm里边看到是这样子的，<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"py3第三方库列表\"></p>\n<h3 id=\"安装bootstrap\"><a href=\"#安装bootstrap\" class=\"headerlink\" title=\"安装bootstrap\"></a>安装bootstrap</h3><p>安装bootstrap，看这里<a href=\"https://v2.bootcss.com/index.html\" target=\"_blank\" rel=\"external\">官方教程</a>,<br>或者<a href=\"http://getbootstrap.com/2.3.2/assets/bootstrap.zip\" target=\"_blank\" rel=\"external\">下载</a>，然后解压，放到Flask的目录下边。我的目录是这样子的<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<h3 id=\"HelloWord\"><a href=\"#HelloWord\" class=\"headerlink\" title=\"HelloWord\"></a>HelloWord</h3><p>初始化Flask，<br>新建app.py<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Flask, request, jsonify</div><div class=\"line\">import os</div><div class=\"line\">from api.v1 import config</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\">from flask_bootstrap import Bootstrap</div><div class=\"line\"></div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\">Bootstrap(app)</div><div class=\"line\">app.config.from_object(config)</div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure></p>\n<p>选中文件，右键-&gt;run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.<br>完整代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app = Flask(__name__)</div><div class=\"line\">Bootstrap(app)</div><div class=\"line\">app.config.from_object(config)</div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</div><div class=\"line\">@app.route(&apos;/index&apos;)//添加路由</div><div class=\"line\">def my_index()://路由执行的函数</div><div class=\"line\">    return jsonify(&#123;&quot;key&quot;:&apos;helloWord&apos;&#125;)//返回数据</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app.run()//app运行</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"helloword\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.安装Flask<br>2.安装bootstrap<br>3.HelloWord</p>\n<h3 id=\"安装Flask\"><a href=\"#安装Flask\" class=\"headerlink\" title=\"安装Flask\"></a>安装Flask</h3><p>我用的py3，所以安装命令是：<br><code>pip3 install Flask</code>，安装之后，在Pycharm里边看到是这样子的，<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-a4a6c6ec9ceee10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"py3第三方库列表\"></p>\n<h3 id=\"安装bootstrap\"><a href=\"#安装bootstrap\" class=\"headerlink\" title=\"安装bootstrap\"></a>安装bootstrap</h3><p>安装bootstrap，看这里<a href=\"https://v2.bootcss.com/index.html\" target=\"_blank\" rel=\"external\">官方教程</a>,<br>或者<a href=\"http://getbootstrap.com/2.3.2/assets/bootstrap.zip\" target=\"_blank\" rel=\"external\">下载</a>，然后解压，放到Flask的目录下边。我的目录是这样子的<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-be66520f42984dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<h3 id=\"HelloWord\"><a href=\"#HelloWord\" class=\"headerlink\" title=\"HelloWord\"></a>HelloWord</h3><p>初始化Flask，<br>新建app.py<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Flask, request, jsonify</div><div class=\"line\">import os</div><div class=\"line\">from api.v1 import config</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\">from flask_bootstrap import Bootstrap</div><div class=\"line\"></div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\">Bootstrap(app)</div><div class=\"line\">app.config.from_object(config)</div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure></p>\n<p>选中文件，右键-&gt;run。这样子就跑起来了，好像现在没接口，那我们添加一个路由.<br>完整代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app = Flask(__name__)</div><div class=\"line\">Bootstrap(app)</div><div class=\"line\">app.config.from_object(config)</div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;)</div><div class=\"line\">@app.route(&apos;/index&apos;)//添加路由</div><div class=\"line\">def my_index()://路由执行的函数</div><div class=\"line\">    return jsonify(&#123;&quot;key&quot;:&apos;helloWord&apos;&#125;)//返回数据</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app.run()//app运行</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/783986-435882bd99cf0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"helloword\"></p>\n"},{"title":"Python3 Flask bootstrap教程(2)","date":"2018-05-28T04:02:22.000Z","_content":"\n1.蓝图\n2.Nav的使用\n3.mysql使用\n4.模板的使用\n### 蓝图使用\n新建user文件夹,在user文件夹下变新建tamplates，还有__init__.py和views.py\n__init.py__\n```\nfrom flask import Blueprint\n//声明蓝图\nuser = Blueprint('user', __name__,template_folder='templates')\n\nfrom api.v1.user import views\n```\n然后在run.py中注册蓝图\n```\n先导入\nfrom api.v1.user import user\n\napp.register_blueprint(user,url_prefix='/user') 后边的是路径\n```\n然后在user的views中就可以写方法了。\n```\nfrom flask import Flask, request, jsonify,render_template\nfrom flask.json import tojson_filter\nfrom api.v1.user import user\nfrom api.v1 import first\nimport pymysql\nimport sys\nimport json\nfrom flask_bootstrap import Bootstrap\n//路由\n@user.route('/',methods=['GET','POST'])\n//方法\ndef my_index():\n    args = request.args;\n    age = ''\n    name = ''\n    if args.__contains__('name'):\n        name = request.args.getlist(key='name')\n    if args.__contains__('age'):\n        age = request.args.__getitem__('age')\n//返回数据是json\n    return jsonify({'method':sys._getframe().f_code.co_name,\n                    'name':str(name),\n                    'age':age})\n```\n现在我们想返回一个html，那么就在tamplates中新建一个index.html\n代码如下:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>结果</title>\n</head>\n<body>\n<h1>helloword</h1>\n</body>\n</html>\n```\n然后在views中增加路由\n```\n@user.route('/helloword')\ndef helloword():\n    return render_template('helloword.html')\n```\n运行程序,输入地址`127.0.0.1：5000/helloword`，出现helloword，就算我们的程序跑起来了。\n###  Nav的使用\nnav就是html的头部或者banner，我们写一个简单的例子\n```\n<ul class=\"nav nav-tabs\">\n    <li role=\"presentation\" class=\"dropdown\" id=\"myDropdown\">\n        <a class=\"dropdown-toggle\" data-toggle=\"dropdown\"  data-target=\"#\" role=\"button\" aria-haspopup=\"true\"\n           aria-expanded=\"false\">\n            主页 <span class=\"caret\" id=\"page1\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"page1\">\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"add\">添加</a></li>\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"list\">列表</a></li>\n            </li>\n        </ul>\n    </li>\n    <li class=\"dropdown\"  >\n        <a class=\"dropdown-toggle\" id=\"group2\" data-toggle=\"dropdown\" href=\"#\" role=\"button\">\n            文章 <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"group2\">\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"add\">添加</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n        </ul>\n    </li>\n\n    <li class=\"active\" role=\"presentation\">\n        <a class=\"dropdown-toggle\" data-toggle=\"\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            关于\n        </a>\n    </li>\n</ul>\n```\n这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。\n###  mysql使用\n本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。\n```\ndef userList():\n    con = pymysql.connect('127.0.0.1', 'root', '123456', 'test', charset='utf8')  # 添加utf8 否则中文乱码\n    cur = con.cursor()\n    cur.execute('select * from user')\n    nums = cur.rownumber\n    all = cur.fetchall()\n    data = []\n    for i in range(len(all)):\n        one = all[i]\n        data.append({'name': str(one[1]),\n                     'age': one[2]})\n\n    con.close()\n    return data\n\n```\n###  模板的使用\n模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html\n代码：\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <title>Bootstrap 101 Template</title>\n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\n<!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n<script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script>\n\n    <!-- Bootstrap -->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 -->\n    <!--[if lt IE 9]>\n      <script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"></script>\n      <script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"></script>\n    <![endif]-->\n</head>\n<ul class=\"nav nav-tabs\">\n    <li role=\"presentation\" class=\"dropdown\" id=\"myDropdown\">\n        <a class=\"dropdown-toggle\" data-toggle=\"dropdown\"  data-target=\"#\" role=\"button\" aria-haspopup=\"true\"\n           aria-expanded=\"false\">\n            主页 <span class=\"caret\" id=\"page1\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"page1\">\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"add\">添加</a></li>\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"list\">列表</a></li>\n            </li>\n        </ul>\n    </li>\n    <li class=\"dropdown\"  >\n        <a class=\"dropdown-toggle\" id=\"group2\" data-toggle=\"dropdown\" href=\"#\" role=\"button\">\n            文章 <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"group2\">\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"add\">添加</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n        </ul>\n    </li>\n\n    <li class=\"active\" role=\"presentation\">\n        <a class=\"dropdown-toggle\" data-toggle=\"\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            关于\n        </a>\n    </li>\n</ul>\n这下边就是定义的缺少的block\n{% block page_content %}\n{% endblock %}\n```\n然后我们在子网页中继承这个模板并且添加上去block\n```\n//继承刚才的网页\n{% extends 'base.html' %}\n//下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码\n{% block page_content %}\n<div class=\"pager\">\n    <h1 align=\"center\">用户列表</h1>\n\n    <table class=\"table nav-tabs\">\n        {% for i in data %}\n            <tr>\n                <td>名字：{{ i.name }}</td>\n                <td>年龄：{{ i.age }}</td>\n            </tr>\n        {% endfor %}\n        <tr>\n            <td align=\"center\">\n                <a href=\"add\">\n                    <input type=\"button\" value=\"添加用户\"  align=\"center\" style=\"width: 200px\">\n                </a>\n            </td>\n            <td align=\"center\">\n                <a href=\"list\" >\n                    <input type=\"button\"  value=\"用户列表\" style=\"width: 200px\">\n                </a>\n            </td>\n        </tr>\n    </table>\n</div>\n{% endblock %}\n```","source":"_posts/Python3 Flask bootstrap教程(2).md","raw":"title: Python3 Flask bootstrap教程(2)\ndate: 2018-05-28 12:02:22\ntags:\n- Flask\n- Python3\ncategories: Python3\n---\n\n1.蓝图\n2.Nav的使用\n3.mysql使用\n4.模板的使用\n### 蓝图使用\n新建user文件夹,在user文件夹下变新建tamplates，还有__init__.py和views.py\n__init.py__\n```\nfrom flask import Blueprint\n//声明蓝图\nuser = Blueprint('user', __name__,template_folder='templates')\n\nfrom api.v1.user import views\n```\n然后在run.py中注册蓝图\n```\n先导入\nfrom api.v1.user import user\n\napp.register_blueprint(user,url_prefix='/user') 后边的是路径\n```\n然后在user的views中就可以写方法了。\n```\nfrom flask import Flask, request, jsonify,render_template\nfrom flask.json import tojson_filter\nfrom api.v1.user import user\nfrom api.v1 import first\nimport pymysql\nimport sys\nimport json\nfrom flask_bootstrap import Bootstrap\n//路由\n@user.route('/',methods=['GET','POST'])\n//方法\ndef my_index():\n    args = request.args;\n    age = ''\n    name = ''\n    if args.__contains__('name'):\n        name = request.args.getlist(key='name')\n    if args.__contains__('age'):\n        age = request.args.__getitem__('age')\n//返回数据是json\n    return jsonify({'method':sys._getframe().f_code.co_name,\n                    'name':str(name),\n                    'age':age})\n```\n现在我们想返回一个html，那么就在tamplates中新建一个index.html\n代码如下:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>结果</title>\n</head>\n<body>\n<h1>helloword</h1>\n</body>\n</html>\n```\n然后在views中增加路由\n```\n@user.route('/helloword')\ndef helloword():\n    return render_template('helloword.html')\n```\n运行程序,输入地址`127.0.0.1：5000/helloword`，出现helloword，就算我们的程序跑起来了。\n###  Nav的使用\nnav就是html的头部或者banner，我们写一个简单的例子\n```\n<ul class=\"nav nav-tabs\">\n    <li role=\"presentation\" class=\"dropdown\" id=\"myDropdown\">\n        <a class=\"dropdown-toggle\" data-toggle=\"dropdown\"  data-target=\"#\" role=\"button\" aria-haspopup=\"true\"\n           aria-expanded=\"false\">\n            主页 <span class=\"caret\" id=\"page1\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"page1\">\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"add\">添加</a></li>\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"list\">列表</a></li>\n            </li>\n        </ul>\n    </li>\n    <li class=\"dropdown\"  >\n        <a class=\"dropdown-toggle\" id=\"group2\" data-toggle=\"dropdown\" href=\"#\" role=\"button\">\n            文章 <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"group2\">\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"add\">添加</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n        </ul>\n    </li>\n\n    <li class=\"active\" role=\"presentation\">\n        <a class=\"dropdown-toggle\" data-toggle=\"\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            关于\n        </a>\n    </li>\n</ul>\n```\n这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。\n###  mysql使用\n本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。\n```\ndef userList():\n    con = pymysql.connect('127.0.0.1', 'root', '123456', 'test', charset='utf8')  # 添加utf8 否则中文乱码\n    cur = con.cursor()\n    cur.execute('select * from user')\n    nums = cur.rownumber\n    all = cur.fetchall()\n    data = []\n    for i in range(len(all)):\n        one = all[i]\n        data.append({'name': str(one[1]),\n                     'age': one[2]})\n\n    con.close()\n    return data\n\n```\n###  模板的使用\n模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html\n代码：\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <title>Bootstrap 101 Template</title>\n    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\n<!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n<script src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script>\n\n    <!-- Bootstrap -->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 -->\n    <!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 -->\n    <!--[if lt IE 9]>\n      <script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"></script>\n      <script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"></script>\n    <![endif]-->\n</head>\n<ul class=\"nav nav-tabs\">\n    <li role=\"presentation\" class=\"dropdown\" id=\"myDropdown\">\n        <a class=\"dropdown-toggle\" data-toggle=\"dropdown\"  data-target=\"#\" role=\"button\" aria-haspopup=\"true\"\n           aria-expanded=\"false\">\n            主页 <span class=\"caret\" id=\"page1\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"page1\">\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"add\">添加</a></li>\n            <li role=\"presentation\">\n                <a role=\"menuitem\" href=\"list\">列表</a></li>\n            </li>\n        </ul>\n    </li>\n    <li class=\"dropdown\"  >\n        <a class=\"dropdown-toggle\" id=\"group2\" data-toggle=\"dropdown\" href=\"#\" role=\"button\">\n            文章 <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"group2\">\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"add\">添加</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n            <li role=\"presentation\">\n                 <a role=\"menuitem\" href=\"list\">列表</a>\n            </li>\n        </ul>\n    </li>\n\n    <li class=\"active\" role=\"presentation\">\n        <a class=\"dropdown-toggle\" data-toggle=\"\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            关于\n        </a>\n    </li>\n</ul>\n这下边就是定义的缺少的block\n{% block page_content %}\n{% endblock %}\n```\n然后我们在子网页中继承这个模板并且添加上去block\n```\n//继承刚才的网页\n{% extends 'base.html' %}\n//下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码\n{% block page_content %}\n<div class=\"pager\">\n    <h1 align=\"center\">用户列表</h1>\n\n    <table class=\"table nav-tabs\">\n        {% for i in data %}\n            <tr>\n                <td>名字：{{ i.name }}</td>\n                <td>年龄：{{ i.age }}</td>\n            </tr>\n        {% endfor %}\n        <tr>\n            <td align=\"center\">\n                <a href=\"add\">\n                    <input type=\"button\" value=\"添加用户\"  align=\"center\" style=\"width: 200px\">\n                </a>\n            </td>\n            <td align=\"center\">\n                <a href=\"list\" >\n                    <input type=\"button\"  value=\"用户列表\" style=\"width: 200px\">\n                </a>\n            </td>\n        </tr>\n    </table>\n</div>\n{% endblock %}\n```","slug":"Python3 Flask bootstrap教程(2)","published":1,"updated":"2019-12-03T04:48:00.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2800049zske1xnz2tl","content":"<p>1.蓝图<br>2.Nav的使用<br>3.mysql使用<br>4.模板的使用</p>\n<h3 id=\"蓝图使用\"><a href=\"#蓝图使用\" class=\"headerlink\" title=\"蓝图使用\"></a>蓝图使用</h3><p>新建user文件夹,在user文件夹下变新建tamplates，还有<strong>init</strong>.py和views.py<br><strong>init.py</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Blueprint</div><div class=\"line\">//声明蓝图</div><div class=\"line\">user = Blueprint(&apos;user&apos;, __name__,template_folder=&apos;templates&apos;)</div><div class=\"line\"></div><div class=\"line\">from api.v1.user import views</div></pre></td></tr></table></figure></p>\n<p>然后在run.py中注册蓝图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">先导入</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\"></div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;) 后边的是路径</div></pre></td></tr></table></figure></p>\n<p>然后在user的views中就可以写方法了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Flask, request, jsonify,render_template</div><div class=\"line\">from flask.json import tojson_filter</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\">from api.v1 import first</div><div class=\"line\">import pymysql</div><div class=\"line\">import sys</div><div class=\"line\">import json</div><div class=\"line\">from flask_bootstrap import Bootstrap</div><div class=\"line\">//路由</div><div class=\"line\">@user.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])</div><div class=\"line\">//方法</div><div class=\"line\">def my_index():</div><div class=\"line\">    args = request.args;</div><div class=\"line\">    age = &apos;&apos;</div><div class=\"line\">    name = &apos;&apos;</div><div class=\"line\">    if args.__contains__(&apos;name&apos;):</div><div class=\"line\">        name = request.args.getlist(key=&apos;name&apos;)</div><div class=\"line\">    if args.__contains__(&apos;age&apos;):</div><div class=\"line\">        age = request.args.__getitem__(&apos;age&apos;)</div><div class=\"line\">//返回数据是json</div><div class=\"line\">    return jsonify(&#123;&apos;method&apos;:sys._getframe().f_code.co_name,</div><div class=\"line\">                    &apos;name&apos;:str(name),</div><div class=\"line\">                    &apos;age&apos;:age&#125;)</div></pre></td></tr></table></figure></p>\n<p>现在我们想返回一个html，那么就在tamplates中新建一个index.html<br>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;结果&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;h1&gt;helloword&lt;/h1&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>然后在views中增加路由<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@user.route(&apos;/helloword&apos;)</div><div class=\"line\">def helloword():</div><div class=\"line\">    return render_template(&apos;helloword.html&apos;)</div></pre></td></tr></table></figure></p>\n<p>运行程序,输入地址<code>127.0.0.1：5000/helloword</code>，出现helloword，就算我们的程序跑起来了。</p>\n<h3 id=\"Nav的使用\"><a href=\"#Nav的使用\" class=\"headerlink\" title=\"Nav的使用\"></a>Nav的使用</h3><p>nav就是html的头部或者banner，我们写一个简单的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</div><div class=\"line\">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</div><div class=\"line\">           aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">    &lt;li class=&quot;dropdown&quot;  &gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</div><div class=\"line\">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            关于</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。</p>\n<h3 id=\"mysql使用\"><a href=\"#mysql使用\" class=\"headerlink\" title=\"mysql使用\"></a>mysql使用</h3><p>本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def userList():</div><div class=\"line\">    con = pymysql.connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;, charset=&apos;utf8&apos;)  # 添加utf8 否则中文乱码</div><div class=\"line\">    cur = con.cursor()</div><div class=\"line\">    cur.execute(&apos;select * from user&apos;)</div><div class=\"line\">    nums = cur.rownumber</div><div class=\"line\">    all = cur.fetchall()</div><div class=\"line\">    data = []</div><div class=\"line\">    for i in range(len(all)):</div><div class=\"line\">        one = all[i]</div><div class=\"line\">        data.append(&#123;&apos;name&apos;: str(one[1]),</div><div class=\"line\">                     &apos;age&apos;: one[2]&#125;)</div><div class=\"line\"></div><div class=\"line\">    con.close()</div><div class=\"line\">    return data</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板的使用\"><a href=\"#模板的使用\" class=\"headerlink\" title=\"模板的使用\"></a>模板的使用</h3><p>模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;zh-CN&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</div><div class=\"line\">    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</div><div class=\"line\">    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;</div><div class=\"line\">    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- Bootstrap --&gt;</div><div class=\"line\">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</div><div class=\"line\">    &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</div><div class=\"line\">    &lt;!--[if lt IE 9]&gt;</div><div class=\"line\">      &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">      &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;![endif]--&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</div><div class=\"line\">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</div><div class=\"line\">           aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">    &lt;li class=&quot;dropdown&quot;  &gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</div><div class=\"line\">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            关于</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">这下边就是定义的缺少的block</div><div class=\"line\">&#123;% block page_content %&#125;</div><div class=\"line\">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们在子网页中继承这个模板并且添加上去block<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//继承刚才的网页</div><div class=\"line\">&#123;% extends &apos;base.html&apos; %&#125;</div><div class=\"line\">//下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码</div><div class=\"line\">&#123;% block page_content %&#125;</div><div class=\"line\">&lt;div class=&quot;pager&quot;&gt;</div><div class=\"line\">    &lt;h1 align=&quot;center&quot;&gt;用户列表&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;table class=&quot;table nav-tabs&quot;&gt;</div><div class=\"line\">        &#123;% for i in data %&#125;</div><div class=\"line\">            &lt;tr&gt;</div><div class=\"line\">                &lt;td&gt;名字：&#123;&#123; i.name &#125;&#125;&lt;/td&gt;</div><div class=\"line\">                &lt;td&gt;年龄：&#123;&#123; i.age &#125;&#125;&lt;/td&gt;</div><div class=\"line\">            &lt;/tr&gt;</div><div class=\"line\">        &#123;% endfor %&#125;</div><div class=\"line\">        &lt;tr&gt;</div><div class=\"line\">            &lt;td align=&quot;center&quot;&gt;</div><div class=\"line\">                &lt;a href=&quot;add&quot;&gt;</div><div class=\"line\">                    &lt;input type=&quot;button&quot; value=&quot;添加用户&quot;  align=&quot;center&quot; style=&quot;width: 200px&quot;&gt;</div><div class=\"line\">                &lt;/a&gt;</div><div class=\"line\">            &lt;/td&gt;</div><div class=\"line\">            &lt;td align=&quot;center&quot;&gt;</div><div class=\"line\">                &lt;a href=&quot;list&quot; &gt;</div><div class=\"line\">                    &lt;input type=&quot;button&quot;  value=&quot;用户列表&quot; style=&quot;width: 200px&quot;&gt;</div><div class=\"line\">                &lt;/a&gt;</div><div class=\"line\">            &lt;/td&gt;</div><div class=\"line\">        &lt;/tr&gt;</div><div class=\"line\">    &lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.蓝图<br>2.Nav的使用<br>3.mysql使用<br>4.模板的使用</p>\n<h3 id=\"蓝图使用\"><a href=\"#蓝图使用\" class=\"headerlink\" title=\"蓝图使用\"></a>蓝图使用</h3><p>新建user文件夹,在user文件夹下变新建tamplates，还有<strong>init</strong>.py和views.py<br><strong>init.py</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Blueprint</div><div class=\"line\">//声明蓝图</div><div class=\"line\">user = Blueprint(&apos;user&apos;, __name__,template_folder=&apos;templates&apos;)</div><div class=\"line\"></div><div class=\"line\">from api.v1.user import views</div></pre></td></tr></table></figure></p>\n<p>然后在run.py中注册蓝图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">先导入</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\"></div><div class=\"line\">app.register_blueprint(user,url_prefix=&apos;/user&apos;) 后边的是路径</div></pre></td></tr></table></figure></p>\n<p>然后在user的views中就可以写方法了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">from flask import Flask, request, jsonify,render_template</div><div class=\"line\">from flask.json import tojson_filter</div><div class=\"line\">from api.v1.user import user</div><div class=\"line\">from api.v1 import first</div><div class=\"line\">import pymysql</div><div class=\"line\">import sys</div><div class=\"line\">import json</div><div class=\"line\">from flask_bootstrap import Bootstrap</div><div class=\"line\">//路由</div><div class=\"line\">@user.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])</div><div class=\"line\">//方法</div><div class=\"line\">def my_index():</div><div class=\"line\">    args = request.args;</div><div class=\"line\">    age = &apos;&apos;</div><div class=\"line\">    name = &apos;&apos;</div><div class=\"line\">    if args.__contains__(&apos;name&apos;):</div><div class=\"line\">        name = request.args.getlist(key=&apos;name&apos;)</div><div class=\"line\">    if args.__contains__(&apos;age&apos;):</div><div class=\"line\">        age = request.args.__getitem__(&apos;age&apos;)</div><div class=\"line\">//返回数据是json</div><div class=\"line\">    return jsonify(&#123;&apos;method&apos;:sys._getframe().f_code.co_name,</div><div class=\"line\">                    &apos;name&apos;:str(name),</div><div class=\"line\">                    &apos;age&apos;:age&#125;)</div></pre></td></tr></table></figure></p>\n<p>现在我们想返回一个html，那么就在tamplates中新建一个index.html<br>代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;结果&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;h1&gt;helloword&lt;/h1&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>然后在views中增加路由<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@user.route(&apos;/helloword&apos;)</div><div class=\"line\">def helloword():</div><div class=\"line\">    return render_template(&apos;helloword.html&apos;)</div></pre></td></tr></table></figure></p>\n<p>运行程序,输入地址<code>127.0.0.1：5000/helloword</code>，出现helloword，就算我们的程序跑起来了。</p>\n<h3 id=\"Nav的使用\"><a href=\"#Nav的使用\" class=\"headerlink\" title=\"Nav的使用\"></a>Nav的使用</h3><p>nav就是html的头部或者banner，我们写一个简单的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</div><div class=\"line\">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</div><div class=\"line\">           aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">    &lt;li class=&quot;dropdown&quot;  &gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</div><div class=\"line\">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            关于</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>\n<p>这里边有一个ul 套着一个li，一个li套着一个ul，第二个 ul就是二级菜单。</p>\n<h3 id=\"mysql使用\"><a href=\"#mysql使用\" class=\"headerlink\" title=\"mysql使用\"></a>mysql使用</h3><p>本地需要装环境mysql，用户是root，密码是123456，数据库是test，格式是utf8。下边是我们一个函数返回查询到的表中所有user的名字和年龄。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def userList():</div><div class=\"line\">    con = pymysql.connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;test&apos;, charset=&apos;utf8&apos;)  # 添加utf8 否则中文乱码</div><div class=\"line\">    cur = con.cursor()</div><div class=\"line\">    cur.execute(&apos;select * from user&apos;)</div><div class=\"line\">    nums = cur.rownumber</div><div class=\"line\">    all = cur.fetchall()</div><div class=\"line\">    data = []</div><div class=\"line\">    for i in range(len(all)):</div><div class=\"line\">        one = all[i]</div><div class=\"line\">        data.append(&#123;&apos;name&apos;: str(one[1]),</div><div class=\"line\">                     &apos;age&apos;: one[2]&#125;)</div><div class=\"line\"></div><div class=\"line\">    con.close()</div><div class=\"line\">    return data</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板的使用\"><a href=\"#模板的使用\" class=\"headerlink\" title=\"模板的使用\"></a>模板的使用</h3><p>模板是需要我们在模板中先定义一个空的block，然后在继承这个html，把这个block给添加上，等于把一个html文件分拆成多个文件，也可以理解成组件化。添加一个base.html<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;zh-CN&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</div><div class=\"line\">    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</div><div class=\"line\">    &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;</div><div class=\"line\">    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</div><div class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- Bootstrap --&gt;</div><div class=\"line\">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</div><div class=\"line\">    &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</div><div class=\"line\">    &lt;!--[if lt IE 9]&gt;</div><div class=\"line\">      &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">      &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;![endif]--&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</div><div class=\"line\">    &lt;li role=&quot;presentation&quot; class=&quot;dropdown&quot; id=&quot;myDropdown&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;  data-target=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot;</div><div class=\"line\">           aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            主页 &lt;span class=&quot;caret&quot; id=&quot;page1&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;page1&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">    &lt;li class=&quot;dropdown&quot;  &gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; id=&quot;group2&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;</div><div class=\"line\">            文章 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">        &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;group2&quot;&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;add&quot;&gt;添加&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">            &lt;li role=&quot;presentation&quot;&gt;</div><div class=\"line\">                 &lt;a role=&quot;menuitem&quot; href=&quot;list&quot;&gt;列表&lt;/a&gt;</div><div class=\"line\">            &lt;/li&gt;</div><div class=\"line\">        &lt;/ul&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;li class=&quot;active&quot; role=&quot;presentation&quot;&gt;</div><div class=\"line\">        &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;&quot; href=&quot;#&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;</div><div class=\"line\">            关于</div><div class=\"line\">        &lt;/a&gt;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">这下边就是定义的缺少的block</div><div class=\"line\">&#123;% block page_content %&#125;</div><div class=\"line\">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们在子网页中继承这个模板并且添加上去block<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//继承刚才的网页</div><div class=\"line\">&#123;% extends &apos;base.html&apos; %&#125;</div><div class=\"line\">//下边的block的对应刚才定义的代码块，对应不上的话，会展现不出来下边的代码</div><div class=\"line\">&#123;% block page_content %&#125;</div><div class=\"line\">&lt;div class=&quot;pager&quot;&gt;</div><div class=\"line\">    &lt;h1 align=&quot;center&quot;&gt;用户列表&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;table class=&quot;table nav-tabs&quot;&gt;</div><div class=\"line\">        &#123;% for i in data %&#125;</div><div class=\"line\">            &lt;tr&gt;</div><div class=\"line\">                &lt;td&gt;名字：&#123;&#123; i.name &#125;&#125;&lt;/td&gt;</div><div class=\"line\">                &lt;td&gt;年龄：&#123;&#123; i.age &#125;&#125;&lt;/td&gt;</div><div class=\"line\">            &lt;/tr&gt;</div><div class=\"line\">        &#123;% endfor %&#125;</div><div class=\"line\">        &lt;tr&gt;</div><div class=\"line\">            &lt;td align=&quot;center&quot;&gt;</div><div class=\"line\">                &lt;a href=&quot;add&quot;&gt;</div><div class=\"line\">                    &lt;input type=&quot;button&quot; value=&quot;添加用户&quot;  align=&quot;center&quot; style=&quot;width: 200px&quot;&gt;</div><div class=\"line\">                &lt;/a&gt;</div><div class=\"line\">            &lt;/td&gt;</div><div class=\"line\">            &lt;td align=&quot;center&quot;&gt;</div><div class=\"line\">                &lt;a href=&quot;list&quot; &gt;</div><div class=\"line\">                    &lt;input type=&quot;button&quot;  value=&quot;用户列表&quot; style=&quot;width: 200px&quot;&gt;</div><div class=\"line\">                &lt;/a&gt;</div><div class=\"line\">            &lt;/td&gt;</div><div class=\"line\">        &lt;/tr&gt;</div><div class=\"line\">    &lt;/table&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"iOS底层原理  对象的本质 --(1)","date":"2019-12-01T03:11:58.000Z","_content":"\n### 对象的本质\n探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。\n那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC对象的内存布局和内存分配机制。\n\n使用的[代码下载](https://github.com/ifgyong/demo/tree/master/OC)\n要用的工具:\n\n- [Xcode 10.2](https://developer.apple.com/cn/support/xcode/)\n- [gotoShell](https://zipzapmac.com/Go2Shell)\n- [linux-glibc-2.29源码](http://ftp.gnu.org/gnu/glibc/)\n- [libmalloc源码](https://opensource.apple.com/tarballs/libmalloc/)\n\n首先我们使用最基本的代码验证对象是什么?\n\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tNSObject *obj=[[NSObject alloc]init];\n\t    NSLog(@\"Hello, World!\");\n\t}\n\treturn 0;\n}\n```\n\n使用`clang`编译器编译成`cpp`，\n执行`clang -rewrite-objc main.m -o main.cpp`之后生成的`cpp`，这个生成的`cpp`我们不知道是跑在哪个平台的，现在我们指定`iphoeos`和`arm64`重新编译一下。`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`，将`main64.cpp`拖拽到Xcode中并打开。\n|clang|编译器|\n|--------------|-------|\n|xcrun|命令|\n|sdk|指定编译的平台|\n|arch|arm64架构|\n|-rewrite-objc|重写|\n|main.m|重写的文件|\n|main64.cpp|导出的文件|\n|-o|导出|\n\n`command + F`查找`int main`,找到关键代码，这就是`main`函数的转化成`c/c++`的代码：\n\n```\nint main(int argc, const char * argv[]) {\n /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n  NSObject *obj=((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n     NSLog((NSString *)&__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);\n }\n return 0;\n}\n```\n\n然后搜索\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n那么这个结构体是什么呢？\n其实我们`Object-C`编译之后对象会编译成结构体，如图所示：\n![](../images/1-1.png)\n那么`isa`是什么吗？通过查看源码得知：\n\n```\ntypedef struct objc_class *Class; \n```\n\n`class`其实是一个指向结构体的指针，然后`com+点击class`得到：\n\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n`class`是一个指针，那么占用多少内存呢？大家都知道**指针在32位是4字节，在64位是8字节。**\n\n```\nNSObject *obj=[[NSObject alloc]init];\n```\n\n可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。\n`obj`就是指向结构体`class`的一个指针。\n那么我们来验证一下：\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tNSObject *obj=[[NSObject alloc]init];\n\t\t//获得NSobject对象实例大小\n\t\tsize_t size = class_getInstanceSize(obj.class);\n\t\t//获取NSObjet指针的指向的内存大小\n\t\t//需要导入：#import <malloc/malloc.h>\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tNSLog(@\"size:%zu size2:%zu\",size,size2);\n\t}\n\treturn 0;\n}\n```\n\n得出结果是：\n\n```\nsize:8 size2:16\n```\n\n结论是：**指针是8字节，指针指向的的内存大小为16字节。**\n查看源码得知`[[NSObject alloc]init]`的函数运行顺序是:\n\n```\nclass_createInstance\n    -_class_createInstanceFromZone\n```\n\n```\nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n    **\n    size_t size = cls->instanceSize(extraBytes);\n    **\n    return obj;\n}\n\n```\n这个函数前边后边省略，取出关键代码，其实`size`是`cls->instanceSize(extraBytes)`执行的结果。那么我们再看下`cls->instanceSize`的源码：\n\n```\n//成员变量大小 8bytes\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n    \n    size_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n可以通过源码注释得知：CF要求所有的objects 最小是16bytes。\n\n`class_getInstanceSize`函数的内部执行顺序是`class_getInstanceSize->cls->alignedInstanceSize()`\n查阅源码：\n```\n//成员变量大小 8bytes\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n```\n所以最终结论是：**对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes**。\n\n验证：\n在刚才 的代码打断点和设置`Debug->Debug Workflow->View Memory`,然后运行程序，\n\n![](../images/1-2.png)\n\n![](../images/1-3.png)\n点击`obj->view *objc`得到上图所示的内存布局，从`address`看出和`obj`内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.\n\n使用lldb命令`memory read 0x100601f30`输出内存布局，如下图：\n![](../images/1-4.png)\n或者使用`x/4xg 0x100601f30`输出：\n\n![](../images/1-5.png)\n`x/4xg 0x100601f30`中`4`是输出`4`个数据,`x` 是16进制,后边`g`是8字节为单位。可以验证刚才的出的结论。\n\n那么我们再使用复杂的一个对象来验证：\n```\n@interface Person : NSObject\n{\n\tint _age;\n\tint _no;\n}\n@end\n```\n使用`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`编译之后对应的源码是：\n\n```\nstruct NSObject_IMPL {\n Class isa;\n};\nstruct Person_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;// 8 bytes\n\tint _age;//4 bytes\n\tint _no;//4 bytes\n};\n```\n\n`Person——IMPL`**结构体占用16bytes**\n\n```\nPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 15;\n\t\tobj->_no = 14;\n```\n\n使用代码验证：\n\n```\n\t\tPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 15;\n\t\tobj->_no = 14;\n\t\t\n\t\tstruct Person_IMPL *p =(__bridge struct Person_IMPL*)obj;\n\t\tNSLog(@\"age:%d no:%d\",p->_age,p->_no);\n\t\t\n\t\t//age:15 no:14\n```\n使用内存布局验证：\n\n![](../images/1-6.png)\n以十进制输出每个4字节\n![](../images/1-7.png)\n使用内存布局查看数据验证，`Person`占用16 bytes。\n\n下边是一个直观的内存布局图：\n\n![](../images/1-8.png)\n\n#### 再看一下更复杂的继承关系的内存布局：\n\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes \n}\n@end\n@implementation Person\n@end\n\n//Student\n@interface Student : Person\n{\n@public\n\tint _no;//4bytes\n}\n@end\n@implementation Student\n@end\n```\n\n那小伙伴可能要说这一定是32字节，因为`Person`上边已经证明是16字节，`Student`又多了个成员变量`_no`，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。\n其实不然，`Person`是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，`Student`是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以`Student`是占用了16字节。\n\n那么我们来证明一下：\n\n```\nStudent *obj=[[Student alloc]init];\n\t\tobj->_age = 6;\n\t\tobj->_no = 7;\n\t\t\n\t\t//获得NSobject对象实例成员变量占用的大小 ->8\n\t\tsize_t size = class_getInstanceSize(obj.class);\n\t\t//获取NSObjet指针的指向的内存大小 ->16\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tNSLog(@\"size:%zu size2:%zu\",size,size2);\n\t\t//size:16 size2:16\n\t\t\n\t\t\n```\n\n再看一下LLDB查看的内存布局：\n\n```\n(lldb) x/8xw 0x10071ae30\n0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007\n0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff\n\n(lldb) memory read 0x10071ae30\n0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................\n0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....\n\n(lldb) x/4xg 0x10071ae30\n0x10071ae30: 0x001d800100001299 0x0000000700000006\n0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0\n\n```\n可以看出来`0x00000006`和`0x00000007`就是两个成员变量的值，占用内存是16字节。\n\n我们将`Student`新增一个成员变量：\n```\n//Student\n@interface Student : Person\n{\n@public\n\tint _no;//4bytes\n\tint _no2;//4bytes\n}\n@end\n@implementation Student\n@end\n```\n然后查看内存布局：\n```\n(lldb) x/8xg 0x102825db0\n0x102825db0: 0x001d8001000012c1 0x0000000700000006\n0x102825dc0: 0x0000000000000000 0x0000000000000000\n0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80\n0x102825de0: 0x0000000102825c60 0x0000000102825890\n\n```\n从`LLDB`可以看出来，**内存变成了32字节。(0x102825dd0-0x102825db0=0x20)**\n\n\n我们再增加一个属性看下:\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes \n}\n@property (nonatomic,assign) int level; //4字节\n@end\n@implementation Person\n@end\n\n//InstanceSize:16 malloc_size:16 \n```\n为什么新增了一个属性，内存还是和没有新增的时候一样呢？\n因为`property`=`setter`+`getter`+`ivar`,`method`是存在类对象中的，所以实例`Person`占用的内存还是`_age`,`_level`和一个指向类的指针，最后结果是`4+4+8=16bytes`。\n\n再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个`int`成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。\n\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes\n\tint _level;//4bytes\n\tint _code;//4bytes\n}\n@end\n@implementation Person\n@end\n\nPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 6;\n\t\t\n\t\t\n\t\t//获得NSobject对象实例成员变量占用的大小 ->24\n\t\tClass ocl = obj.class;\n\t\tsize_t size = class_getInstanceSize(ocl);\n\t\t//获取NSObjet指针的指向的内存大小 ->32\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tprintf(\"InstanceSize:%zu malloc_size:%zu \\n\",size,size2);\n\t\t\nInstanceSize:24 malloc_size:32\n```\n\n为什么和我们猜测的不一样呢？\n那么我们再探究一下：\n实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码`NSObject.mm 2306行`得到创建对象函数调用顺序`allocWithZone->_objc_rootAllocWithZone->_objc_rootAllocWithZone->class_createInstance->_class_createInstanceFromZone->_class_createInstanceFromZone`最后查看下`_class_createInstanceFromZone`的源码，其他已省略，只留关键代码：\n\n```\nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n**\n    size_t size = cls->instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize = size;\n    **\n    obj = (id)calloc(1, size);\n   **\n    return obj;\n}\n\n```\n\n那么我们在看一下`instanceSize`中的实现：\n\n```\n\t//对象指针的大小\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n\n    size_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n\n最后调用的`obj = (id)calloc(1, size);`传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？\n因为这是`c`函数，我们去[苹果开源官网下载源码看下](https://opensource.apple.com/tarballs/libmalloc/),可以找到这句代码：\n\n```\ndefine NANO_MAX_SIZE\t\t\t256 /* Buckets sized {16, 32, 48, 64, 80, 96, 112, ...} */\n```\n\n看来`NANO_MAX_SIZE`在申请空间的时候做完优化就是16的倍数,并且最大是256。所以`size = 24 ;obj = (id)calloc(1, size);`申请的结果是32字节。\n然后再看下`Linux`空间申请的机制是什么？\n[下载gnu资料](http://ftp.gnu.org/gnu/glibc/)，\n得到：\n\n```\n#ifndef _I386_MALLOC_ALIGNMENT_H\n#define _I386_MALLOC_ALIGNMENT_H\n\n#define MALLOC_ALIGNMENT 16\n\n#endif /* !defined(_I386_MALLOC_ALIGNMENT_H) */\n\n\n/* MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.  It\n   must be a power of two at least 2 * SIZE_SZ, even on machines for\n   which smaller alignments would suffice. It may be defined as larger\n   than this though. Note however that code and data structures are\n   optimized for the case of 8-byte alignment.  */\n   //最少是2倍的SIZE_SZ 或者是__alignof__(long double)\n#define MALLOC_ALIGNMENT (2 * SIZE_SZ < __alignof__ (long double) \\\n\t\t\t  ? __alignof__ (long double) : 2 * SIZE_SZ)\n\t\t\t  \n\t\t\t  \n/* The corresponding word size.  */\n#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))\n\n#ifndef INTERNAL_SIZE_T\n# define INTERNAL_SIZE_T size_t\n#endif\n```\n在i386中是16，在其他系统中按照宏定义计算，\n`__alignof__ (long double)`在iOS中是16,`size_t`是8，则上面的代码简写为`#define MALLOC_ALIGNMENT (2*8 < 16 ? 16:2*8)`最终是16字节。\n\n总结：\n> 实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。\n\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo 查看](https://github.com/ifgyong/demo/tree/master/OC)\n\n---\n广告时间\n\n![](https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&h=268&f=jpeg&s=27083)\n\n\n\n\n\n","source":"_posts/IOS底层原理 对象的本质--(1).md","raw":"\ntitle: iOS底层原理  对象的本质 --(1)\ndate: 2019-12-1 11:11:58\ntags:\n- iOS\ncategories: iOS\n---\n\n### 对象的本质\n探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。\n那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC对象的内存布局和内存分配机制。\n\n使用的[代码下载](https://github.com/ifgyong/demo/tree/master/OC)\n要用的工具:\n\n- [Xcode 10.2](https://developer.apple.com/cn/support/xcode/)\n- [gotoShell](https://zipzapmac.com/Go2Shell)\n- [linux-glibc-2.29源码](http://ftp.gnu.org/gnu/glibc/)\n- [libmalloc源码](https://opensource.apple.com/tarballs/libmalloc/)\n\n首先我们使用最基本的代码验证对象是什么?\n\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tNSObject *obj=[[NSObject alloc]init];\n\t    NSLog(@\"Hello, World!\");\n\t}\n\treturn 0;\n}\n```\n\n使用`clang`编译器编译成`cpp`，\n执行`clang -rewrite-objc main.m -o main.cpp`之后生成的`cpp`，这个生成的`cpp`我们不知道是跑在哪个平台的，现在我们指定`iphoeos`和`arm64`重新编译一下。`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`，将`main64.cpp`拖拽到Xcode中并打开。\n|clang|编译器|\n|--------------|-------|\n|xcrun|命令|\n|sdk|指定编译的平台|\n|arch|arm64架构|\n|-rewrite-objc|重写|\n|main.m|重写的文件|\n|main64.cpp|导出的文件|\n|-o|导出|\n\n`command + F`查找`int main`,找到关键代码，这就是`main`函数的转化成`c/c++`的代码：\n\n```\nint main(int argc, const char * argv[]) {\n /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n  NSObject *obj=((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n     NSLog((NSString *)&__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);\n }\n return 0;\n}\n```\n\n然后搜索\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n那么这个结构体是什么呢？\n其实我们`Object-C`编译之后对象会编译成结构体，如图所示：\n![](../images/1-1.png)\n那么`isa`是什么吗？通过查看源码得知：\n\n```\ntypedef struct objc_class *Class; \n```\n\n`class`其实是一个指向结构体的指针，然后`com+点击class`得到：\n\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n\n`class`是一个指针，那么占用多少内存呢？大家都知道**指针在32位是4字节，在64位是8字节。**\n\n```\nNSObject *obj=[[NSObject alloc]init];\n```\n\n可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。\n`obj`就是指向结构体`class`的一个指针。\n那么我们来验证一下：\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tNSObject *obj=[[NSObject alloc]init];\n\t\t//获得NSobject对象实例大小\n\t\tsize_t size = class_getInstanceSize(obj.class);\n\t\t//获取NSObjet指针的指向的内存大小\n\t\t//需要导入：#import <malloc/malloc.h>\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tNSLog(@\"size:%zu size2:%zu\",size,size2);\n\t}\n\treturn 0;\n}\n```\n\n得出结果是：\n\n```\nsize:8 size2:16\n```\n\n结论是：**指针是8字节，指针指向的的内存大小为16字节。**\n查看源码得知`[[NSObject alloc]init]`的函数运行顺序是:\n\n```\nclass_createInstance\n    -_class_createInstanceFromZone\n```\n\n```\nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n    **\n    size_t size = cls->instanceSize(extraBytes);\n    **\n    return obj;\n}\n\n```\n这个函数前边后边省略，取出关键代码，其实`size`是`cls->instanceSize(extraBytes)`执行的结果。那么我们再看下`cls->instanceSize`的源码：\n\n```\n//成员变量大小 8bytes\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n    \n    size_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n可以通过源码注释得知：CF要求所有的objects 最小是16bytes。\n\n`class_getInstanceSize`函数的内部执行顺序是`class_getInstanceSize->cls->alignedInstanceSize()`\n查阅源码：\n```\n//成员变量大小 8bytes\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n```\n所以最终结论是：**对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes**。\n\n验证：\n在刚才 的代码打断点和设置`Debug->Debug Workflow->View Memory`,然后运行程序，\n\n![](../images/1-2.png)\n\n![](../images/1-3.png)\n点击`obj->view *objc`得到上图所示的内存布局，从`address`看出和`obj`内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.\n\n使用lldb命令`memory read 0x100601f30`输出内存布局，如下图：\n![](../images/1-4.png)\n或者使用`x/4xg 0x100601f30`输出：\n\n![](../images/1-5.png)\n`x/4xg 0x100601f30`中`4`是输出`4`个数据,`x` 是16进制,后边`g`是8字节为单位。可以验证刚才的出的结论。\n\n那么我们再使用复杂的一个对象来验证：\n```\n@interface Person : NSObject\n{\n\tint _age;\n\tint _no;\n}\n@end\n```\n使用`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`编译之后对应的源码是：\n\n```\nstruct NSObject_IMPL {\n Class isa;\n};\nstruct Person_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;// 8 bytes\n\tint _age;//4 bytes\n\tint _no;//4 bytes\n};\n```\n\n`Person——IMPL`**结构体占用16bytes**\n\n```\nPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 15;\n\t\tobj->_no = 14;\n```\n\n使用代码验证：\n\n```\n\t\tPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 15;\n\t\tobj->_no = 14;\n\t\t\n\t\tstruct Person_IMPL *p =(__bridge struct Person_IMPL*)obj;\n\t\tNSLog(@\"age:%d no:%d\",p->_age,p->_no);\n\t\t\n\t\t//age:15 no:14\n```\n使用内存布局验证：\n\n![](../images/1-6.png)\n以十进制输出每个4字节\n![](../images/1-7.png)\n使用内存布局查看数据验证，`Person`占用16 bytes。\n\n下边是一个直观的内存布局图：\n\n![](../images/1-8.png)\n\n#### 再看一下更复杂的继承关系的内存布局：\n\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes \n}\n@end\n@implementation Person\n@end\n\n//Student\n@interface Student : Person\n{\n@public\n\tint _no;//4bytes\n}\n@end\n@implementation Student\n@end\n```\n\n那小伙伴可能要说这一定是32字节，因为`Person`上边已经证明是16字节，`Student`又多了个成员变量`_no`，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。\n其实不然，`Person`是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，`Student`是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以`Student`是占用了16字节。\n\n那么我们来证明一下：\n\n```\nStudent *obj=[[Student alloc]init];\n\t\tobj->_age = 6;\n\t\tobj->_no = 7;\n\t\t\n\t\t//获得NSobject对象实例成员变量占用的大小 ->8\n\t\tsize_t size = class_getInstanceSize(obj.class);\n\t\t//获取NSObjet指针的指向的内存大小 ->16\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tNSLog(@\"size:%zu size2:%zu\",size,size2);\n\t\t//size:16 size2:16\n\t\t\n\t\t\n```\n\n再看一下LLDB查看的内存布局：\n\n```\n(lldb) x/8xw 0x10071ae30\n0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007\n0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff\n\n(lldb) memory read 0x10071ae30\n0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................\n0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....\n\n(lldb) x/4xg 0x10071ae30\n0x10071ae30: 0x001d800100001299 0x0000000700000006\n0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0\n\n```\n可以看出来`0x00000006`和`0x00000007`就是两个成员变量的值，占用内存是16字节。\n\n我们将`Student`新增一个成员变量：\n```\n//Student\n@interface Student : Person\n{\n@public\n\tint _no;//4bytes\n\tint _no2;//4bytes\n}\n@end\n@implementation Student\n@end\n```\n然后查看内存布局：\n```\n(lldb) x/8xg 0x102825db0\n0x102825db0: 0x001d8001000012c1 0x0000000700000006\n0x102825dc0: 0x0000000000000000 0x0000000000000000\n0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80\n0x102825de0: 0x0000000102825c60 0x0000000102825890\n\n```\n从`LLDB`可以看出来，**内存变成了32字节。(0x102825dd0-0x102825db0=0x20)**\n\n\n我们再增加一个属性看下:\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes \n}\n@property (nonatomic,assign) int level; //4字节\n@end\n@implementation Person\n@end\n\n//InstanceSize:16 malloc_size:16 \n```\n为什么新增了一个属性，内存还是和没有新增的时候一样呢？\n因为`property`=`setter`+`getter`+`ivar`,`method`是存在类对象中的，所以实例`Person`占用的内存还是`_age`,`_level`和一个指向类的指针，最后结果是`4+4+8=16bytes`。\n\n再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个`int`成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。\n\n```\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes\n\tint _level;//4bytes\n\tint _code;//4bytes\n}\n@end\n@implementation Person\n@end\n\nPerson *obj=[[Person alloc]init];\n\t\tobj->_age = 6;\n\t\t\n\t\t\n\t\t//获得NSobject对象实例成员变量占用的大小 ->24\n\t\tClass ocl = obj.class;\n\t\tsize_t size = class_getInstanceSize(ocl);\n\t\t//获取NSObjet指针的指向的内存大小 ->32\n\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));\n\t\tprintf(\"InstanceSize:%zu malloc_size:%zu \\n\",size,size2);\n\t\t\nInstanceSize:24 malloc_size:32\n```\n\n为什么和我们猜测的不一样呢？\n那么我们再探究一下：\n实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码`NSObject.mm 2306行`得到创建对象函数调用顺序`allocWithZone->_objc_rootAllocWithZone->_objc_rootAllocWithZone->class_createInstance->_class_createInstanceFromZone->_class_createInstanceFromZone`最后查看下`_class_createInstanceFromZone`的源码，其他已省略，只留关键代码：\n\n```\nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n**\n    size_t size = cls->instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize = size;\n    **\n    obj = (id)calloc(1, size);\n   **\n    return obj;\n}\n\n```\n\n那么我们在看一下`instanceSize`中的实现：\n\n```\n\t//对象指针的大小\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n\n    size_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n\n最后调用的`obj = (id)calloc(1, size);`传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？\n因为这是`c`函数，我们去[苹果开源官网下载源码看下](https://opensource.apple.com/tarballs/libmalloc/),可以找到这句代码：\n\n```\ndefine NANO_MAX_SIZE\t\t\t256 /* Buckets sized {16, 32, 48, 64, 80, 96, 112, ...} */\n```\n\n看来`NANO_MAX_SIZE`在申请空间的时候做完优化就是16的倍数,并且最大是256。所以`size = 24 ;obj = (id)calloc(1, size);`申请的结果是32字节。\n然后再看下`Linux`空间申请的机制是什么？\n[下载gnu资料](http://ftp.gnu.org/gnu/glibc/)，\n得到：\n\n```\n#ifndef _I386_MALLOC_ALIGNMENT_H\n#define _I386_MALLOC_ALIGNMENT_H\n\n#define MALLOC_ALIGNMENT 16\n\n#endif /* !defined(_I386_MALLOC_ALIGNMENT_H) */\n\n\n/* MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.  It\n   must be a power of two at least 2 * SIZE_SZ, even on machines for\n   which smaller alignments would suffice. It may be defined as larger\n   than this though. Note however that code and data structures are\n   optimized for the case of 8-byte alignment.  */\n   //最少是2倍的SIZE_SZ 或者是__alignof__(long double)\n#define MALLOC_ALIGNMENT (2 * SIZE_SZ < __alignof__ (long double) \\\n\t\t\t  ? __alignof__ (long double) : 2 * SIZE_SZ)\n\t\t\t  \n\t\t\t  \n/* The corresponding word size.  */\n#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))\n\n#ifndef INTERNAL_SIZE_T\n# define INTERNAL_SIZE_T size_t\n#endif\n```\n在i386中是16，在其他系统中按照宏定义计算，\n`__alignof__ (long double)`在iOS中是16,`size_t`是8，则上面的代码简写为`#define MALLOC_ALIGNMENT (2*8 < 16 ? 16:2*8)`最终是16字节。\n\n总结：\n> 实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。\n\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo 查看](https://github.com/ifgyong/demo/tree/master/OC)\n\n---\n广告时间\n\n![](https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&h=268&f=jpeg&s=27083)\n\n\n\n\n\n","slug":"IOS底层原理 对象的本质--(1)","published":1,"updated":"2019-12-03T04:56:17.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2900059zskd6ld3p9c","content":"<h3 id=\"对象的本质\"><a href=\"#对象的本质\" class=\"headerlink\" title=\"对象的本质\"></a>对象的本质</h3><p>探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。<br>那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC对象的内存布局和内存分配机制。</p>\n<p>使用的<a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">代码下载</a><br>要用的工具:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/cn/support/xcode/\" target=\"_blank\" rel=\"external\">Xcode 10.2</a></li>\n<li><a href=\"https://zipzapmac.com/Go2Shell\" target=\"_blank\" rel=\"external\">gotoShell</a></li>\n<li><a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"external\">linux-glibc-2.29源码</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libmalloc/\" target=\"_blank\" rel=\"external\">libmalloc源码</a></li>\n</ul>\n<p>首先我们使用最基本的代码验证对象是什么?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t\tNSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">\t    NSLog(@&quot;Hello, World!&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>clang</code>编译器编译成<code>cpp</code>，<br>执行<code>clang -rewrite-objc main.m -o main.cpp</code>之后生成的<code>cpp</code>，这个生成的<code>cpp</code>我们不知道是跑在哪个平台的，现在我们指定<code>iphoeos</code>和<code>arm64</code>重新编译一下。<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>，将<code>main64.cpp</code>拖拽到Xcode中并打开。<br>|clang|编译器|<br>|————–|——-|<br>|xcrun|命令|<br>|sdk|指定编译的平台|<br>|arch|arm64架构|<br>|-rewrite-objc|重写|<br>|main.m|重写的文件|<br>|main64.cpp|导出的文件|<br>|-o|导出|</p>\n<p><code>command + F</code>查找<code>int main</code>,找到关键代码，这就是<code>main</code>函数的转化成<code>c/c++</code>的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\"> /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\"></div><div class=\"line\">  NSObject *obj=((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class=\"line\"></div><div class=\"line\">     NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);</div><div class=\"line\"> &#125;</div><div class=\"line\"> return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\">\tClass isa;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>那么这个结构体是什么呢？<br>其实我们<code>Object-C</code>编译之后对象会编译成结构体，如图所示：<br><img src=\"../images/1-1.png\" alt=\"\"><br>那么<code>isa</code>是什么吗？通过查看源码得知：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n<p><code>class</code>其实是一个指向结构体的指针，然后<code>com+点击class</code>得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p><code>class</code>是一个指针，那么占用多少内存呢？大家都知道<strong>指针在32位是4字节，在64位是8字节。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSObject *obj=[[NSObject alloc]init];</div></pre></td></tr></table></figure>\n<p>可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。<br><code>obj</code>就是指向结构体<code>class</code>的一个指针。<br>那么我们来验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t\tNSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">\t\t//获得NSobject对象实例大小</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(obj.class);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小</div><div class=\"line\">\t\t//需要导入：#import &lt;malloc/malloc.h&gt;</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tNSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>得出结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">size:8 size2:16</div></pre></td></tr></table></figure>\n<p>结论是：<strong>指针是8字节，指针指向的的内存大小为16字节。</strong><br>查看源码得知<code>[[NSObject alloc]init]</code>的函数运行顺序是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_createInstance</div><div class=\"line\">    -_class_createInstanceFromZone</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">id</div><div class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </div><div class=\"line\">                              bool cxxConstruct = true, </div><div class=\"line\">                              size_t *outAllocatedSize = nil)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    **</div><div class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class=\"line\">    **</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数前边后边省略，取出关键代码，其实<code>size</code>是<code>cls-&gt;instanceSize(extraBytes)</code>执行的结果。那么我们再看下<code>cls-&gt;instanceSize</code>的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//成员变量大小 8bytes</div><div class=\"line\">    uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">        return word_align(unalignedInstanceSize());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    size_t instanceSize(size_t extraBytes) &#123;</div><div class=\"line\">        size_t size = alignedInstanceSize() + extraBytes;</div><div class=\"line\">        // CF requires all objects be at least 16 bytes.</div><div class=\"line\">        if (size &lt; 16) size = 16;</div><div class=\"line\">        return size;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>可以通过源码注释得知：CF要求所有的objects 最小是16bytes。</p>\n<p><code>class_getInstanceSize</code>函数的内部执行顺序是<code>class_getInstanceSize-&gt;cls-&gt;alignedInstanceSize()</code><br>查阅源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//成员变量大小 8bytes</div><div class=\"line\">    uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">        return word_align(unalignedInstanceSize());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>所以最终结论是：<strong>对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes</strong>。</p>\n<p>验证：<br>在刚才 的代码打断点和设置<code>Debug-&gt;Debug Workflow-&gt;View Memory</code>,然后运行程序，</p>\n<p><img src=\"../images/1-2.png\" alt=\"\"></p>\n<p><img src=\"../images/1-3.png\" alt=\"\"><br>点击<code>obj-&gt;view *objc</code>得到上图所示的内存布局，从<code>address</code>看出和<code>obj</code>内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.</p>\n<p>使用lldb命令<code>memory read 0x100601f30</code>输出内存布局，如下图：<br><img src=\"../images/1-4.png\" alt=\"\"><br>或者使用<code>x/4xg 0x100601f30</code>输出：</p>\n<p><img src=\"../images/1-5.png\" alt=\"\"><br><code>x/4xg 0x100601f30</code>中<code>4</code>是输出<code>4</code>个数据,<code>x</code> 是16进制,后边<code>g</code>是8字节为单位。可以验证刚才的出的结论。</p>\n<p>那么我们再使用复杂的一个对象来验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\tint _age;</div><div class=\"line\">\tint _no;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后对应的源码是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\"> Class isa;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct Person_IMPL &#123;</div><div class=\"line\">\tstruct NSObject_IMPL NSObject_IVARS;// 8 bytes</div><div class=\"line\">\tint _age;//4 bytes</div><div class=\"line\">\tint _no;//4 bytes</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>Person——IMPL</code><strong>结构体占用16bytes</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 15;</div><div class=\"line\">\t\tobj-&gt;_no = 14;</div></pre></td></tr></table></figure>\n<p>使用代码验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">obj-&gt;_age = 15;</div><div class=\"line\">obj-&gt;_no = 14;</div><div class=\"line\"></div><div class=\"line\">struct Person_IMPL *p =(__bridge struct Person_IMPL*)obj;</div><div class=\"line\">NSLog(@&quot;age:%d no:%d&quot;,p-&gt;_age,p-&gt;_no);</div><div class=\"line\"></div><div class=\"line\">//age:15 no:14</div></pre></td></tr></table></figure>\n<p>使用内存布局验证：</p>\n<p><img src=\"../images/1-6.png\" alt=\"\"><br>以十进制输出每个4字节<br><img src=\"../images/1-7.png\" alt=\"\"><br>使用内存布局查看数据验证，<code>Person</code>占用16 bytes。</p>\n<p>下边是一个直观的内存布局图：</p>\n<p><img src=\"../images/1-8.png\" alt=\"\"></p>\n<h4 id=\"再看一下更复杂的继承关系的内存布局：\"><a href=\"#再看一下更复杂的继承关系的内存布局：\" class=\"headerlink\" title=\"再看一下更复杂的继承关系的内存布局：\"></a>再看一下更复杂的继承关系的内存布局：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes </div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//Student</div><div class=\"line\">@interface Student : Person</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tint _no;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>那小伙伴可能要说这一定是32字节，因为<code>Person</code>上边已经证明是16字节，<code>Student</code>又多了个成员变量<code>_no</code>，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。<br>其实不然，<code>Person</code>是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，<code>Student</code>是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以<code>Student</code>是占用了16字节。</p>\n<p>那么我们来证明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Student *obj=[[Student alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 6;</div><div class=\"line\">\t\tobj-&gt;_no = 7;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//获得NSobject对象实例成员变量占用的大小 -&gt;8</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(obj.class);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小 -&gt;16</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tNSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</div><div class=\"line\">\t\t//size:16 size2:16</div></pre></td></tr></table></figure>\n<p>再看一下LLDB查看的内存布局：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) x/8xw 0x10071ae30</div><div class=\"line\">0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007</div><div class=\"line\">0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff</div><div class=\"line\"></div><div class=\"line\">(lldb) memory read 0x10071ae30</div><div class=\"line\">0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................</div><div class=\"line\">0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....</div><div class=\"line\"></div><div class=\"line\">(lldb) x/4xg 0x10071ae30</div><div class=\"line\">0x10071ae30: 0x001d800100001299 0x0000000700000006</div><div class=\"line\">0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0</div></pre></td></tr></table></figure>\n<p>可以看出来<code>0x00000006</code>和<code>0x00000007</code>就是两个成员变量的值，占用内存是16字节。</p>\n<p>我们将<code>Student</code>新增一个成员变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Student</div><div class=\"line\">@interface Student : Person</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tint _no;//4bytes</div><div class=\"line\">\tint _no2;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>然后查看内存布局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) x/8xg 0x102825db0</div><div class=\"line\">0x102825db0: 0x001d8001000012c1 0x0000000700000006</div><div class=\"line\">0x102825dc0: 0x0000000000000000 0x0000000000000000</div><div class=\"line\">0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80</div><div class=\"line\">0x102825de0: 0x0000000102825c60 0x0000000102825890</div></pre></td></tr></table></figure></p>\n<p>从<code>LLDB</code>可以看出来，<strong>内存变成了32字节。(0x102825dd0-0x102825db0=0x20)</strong></p>\n<p>我们再增加一个属性看下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes </div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic,assign) int level; //4字节</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//InstanceSize:16 malloc_size:16</div></pre></td></tr></table></figure></p>\n<p>为什么新增了一个属性，内存还是和没有新增的时候一样呢？<br>因为<code>property</code>=<code>setter</code>+<code>getter</code>+<code>ivar</code>,<code>method</code>是存在类对象中的，所以实例<code>Person</code>占用的内存还是<code>_age</code>,<code>_level</code>和一个指向类的指针，最后结果是<code>4+4+8=16bytes</code>。</p>\n<p>再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个<code>int</code>成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes</div><div class=\"line\">\tint _level;//4bytes</div><div class=\"line\">\tint _code;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 6;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//获得NSobject对象实例成员变量占用的大小 -&gt;24</div><div class=\"line\">\t\tClass ocl = obj.class;</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(ocl);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小 -&gt;32</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tprintf(&quot;InstanceSize:%zu malloc_size:%zu \\n&quot;,size,size2);</div><div class=\"line\">\t\t</div><div class=\"line\">InstanceSize:24 malloc_size:32</div></pre></td></tr></table></figure>\n<p>为什么和我们猜测的不一样呢？<br>那么我们再探究一下：<br>实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码<code>NSObject.mm 2306行</code>得到创建对象函数调用顺序<code>allocWithZone-&gt;_objc_rootAllocWithZone-&gt;_objc_rootAllocWithZone-&gt;class_createInstance-&gt;_class_createInstanceFromZone-&gt;_class_createInstanceFromZone</code>最后查看下<code>_class_createInstanceFromZone</code>的源码，其他已省略，只留关键代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">id</div><div class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </div><div class=\"line\">                              bool cxxConstruct = true, </div><div class=\"line\">                              size_t *outAllocatedSize = nil)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">**</div><div class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class=\"line\">    if (outAllocatedSize) *outAllocatedSize = size;</div><div class=\"line\">    **</div><div class=\"line\">    obj = (id)calloc(1, size);</div><div class=\"line\">   **</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么我们在看一下<code>instanceSize</code>中的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对象指针的大小</div><div class=\"line\">   uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">       return word_align(unalignedInstanceSize());</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   size_t instanceSize(size_t extraBytes) &#123;</div><div class=\"line\">       size_t size = alignedInstanceSize() + extraBytes;</div><div class=\"line\">       // CF requires all objects be at least 16 bytes.</div><div class=\"line\">       if (size &lt; 16) size = 16;</div><div class=\"line\">       return size;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>最后调用的<code>obj = (id)calloc(1, size);</code>传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？<br>因为这是<code>c</code>函数，我们去<a href=\"https://opensource.apple.com/tarballs/libmalloc/\" target=\"_blank\" rel=\"external\">苹果开源官网下载源码看下</a>,可以找到这句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">define NANO_MAX_SIZE\t\t\t256 /* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</div></pre></td></tr></table></figure>\n<p>看来<code>NANO_MAX_SIZE</code>在申请空间的时候做完优化就是16的倍数,并且最大是256。所以<code>size = 24 ;obj = (id)calloc(1, size);</code>申请的结果是32字节。<br>然后再看下<code>Linux</code>空间申请的机制是什么？<br><a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"external\">下载gnu资料</a>，<br>得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef _I386_MALLOC_ALIGNMENT_H</div><div class=\"line\">#define _I386_MALLOC_ALIGNMENT_H</div><div class=\"line\"></div><div class=\"line\">#define MALLOC_ALIGNMENT 16</div><div class=\"line\"></div><div class=\"line\">#endif /* !defined(_I386_MALLOC_ALIGNMENT_H) */</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&apos;ed chunks.  It</div><div class=\"line\">   must be a power of two at least 2 * SIZE_SZ, even on machines for</div><div class=\"line\">   which smaller alignments would suffice. It may be defined as larger</div><div class=\"line\">   than this though. Note however that code and data structures are</div><div class=\"line\">   optimized for the case of 8-byte alignment.  */</div><div class=\"line\">   //最少是2倍的SIZE_SZ 或者是__alignof__(long double)</div><div class=\"line\">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \\</div><div class=\"line\">\t\t\t  ? __alignof__ (long double) : 2 * SIZE_SZ)</div><div class=\"line\">\t\t\t  </div><div class=\"line\">\t\t\t  </div><div class=\"line\">/* The corresponding word size.  */</div><div class=\"line\">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</div><div class=\"line\"></div><div class=\"line\">#ifndef INTERNAL_SIZE_T</div><div class=\"line\"># define INTERNAL_SIZE_T size_t</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>在i386中是16，在其他系统中按照宏定义计算，<br><code>__alignof__ (long double)</code>在iOS中是16,<code>size_t</code>是8，则上面的代码简写为<code>#define MALLOC_ALIGNMENT (2*8 &lt; 16 ? 16:2*8)</code>最终是16字节。</p>\n<p>总结：</p>\n<blockquote>\n<p>实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo 查看</a></li>\n</ul>\n<hr>\n<p>广告时间</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&amp;h=268&amp;f=jpeg&amp;s=27083\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"对象的本质\"><a href=\"#对象的本质\" class=\"headerlink\" title=\"对象的本质\"></a>对象的本质</h3><p>探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。<br>那么一个OC对象占用多少内存呢？看完这篇文章你将了解OC对象的内存布局和内存分配机制。</p>\n<p>使用的<a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">代码下载</a><br>要用的工具:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/cn/support/xcode/\" target=\"_blank\" rel=\"external\">Xcode 10.2</a></li>\n<li><a href=\"https://zipzapmac.com/Go2Shell\" target=\"_blank\" rel=\"external\">gotoShell</a></li>\n<li><a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"external\">linux-glibc-2.29源码</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libmalloc/\" target=\"_blank\" rel=\"external\">libmalloc源码</a></li>\n</ul>\n<p>首先我们使用最基本的代码验证对象是什么?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t\tNSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">\t    NSLog(@&quot;Hello, World!&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>clang</code>编译器编译成<code>cpp</code>，<br>执行<code>clang -rewrite-objc main.m -o main.cpp</code>之后生成的<code>cpp</code>，这个生成的<code>cpp</code>我们不知道是跑在哪个平台的，现在我们指定<code>iphoeos</code>和<code>arm64</code>重新编译一下。<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>，将<code>main64.cpp</code>拖拽到Xcode中并打开。<br>|clang|编译器|<br>|————–|——-|<br>|xcrun|命令|<br>|sdk|指定编译的平台|<br>|arch|arm64架构|<br>|-rewrite-objc|重写|<br>|main.m|重写的文件|<br>|main64.cpp|导出的文件|<br>|-o|导出|</p>\n<p><code>command + F</code>查找<code>int main</code>,找到关键代码，这就是<code>main</code>函数的转化成<code>c/c++</code>的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\"> /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\"></div><div class=\"line\">  NSObject *obj=((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class=\"line\"></div><div class=\"line\">     NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_1b47c1_mi_0);</div><div class=\"line\"> &#125;</div><div class=\"line\"> return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\">\tClass isa;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>那么这个结构体是什么呢？<br>其实我们<code>Object-C</code>编译之后对象会编译成结构体，如图所示：<br><img src=\"../images/1-1.png\" alt=\"\"><br>那么<code>isa</code>是什么吗？通过查看源码得知：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n<p><code>class</code>其实是一个指向结构体的指针，然后<code>com+点击class</code>得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p><code>class</code>是一个指针，那么占用多少内存呢？大家都知道<strong>指针在32位是4字节，在64位是8字节。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSObject *obj=[[NSObject alloc]init];</div></pre></td></tr></table></figure>\n<p>可以理解成实例对象是一个指针,指针占用8或者4字节，那么暂时假设机器是64位，记为对象占用8字节。<br><code>obj</code>就是指向结构体<code>class</code>的一个指针。<br>那么我们来验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t\tNSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">\t\t//获得NSobject对象实例大小</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(obj.class);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小</div><div class=\"line\">\t\t//需要导入：#import &lt;malloc/malloc.h&gt;</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tNSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>得出结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">size:8 size2:16</div></pre></td></tr></table></figure>\n<p>结论是：<strong>指针是8字节，指针指向的的内存大小为16字节。</strong><br>查看源码得知<code>[[NSObject alloc]init]</code>的函数运行顺序是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_createInstance</div><div class=\"line\">    -_class_createInstanceFromZone</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">id</div><div class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </div><div class=\"line\">                              bool cxxConstruct = true, </div><div class=\"line\">                              size_t *outAllocatedSize = nil)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    **</div><div class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class=\"line\">    **</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数前边后边省略，取出关键代码，其实<code>size</code>是<code>cls-&gt;instanceSize(extraBytes)</code>执行的结果。那么我们再看下<code>cls-&gt;instanceSize</code>的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//成员变量大小 8bytes</div><div class=\"line\">    uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">        return word_align(unalignedInstanceSize());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    size_t instanceSize(size_t extraBytes) &#123;</div><div class=\"line\">        size_t size = alignedInstanceSize() + extraBytes;</div><div class=\"line\">        // CF requires all objects be at least 16 bytes.</div><div class=\"line\">        if (size &lt; 16) size = 16;</div><div class=\"line\">        return size;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>可以通过源码注释得知：CF要求所有的objects 最小是16bytes。</p>\n<p><code>class_getInstanceSize</code>函数的内部执行顺序是<code>class_getInstanceSize-&gt;cls-&gt;alignedInstanceSize()</code><br>查阅源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//成员变量大小 8bytes</div><div class=\"line\">    uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">        return word_align(unalignedInstanceSize());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>所以最终结论是：<strong>对象指针实际大小为8bytes，内存分配为16bytes，其实是空出了8bytes</strong>。</p>\n<p>验证：<br>在刚才 的代码打断点和设置<code>Debug-&gt;Debug Workflow-&gt;View Memory</code>,然后运行程序，</p>\n<p><img src=\"../images/1-2.png\" alt=\"\"></p>\n<p><img src=\"../images/1-3.png\" alt=\"\"><br>点击<code>obj-&gt;view *objc</code>得到上图所示的内存布局，从<code>address</code>看出和<code>obj</code>内存一样，左上角是16字节，8个字节有数据，8个字节是空的，默认是0.</p>\n<p>使用lldb命令<code>memory read 0x100601f30</code>输出内存布局，如下图：<br><img src=\"../images/1-4.png\" alt=\"\"><br>或者使用<code>x/4xg 0x100601f30</code>输出：</p>\n<p><img src=\"../images/1-5.png\" alt=\"\"><br><code>x/4xg 0x100601f30</code>中<code>4</code>是输出<code>4</code>个数据,<code>x</code> 是16进制,后边<code>g</code>是8字节为单位。可以验证刚才的出的结论。</p>\n<p>那么我们再使用复杂的一个对象来验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\tint _age;</div><div class=\"line\">\tint _no;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后对应的源码是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\"> Class isa;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct Person_IMPL &#123;</div><div class=\"line\">\tstruct NSObject_IMPL NSObject_IVARS;// 8 bytes</div><div class=\"line\">\tint _age;//4 bytes</div><div class=\"line\">\tint _no;//4 bytes</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>Person——IMPL</code><strong>结构体占用16bytes</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 15;</div><div class=\"line\">\t\tobj-&gt;_no = 14;</div></pre></td></tr></table></figure>\n<p>使用代码验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">obj-&gt;_age = 15;</div><div class=\"line\">obj-&gt;_no = 14;</div><div class=\"line\"></div><div class=\"line\">struct Person_IMPL *p =(__bridge struct Person_IMPL*)obj;</div><div class=\"line\">NSLog(@&quot;age:%d no:%d&quot;,p-&gt;_age,p-&gt;_no);</div><div class=\"line\"></div><div class=\"line\">//age:15 no:14</div></pre></td></tr></table></figure>\n<p>使用内存布局验证：</p>\n<p><img src=\"../images/1-6.png\" alt=\"\"><br>以十进制输出每个4字节<br><img src=\"../images/1-7.png\" alt=\"\"><br>使用内存布局查看数据验证，<code>Person</code>占用16 bytes。</p>\n<p>下边是一个直观的内存布局图：</p>\n<p><img src=\"../images/1-8.png\" alt=\"\"></p>\n<h4 id=\"再看一下更复杂的继承关系的内存布局：\"><a href=\"#再看一下更复杂的继承关系的内存布局：\" class=\"headerlink\" title=\"再看一下更复杂的继承关系的内存布局：\"></a>再看一下更复杂的继承关系的内存布局：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes </div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//Student</div><div class=\"line\">@interface Student : Person</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tint _no;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>那小伙伴可能要说这一定是32字节，因为<code>Person</code>上边已经证明是16字节，<code>Student</code>又多了个成员变量<code>_no</code>，由于内存对齐，一定是16的整倍数，那就是16+16=32字节。<br>其实不然，<code>Person</code>是内存分配16字节，其实占用了8+4=12字节，剩余4字节位子空着而已，<code>Student</code>是一个对象，不可能在成员变量和指针中间有内存对齐的，参数和指针是对象指针+偏移量得出来的，多个不同的对象才会存在内存对齐。所以<code>Student</code>是占用了16字节。</p>\n<p>那么我们来证明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Student *obj=[[Student alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 6;</div><div class=\"line\">\t\tobj-&gt;_no = 7;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//获得NSobject对象实例成员变量占用的大小 -&gt;8</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(obj.class);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小 -&gt;16</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tNSLog(@&quot;size:%zu size2:%zu&quot;,size,size2);</div><div class=\"line\">\t\t//size:16 size2:16</div></pre></td></tr></table></figure>\n<p>再看一下LLDB查看的内存布局：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) x/8xw 0x10071ae30</div><div class=\"line\">0x10071ae30: 0x00001299 0x001d8001 0x00000006 0x00000007</div><div class=\"line\">0x10071ae40: 0xa0090000 0x00000007 0x8735e0b0 0x00007fff</div><div class=\"line\"></div><div class=\"line\">(lldb) memory read 0x10071ae30</div><div class=\"line\">0x10071ae30: 99 12 00 00 01 80 1d 00 06 00 00 00 07 00 00 00  ................</div><div class=\"line\">0x10071ae40: 00 00 09 a0 07 00 00 00 b0 e0 35 87 ff 7f 00 00  ..........5.....</div><div class=\"line\"></div><div class=\"line\">(lldb) x/4xg 0x10071ae30</div><div class=\"line\">0x10071ae30: 0x001d800100001299 0x0000000700000006</div><div class=\"line\">0x10071ae40: 0x00000007a0090000 0x00007fff8735e0b0</div></pre></td></tr></table></figure>\n<p>可以看出来<code>0x00000006</code>和<code>0x00000007</code>就是两个成员变量的值，占用内存是16字节。</p>\n<p>我们将<code>Student</code>新增一个成员变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Student</div><div class=\"line\">@interface Student : Person</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tint _no;//4bytes</div><div class=\"line\">\tint _no2;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Student</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>然后查看内存布局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) x/8xg 0x102825db0</div><div class=\"line\">0x102825db0: 0x001d8001000012c1 0x0000000700000006</div><div class=\"line\">0x102825dc0: 0x0000000000000000 0x0000000000000000</div><div class=\"line\">0x102825dd0: 0x001dffff8736ae71 0x0000000100001f80</div><div class=\"line\">0x102825de0: 0x0000000102825c60 0x0000000102825890</div></pre></td></tr></table></figure></p>\n<p>从<code>LLDB</code>可以看出来，<strong>内存变成了32字节。(0x102825dd0-0x102825db0=0x20)</strong></p>\n<p>我们再增加一个属性看下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes </div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic,assign) int level; //4字节</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//InstanceSize:16 malloc_size:16</div></pre></td></tr></table></figure></p>\n<p>为什么新增了一个属性，内存还是和没有新增的时候一样呢？<br>因为<code>property</code>=<code>setter</code>+<code>getter</code>+<code>ivar</code>,<code>method</code>是存在类对象中的，所以实例<code>Person</code>占用的内存还是<code>_age</code>,<code>_level</code>和一个指向类的指针，最后结果是<code>4+4+8=16bytes</code>。</p>\n<p>再看下成员变量是3个的时候是多少呢？看结果之前先猜测一下：三个<code>int</code>成员变量是12，一个指针是8，最后是20，由于内存是8的倍数，所以是24。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes</div><div class=\"line\">\tint _level;//4bytes</div><div class=\"line\">\tint _code;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">Person *obj=[[Person alloc]init];</div><div class=\"line\">\t\tobj-&gt;_age = 6;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//获得NSobject对象实例成员变量占用的大小 -&gt;24</div><div class=\"line\">\t\tClass ocl = obj.class;</div><div class=\"line\">\t\tsize_t size = class_getInstanceSize(ocl);</div><div class=\"line\">\t\t//获取NSObjet指针的指向的内存大小 -&gt;32</div><div class=\"line\">\t\tsize_t size2 = malloc_size((__bridge const void *)(obj));</div><div class=\"line\">\t\tprintf(&quot;InstanceSize:%zu malloc_size:%zu \\n&quot;,size,size2);</div><div class=\"line\">\t\t</div><div class=\"line\">InstanceSize:24 malloc_size:32</div></pre></td></tr></table></figure>\n<p>为什么和我们猜测的不一样呢？<br>那么我们再探究一下：<br>实例对象占用多少内存，当然是在申请内存的时候创建的，则查找源码<code>NSObject.mm 2306行</code>得到创建对象函数调用顺序<code>allocWithZone-&gt;_objc_rootAllocWithZone-&gt;_objc_rootAllocWithZone-&gt;class_createInstance-&gt;_class_createInstanceFromZone-&gt;_class_createInstanceFromZone</code>最后查看下<code>_class_createInstanceFromZone</code>的源码，其他已省略，只留关键代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">id</div><div class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </div><div class=\"line\">                              bool cxxConstruct = true, </div><div class=\"line\">                              size_t *outAllocatedSize = nil)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">**</div><div class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class=\"line\">    if (outAllocatedSize) *outAllocatedSize = size;</div><div class=\"line\">    **</div><div class=\"line\">    obj = (id)calloc(1, size);</div><div class=\"line\">   **</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么我们在看一下<code>instanceSize</code>中的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对象指针的大小</div><div class=\"line\">   uint32_t alignedInstanceSize() &#123;</div><div class=\"line\">       return word_align(unalignedInstanceSize());</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   size_t instanceSize(size_t extraBytes) &#123;</div><div class=\"line\">       size_t size = alignedInstanceSize() + extraBytes;</div><div class=\"line\">       // CF requires all objects be at least 16 bytes.</div><div class=\"line\">       if (size &lt; 16) size = 16;</div><div class=\"line\">       return size;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>最后调用的<code>obj = (id)calloc(1, size);</code>传进去的值是24，但是结果是申请了32字节的内存，这又是为什么呢？<br>因为这是<code>c</code>函数，我们去<a href=\"https://opensource.apple.com/tarballs/libmalloc/\" target=\"_blank\" rel=\"external\">苹果开源官网下载源码看下</a>,可以找到这句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">define NANO_MAX_SIZE\t\t\t256 /* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</div></pre></td></tr></table></figure>\n<p>看来<code>NANO_MAX_SIZE</code>在申请空间的时候做完优化就是16的倍数,并且最大是256。所以<code>size = 24 ;obj = (id)calloc(1, size);</code>申请的结果是32字节。<br>然后再看下<code>Linux</code>空间申请的机制是什么？<br><a href=\"http://ftp.gnu.org/gnu/glibc/\" target=\"_blank\" rel=\"external\">下载gnu资料</a>，<br>得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifndef _I386_MALLOC_ALIGNMENT_H</div><div class=\"line\">#define _I386_MALLOC_ALIGNMENT_H</div><div class=\"line\"></div><div class=\"line\">#define MALLOC_ALIGNMENT 16</div><div class=\"line\"></div><div class=\"line\">#endif /* !defined(_I386_MALLOC_ALIGNMENT_H) */</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&apos;ed chunks.  It</div><div class=\"line\">   must be a power of two at least 2 * SIZE_SZ, even on machines for</div><div class=\"line\">   which smaller alignments would suffice. It may be defined as larger</div><div class=\"line\">   than this though. Note however that code and data structures are</div><div class=\"line\">   optimized for the case of 8-byte alignment.  */</div><div class=\"line\">   //最少是2倍的SIZE_SZ 或者是__alignof__(long double)</div><div class=\"line\">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \\</div><div class=\"line\">\t\t\t  ? __alignof__ (long double) : 2 * SIZE_SZ)</div><div class=\"line\">\t\t\t  </div><div class=\"line\">\t\t\t  </div><div class=\"line\">/* The corresponding word size.  */</div><div class=\"line\">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</div><div class=\"line\"></div><div class=\"line\">#ifndef INTERNAL_SIZE_T</div><div class=\"line\"># define INTERNAL_SIZE_T size_t</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>在i386中是16，在其他系统中按照宏定义计算，<br><code>__alignof__ (long double)</code>在iOS中是16,<code>size_t</code>是8，则上面的代码简写为<code>#define MALLOC_ALIGNMENT (2*8 &lt; 16 ? 16:2*8)</code>最终是16字节。</p>\n<p>总结：</p>\n<blockquote>\n<p>实例对象其实是结构体，占用的内存是16的倍数，最少是16，由于内存对齐，实际使用的内存为M,则实际分配内存为(M%16+M/16)*16。实例对象的大小不受方法影响，受实例变量影响。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo 查看</a></li>\n</ul>\n<hr>\n<p>广告时间</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&amp;h=268&amp;f=jpeg&amp;s=27083\" alt=\"\"></p>\n"},{"title":"Python3 PyQt5教程(2)","date":"2018-05-10T08:39:24.000Z","_content":"大家关注的教程2来了。\n第一期是代码布局，现在有更高级的布局方式，那就是Qt5，布局完UI可以用PythonUIC命令转成py文件，添加`import `和\n\n```\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    widget = QMainWindow(None)\n    Ui_MainWindow().setupUi(widget)\n\n    sys.exit(app.exec_())\n    pass\n```\n\n\n1.登陆界面\n2.一个QTproject新建多个视图\n3.在窗体中打开新窗体\n4.安装QT\n### 1.登陆\n\n用QT可视化编程拖出来的界面就是这个样子，用命令`pyuic5 -o target.py fromfile.ui`转化成py文件，代码如下\n![登陆](../1.png)\n\n\n```\n# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file 'mainwindow.ui'\n#\n# Created by: PyQt5 UI code generator 5.10.1\n#\n# WARNING! All changes made in this file will be lost!\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/5/9 下午1:36\n# @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145\n# @Site    : http://fgyong.cn 兜兜转转的技术博客\n# @File    : *.py\n# @Software: PyCharm\n\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nimport sys\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtWidgets import *\n\nclass Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(\"MainWindow\")\n        MainWindow.resize(500, 341)\n        MainWindow.move(1500,300)\n        MainWindow.setWindowOpacity(1.0)\n        MainWindow.setAutoFillBackground(True)\n        self.centralWidget = QtWidgets.QWidget(MainWindow)\n        self.centralWidget.setObjectName(\"centralWidget\")\n        self.accountLabel = QtWidgets.QLabel(self.centralWidget)\n        self.accountLabel.setGeometry(QtCore.QRect(80, 110, 60, 21))\n        self.accountLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.accountLabel.setObjectName(\"accountLabel\")\n        self.pwdLabel = QtWidgets.QLabel(self.centralWidget)\n        self.pwdLabel.setGeometry(QtCore.QRect(80, 150, 60, 21))\n        self.pwdLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.pwdLabel.setObjectName(\"pwdLabel\")\n        self.account = QtWidgets.QLineEdit(self.centralWidget)\n        self.account.setGeometry(QtCore.QRect(140, 110, 191, 21))\n        self.account.setObjectName(\"account\")\n        self.password = QtWidgets.QLineEdit(self.centralWidget)\n        self.password.setGeometry(QtCore.QRect(140, 150, 191, 21))\n        self.password.setObjectName(\"password\")\n        self.pushButton = QtWidgets.QPushButton(self.centralWidget)\n        self.pushButton.setGeometry(QtCore.QRect(140, 191, 201, 41))\n        self.pushButton.setObjectName(\"pushButton\")\n        MainWindow.setCentralWidget(self.centralWidget)\n        self.menuBar = QtWidgets.QMenuBar(MainWindow)\n        self.menuBar.setGeometry(QtCore.QRect(0, 0, 500, 22))\n        self.menuBar.setFocusPolicy(QtCore.Qt.ClickFocus)\n        self.menuBar.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)\n        self.menuBar.setInputMethodHints(QtCore.Qt.ImhNone)\n        self.menuBar.setObjectName(\"menuBar\")\n        MainWindow.setMenuBar(self.menuBar)\n        self.statusBar = QtWidgets.QStatusBar(MainWindow)\n        self.statusBar.setObjectName(\"statusBar\")\n        MainWindow.setStatusBar(self.statusBar)\n\n        self.retranslateUi(MainWindow)\n        QtCore.QMetaObject.connectSlotsByName(MainWindow)\n        MainWindow.show()\n\n    def retranslateUi(self, MainWindow):\n        _translate = QtCore.QCoreApplication.translate\n        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"登陆\"))\n        self.accountLabel.setText(_translate(\"MainWindow\", \"账号\"))\n        self.pwdLabel.setText(_translate(\"MainWindow\", \"密码\"))\n        self.pushButton.setText(_translate(\"MainWindow\", \"登陆\"))\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    widget = QMainWindow(None)\n    Ui_MainWindow().setupUi(widget)\n\n    sys.exit(app.exec_())\n    pass\n\n```\n\n\n###  2.一个QTproject新建多个视图\n如图：\n![新建UI](https://upload-images.jianshu.io/upload_images/783986-8a352a0f49882a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在源文件->main.cpp 导入类，\n```\n#include \"mainwindow.h\"\n#include \"dialog.h\"//新建的文件\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    MainWindow w;//默认的文件\n    Dialog d;//新建的文件\n\n//    w.show();//默认的注释掉\n    d.show();//新建的文件show\n\n    return a.exec();\n}\n```\n然后选择新建的 Dialog.ui文件点击运行按钮，运行的就是Dialog视图\n\n### 4.在窗体中打开新窗体\n```\n\nclass Example(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n#这一句比较关键，先声明这个窗体2等到需要show的时候在展示出来。\n        self.child = Exaple2()\ndef initGUI(self):\n    btn = QPushButton('打开窗体', self)\n        btn.setToolTip('这是个btn')\n        btn.resize(btn.sizeHint())\n        btn.clicked.connect(self.showSecond)\n   def showSecond(self):\n        self.child.show()\n\n#第二个窗口\nclass Exaple2(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.configUI()\n    def configUI(self):\n        self.lable = QLabel('我是第二个窗体', self)\n        self.lable.setWordWrap(True)  # 自动换行\n#设置frame\n        self.lable.setGeometry(50, 100, 200, 50)\n#设置新窗体frame\n        self.setGeometry(500,500,300,300);\n```\n### 4.安装QT\n下载QT5.*\n[下载QT5](http://mirrors.ocf.berkeley.edu/qt/archive/qt/5.8/5.8.0/qt-opensource-mac-x64-clang-5.8.0.dmg)\n因为下载的dmg直接点下一步下一步安装完成\n[QT的官方Demo](http://doc.qt.io/archives/qt-4.8/demos.html)\n### 5.新建工程\n1.第一步\n![第一步](../2.png)\n2.第二步\n![第二步](../3.png)\n3.第三步\n![选择Qtwidgets](../4.png)\n4.第四步 打开视图\n![打开视图](../5.png)\n5.拖拽控件\n![拖拽控件](../6.png)\n6.效果图\n![运行的效果图](../7.png)\n","source":"_posts/Python3 PyQt5教程(2).md","raw":"title: Python3 PyQt5教程(2)\ndate: 2018-5-10 16:39:24\ntags: \n- Python3 \n- PyQt5\ncategories: Python \n---\n大家关注的教程2来了。\n第一期是代码布局，现在有更高级的布局方式，那就是Qt5，布局完UI可以用PythonUIC命令转成py文件，添加`import `和\n\n```\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    widget = QMainWindow(None)\n    Ui_MainWindow().setupUi(widget)\n\n    sys.exit(app.exec_())\n    pass\n```\n\n\n1.登陆界面\n2.一个QTproject新建多个视图\n3.在窗体中打开新窗体\n4.安装QT\n### 1.登陆\n\n用QT可视化编程拖出来的界面就是这个样子，用命令`pyuic5 -o target.py fromfile.ui`转化成py文件，代码如下\n![登陆](../1.png)\n\n\n```\n# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file 'mainwindow.ui'\n#\n# Created by: PyQt5 UI code generator 5.10.1\n#\n# WARNING! All changes made in this file will be lost!\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/5/9 下午1:36\n# @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145\n# @Site    : http://fgyong.cn 兜兜转转的技术博客\n# @File    : *.py\n# @Software: PyCharm\n\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\nimport sys\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtWidgets import *\n\nclass Ui_MainWindow(object):\n    def setupUi(self, MainWindow):\n        MainWindow.setObjectName(\"MainWindow\")\n        MainWindow.resize(500, 341)\n        MainWindow.move(1500,300)\n        MainWindow.setWindowOpacity(1.0)\n        MainWindow.setAutoFillBackground(True)\n        self.centralWidget = QtWidgets.QWidget(MainWindow)\n        self.centralWidget.setObjectName(\"centralWidget\")\n        self.accountLabel = QtWidgets.QLabel(self.centralWidget)\n        self.accountLabel.setGeometry(QtCore.QRect(80, 110, 60, 21))\n        self.accountLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.accountLabel.setObjectName(\"accountLabel\")\n        self.pwdLabel = QtWidgets.QLabel(self.centralWidget)\n        self.pwdLabel.setGeometry(QtCore.QRect(80, 150, 60, 21))\n        self.pwdLabel.setAlignment(QtCore.Qt.AlignCenter)\n        self.pwdLabel.setObjectName(\"pwdLabel\")\n        self.account = QtWidgets.QLineEdit(self.centralWidget)\n        self.account.setGeometry(QtCore.QRect(140, 110, 191, 21))\n        self.account.setObjectName(\"account\")\n        self.password = QtWidgets.QLineEdit(self.centralWidget)\n        self.password.setGeometry(QtCore.QRect(140, 150, 191, 21))\n        self.password.setObjectName(\"password\")\n        self.pushButton = QtWidgets.QPushButton(self.centralWidget)\n        self.pushButton.setGeometry(QtCore.QRect(140, 191, 201, 41))\n        self.pushButton.setObjectName(\"pushButton\")\n        MainWindow.setCentralWidget(self.centralWidget)\n        self.menuBar = QtWidgets.QMenuBar(MainWindow)\n        self.menuBar.setGeometry(QtCore.QRect(0, 0, 500, 22))\n        self.menuBar.setFocusPolicy(QtCore.Qt.ClickFocus)\n        self.menuBar.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)\n        self.menuBar.setInputMethodHints(QtCore.Qt.ImhNone)\n        self.menuBar.setObjectName(\"menuBar\")\n        MainWindow.setMenuBar(self.menuBar)\n        self.statusBar = QtWidgets.QStatusBar(MainWindow)\n        self.statusBar.setObjectName(\"statusBar\")\n        MainWindow.setStatusBar(self.statusBar)\n\n        self.retranslateUi(MainWindow)\n        QtCore.QMetaObject.connectSlotsByName(MainWindow)\n        MainWindow.show()\n\n    def retranslateUi(self, MainWindow):\n        _translate = QtCore.QCoreApplication.translate\n        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"登陆\"))\n        self.accountLabel.setText(_translate(\"MainWindow\", \"账号\"))\n        self.pwdLabel.setText(_translate(\"MainWindow\", \"密码\"))\n        self.pushButton.setText(_translate(\"MainWindow\", \"登陆\"))\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    widget = QMainWindow(None)\n    Ui_MainWindow().setupUi(widget)\n\n    sys.exit(app.exec_())\n    pass\n\n```\n\n\n###  2.一个QTproject新建多个视图\n如图：\n![新建UI](https://upload-images.jianshu.io/upload_images/783986-8a352a0f49882a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在源文件->main.cpp 导入类，\n```\n#include \"mainwindow.h\"\n#include \"dialog.h\"//新建的文件\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    MainWindow w;//默认的文件\n    Dialog d;//新建的文件\n\n//    w.show();//默认的注释掉\n    d.show();//新建的文件show\n\n    return a.exec();\n}\n```\n然后选择新建的 Dialog.ui文件点击运行按钮，运行的就是Dialog视图\n\n### 4.在窗体中打开新窗体\n```\n\nclass Example(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n#这一句比较关键，先声明这个窗体2等到需要show的时候在展示出来。\n        self.child = Exaple2()\ndef initGUI(self):\n    btn = QPushButton('打开窗体', self)\n        btn.setToolTip('这是个btn')\n        btn.resize(btn.sizeHint())\n        btn.clicked.connect(self.showSecond)\n   def showSecond(self):\n        self.child.show()\n\n#第二个窗口\nclass Exaple2(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.configUI()\n    def configUI(self):\n        self.lable = QLabel('我是第二个窗体', self)\n        self.lable.setWordWrap(True)  # 自动换行\n#设置frame\n        self.lable.setGeometry(50, 100, 200, 50)\n#设置新窗体frame\n        self.setGeometry(500,500,300,300);\n```\n### 4.安装QT\n下载QT5.*\n[下载QT5](http://mirrors.ocf.berkeley.edu/qt/archive/qt/5.8/5.8.0/qt-opensource-mac-x64-clang-5.8.0.dmg)\n因为下载的dmg直接点下一步下一步安装完成\n[QT的官方Demo](http://doc.qt.io/archives/qt-4.8/demos.html)\n### 5.新建工程\n1.第一步\n![第一步](../2.png)\n2.第二步\n![第二步](../3.png)\n3.第三步\n![选择Qtwidgets](../4.png)\n4.第四步 打开视图\n![打开视图](../5.png)\n5.拖拽控件\n![拖拽控件](../6.png)\n6.效果图\n![运行的效果图](../7.png)\n","slug":"Python3 PyQt5教程(2)","published":1,"updated":"2019-12-03T04:48:00.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2900069zskc1qnesir","content":"<p>大家关注的教程2来了。<br>第一期是代码布局，现在有更高级的布局方式，那就是Qt5，布局完UI可以用PythonUIC命令转成py文件，添加<code>import</code>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    widget = QMainWindow(None)</div><div class=\"line\">    Ui_MainWindow().setupUi(widget)</div><div class=\"line\"></div><div class=\"line\">    sys.exit(app.exec_())</div><div class=\"line\">    pass</div></pre></td></tr></table></figure>\n<p>1.登陆界面<br>2.一个QTproject新建多个视图<br>3.在窗体中打开新窗体<br>4.安装QT</p>\n<h3 id=\"1-登陆\"><a href=\"#1-登陆\" class=\"headerlink\" title=\"1.登陆\"></a>1.登陆</h3><p>用QT可视化编程拖出来的界面就是这个样子，用命令<code>pyuic5 -o target.py fromfile.ui</code>转化成py文件，代码如下<br><img src=\"../1.png\" alt=\"登陆\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"></div><div class=\"line\"># Form implementation generated from reading ui file &apos;mainwindow.ui&apos;</div><div class=\"line\">#</div><div class=\"line\"># Created by: PyQt5 UI code generator 5.10.1</div><div class=\"line\">#</div><div class=\"line\"># WARNING! All changes made in this file will be lost!</div><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"># @Time    : 2018/5/9 下午1:36</div><div class=\"line\"># @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145</div><div class=\"line\"># @Site    : http://fgyong.cn 兜兜转转的技术博客</div><div class=\"line\"># @File    : *.py</div><div class=\"line\"># @Software: PyCharm</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">from PyQt5 import QtCore, QtGui, QtWidgets</div><div class=\"line\">import sys</div><div class=\"line\">from PyQt5.QtCore import *</div><div class=\"line\">from PyQt5.QtWidgets import *</div><div class=\"line\"></div><div class=\"line\">class Ui_MainWindow(object):</div><div class=\"line\">    def setupUi(self, MainWindow):</div><div class=\"line\">        MainWindow.setObjectName(&quot;MainWindow&quot;)</div><div class=\"line\">        MainWindow.resize(500, 341)</div><div class=\"line\">        MainWindow.move(1500,300)</div><div class=\"line\">        MainWindow.setWindowOpacity(1.0)</div><div class=\"line\">        MainWindow.setAutoFillBackground(True)</div><div class=\"line\">        self.centralWidget = QtWidgets.QWidget(MainWindow)</div><div class=\"line\">        self.centralWidget.setObjectName(&quot;centralWidget&quot;)</div><div class=\"line\">        self.accountLabel = QtWidgets.QLabel(self.centralWidget)</div><div class=\"line\">        self.accountLabel.setGeometry(QtCore.QRect(80, 110, 60, 21))</div><div class=\"line\">        self.accountLabel.setAlignment(QtCore.Qt.AlignCenter)</div><div class=\"line\">        self.accountLabel.setObjectName(&quot;accountLabel&quot;)</div><div class=\"line\">        self.pwdLabel = QtWidgets.QLabel(self.centralWidget)</div><div class=\"line\">        self.pwdLabel.setGeometry(QtCore.QRect(80, 150, 60, 21))</div><div class=\"line\">        self.pwdLabel.setAlignment(QtCore.Qt.AlignCenter)</div><div class=\"line\">        self.pwdLabel.setObjectName(&quot;pwdLabel&quot;)</div><div class=\"line\">        self.account = QtWidgets.QLineEdit(self.centralWidget)</div><div class=\"line\">        self.account.setGeometry(QtCore.QRect(140, 110, 191, 21))</div><div class=\"line\">        self.account.setObjectName(&quot;account&quot;)</div><div class=\"line\">        self.password = QtWidgets.QLineEdit(self.centralWidget)</div><div class=\"line\">        self.password.setGeometry(QtCore.QRect(140, 150, 191, 21))</div><div class=\"line\">        self.password.setObjectName(&quot;password&quot;)</div><div class=\"line\">        self.pushButton = QtWidgets.QPushButton(self.centralWidget)</div><div class=\"line\">        self.pushButton.setGeometry(QtCore.QRect(140, 191, 201, 41))</div><div class=\"line\">        self.pushButton.setObjectName(&quot;pushButton&quot;)</div><div class=\"line\">        MainWindow.setCentralWidget(self.centralWidget)</div><div class=\"line\">        self.menuBar = QtWidgets.QMenuBar(MainWindow)</div><div class=\"line\">        self.menuBar.setGeometry(QtCore.QRect(0, 0, 500, 22))</div><div class=\"line\">        self.menuBar.setFocusPolicy(QtCore.Qt.ClickFocus)</div><div class=\"line\">        self.menuBar.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)</div><div class=\"line\">        self.menuBar.setInputMethodHints(QtCore.Qt.ImhNone)</div><div class=\"line\">        self.menuBar.setObjectName(&quot;menuBar&quot;)</div><div class=\"line\">        MainWindow.setMenuBar(self.menuBar)</div><div class=\"line\">        self.statusBar = QtWidgets.QStatusBar(MainWindow)</div><div class=\"line\">        self.statusBar.setObjectName(&quot;statusBar&quot;)</div><div class=\"line\">        MainWindow.setStatusBar(self.statusBar)</div><div class=\"line\"></div><div class=\"line\">        self.retranslateUi(MainWindow)</div><div class=\"line\">        QtCore.QMetaObject.connectSlotsByName(MainWindow)</div><div class=\"line\">        MainWindow.show()</div><div class=\"line\"></div><div class=\"line\">    def retranslateUi(self, MainWindow):</div><div class=\"line\">        _translate = QtCore.QCoreApplication.translate</div><div class=\"line\">        MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;登陆&quot;))</div><div class=\"line\">        self.accountLabel.setText(_translate(&quot;MainWindow&quot;, &quot;账号&quot;))</div><div class=\"line\">        self.pwdLabel.setText(_translate(&quot;MainWindow&quot;, &quot;密码&quot;))</div><div class=\"line\">        self.pushButton.setText(_translate(&quot;MainWindow&quot;, &quot;登陆&quot;))</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    widget = QMainWindow(None)</div><div class=\"line\">    Ui_MainWindow().setupUi(widget)</div><div class=\"line\"></div><div class=\"line\">    sys.exit(app.exec_())</div><div class=\"line\">    pass</div></pre></td></tr></table></figure>\n<h3 id=\"2-一个QTproject新建多个视图\"><a href=\"#2-一个QTproject新建多个视图\" class=\"headerlink\" title=\"2.一个QTproject新建多个视图\"></a>2.一个QTproject新建多个视图</h3><p>如图：<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-8a352a0f49882a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"新建UI\"></p>\n<p>然后在源文件-&gt;main.cpp 导入类，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;mainwindow.h&quot;</div><div class=\"line\">#include &quot;dialog.h&quot;//新建的文件</div><div class=\"line\">#include &lt;QApplication&gt;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char *argv[])</div><div class=\"line\">&#123;</div><div class=\"line\">    QApplication a(argc, argv);</div><div class=\"line\">    MainWindow w;//默认的文件</div><div class=\"line\">    Dialog d;//新建的文件</div><div class=\"line\"></div><div class=\"line\">//    w.show();//默认的注释掉</div><div class=\"line\">    d.show();//新建的文件show</div><div class=\"line\"></div><div class=\"line\">    return a.exec();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后选择新建的 Dialog.ui文件点击运行按钮，运行的就是Dialog视图</p>\n<h3 id=\"4-在窗体中打开新窗体\"><a href=\"#4-在窗体中打开新窗体\" class=\"headerlink\" title=\"4.在窗体中打开新窗体\"></a>4.在窗体中打开新窗体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class Example(QMainWindow):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\">#这一句比较关键，先声明这个窗体2等到需要show的时候在展示出来。</div><div class=\"line\">        self.child = Exaple2()</div><div class=\"line\">def initGUI(self):</div><div class=\"line\">    btn = QPushButton(&apos;打开窗体&apos;, self)</div><div class=\"line\">        btn.setToolTip(&apos;这是个btn&apos;)</div><div class=\"line\">        btn.resize(btn.sizeHint())</div><div class=\"line\">        btn.clicked.connect(self.showSecond)</div><div class=\"line\">   def showSecond(self):</div><div class=\"line\">        self.child.show()</div><div class=\"line\"></div><div class=\"line\">#第二个窗口</div><div class=\"line\">class Exaple2(QWidget):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.configUI()</div><div class=\"line\">    def configUI(self):</div><div class=\"line\">        self.lable = QLabel(&apos;我是第二个窗体&apos;, self)</div><div class=\"line\">        self.lable.setWordWrap(True)  # 自动换行</div><div class=\"line\">#设置frame</div><div class=\"line\">        self.lable.setGeometry(50, 100, 200, 50)</div><div class=\"line\">#设置新窗体frame</div><div class=\"line\">        self.setGeometry(500,500,300,300);</div></pre></td></tr></table></figure>\n<h3 id=\"4-安装QT\"><a href=\"#4-安装QT\" class=\"headerlink\" title=\"4.安装QT\"></a>4.安装QT</h3><p>下载QT5.*<br><a href=\"http://mirrors.ocf.berkeley.edu/qt/archive/qt/5.8/5.8.0/qt-opensource-mac-x64-clang-5.8.0.dmg\" target=\"_blank\" rel=\"external\">下载QT5</a><br>因为下载的dmg直接点下一步下一步安装完成<br><a href=\"http://doc.qt.io/archives/qt-4.8/demos.html\" target=\"_blank\" rel=\"external\">QT的官方Demo</a></p>\n<h3 id=\"5-新建工程\"><a href=\"#5-新建工程\" class=\"headerlink\" title=\"5.新建工程\"></a>5.新建工程</h3><p>1.第一步<br><img src=\"../2.png\" alt=\"第一步\"><br>2.第二步<br><img src=\"../3.png\" alt=\"第二步\"><br>3.第三步<br><img src=\"../4.png\" alt=\"选择Qtwidgets\"><br>4.第四步 打开视图<br><img src=\"../5.png\" alt=\"打开视图\"><br>5.拖拽控件<br><img src=\"../6.png\" alt=\"拖拽控件\"><br>6.效果图<br><img src=\"../7.png\" alt=\"运行的效果图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>大家关注的教程2来了。<br>第一期是代码布局，现在有更高级的布局方式，那就是Qt5，布局完UI可以用PythonUIC命令转成py文件，添加<code>import</code>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    widget = QMainWindow(None)</div><div class=\"line\">    Ui_MainWindow().setupUi(widget)</div><div class=\"line\"></div><div class=\"line\">    sys.exit(app.exec_())</div><div class=\"line\">    pass</div></pre></td></tr></table></figure>\n<p>1.登陆界面<br>2.一个QTproject新建多个视图<br>3.在窗体中打开新窗体<br>4.安装QT</p>\n<h3 id=\"1-登陆\"><a href=\"#1-登陆\" class=\"headerlink\" title=\"1.登陆\"></a>1.登陆</h3><p>用QT可视化编程拖出来的界面就是这个样子，用命令<code>pyuic5 -o target.py fromfile.ui</code>转化成py文件，代码如下<br><img src=\"../1.png\" alt=\"登陆\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"></div><div class=\"line\"># Form implementation generated from reading ui file &apos;mainwindow.ui&apos;</div><div class=\"line\">#</div><div class=\"line\"># Created by: PyQt5 UI code generator 5.10.1</div><div class=\"line\">#</div><div class=\"line\"># WARNING! All changes made in this file will be lost!</div><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"># @Time    : 2018/5/9 下午1:36</div><div class=\"line\"># @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145</div><div class=\"line\"># @Site    : http://fgyong.cn 兜兜转转的技术博客</div><div class=\"line\"># @File    : *.py</div><div class=\"line\"># @Software: PyCharm</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">from PyQt5 import QtCore, QtGui, QtWidgets</div><div class=\"line\">import sys</div><div class=\"line\">from PyQt5.QtCore import *</div><div class=\"line\">from PyQt5.QtWidgets import *</div><div class=\"line\"></div><div class=\"line\">class Ui_MainWindow(object):</div><div class=\"line\">    def setupUi(self, MainWindow):</div><div class=\"line\">        MainWindow.setObjectName(&quot;MainWindow&quot;)</div><div class=\"line\">        MainWindow.resize(500, 341)</div><div class=\"line\">        MainWindow.move(1500,300)</div><div class=\"line\">        MainWindow.setWindowOpacity(1.0)</div><div class=\"line\">        MainWindow.setAutoFillBackground(True)</div><div class=\"line\">        self.centralWidget = QtWidgets.QWidget(MainWindow)</div><div class=\"line\">        self.centralWidget.setObjectName(&quot;centralWidget&quot;)</div><div class=\"line\">        self.accountLabel = QtWidgets.QLabel(self.centralWidget)</div><div class=\"line\">        self.accountLabel.setGeometry(QtCore.QRect(80, 110, 60, 21))</div><div class=\"line\">        self.accountLabel.setAlignment(QtCore.Qt.AlignCenter)</div><div class=\"line\">        self.accountLabel.setObjectName(&quot;accountLabel&quot;)</div><div class=\"line\">        self.pwdLabel = QtWidgets.QLabel(self.centralWidget)</div><div class=\"line\">        self.pwdLabel.setGeometry(QtCore.QRect(80, 150, 60, 21))</div><div class=\"line\">        self.pwdLabel.setAlignment(QtCore.Qt.AlignCenter)</div><div class=\"line\">        self.pwdLabel.setObjectName(&quot;pwdLabel&quot;)</div><div class=\"line\">        self.account = QtWidgets.QLineEdit(self.centralWidget)</div><div class=\"line\">        self.account.setGeometry(QtCore.QRect(140, 110, 191, 21))</div><div class=\"line\">        self.account.setObjectName(&quot;account&quot;)</div><div class=\"line\">        self.password = QtWidgets.QLineEdit(self.centralWidget)</div><div class=\"line\">        self.password.setGeometry(QtCore.QRect(140, 150, 191, 21))</div><div class=\"line\">        self.password.setObjectName(&quot;password&quot;)</div><div class=\"line\">        self.pushButton = QtWidgets.QPushButton(self.centralWidget)</div><div class=\"line\">        self.pushButton.setGeometry(QtCore.QRect(140, 191, 201, 41))</div><div class=\"line\">        self.pushButton.setObjectName(&quot;pushButton&quot;)</div><div class=\"line\">        MainWindow.setCentralWidget(self.centralWidget)</div><div class=\"line\">        self.menuBar = QtWidgets.QMenuBar(MainWindow)</div><div class=\"line\">        self.menuBar.setGeometry(QtCore.QRect(0, 0, 500, 22))</div><div class=\"line\">        self.menuBar.setFocusPolicy(QtCore.Qt.ClickFocus)</div><div class=\"line\">        self.menuBar.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)</div><div class=\"line\">        self.menuBar.setInputMethodHints(QtCore.Qt.ImhNone)</div><div class=\"line\">        self.menuBar.setObjectName(&quot;menuBar&quot;)</div><div class=\"line\">        MainWindow.setMenuBar(self.menuBar)</div><div class=\"line\">        self.statusBar = QtWidgets.QStatusBar(MainWindow)</div><div class=\"line\">        self.statusBar.setObjectName(&quot;statusBar&quot;)</div><div class=\"line\">        MainWindow.setStatusBar(self.statusBar)</div><div class=\"line\"></div><div class=\"line\">        self.retranslateUi(MainWindow)</div><div class=\"line\">        QtCore.QMetaObject.connectSlotsByName(MainWindow)</div><div class=\"line\">        MainWindow.show()</div><div class=\"line\"></div><div class=\"line\">    def retranslateUi(self, MainWindow):</div><div class=\"line\">        _translate = QtCore.QCoreApplication.translate</div><div class=\"line\">        MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;登陆&quot;))</div><div class=\"line\">        self.accountLabel.setText(_translate(&quot;MainWindow&quot;, &quot;账号&quot;))</div><div class=\"line\">        self.pwdLabel.setText(_translate(&quot;MainWindow&quot;, &quot;密码&quot;))</div><div class=\"line\">        self.pushButton.setText(_translate(&quot;MainWindow&quot;, &quot;登陆&quot;))</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    widget = QMainWindow(None)</div><div class=\"line\">    Ui_MainWindow().setupUi(widget)</div><div class=\"line\"></div><div class=\"line\">    sys.exit(app.exec_())</div><div class=\"line\">    pass</div></pre></td></tr></table></figure>\n<h3 id=\"2-一个QTproject新建多个视图\"><a href=\"#2-一个QTproject新建多个视图\" class=\"headerlink\" title=\"2.一个QTproject新建多个视图\"></a>2.一个QTproject新建多个视图</h3><p>如图：<br><img src=\"https://upload-images.jianshu.io/upload_images/783986-8a352a0f49882a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"新建UI\"></p>\n<p>然后在源文件-&gt;main.cpp 导入类，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;mainwindow.h&quot;</div><div class=\"line\">#include &quot;dialog.h&quot;//新建的文件</div><div class=\"line\">#include &lt;QApplication&gt;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char *argv[])</div><div class=\"line\">&#123;</div><div class=\"line\">    QApplication a(argc, argv);</div><div class=\"line\">    MainWindow w;//默认的文件</div><div class=\"line\">    Dialog d;//新建的文件</div><div class=\"line\"></div><div class=\"line\">//    w.show();//默认的注释掉</div><div class=\"line\">    d.show();//新建的文件show</div><div class=\"line\"></div><div class=\"line\">    return a.exec();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后选择新建的 Dialog.ui文件点击运行按钮，运行的就是Dialog视图</p>\n<h3 id=\"4-在窗体中打开新窗体\"><a href=\"#4-在窗体中打开新窗体\" class=\"headerlink\" title=\"4.在窗体中打开新窗体\"></a>4.在窗体中打开新窗体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class Example(QMainWindow):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\">#这一句比较关键，先声明这个窗体2等到需要show的时候在展示出来。</div><div class=\"line\">        self.child = Exaple2()</div><div class=\"line\">def initGUI(self):</div><div class=\"line\">    btn = QPushButton(&apos;打开窗体&apos;, self)</div><div class=\"line\">        btn.setToolTip(&apos;这是个btn&apos;)</div><div class=\"line\">        btn.resize(btn.sizeHint())</div><div class=\"line\">        btn.clicked.connect(self.showSecond)</div><div class=\"line\">   def showSecond(self):</div><div class=\"line\">        self.child.show()</div><div class=\"line\"></div><div class=\"line\">#第二个窗口</div><div class=\"line\">class Exaple2(QWidget):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.configUI()</div><div class=\"line\">    def configUI(self):</div><div class=\"line\">        self.lable = QLabel(&apos;我是第二个窗体&apos;, self)</div><div class=\"line\">        self.lable.setWordWrap(True)  # 自动换行</div><div class=\"line\">#设置frame</div><div class=\"line\">        self.lable.setGeometry(50, 100, 200, 50)</div><div class=\"line\">#设置新窗体frame</div><div class=\"line\">        self.setGeometry(500,500,300,300);</div></pre></td></tr></table></figure>\n<h3 id=\"4-安装QT\"><a href=\"#4-安装QT\" class=\"headerlink\" title=\"4.安装QT\"></a>4.安装QT</h3><p>下载QT5.*<br><a href=\"http://mirrors.ocf.berkeley.edu/qt/archive/qt/5.8/5.8.0/qt-opensource-mac-x64-clang-5.8.0.dmg\" target=\"_blank\" rel=\"external\">下载QT5</a><br>因为下载的dmg直接点下一步下一步安装完成<br><a href=\"http://doc.qt.io/archives/qt-4.8/demos.html\" target=\"_blank\" rel=\"external\">QT的官方Demo</a></p>\n<h3 id=\"5-新建工程\"><a href=\"#5-新建工程\" class=\"headerlink\" title=\"5.新建工程\"></a>5.新建工程</h3><p>1.第一步<br><img src=\"../2.png\" alt=\"第一步\"><br>2.第二步<br><img src=\"../3.png\" alt=\"第二步\"><br>3.第三步<br><img src=\"../4.png\" alt=\"选择Qtwidgets\"><br>4.第四步 打开视图<br><img src=\"../5.png\" alt=\"打开视图\"><br>5.拖拽控件<br><img src=\"../6.png\" alt=\"拖拽控件\"><br>6.效果图<br><img src=\"../7.png\" alt=\"运行的效果图\"></p>\n"},{"title":"hexo换了电脑处理方法","date":"2016-01-31T04:02:22.000Z","_content":"\n## hexo换了电脑处理方法\n为了可以在多个电脑上面都处理hexo博客，所以我把source文件和网站的文件分别放在hexo和master分支上面了。\n克隆到本地你的仓库\n```\ngit clone git@github.com:ifgyongifgyong.github.io.git\n```\n## 然后切换到hexo分支上面\n```\ngit checkout hexo\n\n运行 `hexo s --debug` 看看能不能正常启动。\n在浏览器打开 `localhost:4000`\n```\n## 然后测试是否在新的电脑上面能不能发表新的文章\n```\nhexo new '测试'\n\nhexo s --debug 然后打开`localhost:4000`就可以看见刚才发表的测试文章了\n```\n## 编译到git上面\n```\nhexo clean\nhexo g\nhexo d\n然后打开你自己的网站，我的是fgyong.cn，查看文章上去没了没。\n```\n我执行`hexo d`好几次都成功了，但是 网站上面的内容都没有更新，我就纳闷了。\n## 最终大招\n最后在知乎偶尔看见一个答案说是 删除仓库中的`.deploy_git`文件夹，然后在重新编译，部署。OK，新的文章出现了。\n\n","source":"_posts/hexo换了电脑处理方法.md","raw":"title: hexo换了电脑处理方法\ndate: 2016-01-31 12:02:22\ntags:\n- 建站\n- hexo\ncategories: 建站\n---\n\n## hexo换了电脑处理方法\n为了可以在多个电脑上面都处理hexo博客，所以我把source文件和网站的文件分别放在hexo和master分支上面了。\n克隆到本地你的仓库\n```\ngit clone git@github.com:ifgyongifgyong.github.io.git\n```\n## 然后切换到hexo分支上面\n```\ngit checkout hexo\n\n运行 `hexo s --debug` 看看能不能正常启动。\n在浏览器打开 `localhost:4000`\n```\n## 然后测试是否在新的电脑上面能不能发表新的文章\n```\nhexo new '测试'\n\nhexo s --debug 然后打开`localhost:4000`就可以看见刚才发表的测试文章了\n```\n## 编译到git上面\n```\nhexo clean\nhexo g\nhexo d\n然后打开你自己的网站，我的是fgyong.cn，查看文章上去没了没。\n```\n我执行`hexo d`好几次都成功了，但是 网站上面的内容都没有更新，我就纳闷了。\n## 最终大招\n最后在知乎偶尔看见一个答案说是 删除仓库中的`.deploy_git`文件夹，然后在重新编译，部署。OK，新的文章出现了。\n\n","slug":"hexo换了电脑处理方法","published":1,"updated":"2019-12-03T04:48:00.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2a00079zskp88fb7sd","content":"<h2 id=\"hexo换了电脑处理方法\"><a href=\"#hexo换了电脑处理方法\" class=\"headerlink\" title=\"hexo换了电脑处理方法\"></a>hexo换了电脑处理方法</h2><p>为了可以在多个电脑上面都处理hexo博客，所以我把source文件和网站的文件分别放在hexo和master分支上面了。<br>克隆到本地你的仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ifgyongifgyong.github.io.git</div></pre></td></tr></table></figure></p>\n<h2 id=\"然后切换到hexo分支上面\"><a href=\"#然后切换到hexo分支上面\" class=\"headerlink\" title=\"然后切换到hexo分支上面\"></a>然后切换到hexo分支上面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout hexo</div><div class=\"line\"></div><div class=\"line\">运行 `hexo s --debug` 看看能不能正常启动。</div><div class=\"line\">在浏览器打开 `localhost:4000`</div></pre></td></tr></table></figure>\n<h2 id=\"然后测试是否在新的电脑上面能不能发表新的文章\"><a href=\"#然后测试是否在新的电脑上面能不能发表新的文章\" class=\"headerlink\" title=\"然后测试是否在新的电脑上面能不能发表新的文章\"></a>然后测试是否在新的电脑上面能不能发表新的文章</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &apos;测试&apos;</div><div class=\"line\"></div><div class=\"line\">hexo s --debug 然后打开`localhost:4000`就可以看见刚才发表的测试文章了</div></pre></td></tr></table></figure>\n<h2 id=\"编译到git上面\"><a href=\"#编译到git上面\" class=\"headerlink\" title=\"编译到git上面\"></a>编译到git上面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div><div class=\"line\">然后打开你自己的网站，我的是fgyong.cn，查看文章上去没了没。</div></pre></td></tr></table></figure>\n<p>我执行<code>hexo d</code>好几次都成功了，但是 网站上面的内容都没有更新，我就纳闷了。</p>\n<h2 id=\"最终大招\"><a href=\"#最终大招\" class=\"headerlink\" title=\"最终大招\"></a>最终大招</h2><p>最后在知乎偶尔看见一个答案说是 删除仓库中的<code>.deploy_git</code>文件夹，然后在重新编译，部署。OK，新的文章出现了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hexo换了电脑处理方法\"><a href=\"#hexo换了电脑处理方法\" class=\"headerlink\" title=\"hexo换了电脑处理方法\"></a>hexo换了电脑处理方法</h2><p>为了可以在多个电脑上面都处理hexo博客，所以我把source文件和网站的文件分别放在hexo和master分支上面了。<br>克隆到本地你的仓库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ifgyongifgyong.github.io.git</div></pre></td></tr></table></figure></p>\n<h2 id=\"然后切换到hexo分支上面\"><a href=\"#然后切换到hexo分支上面\" class=\"headerlink\" title=\"然后切换到hexo分支上面\"></a>然后切换到hexo分支上面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout hexo</div><div class=\"line\"></div><div class=\"line\">运行 `hexo s --debug` 看看能不能正常启动。</div><div class=\"line\">在浏览器打开 `localhost:4000`</div></pre></td></tr></table></figure>\n<h2 id=\"然后测试是否在新的电脑上面能不能发表新的文章\"><a href=\"#然后测试是否在新的电脑上面能不能发表新的文章\" class=\"headerlink\" title=\"然后测试是否在新的电脑上面能不能发表新的文章\"></a>然后测试是否在新的电脑上面能不能发表新的文章</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &apos;测试&apos;</div><div class=\"line\"></div><div class=\"line\">hexo s --debug 然后打开`localhost:4000`就可以看见刚才发表的测试文章了</div></pre></td></tr></table></figure>\n<h2 id=\"编译到git上面\"><a href=\"#编译到git上面\" class=\"headerlink\" title=\"编译到git上面\"></a>编译到git上面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div><div class=\"line\">然后打开你自己的网站，我的是fgyong.cn，查看文章上去没了没。</div></pre></td></tr></table></figure>\n<p>我执行<code>hexo d</code>好几次都成功了，但是 网站上面的内容都没有更新，我就纳闷了。</p>\n<h2 id=\"最终大招\"><a href=\"#最终大招\" class=\"headerlink\" title=\"最终大招\"></a>最终大招</h2><p>最后在知乎偶尔看见一个答案说是 删除仓库中的<code>.deploy_git</code>文件夹，然后在重新编译，部署。OK，新的文章出现了。</p>\n"},{"title":"Python3 PyQt5教程(1)","date":"2018-05-09T08:39:24.000Z","_content":"\n\nPython的GUI库，新手可以先从PyQt5入手，一周精通。\n1.HelloWord\n2.添加button\n3.菜单栏\n4.textEdit\n5.打包\n### 1.helloWord\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/5/9 下午1:36\n# @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145\n# @Site    : http://fgyong.cn 兜兜转转的技术博客\n# @File    : 12.py\n# @Software: PyCharm\nimport sys,time,datetime\nfrom PyQt5.QtWidgets import (QMainWindow,QMessageBox,QWidget, QToolTip, QPushButton, QApplication, QGestureEvent,QLabel,QDesktopWidget)\nfrom PyQt5.QtGui import QFont,QIcon\n\n\nclass Example(QWidget):\n  #构造函数\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n#初始化函数\n    def initGUI(self):\n#设置窗体frame\n         self.setGeometry(500, 300, 300, 300)\n#窗体title\n        self.setWindowTitle('我的第一个程序')\n#添加label\n        self.lable = QLabel('helloword!',self)\n#自动换行\n        self.lable.setWordWrap(True)\n#lable的frame\n        self.lable.setGeometry(50,100,200,150)\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    ex = Example()\n    ex.show()\n    sys.exit(app.exec_())\n\n```\n### 2.添加按钮\n```\nclass Example(QWidget):\n    lable = ''\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n\n    def initGUI(self):\n        # QToolTip.setFont('SanSerif',10)\n#提示文字\n        self.setToolTip('<b>这是第一个QWidget</b>')\n#更新时间的button\n        btn = QPushButton('更新时间', self)\n#button的提示文字\n        btn.setToolTip('这是个btn')\n#设置默认大小\n        btn.resize(btn.sizeHint())\n\n        btn2 = QPushButton('alert', self)\n        btn2.setToolTip('这是弹出alert的btn')\n        btn2.resize(btn.sizeHint())\n        btn2.move(0,60)\n        btn2.clicked.connect(self.showMessage)\n\n        size = self.geometry()\n   #绑定button的点击函数   self.showTime是函数名字后边没有（）\n        btn.clicked.connect(self.showTime)\n\n        self.setGeometry(1500, 300, 300, 300)\n        self.setWindowTitle('我的第一个程序')\n\n        self.lable = QLabel('时间：',self)\n        self.lable.setWordWrap(True)#自动换行\n        self.lable.setGeometry(50,100,200,150)\n        self.lable.setText('时间:'+datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n        icon = QIcon(\"/Users/Jerry/PycharmProjects/Flask_dmeo_1/App/icons/cry.png\")\n        btn.setIcon(icon)\n        self.setWindowIcon(icon)\n    def showTime(self):\n        nowTime=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        self.lable.setText(\"时间:\"+nowTime)\n\n    def showMessage(self):\n        self.showBox(\"alert message\")\n    def showBox(self,message):\n        box=QMessageBox.question(self,'温馨提示',message,QMessageBox.Yes|QMessageBox.No,QMessageBox.No)\n        if box == QMessageBox.Yes:\n            self.lable.setText(self.lable.text()+'YES')\n        else:\n            self.lable.setText(self.lable.text() + 'NO')\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    ex = Example()\n    ex.show()\n    sys.exit(app.exec_())\n```\n### 3.菜单栏\n```\n    def showMenu(self):\n        # 生成母菜单栏\n        menubar = self.menuBar()\n        #添加菜单\n        p = menubar.addMenu('p')\n        #菜单 p2\n        impMenu = QMenu('p2', self)\n        # 子菜单 p2 click\n        impAct = QAction('p2 click', self)\n        #绑定 action\n        impAct.triggered.connect(self.p2)\n        # 添加菜单 p2 click\n        impMenu.addAction(impAct)\n        # 添加菜单 p2\n        p.addMenu(impMenu)\n\n\n        newAct = QAction('p1', self)\n        newAct.triggered.connect(self.p1)\n        p.addAction(newAct)\n\n\n    def p1(self):\n        print(\"p1\")\n\n    def p2(self):\n        print(\"p2\")\n```\n\n\n### 4.文本框 QTextEdit\n```\n    def showTextView(self):\n        self.b=QTextEdit(self)\n        self.b.setPlaceholderText('我是默认文字')\n        self.b.setGeometry(20,150,200,100)\n\n        btn3 = QPushButton('提交', self)\n        btn3.resize(btn3.sizeHint())\n        btn3.clicked.connect(self.print)\n        btn3.move(110,260)\n    def print(self):\n        #输出来文本框的汉字\n        print(self.b.toPlainText())\n```\n\n### 5.打包成可执行文件\n这里说是打包，不是exe和dmg，而是可执行文件\n```\n********************************************************************\npyinstaller -F path \n编译成可执行文件\npath是想编译文件的路径\n\n会生成 dist文件夹和build文件夹,在dist文件夹下边生成一个可执行文件，\n文件的名字和编译文件的名字一样。双击就可以执行这个程序了。\n********************************************************************\n```\n学习的小伙伴可以下载来看哦[仓库地址](git@github.com:ifgyong/PYDemo.git)\n\n","source":"_posts/Python3 PyQt5教程(1).md","raw":"title: Python3 PyQt5教程(1)\ndate: 2018-5-9 16:39:24\ntags: \n- Python3 \n- 开发\n- 建站\ncategories: Python3\n---\n\n\nPython的GUI库，新手可以先从PyQt5入手，一周精通。\n1.HelloWord\n2.添加button\n3.菜单栏\n4.textEdit\n5.打包\n### 1.helloWord\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/5/9 下午1:36\n# @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145\n# @Site    : http://fgyong.cn 兜兜转转的技术博客\n# @File    : 12.py\n# @Software: PyCharm\nimport sys,time,datetime\nfrom PyQt5.QtWidgets import (QMainWindow,QMessageBox,QWidget, QToolTip, QPushButton, QApplication, QGestureEvent,QLabel,QDesktopWidget)\nfrom PyQt5.QtGui import QFont,QIcon\n\n\nclass Example(QWidget):\n  #构造函数\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n#初始化函数\n    def initGUI(self):\n#设置窗体frame\n         self.setGeometry(500, 300, 300, 300)\n#窗体title\n        self.setWindowTitle('我的第一个程序')\n#添加label\n        self.lable = QLabel('helloword!',self)\n#自动换行\n        self.lable.setWordWrap(True)\n#lable的frame\n        self.lable.setGeometry(50,100,200,150)\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    ex = Example()\n    ex.show()\n    sys.exit(app.exec_())\n\n```\n### 2.添加按钮\n```\nclass Example(QWidget):\n    lable = ''\n    def __init__(self):\n        super().__init__()\n        self.initGUI();\n\n    def initGUI(self):\n        # QToolTip.setFont('SanSerif',10)\n#提示文字\n        self.setToolTip('<b>这是第一个QWidget</b>')\n#更新时间的button\n        btn = QPushButton('更新时间', self)\n#button的提示文字\n        btn.setToolTip('这是个btn')\n#设置默认大小\n        btn.resize(btn.sizeHint())\n\n        btn2 = QPushButton('alert', self)\n        btn2.setToolTip('这是弹出alert的btn')\n        btn2.resize(btn.sizeHint())\n        btn2.move(0,60)\n        btn2.clicked.connect(self.showMessage)\n\n        size = self.geometry()\n   #绑定button的点击函数   self.showTime是函数名字后边没有（）\n        btn.clicked.connect(self.showTime)\n\n        self.setGeometry(1500, 300, 300, 300)\n        self.setWindowTitle('我的第一个程序')\n\n        self.lable = QLabel('时间：',self)\n        self.lable.setWordWrap(True)#自动换行\n        self.lable.setGeometry(50,100,200,150)\n        self.lable.setText('时间:'+datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n        icon = QIcon(\"/Users/Jerry/PycharmProjects/Flask_dmeo_1/App/icons/cry.png\")\n        btn.setIcon(icon)\n        self.setWindowIcon(icon)\n    def showTime(self):\n        nowTime=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        self.lable.setText(\"时间:\"+nowTime)\n\n    def showMessage(self):\n        self.showBox(\"alert message\")\n    def showBox(self,message):\n        box=QMessageBox.question(self,'温馨提示',message,QMessageBox.Yes|QMessageBox.No,QMessageBox.No)\n        if box == QMessageBox.Yes:\n            self.lable.setText(self.lable.text()+'YES')\n        else:\n            self.lable.setText(self.lable.text() + 'NO')\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    ex = Example()\n    ex.show()\n    sys.exit(app.exec_())\n```\n### 3.菜单栏\n```\n    def showMenu(self):\n        # 生成母菜单栏\n        menubar = self.menuBar()\n        #添加菜单\n        p = menubar.addMenu('p')\n        #菜单 p2\n        impMenu = QMenu('p2', self)\n        # 子菜单 p2 click\n        impAct = QAction('p2 click', self)\n        #绑定 action\n        impAct.triggered.connect(self.p2)\n        # 添加菜单 p2 click\n        impMenu.addAction(impAct)\n        # 添加菜单 p2\n        p.addMenu(impMenu)\n\n\n        newAct = QAction('p1', self)\n        newAct.triggered.connect(self.p1)\n        p.addAction(newAct)\n\n\n    def p1(self):\n        print(\"p1\")\n\n    def p2(self):\n        print(\"p2\")\n```\n\n\n### 4.文本框 QTextEdit\n```\n    def showTextView(self):\n        self.b=QTextEdit(self)\n        self.b.setPlaceholderText('我是默认文字')\n        self.b.setGeometry(20,150,200,100)\n\n        btn3 = QPushButton('提交', self)\n        btn3.resize(btn3.sizeHint())\n        btn3.clicked.connect(self.print)\n        btn3.move(110,260)\n    def print(self):\n        #输出来文本框的汉字\n        print(self.b.toPlainText())\n```\n\n### 5.打包成可执行文件\n这里说是打包，不是exe和dmg，而是可执行文件\n```\n********************************************************************\npyinstaller -F path \n编译成可执行文件\npath是想编译文件的路径\n\n会生成 dist文件夹和build文件夹,在dist文件夹下边生成一个可执行文件，\n文件的名字和编译文件的名字一样。双击就可以执行这个程序了。\n********************************************************************\n```\n学习的小伙伴可以下载来看哦[仓库地址](git@github.com:ifgyong/PYDemo.git)\n\n","slug":"Python3 PyQt5教程(1)","published":1,"updated":"2019-12-03T04:48:00.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2b00089zskw5rukims","content":"<p>Python的GUI库，新手可以先从PyQt5入手，一周精通。<br>1.HelloWord<br>2.添加button<br>3.菜单栏<br>4.textEdit<br>5.打包</p>\n<h3 id=\"1-helloWord\"><a href=\"#1-helloWord\" class=\"headerlink\" title=\"1.helloWord\"></a>1.helloWord</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"># @Time    : 2018/5/9 下午1:36</div><div class=\"line\"># @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145</div><div class=\"line\"># @Site    : http://fgyong.cn 兜兜转转的技术博客</div><div class=\"line\"># @File    : 12.py</div><div class=\"line\"># @Software: PyCharm</div><div class=\"line\">import sys,time,datetime</div><div class=\"line\">from PyQt5.QtWidgets import (QMainWindow,QMessageBox,QWidget, QToolTip, QPushButton, QApplication, QGestureEvent,QLabel,QDesktopWidget)</div><div class=\"line\">from PyQt5.QtGui import QFont,QIcon</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Example(QWidget):</div><div class=\"line\">  #构造函数</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\">#初始化函数</div><div class=\"line\">    def initGUI(self):</div><div class=\"line\">#设置窗体frame</div><div class=\"line\">         self.setGeometry(500, 300, 300, 300)</div><div class=\"line\">#窗体title</div><div class=\"line\">        self.setWindowTitle(&apos;我的第一个程序&apos;)</div><div class=\"line\">#添加label</div><div class=\"line\">        self.lable = QLabel(&apos;helloword!&apos;,self)</div><div class=\"line\">#自动换行</div><div class=\"line\">        self.lable.setWordWrap(True)</div><div class=\"line\">#lable的frame</div><div class=\"line\">        self.lable.setGeometry(50,100,200,150)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    ex = Example()</div><div class=\"line\">    ex.show()</div><div class=\"line\">    sys.exit(app.exec_())</div></pre></td></tr></table></figure>\n<h3 id=\"2-添加按钮\"><a href=\"#2-添加按钮\" class=\"headerlink\" title=\"2.添加按钮\"></a>2.添加按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Example(QWidget):</div><div class=\"line\">    lable = &apos;&apos;</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\"></div><div class=\"line\">    def initGUI(self):</div><div class=\"line\">        # QToolTip.setFont(&apos;SanSerif&apos;,10)</div><div class=\"line\">#提示文字</div><div class=\"line\">        self.setToolTip(&apos;&lt;b&gt;这是第一个QWidget&lt;/b&gt;&apos;)</div><div class=\"line\">#更新时间的button</div><div class=\"line\">        btn = QPushButton(&apos;更新时间&apos;, self)</div><div class=\"line\">#button的提示文字</div><div class=\"line\">        btn.setToolTip(&apos;这是个btn&apos;)</div><div class=\"line\">#设置默认大小</div><div class=\"line\">        btn.resize(btn.sizeHint())</div><div class=\"line\"></div><div class=\"line\">        btn2 = QPushButton(&apos;alert&apos;, self)</div><div class=\"line\">        btn2.setToolTip(&apos;这是弹出alert的btn&apos;)</div><div class=\"line\">        btn2.resize(btn.sizeHint())</div><div class=\"line\">        btn2.move(0,60)</div><div class=\"line\">        btn2.clicked.connect(self.showMessage)</div><div class=\"line\"></div><div class=\"line\">        size = self.geometry()</div><div class=\"line\">   #绑定button的点击函数   self.showTime是函数名字后边没有（）</div><div class=\"line\">        btn.clicked.connect(self.showTime)</div><div class=\"line\"></div><div class=\"line\">        self.setGeometry(1500, 300, 300, 300)</div><div class=\"line\">        self.setWindowTitle(&apos;我的第一个程序&apos;)</div><div class=\"line\"></div><div class=\"line\">        self.lable = QLabel(&apos;时间：&apos;,self)</div><div class=\"line\">        self.lable.setWordWrap(True)#自动换行</div><div class=\"line\">        self.lable.setGeometry(50,100,200,150)</div><div class=\"line\">        self.lable.setText(&apos;时间:&apos;+datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;))</div><div class=\"line\">        icon = QIcon(&quot;/Users/Jerry/PycharmProjects/Flask_dmeo_1/App/icons/cry.png&quot;)</div><div class=\"line\">        btn.setIcon(icon)</div><div class=\"line\">        self.setWindowIcon(icon)</div><div class=\"line\">    def showTime(self):</div><div class=\"line\">        nowTime=datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</div><div class=\"line\">        self.lable.setText(&quot;时间:&quot;+nowTime)</div><div class=\"line\"></div><div class=\"line\">    def showMessage(self):</div><div class=\"line\">        self.showBox(&quot;alert message&quot;)</div><div class=\"line\">    def showBox(self,message):</div><div class=\"line\">        box=QMessageBox.question(self,&apos;温馨提示&apos;,message,QMessageBox.Yes|QMessageBox.No,QMessageBox.No)</div><div class=\"line\">        if box == QMessageBox.Yes:</div><div class=\"line\">            self.lable.setText(self.lable.text()+&apos;YES&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            self.lable.setText(self.lable.text() + &apos;NO&apos;)</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    ex = Example()</div><div class=\"line\">    ex.show()</div><div class=\"line\">    sys.exit(app.exec_())</div></pre></td></tr></table></figure>\n<h3 id=\"3-菜单栏\"><a href=\"#3-菜单栏\" class=\"headerlink\" title=\"3.菜单栏\"></a>3.菜单栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">def showMenu(self):</div><div class=\"line\">    # 生成母菜单栏</div><div class=\"line\">    menubar = self.menuBar()</div><div class=\"line\">    #添加菜单</div><div class=\"line\">    p = menubar.addMenu(&apos;p&apos;)</div><div class=\"line\">    #菜单 p2</div><div class=\"line\">    impMenu = QMenu(&apos;p2&apos;, self)</div><div class=\"line\">    # 子菜单 p2 click</div><div class=\"line\">    impAct = QAction(&apos;p2 click&apos;, self)</div><div class=\"line\">    #绑定 action</div><div class=\"line\">    impAct.triggered.connect(self.p2)</div><div class=\"line\">    # 添加菜单 p2 click</div><div class=\"line\">    impMenu.addAction(impAct)</div><div class=\"line\">    # 添加菜单 p2</div><div class=\"line\">    p.addMenu(impMenu)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    newAct = QAction(&apos;p1&apos;, self)</div><div class=\"line\">    newAct.triggered.connect(self.p1)</div><div class=\"line\">    p.addAction(newAct)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def p1(self):</div><div class=\"line\">    print(&quot;p1&quot;)</div><div class=\"line\"></div><div class=\"line\">def p2(self):</div><div class=\"line\">    print(&quot;p2&quot;)</div></pre></td></tr></table></figure>\n<h3 id=\"4-文本框-QTextEdit\"><a href=\"#4-文本框-QTextEdit\" class=\"headerlink\" title=\"4.文本框 QTextEdit\"></a>4.文本框 QTextEdit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def showTextView(self):</div><div class=\"line\">    self.b=QTextEdit(self)</div><div class=\"line\">    self.b.setPlaceholderText(&apos;我是默认文字&apos;)</div><div class=\"line\">    self.b.setGeometry(20,150,200,100)</div><div class=\"line\"></div><div class=\"line\">    btn3 = QPushButton(&apos;提交&apos;, self)</div><div class=\"line\">    btn3.resize(btn3.sizeHint())</div><div class=\"line\">    btn3.clicked.connect(self.print)</div><div class=\"line\">    btn3.move(110,260)</div><div class=\"line\">def print(self):</div><div class=\"line\">    #输出来文本框的汉字</div><div class=\"line\">    print(self.b.toPlainText())</div></pre></td></tr></table></figure>\n<h3 id=\"5-打包成可执行文件\"><a href=\"#5-打包成可执行文件\" class=\"headerlink\" title=\"5.打包成可执行文件\"></a>5.打包成可执行文件</h3><p>这里说是打包，不是exe和dmg，而是可执行文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">********************************************************************</div><div class=\"line\">pyinstaller -F path </div><div class=\"line\">编译成可执行文件</div><div class=\"line\">path是想编译文件的路径</div><div class=\"line\"></div><div class=\"line\">会生成 dist文件夹和build文件夹,在dist文件夹下边生成一个可执行文件，</div><div class=\"line\">文件的名字和编译文件的名字一样。双击就可以执行这个程序了。</div><div class=\"line\">********************************************************************</div></pre></td></tr></table></figure></p>\n<p>学习的小伙伴可以下载来看哦<a href=\"git@github.com:ifgyong/PYDemo.git\">仓库地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Python的GUI库，新手可以先从PyQt5入手，一周精通。<br>1.HelloWord<br>2.添加button<br>3.菜单栏<br>4.textEdit<br>5.打包</p>\n<h3 id=\"1-helloWord\"><a href=\"#1-helloWord\" class=\"headerlink\" title=\"1.helloWord\"></a>1.helloWord</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\"># @Time    : 2018/5/9 下午1:36</div><div class=\"line\"># @Author  : fgyong 简书:_兜兜转转_  https://www.jianshu.com/u/6d1254c1d145</div><div class=\"line\"># @Site    : http://fgyong.cn 兜兜转转的技术博客</div><div class=\"line\"># @File    : 12.py</div><div class=\"line\"># @Software: PyCharm</div><div class=\"line\">import sys,time,datetime</div><div class=\"line\">from PyQt5.QtWidgets import (QMainWindow,QMessageBox,QWidget, QToolTip, QPushButton, QApplication, QGestureEvent,QLabel,QDesktopWidget)</div><div class=\"line\">from PyQt5.QtGui import QFont,QIcon</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Example(QWidget):</div><div class=\"line\">  #构造函数</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\">#初始化函数</div><div class=\"line\">    def initGUI(self):</div><div class=\"line\">#设置窗体frame</div><div class=\"line\">         self.setGeometry(500, 300, 300, 300)</div><div class=\"line\">#窗体title</div><div class=\"line\">        self.setWindowTitle(&apos;我的第一个程序&apos;)</div><div class=\"line\">#添加label</div><div class=\"line\">        self.lable = QLabel(&apos;helloword!&apos;,self)</div><div class=\"line\">#自动换行</div><div class=\"line\">        self.lable.setWordWrap(True)</div><div class=\"line\">#lable的frame</div><div class=\"line\">        self.lable.setGeometry(50,100,200,150)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    ex = Example()</div><div class=\"line\">    ex.show()</div><div class=\"line\">    sys.exit(app.exec_())</div></pre></td></tr></table></figure>\n<h3 id=\"2-添加按钮\"><a href=\"#2-添加按钮\" class=\"headerlink\" title=\"2.添加按钮\"></a>2.添加按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Example(QWidget):</div><div class=\"line\">    lable = &apos;&apos;</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.initGUI();</div><div class=\"line\"></div><div class=\"line\">    def initGUI(self):</div><div class=\"line\">        # QToolTip.setFont(&apos;SanSerif&apos;,10)</div><div class=\"line\">#提示文字</div><div class=\"line\">        self.setToolTip(&apos;&lt;b&gt;这是第一个QWidget&lt;/b&gt;&apos;)</div><div class=\"line\">#更新时间的button</div><div class=\"line\">        btn = QPushButton(&apos;更新时间&apos;, self)</div><div class=\"line\">#button的提示文字</div><div class=\"line\">        btn.setToolTip(&apos;这是个btn&apos;)</div><div class=\"line\">#设置默认大小</div><div class=\"line\">        btn.resize(btn.sizeHint())</div><div class=\"line\"></div><div class=\"line\">        btn2 = QPushButton(&apos;alert&apos;, self)</div><div class=\"line\">        btn2.setToolTip(&apos;这是弹出alert的btn&apos;)</div><div class=\"line\">        btn2.resize(btn.sizeHint())</div><div class=\"line\">        btn2.move(0,60)</div><div class=\"line\">        btn2.clicked.connect(self.showMessage)</div><div class=\"line\"></div><div class=\"line\">        size = self.geometry()</div><div class=\"line\">   #绑定button的点击函数   self.showTime是函数名字后边没有（）</div><div class=\"line\">        btn.clicked.connect(self.showTime)</div><div class=\"line\"></div><div class=\"line\">        self.setGeometry(1500, 300, 300, 300)</div><div class=\"line\">        self.setWindowTitle(&apos;我的第一个程序&apos;)</div><div class=\"line\"></div><div class=\"line\">        self.lable = QLabel(&apos;时间：&apos;,self)</div><div class=\"line\">        self.lable.setWordWrap(True)#自动换行</div><div class=\"line\">        self.lable.setGeometry(50,100,200,150)</div><div class=\"line\">        self.lable.setText(&apos;时间:&apos;+datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;))</div><div class=\"line\">        icon = QIcon(&quot;/Users/Jerry/PycharmProjects/Flask_dmeo_1/App/icons/cry.png&quot;)</div><div class=\"line\">        btn.setIcon(icon)</div><div class=\"line\">        self.setWindowIcon(icon)</div><div class=\"line\">    def showTime(self):</div><div class=\"line\">        nowTime=datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</div><div class=\"line\">        self.lable.setText(&quot;时间:&quot;+nowTime)</div><div class=\"line\"></div><div class=\"line\">    def showMessage(self):</div><div class=\"line\">        self.showBox(&quot;alert message&quot;)</div><div class=\"line\">    def showBox(self,message):</div><div class=\"line\">        box=QMessageBox.question(self,&apos;温馨提示&apos;,message,QMessageBox.Yes|QMessageBox.No,QMessageBox.No)</div><div class=\"line\">        if box == QMessageBox.Yes:</div><div class=\"line\">            self.lable.setText(self.lable.text()+&apos;YES&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            self.lable.setText(self.lable.text() + &apos;NO&apos;)</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    app = QApplication(sys.argv)</div><div class=\"line\">    ex = Example()</div><div class=\"line\">    ex.show()</div><div class=\"line\">    sys.exit(app.exec_())</div></pre></td></tr></table></figure>\n<h3 id=\"3-菜单栏\"><a href=\"#3-菜单栏\" class=\"headerlink\" title=\"3.菜单栏\"></a>3.菜单栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">def showMenu(self):</div><div class=\"line\">    # 生成母菜单栏</div><div class=\"line\">    menubar = self.menuBar()</div><div class=\"line\">    #添加菜单</div><div class=\"line\">    p = menubar.addMenu(&apos;p&apos;)</div><div class=\"line\">    #菜单 p2</div><div class=\"line\">    impMenu = QMenu(&apos;p2&apos;, self)</div><div class=\"line\">    # 子菜单 p2 click</div><div class=\"line\">    impAct = QAction(&apos;p2 click&apos;, self)</div><div class=\"line\">    #绑定 action</div><div class=\"line\">    impAct.triggered.connect(self.p2)</div><div class=\"line\">    # 添加菜单 p2 click</div><div class=\"line\">    impMenu.addAction(impAct)</div><div class=\"line\">    # 添加菜单 p2</div><div class=\"line\">    p.addMenu(impMenu)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    newAct = QAction(&apos;p1&apos;, self)</div><div class=\"line\">    newAct.triggered.connect(self.p1)</div><div class=\"line\">    p.addAction(newAct)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def p1(self):</div><div class=\"line\">    print(&quot;p1&quot;)</div><div class=\"line\"></div><div class=\"line\">def p2(self):</div><div class=\"line\">    print(&quot;p2&quot;)</div></pre></td></tr></table></figure>\n<h3 id=\"4-文本框-QTextEdit\"><a href=\"#4-文本框-QTextEdit\" class=\"headerlink\" title=\"4.文本框 QTextEdit\"></a>4.文本框 QTextEdit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def showTextView(self):</div><div class=\"line\">    self.b=QTextEdit(self)</div><div class=\"line\">    self.b.setPlaceholderText(&apos;我是默认文字&apos;)</div><div class=\"line\">    self.b.setGeometry(20,150,200,100)</div><div class=\"line\"></div><div class=\"line\">    btn3 = QPushButton(&apos;提交&apos;, self)</div><div class=\"line\">    btn3.resize(btn3.sizeHint())</div><div class=\"line\">    btn3.clicked.connect(self.print)</div><div class=\"line\">    btn3.move(110,260)</div><div class=\"line\">def print(self):</div><div class=\"line\">    #输出来文本框的汉字</div><div class=\"line\">    print(self.b.toPlainText())</div></pre></td></tr></table></figure>\n<h3 id=\"5-打包成可执行文件\"><a href=\"#5-打包成可执行文件\" class=\"headerlink\" title=\"5.打包成可执行文件\"></a>5.打包成可执行文件</h3><p>这里说是打包，不是exe和dmg，而是可执行文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">********************************************************************</div><div class=\"line\">pyinstaller -F path </div><div class=\"line\">编译成可执行文件</div><div class=\"line\">path是想编译文件的路径</div><div class=\"line\"></div><div class=\"line\">会生成 dist文件夹和build文件夹,在dist文件夹下边生成一个可执行文件，</div><div class=\"line\">文件的名字和编译文件的名字一样。双击就可以执行这个程序了。</div><div class=\"line\">********************************************************************</div></pre></td></tr></table></figure></p>\n<p>学习的小伙伴可以下载来看哦<a href=\"git@github.com:ifgyong/PYDemo.git\">仓库地址</a></p>\n"},{"title":"hexo自定义域名","date":"2016-01-28T03:44:52.000Z","_content":"## 注册购买域名\n就像买淘宝的宝贝一样简单，[阿里云域名购买](http://wanwang.aliyun.com/domain/?spm=5176.200001.n2.13.iyigkk)\n\n## 设置DNS\n 设置IP地址的时候设置成github的IP具体获取方法是\n  ```\n    $ nslookup fgyong.github.io//这个地址是你自己的地址下边的是输出来的，其中103.245.222.144便是上边需要的IP。\n     Server:        211.162.96.1\n     Address:    211.162.96.1#53\n\n     Non-authoritative answer: \n     fgyong.github.io    canonical name = github.map.fastly.net.\n     Name:    github.map.fastly.net\n     Address: 103.245.222.133\n     ```\n## 新建CNAME\n           在hexo文件目录source下边执行\n           ```\n           vi CNAME //新建文件并打开\n           然后把你买的域名写入文件退出并保存。\n           比如我的是 http://fgyong.cn,写入文件的 网址是fgyong.cn.`没有http字样的`\n           ```\n\n           然后\n           ```\n           编译 hexo g\n           上传github hexo d\n           ```\n\n           大功告成，可以测试查看成果了。\n            \n             \n","source":"_posts/hexo自定义域名.md","raw":"title: hexo自定义域名\ndate: 2016-01-28 11:44:52\ntags:\n- 建站\ncategories: 建站\n---\n## 注册购买域名\n就像买淘宝的宝贝一样简单，[阿里云域名购买](http://wanwang.aliyun.com/domain/?spm=5176.200001.n2.13.iyigkk)\n\n## 设置DNS\n 设置IP地址的时候设置成github的IP具体获取方法是\n  ```\n    $ nslookup fgyong.github.io//这个地址是你自己的地址下边的是输出来的，其中103.245.222.144便是上边需要的IP。\n     Server:        211.162.96.1\n     Address:    211.162.96.1#53\n\n     Non-authoritative answer: \n     fgyong.github.io    canonical name = github.map.fastly.net.\n     Name:    github.map.fastly.net\n     Address: 103.245.222.133\n     ```\n## 新建CNAME\n           在hexo文件目录source下边执行\n           ```\n           vi CNAME //新建文件并打开\n           然后把你买的域名写入文件退出并保存。\n           比如我的是 http://fgyong.cn,写入文件的 网址是fgyong.cn.`没有http字样的`\n           ```\n\n           然后\n           ```\n           编译 hexo g\n           上传github hexo d\n           ```\n\n           大功告成，可以测试查看成果了。\n            \n             \n","slug":"hexo自定义域名","published":1,"updated":"2019-12-03T04:48:00.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2b00099zsk4b44qr0g","content":"<h2 id=\"注册购买域名\"><a href=\"#注册购买域名\" class=\"headerlink\" title=\"注册购买域名\"></a>注册购买域名</h2><p>就像买淘宝的宝贝一样简单，<a href=\"http://wanwang.aliyun.com/domain/?spm=5176.200001.n2.13.iyigkk\" target=\"_blank\" rel=\"external\">阿里云域名购买</a></p>\n<h2 id=\"设置DNS\"><a href=\"#设置DNS\" class=\"headerlink\" title=\"设置DNS\"></a>设置DNS</h2><p> 设置IP地址的时候设置成github的IP具体获取方法是<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nslookup fgyong.github.io//这个地址是你自己的地址下边的是输出来的，其中103.245.222.144便是上边需要的IP。</div><div class=\"line\"> Server:        211.162.96.1</div><div class=\"line\"> Address:    211.162.96.1#53</div><div class=\"line\"></div><div class=\"line\"> Non-authoritative answer: </div><div class=\"line\"> fgyong.github.io    canonical name = github.map.fastly.net.</div><div class=\"line\"> Name:    github.map.fastly.net</div><div class=\"line\"> Address: 103.245.222.133</div></pre></td></tr></table></figure></p>\n<h2 id=\"新建CNAME\"><a href=\"#新建CNAME\" class=\"headerlink\" title=\"新建CNAME\"></a>新建CNAME</h2><pre><code>在hexo文件目录source下边执行\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi CNAME //新建文件并打开</div><div class=\"line\">然后把你买的域名写入文件退出并保存。</div><div class=\"line\">比如我的是 http://fgyong.cn,写入文件的 网址是fgyong.cn.`没有http字样的`</div></pre></td></tr></table></figure>\n\n然后\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">编译 hexo g</div><div class=\"line\">上传github hexo d</div></pre></td></tr></table></figure>\n\n大功告成，可以测试查看成果了。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"注册购买域名\"><a href=\"#注册购买域名\" class=\"headerlink\" title=\"注册购买域名\"></a>注册购买域名</h2><p>就像买淘宝的宝贝一样简单，<a href=\"http://wanwang.aliyun.com/domain/?spm=5176.200001.n2.13.iyigkk\" target=\"_blank\" rel=\"external\">阿里云域名购买</a></p>\n<h2 id=\"设置DNS\"><a href=\"#设置DNS\" class=\"headerlink\" title=\"设置DNS\"></a>设置DNS</h2><p> 设置IP地址的时候设置成github的IP具体获取方法是<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nslookup fgyong.github.io//这个地址是你自己的地址下边的是输出来的，其中103.245.222.144便是上边需要的IP。</div><div class=\"line\"> Server:        211.162.96.1</div><div class=\"line\"> Address:    211.162.96.1#53</div><div class=\"line\"></div><div class=\"line\"> Non-authoritative answer: </div><div class=\"line\"> fgyong.github.io    canonical name = github.map.fastly.net.</div><div class=\"line\"> Name:    github.map.fastly.net</div><div class=\"line\"> Address: 103.245.222.133</div></pre></td></tr></table></figure></p>\n<h2 id=\"新建CNAME\"><a href=\"#新建CNAME\" class=\"headerlink\" title=\"新建CNAME\"></a>新建CNAME</h2><pre><code>在hexo文件目录source下边执行\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi CNAME //新建文件并打开</div><div class=\"line\">然后把你买的域名写入文件退出并保存。</div><div class=\"line\">比如我的是 http://fgyong.cn,写入文件的 网址是fgyong.cn.`没有http字样的`</div></pre></td></tr></table></figure>\n\n然后\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">编译 hexo g</div><div class=\"line\">上传github hexo d</div></pre></td></tr></table></figure>\n\n大功告成，可以测试查看成果了。\n</code></pre>"},{"title":"iOS WebView设置cookie","date":"2016-01-28T03:13:58.000Z","_content":"\n## 添加cookie的时候必须先设置可以接受cookie\n```\n[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];\n```\n然后设置cookie内容\n\n\n```\nNSMutableDictionary *cookiePropertiesUser = [NSMutableDictionary dictionary];\nNSString *cook = [[MDUserCache getInstance].user objectForKey:@\"cookie_key\"];\nif ([cook length]) {\n    [cookiePropertiesUser setObject:@\"user_info\" forKey:NSHTTPCookieName];//cookie的名字\n    [cookiePropertiesUser setObject:cook forKey:NSHTTPCookieValue];//cookie的值\n    [cookiePropertiesUser setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires];//过期时间\n    [cookiePropertiesUser setObject:@\"baidu.com\" forKey:NSHTTPCookieDomain];//给那个网址设置\n    [cookiePropertiesUser setObject:@\"/\" forKey:NSHTTPCookiePath];\n    [cookiePropertiesUser setObject:@\"0\" forKey:NSHTTPCookieVersion];\n}\n\nNSHTTPCookie *cookieuser = [NSHTTPCookie cookieWithProperties:cookiePropertiesUser];\n```\n\n\n## 删除cookie\n```\n[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookieuser];\n删除cookie\n\n- (nullable NSArray *)cookiesForURL:(NSURL *)URL;//先获取某个域名下的cookie然后删除\n\n- (void)deleteCookie:(NSHTTPCookie *)cookie; //删除cookie\n```\n","source":"_posts/iOS-WebView设置cookie.md","raw":"title: iOS WebView设置cookie\ndate: 2016-01-28 11:13:58\ntags:\n- iOS\ncategories: iOS\n---\n\n## 添加cookie的时候必须先设置可以接受cookie\n```\n[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];\n```\n然后设置cookie内容\n\n\n```\nNSMutableDictionary *cookiePropertiesUser = [NSMutableDictionary dictionary];\nNSString *cook = [[MDUserCache getInstance].user objectForKey:@\"cookie_key\"];\nif ([cook length]) {\n    [cookiePropertiesUser setObject:@\"user_info\" forKey:NSHTTPCookieName];//cookie的名字\n    [cookiePropertiesUser setObject:cook forKey:NSHTTPCookieValue];//cookie的值\n    [cookiePropertiesUser setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires];//过期时间\n    [cookiePropertiesUser setObject:@\"baidu.com\" forKey:NSHTTPCookieDomain];//给那个网址设置\n    [cookiePropertiesUser setObject:@\"/\" forKey:NSHTTPCookiePath];\n    [cookiePropertiesUser setObject:@\"0\" forKey:NSHTTPCookieVersion];\n}\n\nNSHTTPCookie *cookieuser = [NSHTTPCookie cookieWithProperties:cookiePropertiesUser];\n```\n\n\n## 删除cookie\n```\n[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookieuser];\n删除cookie\n\n- (nullable NSArray *)cookiesForURL:(NSURL *)URL;//先获取某个域名下的cookie然后删除\n\n- (void)deleteCookie:(NSHTTPCookie *)cookie; //删除cookie\n```\n","slug":"iOS-WebView设置cookie","published":1,"updated":"2019-12-03T04:48:00.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2c000a9zsk4t1hzyxn","content":"<h2 id=\"添加cookie的时候必须先设置可以接受cookie\"><a href=\"#添加cookie的时候必须先设置可以接受cookie\" class=\"headerlink\" title=\"添加cookie的时候必须先设置可以接受cookie\"></a>添加cookie的时候必须先设置可以接受cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];</div></pre></td></tr></table></figure>\n<p>然后设置cookie内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableDictionary *cookiePropertiesUser = [NSMutableDictionary dictionary];</div><div class=\"line\">NSString *cook = [[MDUserCache getInstance].user objectForKey:@&quot;cookie_key&quot;];</div><div class=\"line\">if ([cook length]) &#123;</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;user_info&quot; forKey:NSHTTPCookieName];//cookie的名字</div><div class=\"line\">    [cookiePropertiesUser setObject:cook forKey:NSHTTPCookieValue];//cookie的值</div><div class=\"line\">    [cookiePropertiesUser setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires];//过期时间</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;baidu.com&quot; forKey:NSHTTPCookieDomain];//给那个网址设置</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">NSHTTPCookie *cookieuser = [NSHTTPCookie cookieWithProperties:cookiePropertiesUser];</div></pre></td></tr></table></figure>\n<h2 id=\"删除cookie\"><a href=\"#删除cookie\" class=\"headerlink\" title=\"删除cookie\"></a>删除cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookieuser];</div><div class=\"line\">删除cookie</div><div class=\"line\"></div><div class=\"line\">- (nullable NSArray *)cookiesForURL:(NSURL *)URL;//先获取某个域名下的cookie然后删除</div><div class=\"line\"></div><div class=\"line\">- (void)deleteCookie:(NSHTTPCookie *)cookie; //删除cookie</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"添加cookie的时候必须先设置可以接受cookie\"><a href=\"#添加cookie的时候必须先设置可以接受cookie\" class=\"headerlink\" title=\"添加cookie的时候必须先设置可以接受cookie\"></a>添加cookie的时候必须先设置可以接受cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];</div></pre></td></tr></table></figure>\n<p>然后设置cookie内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableDictionary *cookiePropertiesUser = [NSMutableDictionary dictionary];</div><div class=\"line\">NSString *cook = [[MDUserCache getInstance].user objectForKey:@&quot;cookie_key&quot;];</div><div class=\"line\">if ([cook length]) &#123;</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;user_info&quot; forKey:NSHTTPCookieName];//cookie的名字</div><div class=\"line\">    [cookiePropertiesUser setObject:cook forKey:NSHTTPCookieValue];//cookie的值</div><div class=\"line\">    [cookiePropertiesUser setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires];//过期时间</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;baidu.com&quot; forKey:NSHTTPCookieDomain];//给那个网址设置</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];</div><div class=\"line\">    [cookiePropertiesUser setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">NSHTTPCookie *cookieuser = [NSHTTPCookie cookieWithProperties:cookiePropertiesUser];</div></pre></td></tr></table></figure>\n<h2 id=\"删除cookie\"><a href=\"#删除cookie\" class=\"headerlink\" title=\"删除cookie\"></a>删除cookie</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookieuser];</div><div class=\"line\">删除cookie</div><div class=\"line\"></div><div class=\"line\">- (nullable NSArray *)cookiesForURL:(NSURL *)URL;//先获取某个域名下的cookie然后删除</div><div class=\"line\"></div><div class=\"line\">- (void)deleteCookie:(NSHTTPCookie *)cookie; //删除cookie</div></pre></td></tr></table></figure>\n"},{"title":"iOS 手动做一个自动打包部署神器","date":"2019-06-25T08:39:24.000Z","_content":"之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。\n- 打包\n- 导出ipa\n- 上传pgyer\n\n#### 打包自动上传pgyer\n```\n#!/bin/bash\n\n#xcodebuild archive -project 'test.xcodeproj' -configuration 'Debug' -scheme 'BLTSZY' -archivePath './app.xcarchive' LIBRARY_SEARCH_PATHS=\"./Pods/../build/**  ./BLTSZY/**\"\nproName='your project name'\nproURL=\"your project path\"#like /Users/Jerry/Desktop/ios_afu\napi_key=''#pgyer api_key\nconfiguration='Debug' #Release \nautoPlus(){\npath=${proURL}/${proName}/${proName}/Info.plist\nnumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"${path}\")\nBundleVersion=$(( $number + 1 ))\n/usr/libexec/PlistBuddy -c \"Set CFBundleVersion $BundleVersion\" \"${path}\"\n}\n#打包\narch(){\n    echo '开始编译Pods'\n    xcodebuild -project Pods/Pods.xcodeproj build\n    echo '开始编译project'\n\nxcodebuild -archivePath \"./build/${proName}.xcarchive\" -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive\nautoPlus\n}\n#导出ipa\nexportIPA(){\n    echo '开始导出ipa'\n    xcodebuild -exportArchive -archivePath \"./build/${proName}.xcarchive\" -exportPath './app' -exportOptionsPlist './ExportOptions.plist'\n}\n#上传ipa到蒲公英\nupload(){\nif [ -e \"${proURL}/app/${proName}.ipa\" ]\nthen\n    echo '开始上传ipa/apk到蒲公英'\n    curl -F \"file=@${proURL}/app/${proName}.ipa\" -F \"_api_key=${api_key}\" 'http://www.pgyer.com/apiv2/app/upload'\nelse\n    echo \"在目录：${proURL}/app/${proName}.ipa 不存在\"\nfi\n}\nstartarch(){\n    arch\n    if (($? == 0))\n    then\n        echo 'archive success🍺'\n        startExportIPA\n    else\n        echo 'archive faild❌'\n    fi\n}\nstartExportIPA(){\n    exportIPA\n    if(($? == 0))\n    then\n        echo 'exportIPA success🍺🍺'\n        startUPLoadIPA\n    else\n        echo 'exportIPA faild ❌'\n    fi\n}\nstartUPLoadIPA(){\n    upload\n    if(($? == 0))\n    then\n        echo 'uploadIPA success'\n    else\n        echo 'uploadIPA faild ❌'\n    fi\n}\n\n\nif (($# == 0))\n#then\n#    startarch\n#elif (($# == 1))\nthen\n        while :\n        do\n        echo '🍺🍺🍺***********************🍺🍺🍺'\n        echo  \"输入 1 到 4 之间的数字:\"\n        echo  \"输入 1:从编译打包开始至结束\"\n        echo  \"输入 2:从导出IPA开始至结束\"\n        echo  \"输入 3:从上传ipa开始至结束\"\n        echo  \"输入 4:退出\"\n        read a\n        case $a in\n            1)startarch\n            break;;\n            2)startExportIPA\n            break;;\n            3)startUPLoadIPA\n            break;;\n            4) break;;\n        esac\n        done\nfi\n\n```\n将该文件和plis拖到project目录下，然后配置\nplis文件：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>compileBitcode</key>\n\t<false/>\n\t<key>method</key>\n\t<string>ad-hoc</string>\n\t<key>provisioningProfiles</key>\n\t<dict>\n\t\t<key>your bundle id</key>\n\t\t<string>your .mobileprovsion</string>\n\t</dict>\n\t<key>signingCertificate</key>\n\t<string>iPhone Distribution</string>\n\t<key>signingStyle</key>\n\t<string>manual</string>\n\t<key>stripSwiftSymbols</key>\n\t<true/>\n\t<key>teamID</key>\n\t<string>your_team_id</string>\n\t<key>thinning</key>\n\t<string>&lt;none&gt;</string>\n</dict>\n</plist>\n```\n下载`setup.sh`拖到项目文件夹内，然后\n运行`./setup.sh`，即可完成上传到pgyer网站。\n具体的配置属性见源码下载页面。\n[查看源码](https://github.com/ifgyong/autoAEU)\n\n```\n","source":"_posts/iOS 手动做一个自动打包部署神器.md","raw":"title: iOS 手动做一个自动打包部署神器\ndate: 2019-6-25 16:39:24\ntags: \n- iOS \n- 自动打包\ncategories: iOS\n---\n之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。\n- 打包\n- 导出ipa\n- 上传pgyer\n\n#### 打包自动上传pgyer\n```\n#!/bin/bash\n\n#xcodebuild archive -project 'test.xcodeproj' -configuration 'Debug' -scheme 'BLTSZY' -archivePath './app.xcarchive' LIBRARY_SEARCH_PATHS=\"./Pods/../build/**  ./BLTSZY/**\"\nproName='your project name'\nproURL=\"your project path\"#like /Users/Jerry/Desktop/ios_afu\napi_key=''#pgyer api_key\nconfiguration='Debug' #Release \nautoPlus(){\npath=${proURL}/${proName}/${proName}/Info.plist\nnumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"${path}\")\nBundleVersion=$(( $number + 1 ))\n/usr/libexec/PlistBuddy -c \"Set CFBundleVersion $BundleVersion\" \"${path}\"\n}\n#打包\narch(){\n    echo '开始编译Pods'\n    xcodebuild -project Pods/Pods.xcodeproj build\n    echo '开始编译project'\n\nxcodebuild -archivePath \"./build/${proName}.xcarchive\" -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive\nautoPlus\n}\n#导出ipa\nexportIPA(){\n    echo '开始导出ipa'\n    xcodebuild -exportArchive -archivePath \"./build/${proName}.xcarchive\" -exportPath './app' -exportOptionsPlist './ExportOptions.plist'\n}\n#上传ipa到蒲公英\nupload(){\nif [ -e \"${proURL}/app/${proName}.ipa\" ]\nthen\n    echo '开始上传ipa/apk到蒲公英'\n    curl -F \"file=@${proURL}/app/${proName}.ipa\" -F \"_api_key=${api_key}\" 'http://www.pgyer.com/apiv2/app/upload'\nelse\n    echo \"在目录：${proURL}/app/${proName}.ipa 不存在\"\nfi\n}\nstartarch(){\n    arch\n    if (($? == 0))\n    then\n        echo 'archive success🍺'\n        startExportIPA\n    else\n        echo 'archive faild❌'\n    fi\n}\nstartExportIPA(){\n    exportIPA\n    if(($? == 0))\n    then\n        echo 'exportIPA success🍺🍺'\n        startUPLoadIPA\n    else\n        echo 'exportIPA faild ❌'\n    fi\n}\nstartUPLoadIPA(){\n    upload\n    if(($? == 0))\n    then\n        echo 'uploadIPA success'\n    else\n        echo 'uploadIPA faild ❌'\n    fi\n}\n\n\nif (($# == 0))\n#then\n#    startarch\n#elif (($# == 1))\nthen\n        while :\n        do\n        echo '🍺🍺🍺***********************🍺🍺🍺'\n        echo  \"输入 1 到 4 之间的数字:\"\n        echo  \"输入 1:从编译打包开始至结束\"\n        echo  \"输入 2:从导出IPA开始至结束\"\n        echo  \"输入 3:从上传ipa开始至结束\"\n        echo  \"输入 4:退出\"\n        read a\n        case $a in\n            1)startarch\n            break;;\n            2)startExportIPA\n            break;;\n            3)startUPLoadIPA\n            break;;\n            4) break;;\n        esac\n        done\nfi\n\n```\n将该文件和plis拖到project目录下，然后配置\nplis文件：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>compileBitcode</key>\n\t<false/>\n\t<key>method</key>\n\t<string>ad-hoc</string>\n\t<key>provisioningProfiles</key>\n\t<dict>\n\t\t<key>your bundle id</key>\n\t\t<string>your .mobileprovsion</string>\n\t</dict>\n\t<key>signingCertificate</key>\n\t<string>iPhone Distribution</string>\n\t<key>signingStyle</key>\n\t<string>manual</string>\n\t<key>stripSwiftSymbols</key>\n\t<true/>\n\t<key>teamID</key>\n\t<string>your_team_id</string>\n\t<key>thinning</key>\n\t<string>&lt;none&gt;</string>\n</dict>\n</plist>\n```\n下载`setup.sh`拖到项目文件夹内，然后\n运行`./setup.sh`，即可完成上传到pgyer网站。\n具体的配置属性见源码下载页面。\n[查看源码](https://github.com/ifgyong/autoAEU)\n\n```\n","slug":"iOS 手动做一个自动打包部署神器","published":1,"updated":"2019-12-03T04:48:00.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2d000b9zsko2w5ftgw","content":"<p>之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。</p>\n<ul>\n<li>打包</li>\n<li>导出ipa</li>\n<li>上传pgyer</li>\n</ul>\n<h4 id=\"打包自动上传pgyer\"><a href=\"#打包自动上传pgyer\" class=\"headerlink\" title=\"打包自动上传pgyer\"></a>打包自动上传pgyer</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">#xcodebuild archive -project &apos;test.xcodeproj&apos; -configuration &apos;Debug&apos; -scheme &apos;BLTSZY&apos; -archivePath &apos;./app.xcarchive&apos; LIBRARY_SEARCH_PATHS=&quot;./Pods/../build/**  ./BLTSZY/**&quot;</div><div class=\"line\">proName=&apos;your project name&apos;</div><div class=\"line\">proURL=&quot;your project path&quot;#like /Users/Jerry/Desktop/ios_afu</div><div class=\"line\">api_key=&apos;&apos;#pgyer api_key</div><div class=\"line\">configuration=&apos;Debug&apos; #Release </div><div class=\"line\">autoPlus()&#123;</div><div class=\"line\">path=$&#123;proURL&#125;/$&#123;proName&#125;/$&#123;proName&#125;/Info.plist</div><div class=\"line\">number=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;path&#125;&quot;)</div><div class=\"line\">BundleVersion=$(( $number + 1 ))</div><div class=\"line\">/usr/libexec/PlistBuddy -c &quot;Set CFBundleVersion $BundleVersion&quot; &quot;$&#123;path&#125;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">#打包</div><div class=\"line\">arch()&#123;</div><div class=\"line\">    echo &apos;开始编译Pods&apos;</div><div class=\"line\">    xcodebuild -project Pods/Pods.xcodeproj build</div><div class=\"line\">    echo &apos;开始编译project&apos;</div><div class=\"line\"></div><div class=\"line\">xcodebuild -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive</div><div class=\"line\">autoPlus</div><div class=\"line\">&#125;</div><div class=\"line\">#导出ipa</div><div class=\"line\">exportIPA()&#123;</div><div class=\"line\">    echo &apos;开始导出ipa&apos;</div><div class=\"line\">    xcodebuild -exportArchive -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -exportPath &apos;./app&apos; -exportOptionsPlist &apos;./ExportOptions.plist&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">#上传ipa到蒲公英</div><div class=\"line\">upload()&#123;</div><div class=\"line\">if [ -e &quot;$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; ]</div><div class=\"line\">then</div><div class=\"line\">    echo &apos;开始上传ipa/apk到蒲公英&apos;</div><div class=\"line\">    curl -F &quot;file=@$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; -F &quot;_api_key=$&#123;api_key&#125;&quot; &apos;http://www.pgyer.com/apiv2/app/upload&apos;</div><div class=\"line\">else</div><div class=\"line\">    echo &quot;在目录：$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa 不存在&quot;</div><div class=\"line\">fi</div><div class=\"line\">&#125;</div><div class=\"line\">startarch()&#123;</div><div class=\"line\">    arch</div><div class=\"line\">    if (($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;archive success🍺&apos;</div><div class=\"line\">        startExportIPA</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;archive faild❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\">startExportIPA()&#123;</div><div class=\"line\">    exportIPA</div><div class=\"line\">    if(($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;exportIPA success🍺🍺&apos;</div><div class=\"line\">        startUPLoadIPA</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;exportIPA faild ❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\">startUPLoadIPA()&#123;</div><div class=\"line\">    upload</div><div class=\"line\">    if(($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;uploadIPA success&apos;</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;uploadIPA faild ❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if (($# == 0))</div><div class=\"line\">#then</div><div class=\"line\">#    startarch</div><div class=\"line\">#elif (($# == 1))</div><div class=\"line\">then</div><div class=\"line\">        while :</div><div class=\"line\">        do</div><div class=\"line\">        echo &apos;🍺🍺🍺***********************🍺🍺🍺&apos;</div><div class=\"line\">        echo  &quot;输入 1 到 4 之间的数字:&quot;</div><div class=\"line\">        echo  &quot;输入 1:从编译打包开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 2:从导出IPA开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 3:从上传ipa开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 4:退出&quot;</div><div class=\"line\">        read a</div><div class=\"line\">        case $a in</div><div class=\"line\">            1)startarch</div><div class=\"line\">            break;;</div><div class=\"line\">            2)startExportIPA</div><div class=\"line\">            break;;</div><div class=\"line\">            3)startUPLoadIPA</div><div class=\"line\">            break;;</div><div class=\"line\">            4) break;;</div><div class=\"line\">        esac</div><div class=\"line\">        done</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>将该文件和plis拖到project目录下，然后配置<br>plis文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</div><div class=\"line\">&lt;dict&gt;</div><div class=\"line\">\t&lt;key&gt;compileBitcode&lt;/key&gt;</div><div class=\"line\">\t&lt;false/&gt;</div><div class=\"line\">\t&lt;key&gt;method&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;ad-hoc&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;provisioningProfiles&lt;/key&gt;</div><div class=\"line\">\t&lt;dict&gt;</div><div class=\"line\">\t\t&lt;key&gt;your bundle id&lt;/key&gt;</div><div class=\"line\">\t\t&lt;string&gt;your .mobileprovsion&lt;/string&gt;</div><div class=\"line\">\t&lt;/dict&gt;</div><div class=\"line\">\t&lt;key&gt;signingCertificate&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;iPhone Distribution&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;signingStyle&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;manual&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</div><div class=\"line\">\t&lt;true/&gt;</div><div class=\"line\">\t&lt;key&gt;teamID&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;your_team_id&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;thinning&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;</div><div class=\"line\">&lt;/dict&gt;</div><div class=\"line\">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>\n<p>下载<code>setup.sh</code>拖到项目文件夹内，然后<br>运行<code>./setup.sh</code>，即可完成上传到pgyer网站。<br>具体的配置属性见源码下载页面。<br><a href=\"https://github.com/ifgyong/autoAEU\" target=\"_blank\" rel=\"external\">查看源码</a></p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前使用的fastlane添加pgyer自动打包的，最近发现更新总是有问题，所以产生了自己shell做一个的想法。虽然代码比较少，但是很实用。</p>\n<ul>\n<li>打包</li>\n<li>导出ipa</li>\n<li>上传pgyer</li>\n</ul>\n<h4 id=\"打包自动上传pgyer\"><a href=\"#打包自动上传pgyer\" class=\"headerlink\" title=\"打包自动上传pgyer\"></a>打包自动上传pgyer</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\"></div><div class=\"line\">#xcodebuild archive -project &apos;test.xcodeproj&apos; -configuration &apos;Debug&apos; -scheme &apos;BLTSZY&apos; -archivePath &apos;./app.xcarchive&apos; LIBRARY_SEARCH_PATHS=&quot;./Pods/../build/**  ./BLTSZY/**&quot;</div><div class=\"line\">proName=&apos;your project name&apos;</div><div class=\"line\">proURL=&quot;your project path&quot;#like /Users/Jerry/Desktop/ios_afu</div><div class=\"line\">api_key=&apos;&apos;#pgyer api_key</div><div class=\"line\">configuration=&apos;Debug&apos; #Release </div><div class=\"line\">autoPlus()&#123;</div><div class=\"line\">path=$&#123;proURL&#125;/$&#123;proName&#125;/$&#123;proName&#125;/Info.plist</div><div class=\"line\">number=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;path&#125;&quot;)</div><div class=\"line\">BundleVersion=$(( $number + 1 ))</div><div class=\"line\">/usr/libexec/PlistBuddy -c &quot;Set CFBundleVersion $BundleVersion&quot; &quot;$&#123;path&#125;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">#打包</div><div class=\"line\">arch()&#123;</div><div class=\"line\">    echo &apos;开始编译Pods&apos;</div><div class=\"line\">    xcodebuild -project Pods/Pods.xcodeproj build</div><div class=\"line\">    echo &apos;开始编译project&apos;</div><div class=\"line\"></div><div class=\"line\">xcodebuild -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -workspace $proName.xcworkspace -sdk iphoneos -scheme $proName -configuration $configuration archive</div><div class=\"line\">autoPlus</div><div class=\"line\">&#125;</div><div class=\"line\">#导出ipa</div><div class=\"line\">exportIPA()&#123;</div><div class=\"line\">    echo &apos;开始导出ipa&apos;</div><div class=\"line\">    xcodebuild -exportArchive -archivePath &quot;./build/$&#123;proName&#125;.xcarchive&quot; -exportPath &apos;./app&apos; -exportOptionsPlist &apos;./ExportOptions.plist&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">#上传ipa到蒲公英</div><div class=\"line\">upload()&#123;</div><div class=\"line\">if [ -e &quot;$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; ]</div><div class=\"line\">then</div><div class=\"line\">    echo &apos;开始上传ipa/apk到蒲公英&apos;</div><div class=\"line\">    curl -F &quot;file=@$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa&quot; -F &quot;_api_key=$&#123;api_key&#125;&quot; &apos;http://www.pgyer.com/apiv2/app/upload&apos;</div><div class=\"line\">else</div><div class=\"line\">    echo &quot;在目录：$&#123;proURL&#125;/app/$&#123;proName&#125;.ipa 不存在&quot;</div><div class=\"line\">fi</div><div class=\"line\">&#125;</div><div class=\"line\">startarch()&#123;</div><div class=\"line\">    arch</div><div class=\"line\">    if (($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;archive success🍺&apos;</div><div class=\"line\">        startExportIPA</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;archive faild❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\">startExportIPA()&#123;</div><div class=\"line\">    exportIPA</div><div class=\"line\">    if(($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;exportIPA success🍺🍺&apos;</div><div class=\"line\">        startUPLoadIPA</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;exportIPA faild ❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\">startUPLoadIPA()&#123;</div><div class=\"line\">    upload</div><div class=\"line\">    if(($? == 0))</div><div class=\"line\">    then</div><div class=\"line\">        echo &apos;uploadIPA success&apos;</div><div class=\"line\">    else</div><div class=\"line\">        echo &apos;uploadIPA faild ❌&apos;</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if (($# == 0))</div><div class=\"line\">#then</div><div class=\"line\">#    startarch</div><div class=\"line\">#elif (($# == 1))</div><div class=\"line\">then</div><div class=\"line\">        while :</div><div class=\"line\">        do</div><div class=\"line\">        echo &apos;🍺🍺🍺***********************🍺🍺🍺&apos;</div><div class=\"line\">        echo  &quot;输入 1 到 4 之间的数字:&quot;</div><div class=\"line\">        echo  &quot;输入 1:从编译打包开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 2:从导出IPA开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 3:从上传ipa开始至结束&quot;</div><div class=\"line\">        echo  &quot;输入 4:退出&quot;</div><div class=\"line\">        read a</div><div class=\"line\">        case $a in</div><div class=\"line\">            1)startarch</div><div class=\"line\">            break;;</div><div class=\"line\">            2)startExportIPA</div><div class=\"line\">            break;;</div><div class=\"line\">            3)startUPLoadIPA</div><div class=\"line\">            break;;</div><div class=\"line\">            4) break;;</div><div class=\"line\">        esac</div><div class=\"line\">        done</div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>将该文件和plis拖到project目录下，然后配置<br>plis文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</div><div class=\"line\">&lt;dict&gt;</div><div class=\"line\">\t&lt;key&gt;compileBitcode&lt;/key&gt;</div><div class=\"line\">\t&lt;false/&gt;</div><div class=\"line\">\t&lt;key&gt;method&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;ad-hoc&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;provisioningProfiles&lt;/key&gt;</div><div class=\"line\">\t&lt;dict&gt;</div><div class=\"line\">\t\t&lt;key&gt;your bundle id&lt;/key&gt;</div><div class=\"line\">\t\t&lt;string&gt;your .mobileprovsion&lt;/string&gt;</div><div class=\"line\">\t&lt;/dict&gt;</div><div class=\"line\">\t&lt;key&gt;signingCertificate&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;iPhone Distribution&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;signingStyle&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;manual&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</div><div class=\"line\">\t&lt;true/&gt;</div><div class=\"line\">\t&lt;key&gt;teamID&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;your_team_id&lt;/string&gt;</div><div class=\"line\">\t&lt;key&gt;thinning&lt;/key&gt;</div><div class=\"line\">\t&lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;</div><div class=\"line\">&lt;/dict&gt;</div><div class=\"line\">&lt;/plist&gt;</div></pre></td></tr></table></figure></p>\n<p>下载<code>setup.sh</code>拖到项目文件夹内，然后<br>运行<code>./setup.sh</code>，即可完成上传到pgyer网站。<br>具体的配置属性见源码下载页面。<br><a href=\"https://github.com/ifgyong/autoAEU\" target=\"_blank\" rel=\"external\">查看源码</a></p>\n<p>```</p>\n"},{"title":"iOS static const extern 用法技巧","date":"2016-01-28T03:07:58.000Z","_content":"## 通俗的讲：\n\nextern字段使用的时候，声明的变量为全局变量，都可以调用，也有这样一种比较狭义的说法：extern可以扩展一个类中的变量到另一个类中；\n\nstatic声明的变量是静态变量，变量值改变过之后，保存这次改变，每次使用的时候都要读取一遍值；\n\nconst声明过得变量值是不可改变的，是readonly的属性，不可以改变变量的值。<!--more-->\n\n## 具体用法：\n\n1.static的用法：static NSString *str = @\"哈哈\";\n\n2.const的用法：NSString *const str = @\"哈哈\";\n\n3.extern的用法：在A.h里边声明一个变量extern NSString *str = @\"123\";\n\n 这样就声明了一个全局变量，在B.h里边同样写入代码extern NSString *str；然后再B.m里边直接打印str就可以打印出123来，使用的时候不需要导入A.h文件头，也不区分类是否已经创建等等因素。\n\n 希望对大家有所帮助，以后写代码的时候可以更加高大上一些，也是一种技巧。\n","source":"_posts/iOS-static-const-extern-用法技巧.md","raw":"title: iOS static const extern 用法技巧\ndate: 2016-01-28 11:07:58\ntags:\n- iOS\n---\n## 通俗的讲：\n\nextern字段使用的时候，声明的变量为全局变量，都可以调用，也有这样一种比较狭义的说法：extern可以扩展一个类中的变量到另一个类中；\n\nstatic声明的变量是静态变量，变量值改变过之后，保存这次改变，每次使用的时候都要读取一遍值；\n\nconst声明过得变量值是不可改变的，是readonly的属性，不可以改变变量的值。<!--more-->\n\n## 具体用法：\n\n1.static的用法：static NSString *str = @\"哈哈\";\n\n2.const的用法：NSString *const str = @\"哈哈\";\n\n3.extern的用法：在A.h里边声明一个变量extern NSString *str = @\"123\";\n\n 这样就声明了一个全局变量，在B.h里边同样写入代码extern NSString *str；然后再B.m里边直接打印str就可以打印出123来，使用的时候不需要导入A.h文件头，也不区分类是否已经创建等等因素。\n\n 希望对大家有所帮助，以后写代码的时候可以更加高大上一些，也是一种技巧。\n","slug":"iOS-static-const-extern-用法技巧","published":1,"updated":"2019-12-03T04:48:00.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2d000c9zskjllvdgx8","content":"<h2 id=\"通俗的讲：\"><a href=\"#通俗的讲：\" class=\"headerlink\" title=\"通俗的讲：\"></a>通俗的讲：</h2><p>extern字段使用的时候，声明的变量为全局变量，都可以调用，也有这样一种比较狭义的说法：extern可以扩展一个类中的变量到另一个类中；</p>\n<p>static声明的变量是静态变量，变量值改变过之后，保存这次改变，每次使用的时候都要读取一遍值；</p>\n<p>const声明过得变量值是不可改变的，是readonly的属性，不可以改变变量的值。<a id=\"more\"></a></p>\n<h2 id=\"具体用法：\"><a href=\"#具体用法：\" class=\"headerlink\" title=\"具体用法：\"></a>具体用法：</h2><p>1.static的用法：static NSString *str = @”哈哈”;</p>\n<p>2.const的用法：NSString *const str = @”哈哈”;</p>\n<p>3.extern的用法：在A.h里边声明一个变量extern NSString *str = @”123”;</p>\n<p> 这样就声明了一个全局变量，在B.h里边同样写入代码extern NSString *str；然后再B.m里边直接打印str就可以打印出123来，使用的时候不需要导入A.h文件头，也不区分类是否已经创建等等因素。</p>\n<p> 希望对大家有所帮助，以后写代码的时候可以更加高大上一些，也是一种技巧。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"通俗的讲：\"><a href=\"#通俗的讲：\" class=\"headerlink\" title=\"通俗的讲：\"></a>通俗的讲：</h2><p>extern字段使用的时候，声明的变量为全局变量，都可以调用，也有这样一种比较狭义的说法：extern可以扩展一个类中的变量到另一个类中；</p>\n<p>static声明的变量是静态变量，变量值改变过之后，保存这次改变，每次使用的时候都要读取一遍值；</p>\n<p>const声明过得变量值是不可改变的，是readonly的属性，不可以改变变量的值。","more":"</p>\n<h2 id=\"具体用法：\"><a href=\"#具体用法：\" class=\"headerlink\" title=\"具体用法：\"></a>具体用法：</h2><p>1.static的用法：static NSString *str = @”哈哈”;</p>\n<p>2.const的用法：NSString *const str = @”哈哈”;</p>\n<p>3.extern的用法：在A.h里边声明一个变量extern NSString *str = @”123”;</p>\n<p> 这样就声明了一个全局变量，在B.h里边同样写入代码extern NSString *str；然后再B.m里边直接打印str就可以打印出123来，使用的时候不需要导入A.h文件头，也不区分类是否已经创建等等因素。</p>\n<p> 希望对大家有所帮助，以后写代码的时候可以更加高大上一些，也是一种技巧。</p>"},{"title":"iOS之Safari之添加到主屏幕应用","date":"2016-11-21T08:39:24.000Z","_content":"\n先写好的DemoHtml先需要在手机上试验一下，结果mac上面的文件不能用手机打开，我就想了个办法，直接开一个服务，把mac当成服务器访问服务器上面的文件，这个问题就解决了。\n\n### 1.启动mac py 服务\n首先进入到你要共享的文件夹，直接运行下边的命令，然后就可以再手机浏览器中查看mac上面的电脑了。\n```\npython -m SimpleHTTPServer 8000  启动本地端口8000\n```\n\n### 2.查看电脑IP[局域网的ip]\n```\n我的是：192.168.99.1\n```\n### 3.手机Safari打开\n```\n192.168.99.1:8000\n```\n\n![IMG_0853.PNG](http://upload-images.jianshu.io/upload_images/783986-f559dd371ab3227d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4.js代码\nhtml代码和正常的布局一样，想要什么样子自己可以随意写，这里只是提供了比较特殊的 js代码。\n```\n<script>\n    var alone = window.navigator.standalone;//是否是从桌面启动\n   var url = \"taobao\"; //url可以换成自己的\n        if(alone){\n        window.open(url+\":\",'_self');//打开淘宝app url可以换成自己的app scheme\n    }     else {  \n      window.open(url+\":\",'_self');  \n  }</script>\n```\n打开这个html文件点击Safari保存到主屏幕。\n在此打开之后的效果：\n\n![IMG_0854.PNG](http://upload-images.jianshu.io/upload_images/783986-bb3c3fadbd9cf618.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其实做这个功能就是方面用户直接点击icon启动app并且调用某个功能，省了不少时间。\n","source":"_posts/iOS之Safari之添加到主屏幕应用.md","raw":"title: iOS之Safari之添加到主屏幕应用\ndate: 2016-11-21 16:39:24\ntags: iOS高级开发\ncategories: iOS\n---\n\n先写好的DemoHtml先需要在手机上试验一下，结果mac上面的文件不能用手机打开，我就想了个办法，直接开一个服务，把mac当成服务器访问服务器上面的文件，这个问题就解决了。\n\n### 1.启动mac py 服务\n首先进入到你要共享的文件夹，直接运行下边的命令，然后就可以再手机浏览器中查看mac上面的电脑了。\n```\npython -m SimpleHTTPServer 8000  启动本地端口8000\n```\n\n### 2.查看电脑IP[局域网的ip]\n```\n我的是：192.168.99.1\n```\n### 3.手机Safari打开\n```\n192.168.99.1:8000\n```\n\n![IMG_0853.PNG](http://upload-images.jianshu.io/upload_images/783986-f559dd371ab3227d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4.js代码\nhtml代码和正常的布局一样，想要什么样子自己可以随意写，这里只是提供了比较特殊的 js代码。\n```\n<script>\n    var alone = window.navigator.standalone;//是否是从桌面启动\n   var url = \"taobao\"; //url可以换成自己的\n        if(alone){\n        window.open(url+\":\",'_self');//打开淘宝app url可以换成自己的app scheme\n    }     else {  \n      window.open(url+\":\",'_self');  \n  }</script>\n```\n打开这个html文件点击Safari保存到主屏幕。\n在此打开之后的效果：\n\n![IMG_0854.PNG](http://upload-images.jianshu.io/upload_images/783986-bb3c3fadbd9cf618.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其实做这个功能就是方面用户直接点击icon启动app并且调用某个功能，省了不少时间。\n","slug":"iOS之Safari之添加到主屏幕应用","published":1,"updated":"2019-12-03T04:48:00.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2e000d9zsk0h0yo8q3","content":"<p>先写好的DemoHtml先需要在手机上试验一下，结果mac上面的文件不能用手机打开，我就想了个办法，直接开一个服务，把mac当成服务器访问服务器上面的文件，这个问题就解决了。</p>\n<h3 id=\"1-启动mac-py-服务\"><a href=\"#1-启动mac-py-服务\" class=\"headerlink\" title=\"1.启动mac py 服务\"></a>1.启动mac py 服务</h3><p>首先进入到你要共享的文件夹，直接运行下边的命令，然后就可以再手机浏览器中查看mac上面的电脑了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python -m SimpleHTTPServer 8000  启动本地端口8000</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-查看电脑IP-局域网的ip\"><a href=\"#2-查看电脑IP-局域网的ip\" class=\"headerlink\" title=\"2.查看电脑IP[局域网的ip]\"></a>2.查看电脑IP[局域网的ip]</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我的是：192.168.99.1</div></pre></td></tr></table></figure>\n<h3 id=\"3-手机Safari打开\"><a href=\"#3-手机Safari打开\" class=\"headerlink\" title=\"3.手机Safari打开\"></a>3.手机Safari打开</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.99.1:8000</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-f559dd371ab3227d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IMG_0853.PNG\"></p>\n<h3 id=\"4-js代码\"><a href=\"#4-js代码\" class=\"headerlink\" title=\"4.js代码\"></a>4.js代码</h3><p>html代码和正常的布局一样，想要什么样子自己可以随意写，这里只是提供了比较特殊的 js代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var alone = window.navigator.standalone;//是否是从桌面启动</div><div class=\"line\">   var url = &quot;taobao&quot;; //url可以换成自己的</div><div class=\"line\">        if(alone)&#123;</div><div class=\"line\">        window.open(url+&quot;:&quot;,&apos;_self&apos;);//打开淘宝app url可以换成自己的app scheme</div><div class=\"line\">    &#125;     else &#123;  </div><div class=\"line\">      window.open(url+&quot;:&quot;,&apos;_self&apos;);  </div><div class=\"line\">  &#125;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>打开这个html文件点击Safari保存到主屏幕。<br>在此打开之后的效果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-bb3c3fadbd9cf618.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IMG_0854.PNG\"></p>\n<p>其实做这个功能就是方面用户直接点击icon启动app并且调用某个功能，省了不少时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>先写好的DemoHtml先需要在手机上试验一下，结果mac上面的文件不能用手机打开，我就想了个办法，直接开一个服务，把mac当成服务器访问服务器上面的文件，这个问题就解决了。</p>\n<h3 id=\"1-启动mac-py-服务\"><a href=\"#1-启动mac-py-服务\" class=\"headerlink\" title=\"1.启动mac py 服务\"></a>1.启动mac py 服务</h3><p>首先进入到你要共享的文件夹，直接运行下边的命令，然后就可以再手机浏览器中查看mac上面的电脑了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python -m SimpleHTTPServer 8000  启动本地端口8000</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-查看电脑IP-局域网的ip\"><a href=\"#2-查看电脑IP-局域网的ip\" class=\"headerlink\" title=\"2.查看电脑IP[局域网的ip]\"></a>2.查看电脑IP[局域网的ip]</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我的是：192.168.99.1</div></pre></td></tr></table></figure>\n<h3 id=\"3-手机Safari打开\"><a href=\"#3-手机Safari打开\" class=\"headerlink\" title=\"3.手机Safari打开\"></a>3.手机Safari打开</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.99.1:8000</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-f559dd371ab3227d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IMG_0853.PNG\"></p>\n<h3 id=\"4-js代码\"><a href=\"#4-js代码\" class=\"headerlink\" title=\"4.js代码\"></a>4.js代码</h3><p>html代码和正常的布局一样，想要什么样子自己可以随意写，这里只是提供了比较特殊的 js代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    var alone = window.navigator.standalone;//是否是从桌面启动</div><div class=\"line\">   var url = &quot;taobao&quot;; //url可以换成自己的</div><div class=\"line\">        if(alone)&#123;</div><div class=\"line\">        window.open(url+&quot;:&quot;,&apos;_self&apos;);//打开淘宝app url可以换成自己的app scheme</div><div class=\"line\">    &#125;     else &#123;  </div><div class=\"line\">      window.open(url+&quot;:&quot;,&apos;_self&apos;);  </div><div class=\"line\">  &#125;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>打开这个html文件点击Safari保存到主屏幕。<br>在此打开之后的效果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-bb3c3fadbd9cf618.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IMG_0854.PNG\"></p>\n<p>其实做这个功能就是方面用户直接点击icon启动app并且调用某个功能，省了不少时间。</p>\n"},{"title":"iOS 浅析指针、函数、typedef","date":"2019-06-24T08:39:24.000Z","_content":"#### 指针函数和函数指针\n\n顾名思义，指针函数即返回指针的函数。其一般定义形式如下：\n\n```\n类型名 *函数名(函数参数表列);  \n```\n其中，后缀运算符括号`“()”`表示这是一个函数，其前缀运算符星号`“*”`表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。\n\n`“(函数参数表列)”`中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：\n\n```\nint *pfun(int, int);\n```\n由于`“*”`的优先级低于`“()”`的优先级，因而pfun首先和后面的`“()”`结合，也就意味着，pfun是一个函数。即：\n\n```\nint *(pfun(int, int));\n```\n接着再和前面的`“*”`结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。\n我们不妨来再看一看，指针函数与函数指针有什么区别？\n\n```\nint (*pfun)(int, int);\n```\n通过括号强行将pfun首先与`“*”`结合，也就意味着，pfun是一个指针，接着与后面的`“()”`结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。\n\n虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。\n\n用函数指针作为指针函数的返回值\n在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：\n\n```\nint (*ff(int))(int *, int);\n```\n我们用上面介绍的方法分析一下，ff首先与后面的`“()”`结合，即：\n\n```\nint (*(ff(int)))(int *, int);\n```\n用括号将`ff(int)`再括起来也就意味着，`ff`是一个函数。\n接着与前面的`“*”`结合，说明`ff`函数的返回值是一个指针。然后再与后面的`“()”`结合，也就是说，该指针指向的是一个函数。\n\n这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：\n\n```\nint (*PF)(int *, int);\n```\n也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针`“类型”`，即：\n\n```\ntypedef int (*PF)(int *, int);\n```\n这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:\n\n```\nPF ff(int);\n```\n\n\n#### 深入理解 typedef\n平时我们在OC中的使用写法，但是对`typedef`困惑。\n```\ntypedef <#returnType#>(^<#name#>)(<#arguments#>);//typedefBlock Code Snippets\n\ntypedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);\n\n```\n然后可以通过`RWAlertViewCompletionBlock`当成block类型直接使用了。\n然后看下`libffi`的用法：\n```\ntypedef enum {\n  FFI_OK = 0,\n  FFI_BAD_TYPEDEF,\n  FFI_BAD_ABI\n} ffi_status;\ntypedef int INT64;//INT64 其实是int\n```\n使用起来的话：\n```\nffi_status status;//声明一个类型是ffi_status的参数\nINT64 age;//声明一个age 类型是INT64\n```\n现在block也可以是函数指针了\n```\nint (*PF)(int *, int);\n//也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：\ntypedef int (*PF)(int *, int);\n```\n**typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。**\n针对经典的const来个例子\n```\ntypedef char * pStr;\nchar string[4] = \"abc\";\nconst char *p1 = string;\nconst pStr p2 = string;\np1++;\np2++;//error\n```\n那么为什么`p2++`为什么会报错呢？\n我们来分析一下，`const char *p1 = string;`是声明了一个`const char `的指针，不可变的是`char`,相当于`(const char)*p=string`,所以`p1++`不会报错。`p2++`报错根本原因是`p2`是不可变的，`const pStr p2 = string`相当于`const (char *) p2 = string`,`const`修饰的是`char *`，所以`p2`不可改变。`p1`是数组，`p2`是固定的值。\n#### `typedef`如何使用呢？\n我们具体看几个案例分析一下。\n\n案例1：\n```\nint (*b) (void (*)());\n```\n简化一下是：\n```\ntypedef  void (*func)()\ntypedef  int (*ifunc)(func)\n```\n最终简化成`ifunc b;`。可以理解成`(void (*)())`是一个`func`,然后替换`func`成了最终的形参是`func`，返回值是`int`。\n\n案例2分析：\n```\nint (*func)(int *p);\n```\n首先找到`func`，`func`左边是`*`，说明`func`是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明`(*func)`是一个函数，所以\nfunc是一个指向这类函数的指针，即函数指针，这类函数具有`int*`类型的形参，返回值类型是`int`。\n\n综合案例：\n```\nSEL didload = @selector(viewDidLoad);\nMethod md = class_getInstanceMethod(aclass, didload);\nIMP load = method_getImplementation(md);\nvoid(*loadFunc)(id,SEL) = (void *)load;\n```\n这是将SEL获取了Method之后将IMP转化成`void(*loadFunc)(id,SEL)`，调用的时候可以直接调用。\n```\n//执行ViewDidLoad IMP\n loadFunc(aclass,NULL);\n```\nMethod可以这样使用，block同样也可以这样使用:\n```\nvoid (^block)(id _self) = ^(id _self){\n    //code here\n};\nvoid(*func)(id,SEL) = (void*)imp_implementationWithBlock(block);\nclass_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));\n```\n这可以直接使用`runtime/message.h`函数`imp_implementationWithBlock`将`block`转化成`IMP`,使用`class_replaceMethod`替换某个函数的`IMP`。那么再调用该函数的时候，则是调用的`block`的`IMP`。获取`method`和`block`参数后续再分析。\n\n\n\n资料参考：\n\n[玉令天下博客地址](http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/)\n","source":"_posts/iOS 浅析指针、函数、typedef.md","raw":"title: iOS 浅析指针、函数、typedef\ndate: 2019-6-24 16:39:24\ntags: \n- 指针 \n- iOS\ncategories: iOS\n---\n#### 指针函数和函数指针\n\n顾名思义，指针函数即返回指针的函数。其一般定义形式如下：\n\n```\n类型名 *函数名(函数参数表列);  \n```\n其中，后缀运算符括号`“()”`表示这是一个函数，其前缀运算符星号`“*”`表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。\n\n`“(函数参数表列)”`中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：\n\n```\nint *pfun(int, int);\n```\n由于`“*”`的优先级低于`“()”`的优先级，因而pfun首先和后面的`“()”`结合，也就意味着，pfun是一个函数。即：\n\n```\nint *(pfun(int, int));\n```\n接着再和前面的`“*”`结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。\n我们不妨来再看一看，指针函数与函数指针有什么区别？\n\n```\nint (*pfun)(int, int);\n```\n通过括号强行将pfun首先与`“*”`结合，也就意味着，pfun是一个指针，接着与后面的`“()”`结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。\n\n虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。\n\n用函数指针作为指针函数的返回值\n在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：\n\n```\nint (*ff(int))(int *, int);\n```\n我们用上面介绍的方法分析一下，ff首先与后面的`“()”`结合，即：\n\n```\nint (*(ff(int)))(int *, int);\n```\n用括号将`ff(int)`再括起来也就意味着，`ff`是一个函数。\n接着与前面的`“*”`结合，说明`ff`函数的返回值是一个指针。然后再与后面的`“()”`结合，也就是说，该指针指向的是一个函数。\n\n这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：\n\n```\nint (*PF)(int *, int);\n```\n也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针`“类型”`，即：\n\n```\ntypedef int (*PF)(int *, int);\n```\n这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:\n\n```\nPF ff(int);\n```\n\n\n#### 深入理解 typedef\n平时我们在OC中的使用写法，但是对`typedef`困惑。\n```\ntypedef <#returnType#>(^<#name#>)(<#arguments#>);//typedefBlock Code Snippets\n\ntypedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);\n\n```\n然后可以通过`RWAlertViewCompletionBlock`当成block类型直接使用了。\n然后看下`libffi`的用法：\n```\ntypedef enum {\n  FFI_OK = 0,\n  FFI_BAD_TYPEDEF,\n  FFI_BAD_ABI\n} ffi_status;\ntypedef int INT64;//INT64 其实是int\n```\n使用起来的话：\n```\nffi_status status;//声明一个类型是ffi_status的参数\nINT64 age;//声明一个age 类型是INT64\n```\n现在block也可以是函数指针了\n```\nint (*PF)(int *, int);\n//也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：\ntypedef int (*PF)(int *, int);\n```\n**typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。**\n针对经典的const来个例子\n```\ntypedef char * pStr;\nchar string[4] = \"abc\";\nconst char *p1 = string;\nconst pStr p2 = string;\np1++;\np2++;//error\n```\n那么为什么`p2++`为什么会报错呢？\n我们来分析一下，`const char *p1 = string;`是声明了一个`const char `的指针，不可变的是`char`,相当于`(const char)*p=string`,所以`p1++`不会报错。`p2++`报错根本原因是`p2`是不可变的，`const pStr p2 = string`相当于`const (char *) p2 = string`,`const`修饰的是`char *`，所以`p2`不可改变。`p1`是数组，`p2`是固定的值。\n#### `typedef`如何使用呢？\n我们具体看几个案例分析一下。\n\n案例1：\n```\nint (*b) (void (*)());\n```\n简化一下是：\n```\ntypedef  void (*func)()\ntypedef  int (*ifunc)(func)\n```\n最终简化成`ifunc b;`。可以理解成`(void (*)())`是一个`func`,然后替换`func`成了最终的形参是`func`，返回值是`int`。\n\n案例2分析：\n```\nint (*func)(int *p);\n```\n首先找到`func`，`func`左边是`*`，说明`func`是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明`(*func)`是一个函数，所以\nfunc是一个指向这类函数的指针，即函数指针，这类函数具有`int*`类型的形参，返回值类型是`int`。\n\n综合案例：\n```\nSEL didload = @selector(viewDidLoad);\nMethod md = class_getInstanceMethod(aclass, didload);\nIMP load = method_getImplementation(md);\nvoid(*loadFunc)(id,SEL) = (void *)load;\n```\n这是将SEL获取了Method之后将IMP转化成`void(*loadFunc)(id,SEL)`，调用的时候可以直接调用。\n```\n//执行ViewDidLoad IMP\n loadFunc(aclass,NULL);\n```\nMethod可以这样使用，block同样也可以这样使用:\n```\nvoid (^block)(id _self) = ^(id _self){\n    //code here\n};\nvoid(*func)(id,SEL) = (void*)imp_implementationWithBlock(block);\nclass_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));\n```\n这可以直接使用`runtime/message.h`函数`imp_implementationWithBlock`将`block`转化成`IMP`,使用`class_replaceMethod`替换某个函数的`IMP`。那么再调用该函数的时候，则是调用的`block`的`IMP`。获取`method`和`block`参数后续再分析。\n\n\n\n资料参考：\n\n[玉令天下博客地址](http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/)\n","slug":"iOS 浅析指针、函数、typedef","published":1,"updated":"2019-12-03T04:48:00.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2e000e9zsk4yf977qk","content":"<h4 id=\"指针函数和函数指针\"><a href=\"#指针函数和函数指针\" class=\"headerlink\" title=\"指针函数和函数指针\"></a>指针函数和函数指针</h4><p>顾名思义，指针函数即返回指针的函数。其一般定义形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">类型名 *函数名(函数参数表列);</div></pre></td></tr></table></figure>\n<p>其中，后缀运算符括号<code>“()”</code>表示这是一个函数，其前缀运算符星号<code>“*”</code>表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。</p>\n<p><code>“(函数参数表列)”</code>中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *pfun(int, int);</div></pre></td></tr></table></figure>\n<p>由于<code>“*”</code>的优先级低于<code>“()”</code>的优先级，因而pfun首先和后面的<code>“()”</code>结合，也就意味着，pfun是一个函数。即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *(pfun(int, int));</div></pre></td></tr></table></figure>\n<p>接着再和前面的<code>“*”</code>结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。<br>我们不妨来再看一看，指针函数与函数指针有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*pfun)(int, int);</div></pre></td></tr></table></figure>\n<p>通过括号强行将pfun首先与<code>“*”</code>结合，也就意味着，pfun是一个指针，接着与后面的<code>“()”</code>结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。</p>\n<p>虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。</p>\n<p>用函数指针作为指针函数的返回值<br>在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*ff(int))(int *, int);</div></pre></td></tr></table></figure>\n<p>我们用上面介绍的方法分析一下，ff首先与后面的<code>“()”</code>结合，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*(ff(int)))(int *, int);</div></pre></td></tr></table></figure>\n<p>用括号将<code>ff(int)</code>再括起来也就意味着，<code>ff</code>是一个函数。<br>接着与前面的<code>“*”</code>结合，说明<code>ff</code>函数的返回值是一个指针。然后再与后面的<code>“()”</code>结合，也就是说，该指针指向的是一个函数。</p>\n<p>这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*PF)(int *, int);</div></pre></td></tr></table></figure>\n<p>也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针<code>“类型”</code>，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef int (*PF)(int *, int);</div></pre></td></tr></table></figure>\n<p>这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">PF ff(int);</div></pre></td></tr></table></figure>\n<h4 id=\"深入理解-typedef\"><a href=\"#深入理解-typedef\" class=\"headerlink\" title=\"深入理解 typedef\"></a>深入理解 typedef</h4><p>平时我们在OC中的使用写法，但是对<code>typedef</code>困惑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);//typedefBlock Code Snippets</div><div class=\"line\"></div><div class=\"line\">typedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);</div></pre></td></tr></table></figure></p>\n<p>然后可以通过<code>RWAlertViewCompletionBlock</code>当成block类型直接使用了。<br>然后看下<code>libffi</code>的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum &#123;</div><div class=\"line\">  FFI_OK = 0,</div><div class=\"line\">  FFI_BAD_TYPEDEF,</div><div class=\"line\">  FFI_BAD_ABI</div><div class=\"line\">&#125; ffi_status;</div><div class=\"line\">typedef int INT64;//INT64 其实是int</div></pre></td></tr></table></figure></p>\n<p>使用起来的话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffi_status status;//声明一个类型是ffi_status的参数</div><div class=\"line\">INT64 age;//声明一个age 类型是INT64</div></pre></td></tr></table></figure></p>\n<p>现在block也可以是函数指针了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*PF)(int *, int);</div><div class=\"line\">//也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：</div><div class=\"line\">typedef int (*PF)(int *, int);</div></pre></td></tr></table></figure></p>\n<p><strong>typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。</strong><br>针对经典的const来个例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef char * pStr;</div><div class=\"line\">char string[4] = &quot;abc&quot;;</div><div class=\"line\">const char *p1 = string;</div><div class=\"line\">const pStr p2 = string;</div><div class=\"line\">p1++;</div><div class=\"line\">p2++;//error</div></pre></td></tr></table></figure></p>\n<p>那么为什么<code>p2++</code>为什么会报错呢？<br>我们来分析一下，<code>const char *p1 = string;</code>是声明了一个<code>const char</code>的指针，不可变的是<code>char</code>,相当于<code>(const char)*p=string</code>,所以<code>p1++</code>不会报错。<code>p2++</code>报错根本原因是<code>p2</code>是不可变的，<code>const pStr p2 = string</code>相当于<code>const (char *) p2 = string</code>,<code>const</code>修饰的是<code>char *</code>，所以<code>p2</code>不可改变。<code>p1</code>是数组，<code>p2</code>是固定的值。</p>\n<h4 id=\"typedef如何使用呢？\"><a href=\"#typedef如何使用呢？\" class=\"headerlink\" title=\"typedef如何使用呢？\"></a><code>typedef</code>如何使用呢？</h4><p>我们具体看几个案例分析一下。</p>\n<p>案例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*b) (void (*)());</div></pre></td></tr></table></figure></p>\n<p>简化一下是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef  void (*func)()</div><div class=\"line\">typedef  int (*ifunc)(func)</div></pre></td></tr></table></figure></p>\n<p>最终简化成<code>ifunc b;</code>。可以理解成<code>(void (*)())</code>是一个<code>func</code>,然后替换<code>func</code>成了最终的形参是<code>func</code>，返回值是<code>int</code>。</p>\n<p>案例2分析：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*func)(int *p);</div></pre></td></tr></table></figure></p>\n<p>首先找到<code>func</code>，<code>func</code>左边是<code>*</code>，说明<code>func</code>是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<br>func是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p>\n<p>综合案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL didload = @selector(viewDidLoad);</div><div class=\"line\">Method md = class_getInstanceMethod(aclass, didload);</div><div class=\"line\">IMP load = method_getImplementation(md);</div><div class=\"line\">void(*loadFunc)(id,SEL) = (void *)load;</div></pre></td></tr></table></figure></p>\n<p>这是将SEL获取了Method之后将IMP转化成<code>void(*loadFunc)(id,SEL)</code>，调用的时候可以直接调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//执行ViewDidLoad IMP</div><div class=\"line\"> loadFunc(aclass,NULL);</div></pre></td></tr></table></figure></p>\n<p>Method可以这样使用，block同样也可以这样使用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void (^block)(id _self) = ^(id _self)&#123;</div><div class=\"line\">    //code here</div><div class=\"line\">&#125;;</div><div class=\"line\">void(*func)(id,SEL) = (void*)imp_implementationWithBlock(block);</div><div class=\"line\">class_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));</div></pre></td></tr></table></figure></p>\n<p>这可以直接使用<code>runtime/message.h</code>函数<code>imp_implementationWithBlock</code>将<code>block</code>转化成<code>IMP</code>,使用<code>class_replaceMethod</code>替换某个函数的<code>IMP</code>。那么再调用该函数的时候，则是调用的<code>block</code>的<code>IMP</code>。获取<code>method</code>和<code>block</code>参数后续再分析。</p>\n<p>资料参考：</p>\n<p><a href=\"http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/\" target=\"_blank\" rel=\"external\">玉令天下博客地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"指针函数和函数指针\"><a href=\"#指针函数和函数指针\" class=\"headerlink\" title=\"指针函数和函数指针\"></a>指针函数和函数指针</h4><p>顾名思义，指针函数即返回指针的函数。其一般定义形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">类型名 *函数名(函数参数表列);</div></pre></td></tr></table></figure>\n<p>其中，后缀运算符括号<code>“()”</code>表示这是一个函数，其前缀运算符星号<code>“*”</code>表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。</p>\n<p><code>“(函数参数表列)”</code>中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *pfun(int, int);</div></pre></td></tr></table></figure>\n<p>由于<code>“*”</code>的优先级低于<code>“()”</code>的优先级，因而pfun首先和后面的<code>“()”</code>结合，也就意味着，pfun是一个函数。即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *(pfun(int, int));</div></pre></td></tr></table></figure>\n<p>接着再和前面的<code>“*”</code>结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。<br>我们不妨来再看一看，指针函数与函数指针有什么区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*pfun)(int, int);</div></pre></td></tr></table></figure>\n<p>通过括号强行将pfun首先与<code>“*”</code>结合，也就意味着，pfun是一个指针，接着与后面的<code>“()”</code>结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。</p>\n<p>虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。</p>\n<p>用函数指针作为指针函数的返回值<br>在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*ff(int))(int *, int);</div></pre></td></tr></table></figure>\n<p>我们用上面介绍的方法分析一下，ff首先与后面的<code>“()”</code>结合，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*(ff(int)))(int *, int);</div></pre></td></tr></table></figure>\n<p>用括号将<code>ff(int)</code>再括起来也就意味着，<code>ff</code>是一个函数。<br>接着与前面的<code>“*”</code>结合，说明<code>ff</code>函数的返回值是一个指针。然后再与后面的<code>“()”</code>结合，也就是说，该指针指向的是一个函数。</p>\n<p>这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*PF)(int *, int);</div></pre></td></tr></table></figure>\n<p>也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针<code>“类型”</code>，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef int (*PF)(int *, int);</div></pre></td></tr></table></figure>\n<p>这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">PF ff(int);</div></pre></td></tr></table></figure>\n<h4 id=\"深入理解-typedef\"><a href=\"#深入理解-typedef\" class=\"headerlink\" title=\"深入理解 typedef\"></a>深入理解 typedef</h4><p>平时我们在OC中的使用写法，但是对<code>typedef</code>困惑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);//typedefBlock Code Snippets</div><div class=\"line\"></div><div class=\"line\">typedef void (^RWAlertViewCompletionBlock)(UIAlertView *alertView, NSInteger buttonIndex);</div></pre></td></tr></table></figure></p>\n<p>然后可以通过<code>RWAlertViewCompletionBlock</code>当成block类型直接使用了。<br>然后看下<code>libffi</code>的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum &#123;</div><div class=\"line\">  FFI_OK = 0,</div><div class=\"line\">  FFI_BAD_TYPEDEF,</div><div class=\"line\">  FFI_BAD_ABI</div><div class=\"line\">&#125; ffi_status;</div><div class=\"line\">typedef int INT64;//INT64 其实是int</div></pre></td></tr></table></figure></p>\n<p>使用起来的话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffi_status status;//声明一个类型是ffi_status的参数</div><div class=\"line\">INT64 age;//声明一个age 类型是INT64</div></pre></td></tr></table></figure></p>\n<p>现在block也可以是函数指针了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*PF)(int *, int);</div><div class=\"line\">//也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：</div><div class=\"line\">typedef int (*PF)(int *, int);</div></pre></td></tr></table></figure></p>\n<p><strong>typedef的语法规则其实很简单，一句话来说就是定义对象的语法前加关键字typedef，剩下的不变，原本定义的对象标识符换成类型标识符，对应语义从定义一个对象改成定义一个类型别名。typedef看起来复杂根本原因是对象定义的语法比较复杂，例如分隔符*和[]的用法。</strong><br>针对经典的const来个例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef char * pStr;</div><div class=\"line\">char string[4] = &quot;abc&quot;;</div><div class=\"line\">const char *p1 = string;</div><div class=\"line\">const pStr p2 = string;</div><div class=\"line\">p1++;</div><div class=\"line\">p2++;//error</div></pre></td></tr></table></figure></p>\n<p>那么为什么<code>p2++</code>为什么会报错呢？<br>我们来分析一下，<code>const char *p1 = string;</code>是声明了一个<code>const char</code>的指针，不可变的是<code>char</code>,相当于<code>(const char)*p=string</code>,所以<code>p1++</code>不会报错。<code>p2++</code>报错根本原因是<code>p2</code>是不可变的，<code>const pStr p2 = string</code>相当于<code>const (char *) p2 = string</code>,<code>const</code>修饰的是<code>char *</code>，所以<code>p2</code>不可改变。<code>p1</code>是数组，<code>p2</code>是固定的值。</p>\n<h4 id=\"typedef如何使用呢？\"><a href=\"#typedef如何使用呢？\" class=\"headerlink\" title=\"typedef如何使用呢？\"></a><code>typedef</code>如何使用呢？</h4><p>我们具体看几个案例分析一下。</p>\n<p>案例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*b) (void (*)());</div></pre></td></tr></table></figure></p>\n<p>简化一下是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef  void (*func)()</div><div class=\"line\">typedef  int (*ifunc)(func)</div></pre></td></tr></table></figure></p>\n<p>最终简化成<code>ifunc b;</code>。可以理解成<code>(void (*)())</code>是一个<code>func</code>,然后替换<code>func</code>成了最终的形参是<code>func</code>，返回值是<code>int</code>。</p>\n<p>案例2分析：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">int (*func)(int *p);</div></pre></td></tr></table></figure></p>\n<p>首先找到<code>func</code>，<code>func</code>左边是<code>*</code>，说明<code>func</code>是个指针，然后跳出这个圆括号，先看右边，又遇到圆括号，这说明<code>(*func)</code>是一个函数，所以<br>func是一个指向这类函数的指针，即函数指针，这类函数具有<code>int*</code>类型的形参，返回值类型是<code>int</code>。</p>\n<p>综合案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL didload = @selector(viewDidLoad);</div><div class=\"line\">Method md = class_getInstanceMethod(aclass, didload);</div><div class=\"line\">IMP load = method_getImplementation(md);</div><div class=\"line\">void(*loadFunc)(id,SEL) = (void *)load;</div></pre></td></tr></table></figure></p>\n<p>这是将SEL获取了Method之后将IMP转化成<code>void(*loadFunc)(id,SEL)</code>，调用的时候可以直接调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//执行ViewDidLoad IMP</div><div class=\"line\"> loadFunc(aclass,NULL);</div></pre></td></tr></table></figure></p>\n<p>Method可以这样使用，block同样也可以这样使用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void (^block)(id _self) = ^(id _self)&#123;</div><div class=\"line\">    //code here</div><div class=\"line\">&#125;;</div><div class=\"line\">void(*func)(id,SEL) = (void*)imp_implementationWithBlock(block);</div><div class=\"line\">class_replaceMethod(aclass, didload, (IMP)func, method_getTypeEncoding(md));</div></pre></td></tr></table></figure></p>\n<p>这可以直接使用<code>runtime/message.h</code>函数<code>imp_implementationWithBlock</code>将<code>block</code>转化成<code>IMP</code>,使用<code>class_replaceMethod</code>替换某个函数的<code>IMP</code>。那么再调用该函数的时候，则是调用的<code>block</code>的<code>IMP</code>。获取<code>method</code>和<code>block</code>参数后续再分析。</p>\n<p>资料参考：</p>\n<p><a href=\"http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/\" target=\"_blank\" rel=\"external\">玉令天下博客地址</a></p>\n"},{"title":"iOS图片优化","date":"2019-12-13T03:15:58.000Z","_content":"\n基于现在iOS11新生成的图片都是`HEIF`，该图片使用`[UIImage image:name]`已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。\n\n既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?\n\n这就要先了解该图片的编码了。\n## HEIC HEIF\n\n> 带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件\n\n`heic`和`heif`是广色域图片的格式，广色域比`sRGB`表示范围大25%，在广色域设备中能显示更广的色彩，`sRGB 8bit/dept`，广色域达到`16bit/dept`。广色域只是在硬件支持的情况下才能显示的。\n其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。\n\n## 加载\n加载`image`，只是把**文件信息**加载到内存中，下一步就是解码。在代码中体现就是\n```\nlet image = UIImage(contentsOfFile: url.path)\n或 加载图片到内存 会常驻内存\nlet image = UIImage(named: name)!\n```\n\n## 解码\n其实是发生在添加到要显示的view上面才会解码\n```\nlet imageV = UIImageView.init(image: image)\nimageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)\nself.view.addSubview(imageV)\n```\n最后一行不写，则不会解码。\n\n## 渲染\n当`view`显示出来则是渲染。过程是解码的`data buffer` 复制到`frame buffer`,硬件从帧缓冲区读取数据显示到屏幕上。\n```\nself.view.addSubview(imageV)\n```\n\n## 内存暴涨原因\n一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。\n\n首先有请我们准备的素材和设备(6s 64g版本)\n```\nA:jpg\n20M 12000*12000\n\nB:jpg\n2.8M 3024*4032\n\nC:HEIC\n1.8M 3024*4032\n```\n素材A\n```\nAPP运行内存：13.8M\n加载Image: 240.3M之后稳定到220M\nCPU：峰值5%，随后降低到0%\nimage占内存：226.5M\n```\n\n素材B\n```\nAPP运行内存：13.7M\n加载Image: 31.5\nCPU：峰值5%，随后降低到0%\nimage占内存：17.8M\n```\n\n素材C\n```\nAPP运行内存：13.8M\n加载Image: 32.3\nCPU：峰值4%，随后降低到0%\nimage占内存：18.5M\n```\n\n我们猜测是否是`imageView`的大小影响内存的呢？\n`size`改为原来的1/10结果运行内存还是和以前一样。\n\n为什么呢？\n> 内存大小不是取决于`view`的`size`，而是原始文件**image size**。\n\n![](https://user-gold-cdn.xitu.io/2019/11/29/16eb5cff5d35a254?w=1016&h=542&f=png&s=54318)\n### 渲染格式\n#### SRGB\n每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。\n#### display p3 宽色域\n每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。\n#### 亮度和透明度\n每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。\n#### Alpha 8 Format\n每个像素1字节，用来表示透明度，一般用作蒙版和文字。\n相比sRGB容量小了75%，详细 宽色域 容量小了87.5%\n\n\n### 渲染图片大小计算\n图片大小 = 图片格式容量 * 像素个数\n当我们把大小是20\\*20使用`Alpha 8 format`渲染到20\\*20的view上面，和40\\*40的image使用`p3`渲染到20\\*20的view中，后着占用内存是前者的8倍。\n\n使用sRGB色域进行渲染所占用的大小为\n```\nimageWidth*imageHeight*4 字节\n```\n每个像素占用了4字节，每个字节8位，\n\n使用`display p3`则每个通道占用16位，那么占用内存大小是 \n```\nimageWidth*imageHeight*8 字节\n```\n\n### 如何选择正确的图片格式\n> 不要主动选择图片格式，让格式选择你。\n\n不要再使用`UIGraphicsBeginImageContextWithOptions`,该方法总是使用sRGB格式，你想节约内存是不行的，在支持`p3`的设备上想绘制出来`p3`色域的图片也是不行的。那么使用`UIGraphicsImageRenderer`系统可以自动为你选择格式，如果绘制`image`，自己再添加单色蒙版，是不需要另外单独分配内存的。\n```\nif let im = imageV {\n//第二次添加蒙版\n\tim.tintColor = UIColor.black\n}else{\n//绘制一个红色矩形\n\tlet bounds = CGRect(x: 0, y: 0, width: width, height: height)\n\tlet renderer = UIGraphicsImageRenderer(bounds: bounds)\n\t let image = renderer.image { (coxt) in\n\t\tUIColor.red.setFill()\n\t\tlet path = UIBezierPath(roundedRect: bounds,\n\t\t\t\t\t\t\t\tcornerRadius: 20)\n\t\tpath.addClip()\n\t\tUIRectFill(bounds)\n\t}\n\timageV = UIImageView(image: image)\n\timageV?.frame = bounds\n\tself.view.addSubview(imageV!)\n}\n```\n\n`UIImage` 直接读出来需要将所有`UIImage`的`data`全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用**下采样**。\n### 下采样\n当`image`素材大小是`1000*1000`，但是在手机上显示出来只有`200*200`，我们其实是没必要将`1000*1000`的数据都解码的，只需要缩小成`200*200`的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。\n在`UIKit`中使用`UIGraphicsImageRenderer`会有瞬间很高的内存和CPU峰值，那么\n#### 1.UIKit  UIGraphicsImageRenderer\n使用素材A下采样技术，使用`UIKit`中的`UIGraphicsImageRenderer`\n\n```\nMemory \nHigh:16.4M\nnormal:14.8M\nCPU:\nHight:29%\nnormal:0%\n```\n\n```\nfunc resizedImage(at url: URL, for size: CGSize) -> UIImage? {\n\tguard let image = UIImage(contentsOfFile: url.path) else {\n\t\treturn nil\n\t}\n\tif #available(iOS 10.0, *) {\n\t\tlet renderer = UIGraphicsImageRenderer(size: size)\n\t\n\t\treturn renderer.image { (context) in\n\t\t\timage.draw(in: CGRect(origin: .zero, size: size))\n\t\t}\n\t}else{\n\t\tUIGraphicsBeginImageContext(size)\n\t\timage.draw(in: CGRect(origin: .zero, size: size))\n\t\tlet image = UIGraphicsGetImageFromCurrentImageContext()\n\t\tUIGraphicsEndImageContext()\n\t\treturn image\n\t}\n}\n```\n\n用子线程绘制，会出现CPU略微升高，当`image size`大很多的时候会出现内存飙升然后慢慢恢复到`normal`。\n\n#### 2.CoreGraphics CGContext上下文绘制缩略图\n\n使用上下文绘制 `cpu` 和内存变化如下,`CPU`和内存没有大的变动解决了该问题，也做到省电、顺滑。\n```\nMemory \nHigh:42.3M\nnormal:14.1M\nCPU:\nHight:6%\nnormal:0%\n```\n```\nfunc resizedImage2(at url: URL, for size: CGSize) -> UIImage?{\n\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)\n\telse{\n\t\treturn nil;\n\t}\n\tlet cxt = CGContext(data: nil,\n\t\t\t\t\t\twidth: Int(size.width),\n\t\t\t\t\t\theight: Int(size.height),\n\t\t\t\t\t\tbitsPerComponent: image.bitsPerComponent,\n\t\t\t\t\t\tbytesPerRow: image.bytesPerRow,\n\t\t\t\t\t\tspace: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!\n\t\t,\n\t\t\t\t\t\tbitmapInfo: image.bitmapInfo.rawValue)\n\tcxt?.interpolationQuality = .high\n\tcxt?.draw(image, in: CGRect(origin: .zero, size: size))\n\tguard let scaledImage = cxt?.makeImage() else {\n\t\treturn nil\n\t}\n\tlet ima = UIImage(cgImage: scaledImage)\n\treturn ima\n\t\n}\n```\n\n#### 3.ImageIO 创建缩略图\n使用`ImageIO` 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。\n```\nMemory \nHigh:320M\nnormal:221M\nCPU:\nHight:73%\nnormal:0%\n```\n\n```\nfunc resizedImage3(at url: URL, for size: CGSize) -> UIImage?{\n\t\n\tlet ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,\n\t\t\t\t\t\t\t  kCGImageSourceCreateThumbnailWithTransform:true,\n\t\t\t\t\t\t\t  kCGImageSourceShouldCacheImmediately:true,\n\t\t\t\t\t\t\t  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]\n\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else {\n\t\t\treturn nil;\n\t}\n\tlet ima = UIImage(cgImage: image)\n\tprintImageCost(image: ima)\n\treturn ima\n}\n```\n#### 4.CoreImage 滤镜\n使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。\n```\nMemory \nHigh:1.04G\nnormal:566M\nCPU:\nHight:73%\nnormal:0%\n```\n```\n\tfunc resizedImage4(at url: URL, for size: CGSize) -> UIImage?{\n\t\tlet shareContext = CIContext(options: [.useSoftwareRenderer:false])\n\t\t\n\t\t guard let image = CIImage(contentsOf: url) else { return nil }\n\t\tlet fillter = CIFilter(name: \"CILanczosScaleTransform\")\n\t\tfillter?.setValue(image, forKey: kCIInputImageKey)\n\t\tfillter?.setValue(1, forKey: kCIInputScaleKey)\n\t\tguard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else { return nil }\n\t\t\n\t\treturn UIImage(cgImage: outputCGImage)\n\t}\n```\n\n#### 5.使用 vImage 优化图片渲染\n使用`vImage`创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要`crash`了。\n```\nMemory \nHigh:998.7M\nnormal:566M\nCPU:\nHight:78%\nnormal:0%\n```\n\n```\nfunc resizedImage5(at url: URL, for size: CGSize) -> UIImage? {\n    // 解码源图像\n    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),\n        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],\n        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,\n        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount\n    else {\n        return nil\n    }\n\n    // 定义图像格式\n    var format = vImage_CGImageFormat(bitsPerComponent: 8,\n                                      bitsPerPixel: 32,\n                                      colorSpace: nil,\n                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),\n                                      version: 0,\n                                      decode: nil,\n                                      renderingIntent: .defaultIntent)\n\n    var error: vImage_Error\n\n    // 创建并初始化源缓冲区\n    var sourceBuffer = vImage_Buffer()\n    defer { sourceBuffer.data.deallocate() }\n    error = vImageBuffer_InitWithCGImage(&sourceBuffer,\n                                         &format,\n                                         nil,\n                                         image,\n                                         vImage_Flags(kvImageNoFlags))\n    guard error == kvImageNoError else { return nil }\n\n    // 创建并初始化目标缓冲区\n    var destinationBuffer = vImage_Buffer()\n    error = vImageBuffer_Init(&destinationBuffer,\n                              vImagePixelCount(size.height),\n                              vImagePixelCount(size.width),\n                              format.bitsPerPixel,\n                              vImage_Flags(kvImageNoFlags))\n    guard error == kvImageNoError else { return nil }\n\n    // 优化缩放图像\n    error = vImageScale_ARGB8888(&sourceBuffer,\n                                 &destinationBuffer,\n                                 nil,\n                                 vImage_Flags(kvImageHighQualityResampling))\n    guard error == kvImageNoError else { return nil }\n\n    // 从目标缓冲区创建一个 CGImage 对象\n    guard let resizedImage =\n        vImageCreateCGImageFromBuffer(&destinationBuffer,\n                                      &format,\n                                      nil,\n                                      nil,\n                                      vImage_Flags(kvImageNoAllocate),\n                                      &error)?.takeRetainedValue(),\n        error == kvImageNoError\n    else {\n        return nil\n    }\n\n    return UIImage(cgImage: resizedImage)\n}\n```\n### 内存优化\n图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。\n\n在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。\n```\n# 1\nNotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,\n\t\t\t\t\t\t\t\t\t   object: nil,\n\t\t\t\t\t\t\t\t\t   queue: .main)\n{[weak self] (note) in\n\tself?.unloadImage()\n}\nNotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,\n\t\t\t\t\t\t\t\t\t   object: nil,\n\t\t\t\t\t\t\t\t\t   queue: .main)\n{[weak self] (note) in\n\tself?.loadImage()\n}\n# 2\n\noverride func viewWillAppear(_ animated: Bool) {\n\tsuper.viewWillAppear(animated)\n\tself.loadImage()\n}\noverride func viewWillDisappear(_ animated: Bool) {\n\tsuper.viewWillDisappear(animated)\n\tself.unloadImage()\n}\n```\n\n### 总结\n- 基于性能综合考虑方法1是最简单最合适的\n- 使用滤镜和`vImage`略微复杂点，平时开发过程中可以不用考虑了。\n- 图片解码缓存和图片大小有关，适当的下采样是不错的选择。\n\n\n\n\n\n### 参考\n- [session 2018 416 iOS Memory Deep Dive](https://developer.apple.com/videos/play/wwdc2018/416)\n- [219_image_and_graphics_best_practices](https://developer.apple.com/videos/play/wwdc2018/219)\n- [WWDC 中文字幕下载](https://github.com/ifgyong/iOSDataFactory)\n- [swift gg 图像优化](https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1)\n\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master)\n\n \n \n**唯有实践才是检验真理的唯一标准**\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n\n\n广告时间\n\n![](../images/0.png)\n\n\n","source":"_posts/iOS图片优化 .md","raw":"title: iOS图片优化 \ndate: 2019-12-13 11:15:58\ntags:\n- iOS\ncategories: iOS\n---\n\n基于现在iOS11新生成的图片都是`HEIF`，该图片使用`[UIImage image:name]`已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。\n\n既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?\n\n这就要先了解该图片的编码了。\n## HEIC HEIF\n\n> 带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件\n\n`heic`和`heif`是广色域图片的格式，广色域比`sRGB`表示范围大25%，在广色域设备中能显示更广的色彩，`sRGB 8bit/dept`，广色域达到`16bit/dept`。广色域只是在硬件支持的情况下才能显示的。\n其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。\n\n## 加载\n加载`image`，只是把**文件信息**加载到内存中，下一步就是解码。在代码中体现就是\n```\nlet image = UIImage(contentsOfFile: url.path)\n或 加载图片到内存 会常驻内存\nlet image = UIImage(named: name)!\n```\n\n## 解码\n其实是发生在添加到要显示的view上面才会解码\n```\nlet imageV = UIImageView.init(image: image)\nimageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)\nself.view.addSubview(imageV)\n```\n最后一行不写，则不会解码。\n\n## 渲染\n当`view`显示出来则是渲染。过程是解码的`data buffer` 复制到`frame buffer`,硬件从帧缓冲区读取数据显示到屏幕上。\n```\nself.view.addSubview(imageV)\n```\n\n## 内存暴涨原因\n一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。\n\n首先有请我们准备的素材和设备(6s 64g版本)\n```\nA:jpg\n20M 12000*12000\n\nB:jpg\n2.8M 3024*4032\n\nC:HEIC\n1.8M 3024*4032\n```\n素材A\n```\nAPP运行内存：13.8M\n加载Image: 240.3M之后稳定到220M\nCPU：峰值5%，随后降低到0%\nimage占内存：226.5M\n```\n\n素材B\n```\nAPP运行内存：13.7M\n加载Image: 31.5\nCPU：峰值5%，随后降低到0%\nimage占内存：17.8M\n```\n\n素材C\n```\nAPP运行内存：13.8M\n加载Image: 32.3\nCPU：峰值4%，随后降低到0%\nimage占内存：18.5M\n```\n\n我们猜测是否是`imageView`的大小影响内存的呢？\n`size`改为原来的1/10结果运行内存还是和以前一样。\n\n为什么呢？\n> 内存大小不是取决于`view`的`size`，而是原始文件**image size**。\n\n![](https://user-gold-cdn.xitu.io/2019/11/29/16eb5cff5d35a254?w=1016&h=542&f=png&s=54318)\n### 渲染格式\n#### SRGB\n每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。\n#### display p3 宽色域\n每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。\n#### 亮度和透明度\n每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。\n#### Alpha 8 Format\n每个像素1字节，用来表示透明度，一般用作蒙版和文字。\n相比sRGB容量小了75%，详细 宽色域 容量小了87.5%\n\n\n### 渲染图片大小计算\n图片大小 = 图片格式容量 * 像素个数\n当我们把大小是20\\*20使用`Alpha 8 format`渲染到20\\*20的view上面，和40\\*40的image使用`p3`渲染到20\\*20的view中，后着占用内存是前者的8倍。\n\n使用sRGB色域进行渲染所占用的大小为\n```\nimageWidth*imageHeight*4 字节\n```\n每个像素占用了4字节，每个字节8位，\n\n使用`display p3`则每个通道占用16位，那么占用内存大小是 \n```\nimageWidth*imageHeight*8 字节\n```\n\n### 如何选择正确的图片格式\n> 不要主动选择图片格式，让格式选择你。\n\n不要再使用`UIGraphicsBeginImageContextWithOptions`,该方法总是使用sRGB格式，你想节约内存是不行的，在支持`p3`的设备上想绘制出来`p3`色域的图片也是不行的。那么使用`UIGraphicsImageRenderer`系统可以自动为你选择格式，如果绘制`image`，自己再添加单色蒙版，是不需要另外单独分配内存的。\n```\nif let im = imageV {\n//第二次添加蒙版\n\tim.tintColor = UIColor.black\n}else{\n//绘制一个红色矩形\n\tlet bounds = CGRect(x: 0, y: 0, width: width, height: height)\n\tlet renderer = UIGraphicsImageRenderer(bounds: bounds)\n\t let image = renderer.image { (coxt) in\n\t\tUIColor.red.setFill()\n\t\tlet path = UIBezierPath(roundedRect: bounds,\n\t\t\t\t\t\t\t\tcornerRadius: 20)\n\t\tpath.addClip()\n\t\tUIRectFill(bounds)\n\t}\n\timageV = UIImageView(image: image)\n\timageV?.frame = bounds\n\tself.view.addSubview(imageV!)\n}\n```\n\n`UIImage` 直接读出来需要将所有`UIImage`的`data`全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用**下采样**。\n### 下采样\n当`image`素材大小是`1000*1000`，但是在手机上显示出来只有`200*200`，我们其实是没必要将`1000*1000`的数据都解码的，只需要缩小成`200*200`的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。\n在`UIKit`中使用`UIGraphicsImageRenderer`会有瞬间很高的内存和CPU峰值，那么\n#### 1.UIKit  UIGraphicsImageRenderer\n使用素材A下采样技术，使用`UIKit`中的`UIGraphicsImageRenderer`\n\n```\nMemory \nHigh:16.4M\nnormal:14.8M\nCPU:\nHight:29%\nnormal:0%\n```\n\n```\nfunc resizedImage(at url: URL, for size: CGSize) -> UIImage? {\n\tguard let image = UIImage(contentsOfFile: url.path) else {\n\t\treturn nil\n\t}\n\tif #available(iOS 10.0, *) {\n\t\tlet renderer = UIGraphicsImageRenderer(size: size)\n\t\n\t\treturn renderer.image { (context) in\n\t\t\timage.draw(in: CGRect(origin: .zero, size: size))\n\t\t}\n\t}else{\n\t\tUIGraphicsBeginImageContext(size)\n\t\timage.draw(in: CGRect(origin: .zero, size: size))\n\t\tlet image = UIGraphicsGetImageFromCurrentImageContext()\n\t\tUIGraphicsEndImageContext()\n\t\treturn image\n\t}\n}\n```\n\n用子线程绘制，会出现CPU略微升高，当`image size`大很多的时候会出现内存飙升然后慢慢恢复到`normal`。\n\n#### 2.CoreGraphics CGContext上下文绘制缩略图\n\n使用上下文绘制 `cpu` 和内存变化如下,`CPU`和内存没有大的变动解决了该问题，也做到省电、顺滑。\n```\nMemory \nHigh:42.3M\nnormal:14.1M\nCPU:\nHight:6%\nnormal:0%\n```\n```\nfunc resizedImage2(at url: URL, for size: CGSize) -> UIImage?{\n\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)\n\telse{\n\t\treturn nil;\n\t}\n\tlet cxt = CGContext(data: nil,\n\t\t\t\t\t\twidth: Int(size.width),\n\t\t\t\t\t\theight: Int(size.height),\n\t\t\t\t\t\tbitsPerComponent: image.bitsPerComponent,\n\t\t\t\t\t\tbytesPerRow: image.bytesPerRow,\n\t\t\t\t\t\tspace: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!\n\t\t,\n\t\t\t\t\t\tbitmapInfo: image.bitmapInfo.rawValue)\n\tcxt?.interpolationQuality = .high\n\tcxt?.draw(image, in: CGRect(origin: .zero, size: size))\n\tguard let scaledImage = cxt?.makeImage() else {\n\t\treturn nil\n\t}\n\tlet ima = UIImage(cgImage: scaledImage)\n\treturn ima\n\t\n}\n```\n\n#### 3.ImageIO 创建缩略图\n使用`ImageIO` 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。\n```\nMemory \nHigh:320M\nnormal:221M\nCPU:\nHight:73%\nnormal:0%\n```\n\n```\nfunc resizedImage3(at url: URL, for size: CGSize) -> UIImage?{\n\t\n\tlet ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,\n\t\t\t\t\t\t\t  kCGImageSourceCreateThumbnailWithTransform:true,\n\t\t\t\t\t\t\t  kCGImageSourceShouldCacheImmediately:true,\n\t\t\t\t\t\t\t  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]\n\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else {\n\t\t\treturn nil;\n\t}\n\tlet ima = UIImage(cgImage: image)\n\tprintImageCost(image: ima)\n\treturn ima\n}\n```\n#### 4.CoreImage 滤镜\n使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。\n```\nMemory \nHigh:1.04G\nnormal:566M\nCPU:\nHight:73%\nnormal:0%\n```\n```\n\tfunc resizedImage4(at url: URL, for size: CGSize) -> UIImage?{\n\t\tlet shareContext = CIContext(options: [.useSoftwareRenderer:false])\n\t\t\n\t\t guard let image = CIImage(contentsOf: url) else { return nil }\n\t\tlet fillter = CIFilter(name: \"CILanczosScaleTransform\")\n\t\tfillter?.setValue(image, forKey: kCIInputImageKey)\n\t\tfillter?.setValue(1, forKey: kCIInputScaleKey)\n\t\tguard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else { return nil }\n\t\t\n\t\treturn UIImage(cgImage: outputCGImage)\n\t}\n```\n\n#### 5.使用 vImage 优化图片渲染\n使用`vImage`创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要`crash`了。\n```\nMemory \nHigh:998.7M\nnormal:566M\nCPU:\nHight:78%\nnormal:0%\n```\n\n```\nfunc resizedImage5(at url: URL, for size: CGSize) -> UIImage? {\n    // 解码源图像\n    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),\n        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),\n        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],\n        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,\n        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount\n    else {\n        return nil\n    }\n\n    // 定义图像格式\n    var format = vImage_CGImageFormat(bitsPerComponent: 8,\n                                      bitsPerPixel: 32,\n                                      colorSpace: nil,\n                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),\n                                      version: 0,\n                                      decode: nil,\n                                      renderingIntent: .defaultIntent)\n\n    var error: vImage_Error\n\n    // 创建并初始化源缓冲区\n    var sourceBuffer = vImage_Buffer()\n    defer { sourceBuffer.data.deallocate() }\n    error = vImageBuffer_InitWithCGImage(&sourceBuffer,\n                                         &format,\n                                         nil,\n                                         image,\n                                         vImage_Flags(kvImageNoFlags))\n    guard error == kvImageNoError else { return nil }\n\n    // 创建并初始化目标缓冲区\n    var destinationBuffer = vImage_Buffer()\n    error = vImageBuffer_Init(&destinationBuffer,\n                              vImagePixelCount(size.height),\n                              vImagePixelCount(size.width),\n                              format.bitsPerPixel,\n                              vImage_Flags(kvImageNoFlags))\n    guard error == kvImageNoError else { return nil }\n\n    // 优化缩放图像\n    error = vImageScale_ARGB8888(&sourceBuffer,\n                                 &destinationBuffer,\n                                 nil,\n                                 vImage_Flags(kvImageHighQualityResampling))\n    guard error == kvImageNoError else { return nil }\n\n    // 从目标缓冲区创建一个 CGImage 对象\n    guard let resizedImage =\n        vImageCreateCGImageFromBuffer(&destinationBuffer,\n                                      &format,\n                                      nil,\n                                      nil,\n                                      vImage_Flags(kvImageNoAllocate),\n                                      &error)?.takeRetainedValue(),\n        error == kvImageNoError\n    else {\n        return nil\n    }\n\n    return UIImage(cgImage: resizedImage)\n}\n```\n### 内存优化\n图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。\n\n在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。\n```\n# 1\nNotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,\n\t\t\t\t\t\t\t\t\t   object: nil,\n\t\t\t\t\t\t\t\t\t   queue: .main)\n{[weak self] (note) in\n\tself?.unloadImage()\n}\nNotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,\n\t\t\t\t\t\t\t\t\t   object: nil,\n\t\t\t\t\t\t\t\t\t   queue: .main)\n{[weak self] (note) in\n\tself?.loadImage()\n}\n# 2\n\noverride func viewWillAppear(_ animated: Bool) {\n\tsuper.viewWillAppear(animated)\n\tself.loadImage()\n}\noverride func viewWillDisappear(_ animated: Bool) {\n\tsuper.viewWillDisappear(animated)\n\tself.unloadImage()\n}\n```\n\n### 总结\n- 基于性能综合考虑方法1是最简单最合适的\n- 使用滤镜和`vImage`略微复杂点，平时开发过程中可以不用考虑了。\n- 图片解码缓存和图片大小有关，适当的下采样是不错的选择。\n\n\n\n\n\n### 参考\n- [session 2018 416 iOS Memory Deep Dive](https://developer.apple.com/videos/play/wwdc2018/416)\n- [219_image_and_graphics_best_practices](https://developer.apple.com/videos/play/wwdc2018/219)\n- [WWDC 中文字幕下载](https://github.com/ifgyong/iOSDataFactory)\n- [swift gg 图像优化](https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1)\n\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master)\n\n \n \n**唯有实践才是检验真理的唯一标准**\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n\n\n广告时间\n\n![](../images/0.png)\n\n\n","slug":"iOS图片优化 ","published":1,"updated":"2019-12-03T06:44:16.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2f000f9zskdh2j61sb","content":"<p>基于现在iOS11新生成的图片都是<code>HEIF</code>，该图片使用<code>[UIImage image:name]</code>已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。</p>\n<p>既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?</p>\n<p>这就要先了解该图片的编码了。</p>\n<h2 id=\"HEIC-HEIF\"><a href=\"#HEIC-HEIF\" class=\"headerlink\" title=\"HEIC HEIF\"></a>HEIC HEIF</h2><blockquote>\n<p>带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件</p>\n</blockquote>\n<p><code>heic</code>和<code>heif</code>是广色域图片的格式，广色域比<code>sRGB</code>表示范围大25%，在广色域设备中能显示更广的色彩，<code>sRGB 8bit/dept</code>，广色域达到<code>16bit/dept</code>。广色域只是在硬件支持的情况下才能显示的。<br>其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。</p>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>加载<code>image</code>，只是把<strong>文件信息</strong>加载到内存中，下一步就是解码。在代码中体现就是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let image = UIImage(contentsOfFile: url.path)</div><div class=\"line\">或 加载图片到内存 会常驻内存</div><div class=\"line\">let image = UIImage(named: name)!</div></pre></td></tr></table></figure></p>\n<h2 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h2><p>其实是发生在添加到要显示的view上面才会解码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imageV = UIImageView.init(image: image)</div><div class=\"line\">imageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)</div><div class=\"line\">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>\n<p>最后一行不写，则不会解码。</p>\n<h2 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h2><p>当<code>view</code>显示出来则是渲染。过程是解码的<code>data buffer</code> 复制到<code>frame buffer</code>,硬件从帧缓冲区读取数据显示到屏幕上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>\n<h2 id=\"内存暴涨原因\"><a href=\"#内存暴涨原因\" class=\"headerlink\" title=\"内存暴涨原因\"></a>内存暴涨原因</h2><p>一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。</p>\n<p>首先有请我们准备的素材和设备(6s 64g版本)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">A:jpg</div><div class=\"line\">20M 12000*12000</div><div class=\"line\"></div><div class=\"line\">B:jpg</div><div class=\"line\">2.8M 3024*4032</div><div class=\"line\"></div><div class=\"line\">C:HEIC</div><div class=\"line\">1.8M 3024*4032</div></pre></td></tr></table></figure></p>\n<p>素材A<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.8M</div><div class=\"line\">加载Image: 240.3M之后稳定到220M</div><div class=\"line\">CPU：峰值5%，随后降低到0%</div><div class=\"line\">image占内存：226.5M</div></pre></td></tr></table></figure></p>\n<p>素材B<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.7M</div><div class=\"line\">加载Image: 31.5</div><div class=\"line\">CPU：峰值5%，随后降低到0%</div><div class=\"line\">image占内存：17.8M</div></pre></td></tr></table></figure></p>\n<p>素材C<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.8M</div><div class=\"line\">加载Image: 32.3</div><div class=\"line\">CPU：峰值4%，随后降低到0%</div><div class=\"line\">image占内存：18.5M</div></pre></td></tr></table></figure></p>\n<p>我们猜测是否是<code>imageView</code>的大小影响内存的呢？<br><code>size</code>改为原来的1/10结果运行内存还是和以前一样。</p>\n<p>为什么呢？</p>\n<blockquote>\n<p>内存大小不是取决于<code>view</code>的<code>size</code>，而是原始文件<strong>image size</strong>。</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/11/29/16eb5cff5d35a254?w=1016&amp;h=542&amp;f=png&amp;s=54318\" alt=\"\"></p>\n<h3 id=\"渲染格式\"><a href=\"#渲染格式\" class=\"headerlink\" title=\"渲染格式\"></a>渲染格式</h3><h4 id=\"SRGB\"><a href=\"#SRGB\" class=\"headerlink\" title=\"SRGB\"></a>SRGB</h4><p>每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。</p>\n<h4 id=\"display-p3-宽色域\"><a href=\"#display-p3-宽色域\" class=\"headerlink\" title=\"display p3 宽色域\"></a>display p3 宽色域</h4><p>每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。</p>\n<h4 id=\"亮度和透明度\"><a href=\"#亮度和透明度\" class=\"headerlink\" title=\"亮度和透明度\"></a>亮度和透明度</h4><p>每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。</p>\n<h4 id=\"Alpha-8-Format\"><a href=\"#Alpha-8-Format\" class=\"headerlink\" title=\"Alpha 8 Format\"></a>Alpha 8 Format</h4><p>每个像素1字节，用来表示透明度，一般用作蒙版和文字。<br>相比sRGB容量小了75%，详细 宽色域 容量小了87.5%</p>\n<h3 id=\"渲染图片大小计算\"><a href=\"#渲染图片大小计算\" class=\"headerlink\" title=\"渲染图片大小计算\"></a>渲染图片大小计算</h3><p>图片大小 = 图片格式容量 <em> 像素个数<br>当我们把大小是20\\</em>20使用<code>Alpha 8 format</code>渲染到20*20的view上面，和40*40的image使用<code>p3</code>渲染到20*20的view中，后着占用内存是前者的8倍。</p>\n<p>使用sRGB色域进行渲染所占用的大小为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageWidth*imageHeight*4 字节</div></pre></td></tr></table></figure></p>\n<p>每个像素占用了4字节，每个字节8位，</p>\n<p>使用<code>display p3</code>则每个通道占用16位，那么占用内存大小是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageWidth*imageHeight*8 字节</div></pre></td></tr></table></figure></p>\n<h3 id=\"如何选择正确的图片格式\"><a href=\"#如何选择正确的图片格式\" class=\"headerlink\" title=\"如何选择正确的图片格式\"></a>如何选择正确的图片格式</h3><blockquote>\n<p>不要主动选择图片格式，让格式选择你。</p>\n</blockquote>\n<p>不要再使用<code>UIGraphicsBeginImageContextWithOptions</code>,该方法总是使用sRGB格式，你想节约内存是不行的，在支持<code>p3</code>的设备上想绘制出来<code>p3</code>色域的图片也是不行的。那么使用<code>UIGraphicsImageRenderer</code>系统可以自动为你选择格式，如果绘制<code>image</code>，自己再添加单色蒙版，是不需要另外单独分配内存的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let im = imageV &#123;</div><div class=\"line\">//第二次添加蒙版</div><div class=\"line\">\tim.tintColor = UIColor.black</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">//绘制一个红色矩形</div><div class=\"line\">\tlet bounds = CGRect(x: 0, y: 0, width: width, height: height)</div><div class=\"line\">\tlet renderer = UIGraphicsImageRenderer(bounds: bounds)</div><div class=\"line\">\t let image = renderer.image &#123; (coxt) in</div><div class=\"line\">\t\tUIColor.red.setFill()</div><div class=\"line\">\t\tlet path = UIBezierPath(roundedRect: bounds,</div><div class=\"line\">\t\t\t\t\t\t\t\tcornerRadius: 20)</div><div class=\"line\">\t\tpath.addClip()</div><div class=\"line\">\t\tUIRectFill(bounds)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\timageV = UIImageView(image: image)</div><div class=\"line\">\timageV?.frame = bounds</div><div class=\"line\">\tself.view.addSubview(imageV!)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>UIImage</code> 直接读出来需要将所有<code>UIImage</code>的<code>data</code>全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用<strong>下采样</strong>。</p>\n<h3 id=\"下采样\"><a href=\"#下采样\" class=\"headerlink\" title=\"下采样\"></a>下采样</h3><p>当<code>image</code>素材大小是<code>1000*1000</code>，但是在手机上显示出来只有<code>200*200</code>，我们其实是没必要将<code>1000*1000</code>的数据都解码的，只需要缩小成<code>200*200</code>的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。<br>在<code>UIKit</code>中使用<code>UIGraphicsImageRenderer</code>会有瞬间很高的内存和CPU峰值，那么</p>\n<h4 id=\"1-UIKit-UIGraphicsImageRenderer\"><a href=\"#1-UIKit-UIGraphicsImageRenderer\" class=\"headerlink\" title=\"1.UIKit  UIGraphicsImageRenderer\"></a>1.UIKit  UIGraphicsImageRenderer</h4><p>使用素材A下采样技术，使用<code>UIKit</code>中的<code>UIGraphicsImageRenderer</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:16.4M</div><div class=\"line\">normal:14.8M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:29%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class=\"line\">\tguard let image = UIImage(contentsOfFile: url.path) else &#123;</div><div class=\"line\">\t\treturn nil</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif #available(iOS 10.0, *) &#123;</div><div class=\"line\">\t\tlet renderer = UIGraphicsImageRenderer(size: size)</div><div class=\"line\">\t</div><div class=\"line\">\t\treturn renderer.image &#123; (context) in</div><div class=\"line\">\t\t\timage.draw(in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tUIGraphicsBeginImageContext(size)</div><div class=\"line\">\t\timage.draw(in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\t\tlet image = UIGraphicsGetImageFromCurrentImageContext()</div><div class=\"line\">\t\tUIGraphicsEndImageContext()</div><div class=\"line\">\t\treturn image</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用子线程绘制，会出现CPU略微升高，当<code>image size</code>大很多的时候会出现内存飙升然后慢慢恢复到<code>normal</code>。</p>\n<h4 id=\"2-CoreGraphics-CGContext上下文绘制缩略图\"><a href=\"#2-CoreGraphics-CGContext上下文绘制缩略图\" class=\"headerlink\" title=\"2.CoreGraphics CGContext上下文绘制缩略图\"></a>2.CoreGraphics CGContext上下文绘制缩略图</h4><p>使用上下文绘制 <code>cpu</code> 和内存变化如下,<code>CPU</code>和内存没有大的变动解决了该问题，也做到省电、顺滑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:42.3M</div><div class=\"line\">normal:14.1M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:6%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage2(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)</div><div class=\"line\">\telse&#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet cxt = CGContext(data: nil,</div><div class=\"line\">\t\t\t\t\t\twidth: Int(size.width),</div><div class=\"line\">\t\t\t\t\t\theight: Int(size.height),</div><div class=\"line\">\t\t\t\t\t\tbitsPerComponent: image.bitsPerComponent,</div><div class=\"line\">\t\t\t\t\t\tbytesPerRow: image.bytesPerRow,</div><div class=\"line\">\t\t\t\t\t\tspace: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!</div><div class=\"line\">\t\t,</div><div class=\"line\">\t\t\t\t\t\tbitmapInfo: image.bitmapInfo.rawValue)</div><div class=\"line\">\tcxt?.interpolationQuality = .high</div><div class=\"line\">\tcxt?.draw(image, in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\tguard let scaledImage = cxt?.makeImage() else &#123;</div><div class=\"line\">\t\treturn nil</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet ima = UIImage(cgImage: scaledImage)</div><div class=\"line\">\treturn ima</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-ImageIO-创建缩略图\"><a href=\"#3-ImageIO-创建缩略图\" class=\"headerlink\" title=\"3.ImageIO 创建缩略图\"></a>3.ImageIO 创建缩略图</h4><p>使用<code>ImageIO</code> 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:320M</div><div class=\"line\">normal:221M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:73%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage3(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\t</div><div class=\"line\">\tlet ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceCreateThumbnailWithTransform:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceShouldCacheImmediately:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]</div><div class=\"line\">\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else &#123;</div><div class=\"line\">\t\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet ima = UIImage(cgImage: image)</div><div class=\"line\">\tprintImageCost(image: ima)</div><div class=\"line\">\treturn ima</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-CoreImage-滤镜\"><a href=\"#4-CoreImage-滤镜\" class=\"headerlink\" title=\"4.CoreImage 滤镜\"></a>4.CoreImage 滤镜</h4><p>使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:1.04G</div><div class=\"line\">normal:566M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:73%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage4(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\tlet shareContext = CIContext(options: [.useSoftwareRenderer:false])</div><div class=\"line\">\t</div><div class=\"line\">\t guard let image = CIImage(contentsOf: url) else &#123; return nil &#125;</div><div class=\"line\">\tlet fillter = CIFilter(name: &quot;CILanczosScaleTransform&quot;)</div><div class=\"line\">\tfillter?.setValue(image, forKey: kCIInputImageKey)</div><div class=\"line\">\tfillter?.setValue(1, forKey: kCIInputScaleKey)</div><div class=\"line\">\tguard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else &#123; return nil &#125;</div><div class=\"line\">\t</div><div class=\"line\">\treturn UIImage(cgImage: outputCGImage)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-使用-vImage-优化图片渲染\"><a href=\"#5-使用-vImage-优化图片渲染\" class=\"headerlink\" title=\"5.使用 vImage 优化图片渲染\"></a>5.使用 vImage 优化图片渲染</h4><p>使用<code>vImage</code>创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要<code>crash</code>了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:998.7M</div><div class=\"line\">normal:566M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:78%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage5(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class=\"line\">    // 解码源图像</div><div class=\"line\">    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),</div><div class=\"line\">        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],</div><div class=\"line\">        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,</div><div class=\"line\">        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 定义图像格式</div><div class=\"line\">    var format = vImage_CGImageFormat(bitsPerComponent: 8,</div><div class=\"line\">                                      bitsPerPixel: 32,</div><div class=\"line\">                                      colorSpace: nil,</div><div class=\"line\">                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),</div><div class=\"line\">                                      version: 0,</div><div class=\"line\">                                      decode: nil,</div><div class=\"line\">                                      renderingIntent: .defaultIntent)</div><div class=\"line\"></div><div class=\"line\">    var error: vImage_Error</div><div class=\"line\"></div><div class=\"line\">    // 创建并初始化源缓冲区</div><div class=\"line\">    var sourceBuffer = vImage_Buffer()</div><div class=\"line\">    defer &#123; sourceBuffer.data.deallocate() &#125;</div><div class=\"line\">    error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</div><div class=\"line\">                                         &amp;format,</div><div class=\"line\">                                         nil,</div><div class=\"line\">                                         image,</div><div class=\"line\">                                         vImage_Flags(kvImageNoFlags))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 创建并初始化目标缓冲区</div><div class=\"line\">    var destinationBuffer = vImage_Buffer()</div><div class=\"line\">    error = vImageBuffer_Init(&amp;destinationBuffer,</div><div class=\"line\">                              vImagePixelCount(size.height),</div><div class=\"line\">                              vImagePixelCount(size.width),</div><div class=\"line\">                              format.bitsPerPixel,</div><div class=\"line\">                              vImage_Flags(kvImageNoFlags))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 优化缩放图像</div><div class=\"line\">    error = vImageScale_ARGB8888(&amp;sourceBuffer,</div><div class=\"line\">                                 &amp;destinationBuffer,</div><div class=\"line\">                                 nil,</div><div class=\"line\">                                 vImage_Flags(kvImageHighQualityResampling))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 从目标缓冲区创建一个 CGImage 对象</div><div class=\"line\">    guard let resizedImage =</div><div class=\"line\">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</div><div class=\"line\">                                      &amp;format,</div><div class=\"line\">                                      nil,</div><div class=\"line\">                                      nil,</div><div class=\"line\">                                      vImage_Flags(kvImageNoAllocate),</div><div class=\"line\">                                      &amp;error)?.takeRetainedValue(),</div><div class=\"line\">        error == kvImageNoError</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return UIImage(cgImage: resizedImage)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h3><p>图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。</p>\n<p>在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 1</div><div class=\"line\">NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   object: nil,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   queue: .main)</div><div class=\"line\">&#123;[weak self] (note) in</div><div class=\"line\">\tself?.unloadImage()</div><div class=\"line\">&#125;</div><div class=\"line\">NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   object: nil,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   queue: .main)</div><div class=\"line\">&#123;[weak self] (note) in</div><div class=\"line\">\tself?.loadImage()</div><div class=\"line\">&#125;</div><div class=\"line\"># 2</div><div class=\"line\"></div><div class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</div><div class=\"line\">\tsuper.viewWillAppear(animated)</div><div class=\"line\">\tself.loadImage()</div><div class=\"line\">&#125;</div><div class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</div><div class=\"line\">\tsuper.viewWillDisappear(animated)</div><div class=\"line\">\tself.unloadImage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>基于性能综合考虑方法1是最简单最合适的</li>\n<li>使用滤镜和<code>vImage</code>略微复杂点，平时开发过程中可以不用考虑了。</li>\n<li>图片解码缓存和图片大小有关，适当的下采样是不错的选择。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2018/416\" target=\"_blank\" rel=\"external\">session 2018 416 iOS Memory Deep Dive</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2018/219\" target=\"_blank\" rel=\"external\">219_image_and_graphics_best_practices</a></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">WWDC 中文字幕下载</a></li>\n<li><p><a href=\"https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1\" target=\"_blank\" rel=\"external\">swift gg 图像优化</a></p>\n</li>\n<li><p><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></p>\n</li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n</ul>\n<h2 id=\"唯有实践才是检验真理的唯一标准\"><a href=\"#唯有实践才是检验真理的唯一标准\" class=\"headerlink\" title=\"唯有实践才是检验真理的唯一标准\"></a><strong>唯有实践才是检验真理的唯一标准</strong></h2><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>基于现在iOS11新生成的图片都是<code>HEIF</code>，该图片使用<code>[UIImage image:name]</code>已不在那么优雅，图片大小为1.8m大小的，读进手机内存，直接飙升了45M，这是我们不想看到的结果，一个页面有多个这样子的图的话，恐怕就是灾难了。</p>\n<p>既然原图不能读入，那么如何可以用更少的内存和CPU来解决呢?</p>\n<p>这就要先了解该图片的编码了。</p>\n<h2 id=\"HEIC-HEIF\"><a href=\"#HEIC-HEIF\" class=\"headerlink\" title=\"HEIC HEIF\"></a>HEIC HEIF</h2><blockquote>\n<p>带有元数据的HEIF的另一种形式。HEIC文件包含一个或多个以“高效图像格式”（HEIF）保存的图像，该格式通常用于在移动设备上存储照片。它可能包含单个图像或图像序列以及描述每个图像的元数据。最常使用文件扩展名“ .heic”，但HEIC文件也可能显示为.HEIF文件</p>\n</blockquote>\n<p><code>heic</code>和<code>heif</code>是广色域图片的格式，广色域比<code>sRGB</code>表示范围大25%，在广色域设备中能显示更广的色彩，<code>sRGB 8bit/dept</code>，广色域达到<code>16bit/dept</code>。广色域只是在硬件支持的情况下才能显示的。<br>其实就是苹果搞的一个更高效体积更小效率更高的压缩方式。</p>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>加载<code>image</code>，只是把<strong>文件信息</strong>加载到内存中，下一步就是解码。在代码中体现就是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let image = UIImage(contentsOfFile: url.path)</div><div class=\"line\">或 加载图片到内存 会常驻内存</div><div class=\"line\">let image = UIImage(named: name)!</div></pre></td></tr></table></figure></p>\n<h2 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h2><p>其实是发生在添加到要显示的view上面才会解码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imageV = UIImageView.init(image: image)</div><div class=\"line\">imageV.frame = CGRect(x: 50, y: (250 * i) + 100, width: 200, height: 200)</div><div class=\"line\">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>\n<p>最后一行不写，则不会解码。</p>\n<h2 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h2><p>当<code>view</code>显示出来则是渲染。过程是解码的<code>data buffer</code> 复制到<code>frame buffer</code>,硬件从帧缓冲区读取数据显示到屏幕上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.view.addSubview(imageV)</div></pre></td></tr></table></figure></p>\n<h2 id=\"内存暴涨原因\"><a href=\"#内存暴涨原因\" class=\"headerlink\" title=\"内存暴涨原因\"></a>内存暴涨原因</h2><p>一部分图片加载到内存，在解码过程中出现了内存暴涨问题，今天探究一下原因和解决方案。</p>\n<p>首先有请我们准备的素材和设备(6s 64g版本)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">A:jpg</div><div class=\"line\">20M 12000*12000</div><div class=\"line\"></div><div class=\"line\">B:jpg</div><div class=\"line\">2.8M 3024*4032</div><div class=\"line\"></div><div class=\"line\">C:HEIC</div><div class=\"line\">1.8M 3024*4032</div></pre></td></tr></table></figure></p>\n<p>素材A<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.8M</div><div class=\"line\">加载Image: 240.3M之后稳定到220M</div><div class=\"line\">CPU：峰值5%，随后降低到0%</div><div class=\"line\">image占内存：226.5M</div></pre></td></tr></table></figure></p>\n<p>素材B<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.7M</div><div class=\"line\">加载Image: 31.5</div><div class=\"line\">CPU：峰值5%，随后降低到0%</div><div class=\"line\">image占内存：17.8M</div></pre></td></tr></table></figure></p>\n<p>素材C<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP运行内存：13.8M</div><div class=\"line\">加载Image: 32.3</div><div class=\"line\">CPU：峰值4%，随后降低到0%</div><div class=\"line\">image占内存：18.5M</div></pre></td></tr></table></figure></p>\n<p>我们猜测是否是<code>imageView</code>的大小影响内存的呢？<br><code>size</code>改为原来的1/10结果运行内存还是和以前一样。</p>\n<p>为什么呢？</p>\n<blockquote>\n<p>内存大小不是取决于<code>view</code>的<code>size</code>，而是原始文件<strong>image size</strong>。</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/11/29/16eb5cff5d35a254?w=1016&amp;h=542&amp;f=png&amp;s=54318\" alt=\"\"></p>\n<h3 id=\"渲染格式\"><a href=\"#渲染格式\" class=\"headerlink\" title=\"渲染格式\"></a>渲染格式</h3><h4 id=\"SRGB\"><a href=\"#SRGB\" class=\"headerlink\" title=\"SRGB\"></a>SRGB</h4><p>每个像素4字节，包含红黄蓝和透明度，每个通道是1字节8位。</p>\n<h4 id=\"display-p3-宽色域\"><a href=\"#display-p3-宽色域\" class=\"headerlink\" title=\"display p3 宽色域\"></a>display p3 宽色域</h4><p>每个像素8字节，包含红黄蓝和透明度，每个通道是2字节16位。使用机型iphone7 、iphone8、iphone X及以后的设备，不支持该格式的机型无法显示该效果。</p>\n<h4 id=\"亮度和透明度\"><a href=\"#亮度和透明度\" class=\"headerlink\" title=\"亮度和透明度\"></a>亮度和透明度</h4><p>每个像素2字节，单一的色调和透明度，只能来显示白色和黑色之间的色值，没有其他颜色。</p>\n<h4 id=\"Alpha-8-Format\"><a href=\"#Alpha-8-Format\" class=\"headerlink\" title=\"Alpha 8 Format\"></a>Alpha 8 Format</h4><p>每个像素1字节，用来表示透明度，一般用作蒙版和文字。<br>相比sRGB容量小了75%，详细 宽色域 容量小了87.5%</p>\n<h3 id=\"渲染图片大小计算\"><a href=\"#渲染图片大小计算\" class=\"headerlink\" title=\"渲染图片大小计算\"></a>渲染图片大小计算</h3><p>图片大小 = 图片格式容量 <em> 像素个数<br>当我们把大小是20\\</em>20使用<code>Alpha 8 format</code>渲染到20*20的view上面，和40*40的image使用<code>p3</code>渲染到20*20的view中，后着占用内存是前者的8倍。</p>\n<p>使用sRGB色域进行渲染所占用的大小为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageWidth*imageHeight*4 字节</div></pre></td></tr></table></figure></p>\n<p>每个像素占用了4字节，每个字节8位，</p>\n<p>使用<code>display p3</code>则每个通道占用16位，那么占用内存大小是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">imageWidth*imageHeight*8 字节</div></pre></td></tr></table></figure></p>\n<h3 id=\"如何选择正确的图片格式\"><a href=\"#如何选择正确的图片格式\" class=\"headerlink\" title=\"如何选择正确的图片格式\"></a>如何选择正确的图片格式</h3><blockquote>\n<p>不要主动选择图片格式，让格式选择你。</p>\n</blockquote>\n<p>不要再使用<code>UIGraphicsBeginImageContextWithOptions</code>,该方法总是使用sRGB格式，你想节约内存是不行的，在支持<code>p3</code>的设备上想绘制出来<code>p3</code>色域的图片也是不行的。那么使用<code>UIGraphicsImageRenderer</code>系统可以自动为你选择格式，如果绘制<code>image</code>，自己再添加单色蒙版，是不需要另外单独分配内存的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let im = imageV &#123;</div><div class=\"line\">//第二次添加蒙版</div><div class=\"line\">\tim.tintColor = UIColor.black</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">//绘制一个红色矩形</div><div class=\"line\">\tlet bounds = CGRect(x: 0, y: 0, width: width, height: height)</div><div class=\"line\">\tlet renderer = UIGraphicsImageRenderer(bounds: bounds)</div><div class=\"line\">\t let image = renderer.image &#123; (coxt) in</div><div class=\"line\">\t\tUIColor.red.setFill()</div><div class=\"line\">\t\tlet path = UIBezierPath(roundedRect: bounds,</div><div class=\"line\">\t\t\t\t\t\t\t\tcornerRadius: 20)</div><div class=\"line\">\t\tpath.addClip()</div><div class=\"line\">\t\tUIRectFill(bounds)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\timageV = UIImageView(image: image)</div><div class=\"line\">\timageV?.frame = bounds</div><div class=\"line\">\tself.view.addSubview(imageV!)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>UIImage</code> 直接读出来需要将所有<code>UIImage</code>的<code>data</code>全部解码到内存，很耗费内存和性能。为了节省内存和降低CPU使用率，可以采用<strong>下采样</strong>。</p>\n<h3 id=\"下采样\"><a href=\"#下采样\" class=\"headerlink\" title=\"下采样\"></a>下采样</h3><p>当<code>image</code>素材大小是<code>1000*1000</code>，但是在手机上显示出来只有<code>200*200</code>，我们其实是没必要将<code>1000*1000</code>的数据都解码的，只需要缩小成<code>200*200</code>的大小即可，这样子节省了内存和CPU，用户感官也没有任何影响。<br>在<code>UIKit</code>中使用<code>UIGraphicsImageRenderer</code>会有瞬间很高的内存和CPU峰值，那么</p>\n<h4 id=\"1-UIKit-UIGraphicsImageRenderer\"><a href=\"#1-UIKit-UIGraphicsImageRenderer\" class=\"headerlink\" title=\"1.UIKit  UIGraphicsImageRenderer\"></a>1.UIKit  UIGraphicsImageRenderer</h4><p>使用素材A下采样技术，使用<code>UIKit</code>中的<code>UIGraphicsImageRenderer</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:16.4M</div><div class=\"line\">normal:14.8M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:29%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class=\"line\">\tguard let image = UIImage(contentsOfFile: url.path) else &#123;</div><div class=\"line\">\t\treturn nil</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif #available(iOS 10.0, *) &#123;</div><div class=\"line\">\t\tlet renderer = UIGraphicsImageRenderer(size: size)</div><div class=\"line\">\t</div><div class=\"line\">\t\treturn renderer.image &#123; (context) in</div><div class=\"line\">\t\t\timage.draw(in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tUIGraphicsBeginImageContext(size)</div><div class=\"line\">\t\timage.draw(in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\t\tlet image = UIGraphicsGetImageFromCurrentImageContext()</div><div class=\"line\">\t\tUIGraphicsEndImageContext()</div><div class=\"line\">\t\treturn image</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用子线程绘制，会出现CPU略微升高，当<code>image size</code>大很多的时候会出现内存飙升然后慢慢恢复到<code>normal</code>。</p>\n<h4 id=\"2-CoreGraphics-CGContext上下文绘制缩略图\"><a href=\"#2-CoreGraphics-CGContext上下文绘制缩略图\" class=\"headerlink\" title=\"2.CoreGraphics CGContext上下文绘制缩略图\"></a>2.CoreGraphics CGContext上下文绘制缩略图</h4><p>使用上下文绘制 <code>cpu</code> 和内存变化如下,<code>CPU</code>和内存没有大的变动解决了该问题，也做到省电、顺滑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:42.3M</div><div class=\"line\">normal:14.1M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:6%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage2(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)</div><div class=\"line\">\telse&#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet cxt = CGContext(data: nil,</div><div class=\"line\">\t\t\t\t\t\twidth: Int(size.width),</div><div class=\"line\">\t\t\t\t\t\theight: Int(size.height),</div><div class=\"line\">\t\t\t\t\t\tbitsPerComponent: image.bitsPerComponent,</div><div class=\"line\">\t\t\t\t\t\tbytesPerRow: image.bytesPerRow,</div><div class=\"line\">\t\t\t\t\t\tspace: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!</div><div class=\"line\">\t\t,</div><div class=\"line\">\t\t\t\t\t\tbitmapInfo: image.bitmapInfo.rawValue)</div><div class=\"line\">\tcxt?.interpolationQuality = .high</div><div class=\"line\">\tcxt?.draw(image, in: CGRect(origin: .zero, size: size))</div><div class=\"line\">\tguard let scaledImage = cxt?.makeImage() else &#123;</div><div class=\"line\">\t\treturn nil</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet ima = UIImage(cgImage: scaledImage)</div><div class=\"line\">\treturn ima</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-ImageIO-创建缩略图\"><a href=\"#3-ImageIO-创建缩略图\" class=\"headerlink\" title=\"3.ImageIO 创建缩略图\"></a>3.ImageIO 创建缩略图</h4><p>使用<code>ImageIO</code> 中创建图像，CPU和内存记录反而更高了，内存也居高不下，时间上基本2s才将图像绘制出来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:320M</div><div class=\"line\">normal:221M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:73%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage3(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\t</div><div class=\"line\">\tlet ops:[CFString:Any] = [kCGImageSourceCreateThumbnailFromImageIfAbsent:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceCreateThumbnailWithTransform:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceShouldCacheImmediately:true,</div><div class=\"line\">\t\t\t\t\t\t\t  kCGImageSourceThumbnailMaxPixelSize:max(size.width, size.height)]</div><div class=\"line\">\tguard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">\t\tlet image = CGImageSourceCreateImageAtIndex(imageSource, 0, ops as CFDictionary) else &#123;</div><div class=\"line\">\t\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tlet ima = UIImage(cgImage: image)</div><div class=\"line\">\tprintImageCost(image: ima)</div><div class=\"line\">\treturn ima</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-CoreImage-滤镜\"><a href=\"#4-CoreImage-滤镜\" class=\"headerlink\" title=\"4.CoreImage 滤镜\"></a>4.CoreImage 滤镜</h4><p>使用滤镜处理反而有点麻烦，在iOS不是专业处理图像的APP中略微臃肿，而且性能不是很好。在重复删除添加操作，第二次出现了APP闪退问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:1.04G</div><div class=\"line\">normal:566M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:73%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage4(at url: URL, for size: CGSize) -&gt; UIImage?&#123;</div><div class=\"line\">\tlet shareContext = CIContext(options: [.useSoftwareRenderer:false])</div><div class=\"line\">\t</div><div class=\"line\">\t guard let image = CIImage(contentsOf: url) else &#123; return nil &#125;</div><div class=\"line\">\tlet fillter = CIFilter(name: &quot;CILanczosScaleTransform&quot;)</div><div class=\"line\">\tfillter?.setValue(image, forKey: kCIInputImageKey)</div><div class=\"line\">\tfillter?.setValue(1, forKey: kCIInputScaleKey)</div><div class=\"line\">\tguard let outPutCIImage = fillter?.outputImage,let outputCGImage = shareContext.createCGImage(outPutCIImage, from: outPutCIImage.extent) else &#123; return nil &#125;</div><div class=\"line\">\t</div><div class=\"line\">\treturn UIImage(cgImage: outputCGImage)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-使用-vImage-优化图片渲染\"><a href=\"#5-使用-vImage-优化图片渲染\" class=\"headerlink\" title=\"5.使用 vImage 优化图片渲染\"></a>5.使用 vImage 优化图片渲染</h4><p>使用<code>vImage</code>创建图像性能略低，内存使用较多，步骤麻烦，是我们该舍弃的。在内存只有1G的手机上恐怕要<code>crash</code>了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Memory </div><div class=\"line\">High:998.7M</div><div class=\"line\">normal:566M</div><div class=\"line\">CPU:</div><div class=\"line\">Hight:78%</div><div class=\"line\">normal:0%</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">func resizedImage5(at url: URL, for size: CGSize) -&gt; UIImage? &#123;</div><div class=\"line\">    // 解码源图像</div><div class=\"line\">    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),</div><div class=\"line\">        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil),</div><div class=\"line\">        let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],</div><div class=\"line\">        let imageWidth = properties[kCGImagePropertyPixelWidth] as? vImagePixelCount,</div><div class=\"line\">        let imageHeight = properties[kCGImagePropertyPixelHeight] as? vImagePixelCount</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 定义图像格式</div><div class=\"line\">    var format = vImage_CGImageFormat(bitsPerComponent: 8,</div><div class=\"line\">                                      bitsPerPixel: 32,</div><div class=\"line\">                                      colorSpace: nil,</div><div class=\"line\">                                      bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue),</div><div class=\"line\">                                      version: 0,</div><div class=\"line\">                                      decode: nil,</div><div class=\"line\">                                      renderingIntent: .defaultIntent)</div><div class=\"line\"></div><div class=\"line\">    var error: vImage_Error</div><div class=\"line\"></div><div class=\"line\">    // 创建并初始化源缓冲区</div><div class=\"line\">    var sourceBuffer = vImage_Buffer()</div><div class=\"line\">    defer &#123; sourceBuffer.data.deallocate() &#125;</div><div class=\"line\">    error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer,</div><div class=\"line\">                                         &amp;format,</div><div class=\"line\">                                         nil,</div><div class=\"line\">                                         image,</div><div class=\"line\">                                         vImage_Flags(kvImageNoFlags))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 创建并初始化目标缓冲区</div><div class=\"line\">    var destinationBuffer = vImage_Buffer()</div><div class=\"line\">    error = vImageBuffer_Init(&amp;destinationBuffer,</div><div class=\"line\">                              vImagePixelCount(size.height),</div><div class=\"line\">                              vImagePixelCount(size.width),</div><div class=\"line\">                              format.bitsPerPixel,</div><div class=\"line\">                              vImage_Flags(kvImageNoFlags))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 优化缩放图像</div><div class=\"line\">    error = vImageScale_ARGB8888(&amp;sourceBuffer,</div><div class=\"line\">                                 &amp;destinationBuffer,</div><div class=\"line\">                                 nil,</div><div class=\"line\">                                 vImage_Flags(kvImageHighQualityResampling))</div><div class=\"line\">    guard error == kvImageNoError else &#123; return nil &#125;</div><div class=\"line\"></div><div class=\"line\">    // 从目标缓冲区创建一个 CGImage 对象</div><div class=\"line\">    guard let resizedImage =</div><div class=\"line\">        vImageCreateCGImageFromBuffer(&amp;destinationBuffer,</div><div class=\"line\">                                      &amp;format,</div><div class=\"line\">                                      nil,</div><div class=\"line\">                                      nil,</div><div class=\"line\">                                      vImage_Flags(kvImageNoAllocate),</div><div class=\"line\">                                      &amp;error)?.takeRetainedValue(),</div><div class=\"line\">        error == kvImageNoError</div><div class=\"line\">    else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return UIImage(cgImage: resizedImage)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h3><p>图片解码后加载在内存中的数据需要在恰当的时机删除掉，在合适的时机添加上，也是保持低内存使用率的手段。</p>\n<p>在用户拨打电话或者进入到其他APP中可以先删除掉大图片，等回来的时候再次添加也是不错的选择。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 1</div><div class=\"line\">NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   object: nil,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   queue: .main)</div><div class=\"line\">&#123;[weak self] (note) in</div><div class=\"line\">\tself?.unloadImage()</div><div class=\"line\">&#125;</div><div class=\"line\">NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   object: nil,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t   queue: .main)</div><div class=\"line\">&#123;[weak self] (note) in</div><div class=\"line\">\tself?.loadImage()</div><div class=\"line\">&#125;</div><div class=\"line\"># 2</div><div class=\"line\"></div><div class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</div><div class=\"line\">\tsuper.viewWillAppear(animated)</div><div class=\"line\">\tself.loadImage()</div><div class=\"line\">&#125;</div><div class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</div><div class=\"line\">\tsuper.viewWillDisappear(animated)</div><div class=\"line\">\tself.unloadImage()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>基于性能综合考虑方法1是最简单最合适的</li>\n<li>使用滤镜和<code>vImage</code>略微复杂点，平时开发过程中可以不用考虑了。</li>\n<li>图片解码缓存和图片大小有关，适当的下采样是不错的选择。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2018/416\" target=\"_blank\" rel=\"external\">session 2018 416 iOS Memory Deep Dive</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2018/219\" target=\"_blank\" rel=\"external\">219_image_and_graphics_best_practices</a></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">WWDC 中文字幕下载</a></li>\n<li><p><a href=\"https://juejin.im/post/5daaf8b3f265da5b6f074c98#heading-1\" target=\"_blank\" rel=\"external\">swift gg 图像优化</a></p>\n</li>\n<li><p><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></p>\n</li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n</ul>\n<h2 id=\"唯有实践才是检验真理的唯一标准\"><a href=\"#唯有实践才是检验真理的唯一标准\" class=\"headerlink\" title=\"唯有实践才是检验真理的唯一标准\"></a><strong>唯有实践才是检验真理的唯一标准</strong></h2><p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  block本质 --(5)","date":"2019-12-01T03:15:58.000Z","_content":"\n本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。\n\n### block本质\n\n前几篇文章讲过了，`class`是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？`block`具有这几个特点：\n\n- block本质上也是一个OC对象，它内部也有isa指针\n- block是封装了函数调用以及函数调用环境的oc对象\n\n先简单来看一下`block`编译之后的样子\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = ^(void){\n            NSLog(@\"hello word\");\n        };\n        block();\n\n    }\n    return 0;\n}\n```\n\n命令行执行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp`,来到`main.cpp`内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n    //构造函数 类似OC init函数\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;//block类型\n    impl.Flags = flags;\n    impl.FuncPtr = fp;// 执行函数的地址\n    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值\n  }\n};\n    //block 内部代码封装成函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;//存储结构体占用空间的大小\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n//定义block\n        void (*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA);\n        //执行block\n        block->FuncPtr(block);\n    }\n    return 0;\n}\n```\n\n最终`block`转化成`__main_block_impl_0`结构体，赋值给变量`block`，传入参数是`__main_block_func_0`和`__main_block_desc_0_DATA`来执行`__main_block_impl_0`的构造函数，`__main_block_desc_0_DATA`函数赋值给`__main_block_impl_0->FuncPtr`，执行函数是`block->FuncPtr(block)`，删除冗余代码之前是`((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n`，那么为什么`block`可以直接强制转化成`__block_impl`呢？因为`__main_block_impl_0`结构体的第一行变量是`__block_impl`，相当于`__main_block_impl_0`的内存地址和`__block_impl`的内存地址一样，强制转化也不会有问题。\n### 变量捕获\n变量捕获分为3种：\n\n|变量类型|是否会捕获到block内部|访问方式|内部变量假定是a|\n|--------|-------|------|-----|\n|局部变量 auto|会|值传递|a|\n|局部变量 static|会|指针传递|*a|\n|全局变量|不会|直接访问|空|\n\n#### auto变量捕获\n\n`auto` 变量，一般`auto`是省略不写的，访问方式是值传递，关于值传递不懂的话可以看[这篇博客](https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&oq=%E5%80%BC%E4%BC%A0%E9%80%92&aqs=chrome..69i57.5169j0j4&sourceid=chrome&ie=UTF-8)，\n看下这个例子\n\n```\nint age = 10;\nvoid (^block)(void) = ^(void){\n    NSLog(@\"age is %d\",age);\n};\nage = 20;\nblock();\n//实际输出是 age is 10\n```\n\n有没有疑问呢？在`block`执行之前`age =20`，为什么输出是10呢？\n将这段代码转化成`c/c++`，如下所示：\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int age;//多了一个变量age,存储值是10\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age));\n        age = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n\n    }\n    return 0;\n}\n```\n\n结构体`__main_block_impl_0`多了一个变量`age`，在`block`转化成`c`函数的时候`__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)`直接将age的值存储在`__main_block_impl_0.age`中，此时`__main_block_impl_0.age`是存储在堆上的，之前的`age`是存储在数据段的，执行`block`访问的变量是堆上的``__main_block_impl_0.age`,所以最终输出来`age is 10`。\n\n\n#### static变量捕获\n我们通过一个例子来讲解static和auto区别：\n\n```\nvoid(^block)(void);\nvoid test(){\n    int age = 10;\n    static int level = 12;\n    block = ^(void){\n        NSLog(@\"age is %d,level is %d\",age,level);\n    };\n    age = 20;\n    level = 13;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n\n//输出：age is 10,level is 13\n```\n\n转化成源码：\n\n```\nvoid(*block)(void);\n\nstruct __test_block_impl_0 {\n  struct __block_impl impl;\n  struct __test_block_desc_0* Desc;\n  int age;\n  int *level;\n  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __test_block_func_0(struct __test_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n  int *level = __cself->level; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));\n    }\n\nstatic struct __test_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __test_block_desc_0_DATA = { 0, sizeof(struct __test_block_impl_0)};\nvoid test(){\n    int age = 10;\n    static int level = 12;\n    block = ((void (*)())&__test_block_impl_0((void *)__test_block_func_0, &__test_block_desc_0_DATA, age, &level));\n    age = 20;\n    level = 13;\n}\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        test();\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n当执行完`test()`函数，`age`变量已经被收回，但是`age`的值存储在`block`结构体中，`level`的地址存储在`__test_block_impl_0.level`,可以看到`level`类型是指针类型，读取值的时候也是`*level`，则不管什么时间改动`level`的值，读`level`的值都是最新的，因为它是从地址直接读的。所以结果是`age is 10,level is 13`。\n\n#### 全局变量\n\n全局不用捕获的，访问的时候直接访问。我们来测试下\n\n```\nint age = 10;\nstatic int level = 12;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        void(^block)(void) = ^(void){\n            NSLog(@\"age is %d,level is %d\",age,level);\n        };\n        age = 20;\n        level = 13;\n        block();\n    }\n    return 0;\n}\n```\n\n转化成`c/c++`\n\n```\nint age = 10;\nstatic int level = 12;\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        void(*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        age = 20;\n        level = 13;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n可以看出来编译之后仅仅是多了两行`int age = 10;\nstatic int level = 12;`，结构体`__main_block_impl_0`内部和构造函数并没有专门来存储值或者指针，原因是当执行`__main_block_func_0`，可以直接访问变量`age `和 `level`，因为全局变量有效区域是全局，不会出了`main`函数就消失。\n**基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。**\n\n我们再看下更复杂的情况，对象类型的引用是如何处理的？\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString * name;\n@end\n\n@implementation FYPerson\n- (void)test{\n    void (^block)(void) = ^{\n        NSLog(@\"person is %@\",self);\n    };\n    \n    void (^block2)(void) = ^{\n        NSLog(@\"name is %@\",_name);\n    };\n}\n@end\n\n\n\n\nstruct __FYPerson__test_block_impl_0 {\n  struct __block_impl impl;\n  struct __FYPerson__test_block_desc_0* Desc;\n  FYPerson *self;\n  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) {\n  FYPerson *self = __cself->self; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);\n    }\nstatic void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __FYPerson__test_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);\n  void (*dispose)(struct __FYPerson__test_block_impl_0*);\n} __FYPerson__test_block_desc_0_DATA = { 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0};\n\nstruct __FYPerson__test_block_impl_1 {\n  struct __block_impl impl;\n  struct __FYPerson__test_block_desc_1* Desc;\n  FYPerson *self;\n  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) {\n  FYPerson *self = __cself->self; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));\n    }\nstatic void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __FYPerson__test_block_desc_1 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);\n  void (*dispose)(struct __FYPerson__test_block_impl_1*);\n} __FYPerson__test_block_desc_1_DATA = { 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1};\n\nstatic void _I_FYPerson_test(FYPerson * self, SEL _cmd) {\n    void (*block)(void) = ((void (*)())&__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &__FYPerson__test_block_desc_0_DATA, self, 570425344));\n\n    void (*block2)(void) = ((void (*)())&__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &__FYPerson__test_block_desc_1_DATA, self, 570425344));\n}\n```\n\n`block`和`block2`都是结构体`__FYPerson__test_block_impl_1`内部引用了一个`FYPerson`对象指针，`FYPerson`对象属于局部变量，需要捕获。第2个`block`访问`_name`捕捉的也是`FYPerson`对象，访问`_name`，需要先访问`FYPerson`对象，然后再访问`_name`，本质上是访问`person.name`,所以捕捉的是`FYPerson`对象。\n\n#### 验证block是对象类型：\n\n```\n//ARC环境下\nvoid(^block)(void)=^{\n\t\t\tNSLog(@\"Hello, World!\");\n\t\t};\n\t\tNSLog(@\"自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@\",[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);\n\t\t//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject\n```\n\n可以了解到`block`是继承与基类的，所以`block`也是OC对象。\n\n#### block的分类\n`block`有3种类型，如下所示，可以通过调用`class`方法或者`isa`指针查看具体类型，最终都是继承来自`NSBlock`类型。\n- __NSGlobalBLock__（_NSConcreteGLobalBlock）\n- __NSStackBlock__（_NSConcreteStackBlock）\n- __NSMallocBLock__（_NSConcreteMallocBlock）\n\n在应用程序中内存分配是这样子的：\n\n```\n---------------\n程序区域 .text区\n---------------\n数据区域 .data区     <--------- _NSConcreteGlobalBlock(存储全局变量)\n---------------\n堆                  <--------- _NSConcreteMallocBlock(动态申请释放内存区域)\n---------------\n栈                  <--------- _NSConcreteStackBlock(存储存局部变量)\n---------------\n\n```\n\n\n|block类型|环境|\n|---|----|\n|__NSGlobalBLock__|没有访问auto变量|\n|__NSStackBlock__|访问auto变量|\n|__NSMallocBLock__|__NSStackBlock__ 调用copy|\n\n\n\n验证需要设置成MRC，找到工程文件，设置`project->Object-C Automatic Reference Counting=`为`NO`\n\n```\nint age = 10;\n\nvoid(^block1)(void)=^{\n\tNSLog(@\"block1\");\n};\nvoid(^block2)(void)=^{\n\tNSLog(@\"block2 %d\",age);\n};\nvoid(^block3)(void)=[block2 copy];\nNSLog(@\"block1:%@   block2:%@ block3:%@ \",[block1 class],[block2 class],[block3 class]);\n\n//输出\nblock1:__NSGlobalBlock__   \nblock2:__NSStackBlock__ \nblock3:__NSMallocBlock__\n```\n\n没有访问`auto`变量的`block`属于`__NSGlobalBlock__`，访问了auto变量的是`__NSStackBlock__`，手动调用了`copy`的`block`属于`__NSMallocBlock__`。`__NSMallocBlock__`是在堆上，需要程序员手动释放`[block3 release];`，不释放会造成内存泄露。\n\n\n\n每一种类型的`block`调用`copy`后的结果如下\n\n|block类型|副本源的配置存储域|复制效果|\n|---|----|---------|\n|__NSGlobalBLock__|堆|从栈复制到堆|\n|__NSStackBlock__|程序的数据区域|什么也不做|\n|__NSMallocBLock__|堆|引用计数+1|\n\n#### 在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\n\n- block作为函数返回值时\n- 将block赋值给__strong指针时\n- block作为Cocoa API中方法名含有usingBlock的方法参数时\n- block作为GCD API的方法参数时\n\n\n在ARC环境下测试:\n\n```\ntypedef void (^FYBlock)(void);\ntypedef void (^FYBlockInt)(int);\nFYBlock myBlock(){\n\treturn ^{\n\t\tNSLog(@\"哈哈\");\n\t};\n};\nFYBlock myBlock2(){\n\tint age = 10;\n\treturn ^{\n\t\tNSLog(@\"哈哈 %d\",age);\n\t};\n};\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\tFYBlock block = myBlock();\n\t\tFYBlock block2 = myBlock2();\n\t\tint age = 10;\n\t\tFYBlock block3= ^{\n\t\t\tNSLog(@\"强指针block %d\",age);\n\t\t};\n\t\tNSLog(@\"没访问变量:%@ 访问布局变量：%@ 强指针:%@\",[block class],[block2 class],[block3 class]);\n\t}\n\treturn 0;\n}\n//输出\n没访问变量:__NSGlobalBlock__ \n访问局部变量：__NSMallocBlock__ \n强指针:__NSMallocBlock__\n```\n\n`arc`环境下，没访问变量的`block`是`__NSGlobalBlock__`，访问了局部变量是`__NSMallocBlock__`,有强指针引用的是`__NSMallocBlock__`,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。\n\n**所以有以下建议：**\n\nMRC下block属性的建议写法\n- @property (copy, nonatomic) void (^block)(void);\n\nARC下block属性的建议写法\n- @property (strong, nonatomic) void (^block)(void);\n- @property (copy, nonatomic) void (^block)(void);\n\n\n### 对象类型数据和block交互\n\n平时我们使用`block`，对象类型来传递数据的比较多，对象类型读取到`block`中用`__block`修饰符，会把对象地址直接读取到`block`结构体内，`__weak`修饰的对象是弱引用，默认是强引用，我们看下这段代码\n\n```\n//FYPerson.h\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age;\n@end\n\n//FYPerson.m\n@implementation FYPerson\n@end\n\n//main.m\ntypedef void (^FYBlock)(void);\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\tFYBlock block ;\n\t\t\tFYPerson *person = [[FYPerson alloc]init];\n\t\t\tperson.age = 10;\n\t\t__weak typeof(person) __weakPerson = person;\n\t\t\tblock = ^{\n\t\t\t\tNSLog(@\" %d\",__weakPerson.age);\n\t\t\t};\n\t\t\n\t\tblock();\n\t}\n\treturn 0;\n}\n```\n\n使用下面该命令转化成`cpp`\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp\n```\n\n摘取关键结构体代码：\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  FYPerson *__weak __weakPerson;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  FYPerson *__weak __weakPerson = __cself->__weakPerson; // bound by copy\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(\"age\")));\n   }\n```\n\n`FYPerson *__weak __weakPerson`是`__weak`修饰的对象\n当block内部换成`block = ^{\n\t\t\t\tNSLog(@\" %d\",person.age);\n\t\t\t};`，转换源码之后是\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  FYPerson *__strong person;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n`person`默认是使用`__storng`来修饰的，`arc`中，`block`引用外界变量，系统执行了`copy`操作，将`block` `copy`到堆上，由开发者自己管理，转`c/c++`中结构体描述为\n\n```\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->__weakPerson, (void*)src->__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n\n```\n\n有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数`void (*copy)`和`void (*dispose)`就是对block的引用计数的`+1`和`-1`。\n\n如果block被拷贝到堆上\n\n- 会调用block内部的copy函数\n- copy函数内部会调用_Block_object_assign函数\n- _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用\n\n如果block从堆上移除\n- 会调用block内部的dispose函数\n- dispose函数内部会调用_Block_object_dispose函数\n- _Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）\n\n|函数|调用时机|\n|:-:|:-:|\n|copy函数|栈上的Block复制到堆时|\n|dispose函数|堆上的Block被废弃时|\n\n#### 题目\nperson什么时间释放？\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",person.age);\n});\n}\n```\n\n3s后释放，`dispatch`对`block`强引用，`block`强引用`person`，在`block`释放的时候，`person`没其他的引用，就释放掉了。\n\n变换1：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak FYPerson *__weakPerosn = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",__weakPerosn.age);\n});\n```\n\n`__weak`没有对`perosn`进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。\n变换2：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak typeof(person) __weakPerson = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",__weakPerson.age);\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\tNSLog(@\"---%d\",person.age);\n\t});\n});\n```\n\n`person`被内部`block`强引用，则`block`销毁之前`person`不会释放，`__weakPerson`执行完`person`不会销毁，`NSLog(@\"---%d\",person.age)`执行完毕之后，`person`销毁。答案是4秒之后`NSLog(@\"---%d\",person.age)`执行完毕之后，`person`销毁。\n\n变换3：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak typeof(person) __weakPerson = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",person.age);\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\tNSLog(@\"---%d\",__weakPerson.age);\n\t});\n});\n```\n\n`person`被强引用于第一层`block`，第二层弱引用`person`，仅仅当第一层block执行完毕的时候，`person`释放。\n\n\n\n#### 修改block外部变量\n想要修改变量，首先要变量的有效区域，或者block持有变量的地址。\n例子1：\n\n```\nint age = 10;\nFYBlock block = ^{\n    age = 20;//会报错\n};\n```\n\n报错的原因是`age`是值传递，想要不报错只需要将`int age = 10`改成`static int age = 10`，就由值传递变成地址传递，有了`age`的地址，在`block`的内部就可以更改`age`的值了。或者将`int age = 10`改成全局变量，全局变量在`block`中不用捕获，`block`本质会编译成`c`函数，`c`函数访问全局变量在任意地方都可以直接访问。\n\n#### __block本质\n`__block`本质上是修饰的对象或基本类型，编译之后会生成一个结构体`__Block_byref_age_0`,结构体中`*__forwarding`指向结构体自己，通过\n`(age->__forwarding->age) = 20`来修改变量的值。\n\n```\nstruct __Block_byref_age_0 {\n  void *__isa;\n__Block_byref_age_0 *__forwarding;\n int __flags;\n int __size;\n int age;//10\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_age_0 *age; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  __Block_byref_age_0 *age = __cself->age; // bound by ref\n            (age->__forwarding->age) = 20;\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age->__forwarding->age));\n        }\n```\n\n`age`在`block`外部有一个，在`block`内部有一个，他们是同一个吗？我们来探究一下：\n\n```\ntypedef   void (^FYBlock)(void);\nstruct __Block_byref_age_0 {\n    void *__isa;\n    struct __Block_byref_age_0 *__forwarding;\n    int __flags;\n    int __size;\n    int age;//10\n};\nstruct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(void);\n    void (*dispose)(void);\n};\nstruct __block_impl {\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    struct __Block_byref_age_0 *age; // by ref\n};\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t__block\tint age = 10;\n        NSLog(@\" age1:%p\",&age);\n        FYBlock block = ^{\n            age = 20;\n            NSLog(@\"age is %d\",age);\n        };\n        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;\n        NSLog(@\" age1:%p age2:%p\",&age,&(main->age->__forwarding->age));\n\t}\n\treturn 0;\n}\n输出：\nage1:0x7ffeefbff548\nage1:0x100605358 age2:0x100605358\n```\n\n经过`__block`修饰之后，之后访问的`age`和结构体`__Block_byref_age_0`中的`age`地址是一样的，可以判定`age`被系统`copy`了一份。\n\n例子：\n\n```\n\t__block\tint age = 10;\n        NSLog(@\" age1:%p\",&age);\n        NSObject *obj=[[NSObject alloc]init];\n        FYBlock block = ^{\n            \n            NSLog(@\"age is %d,obj is %p\",age,&obj);\n        };\n```\n\n使用命令编译\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n摘录主要函数：\n\n```\nstruct __Block_byref_age_0 {\n  void *__isa;\n__Block_byref_age_0 *__forwarding;\n int __flags;\n int __size;\n int age;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  NSObject *__strong obj;\n  __Block_byref_age_0 *age; // by ref\n};\n``` \n\n`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0->__forwarding->age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。\n\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    _Block_object_assign((void*)&dst->age, (void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);\n    _Block_object_assign((void*)&dst->obj, (void*)src->obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n    \n    static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);\n    _Block_object_dispose((void*)src->obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n```\n\n`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。\n\n看一下循环引用是反面教材\n\n```\ntypedef   void (^FYBlock)(void);\n@interface FYPerson : NSObject\n\n@property (nonatomic,copy) FYBlock blcok;\n@end\n\n@implementation FYPerson\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n        NSLog(@\" age1:%p\",&age);\n        FYPerson *obj=[[FYPerson alloc]init];\n\t\t[obj setBlcok:^{\n\t\t\tNSLog(@\"%p\",&obj);\n\t\t}];\n\t\tNSLog(@\"--------------\");\n\t}\n\treturn 0;\n}\n```\n\n输出是：\n\n```\nage1:0x7ffeefbff4e8\nblock 执行完毕--------------\n```\n\n`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A<---->B`，相互引用导致执行结束应该释放的时候无法释放。\n将`main`改成\n\n```\nFYPerson *obj=[[FYPerson alloc]init];\n\t\t__weak typeof(obj) weakObj = obj;\n\t\t[obj setBlcok:^{\n\t\t\tNSLog(@\"%p\",&weakObj);\n\t\t}];\n```\n\n结果是\n\n```\nage1:0x7ffeefbff4e8\nblock 执行完毕--------------\n-[FYPerson dealloc]\n```\n\n使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。\n#### `__weak`和`__unsafe__unretain`\n`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。\n下面我们来具体验证一下该结论：\n\n```\ntypedef   void (^FYBlock)(void);\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age ;\n@end\n@implementation FYPerson\n-(void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\nstruct __Block_byref_age_0 {\n\tvoid *__isa;\n\tstruct __Block_byref_age_0 *__forwarding;\n\tint __flags;\n\tint __size;\n\tint age;\n};\nstruct __block_impl {\n\tvoid *isa;\n\tint Flags;\n\tint Reserved;\n\tvoid *FuncPtr;\n};\nstruct __main_block_desc_0 {\n\tsize_t reserved;\n\tsize_t Block_size;\n\tvoid (*copy)(void);\n\tvoid (*dispose)(void);\n};\nstruct __main_block_impl_0 {\n\tstruct __block_impl impl;\n\tstruct __main_block_desc_0* Desc;\n\tFYPerson *__unsafe_unretained __unsafe_obj;\n};\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tFYBlock block;\n\t\t{\n\t\t\tFYPerson *obj=[[FYPerson alloc]init];\n\t\t\tobj.age = 5;\n\t\t\t__weak typeof(obj) __unsafe_obj = obj;\n\t\t\tblock = ^{\n\t\t\t\t\n\t\t\t\tNSLog(@\"obj->age is %d obj:%p\",__unsafe_obj.age,&__unsafe_obj);\n\t\t\t};\n\t\t\tstruct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n\t\t\tNSLog(@\"inside struct->obj:%p\",suct->__unsafe_obj);//断点1\n\t\t}\n\t\tstruct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n\t\tNSLog(@\"outside struct->obj:%p\",suct->__unsafe_obj);//断点2\n\t\tblock();\n\t\tNSLog(@\"----end------\");\n\t}\n\treturn 0;\n}\n```\n\n根据文中提示断点1处使用`lldb`打印`obj`命令\n\n```\n(lldb) p suct->__unsafe_obj->_age\n(int) $0 = 5 //年龄5还是存储在这里的\ninside struct->obj:0x102929d80\n\n```\n\n在断点2处再次查看`obj`的值，报错不可读取该内存\n\n```\n-[FYPerson dealloc]\noutside struct->obj:0x0\np suct->__unsafe_obj->_age\nerror: Couldn't apply expression side effects : Couldn't dematerialize a result variable: couldn't read its memory\n```\n\n已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。\n上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：\n\n```\n(lldb) p suct->__unsafe_obj->_age\n(int) $0 = 5\ninside struct->obj:0x10078c0c0\n\n```\n\n在断点2出再次查看地址并查看`age`的值\n\n```\n-[FYPerson dealloc]\noutside struct->obj:0x10078c0c0\n(lldb) p suct->__unsafe_obj->_age\n(int) $1 = 5\n```\n\n`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。\n\n\n当我们离开某个页面需要再执行的操作，那么我们改怎么办？\n实际应用A:\n\n```\n-(void)test{\n\t__weak typeof(self) __weakself = self;\n\t[self setBlcok:^{\n\t\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\t\tNSLog(@\"perosn :%p\",__weakself);\n\t\t});\n\t}];\n\tself.blcok();\n}\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\t{\n        \tFYPerson *obj=[[FYPerson alloc]init];\n\t\t\t[obj test];\n\t\t\tNSLog(@\"block 执行完毕--------------\");\n\t\t}\n\t\tNSLog(@\"person 死了\");\n\t}\n\treturn 0;\n}\n输出：\nblock 执行完毕--------------\n-[FYPerson dealloc]\nperson 死了\n```\n\n猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。\n那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：\n\n```\n    __block typeof(self) __weakSelf = self;//__block或者没有修饰符\n    dispatch_async(dispatch_get_main_queue(), ^{\n        sleep(2);\n        NSLog(@\"obj:%@\",__weakSelf->_obj);\n    });\n//perosn :0x0\n```\n\n当`self`不持用`block`的时候，`block`可以强引用`self`,`block`执行完毕自己释放，也会释放`self`，当`self`持有`block`，`block`必须弱引用`self`,则释放`self`,`block`也会释放，否则会循环引用。\n\n\n### 总结\n- `block`本质是一个封装了函数调用以及调用环境的`结构体`对象\n- `__block`修饰的变量会被封装成`结构体`对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决`auto`对象在`block`内部无法修改的问题，在`MRC`环境下,`__block`不会对变量产生强引用.\n- `block`不使用`copy`则不会从全局或者栈区域移动到堆上，使用`copy`之后有由发者管理\n- 使用`block`要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。\n- `__weak`修饰的对象，`block`不会对对象强引用，在执行`block`的时候有可能会值已经被系统置为`nil`,`__unsafe_unretained`修饰的销毁之后内存不会及时重置为空。\n\n\n我们看的`cpp`是编译之后的代码，`runtime`是否和我们看到的一致呢？请听下回分解。\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n 本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n\n\n\n\n\n\n\n\n广告时间\n\n![](../images/0.png)\n\n\n","source":"_posts/iOS底层原理  block本质 --(5).md","raw":"title: iOS底层原理  block本质 --(5)\ndate: 2019-12-1 11:15:58\ntags:\n- iOS\ncategories: iOS\n---\n\n本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。\n\n### block本质\n\n前几篇文章讲过了，`class`是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？`block`具有这几个特点：\n\n- block本质上也是一个OC对象，它内部也有isa指针\n- block是封装了函数调用以及函数调用环境的oc对象\n\n先简单来看一下`block`编译之后的样子\n\n```\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        void (^block)(void) = ^(void){\n            NSLog(@\"hello word\");\n        };\n        block();\n\n    }\n    return 0;\n}\n```\n\n命令行执行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp`,来到`main.cpp`内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n    //构造函数 类似OC init函数\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;//block类型\n    impl.Flags = flags;\n    impl.FuncPtr = fp;// 执行函数的地址\n    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值\n  }\n};\n    //block 内部代码封装成函数\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;//存储结构体占用空间的大小\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n//定义block\n        void (*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA);\n        //执行block\n        block->FuncPtr(block);\n    }\n    return 0;\n}\n```\n\n最终`block`转化成`__main_block_impl_0`结构体，赋值给变量`block`，传入参数是`__main_block_func_0`和`__main_block_desc_0_DATA`来执行`__main_block_impl_0`的构造函数，`__main_block_desc_0_DATA`函数赋值给`__main_block_impl_0->FuncPtr`，执行函数是`block->FuncPtr(block)`，删除冗余代码之前是`((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n`，那么为什么`block`可以直接强制转化成`__block_impl`呢？因为`__main_block_impl_0`结构体的第一行变量是`__block_impl`，相当于`__main_block_impl_0`的内存地址和`__block_impl`的内存地址一样，强制转化也不会有问题。\n### 变量捕获\n变量捕获分为3种：\n\n|变量类型|是否会捕获到block内部|访问方式|内部变量假定是a|\n|--------|-------|------|-----|\n|局部变量 auto|会|值传递|a|\n|局部变量 static|会|指针传递|*a|\n|全局变量|不会|直接访问|空|\n\n#### auto变量捕获\n\n`auto` 变量，一般`auto`是省略不写的，访问方式是值传递，关于值传递不懂的话可以看[这篇博客](https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&oq=%E5%80%BC%E4%BC%A0%E9%80%92&aqs=chrome..69i57.5169j0j4&sourceid=chrome&ie=UTF-8)，\n看下这个例子\n\n```\nint age = 10;\nvoid (^block)(void) = ^(void){\n    NSLog(@\"age is %d\",age);\n};\nage = 20;\nblock();\n//实际输出是 age is 10\n```\n\n有没有疑问呢？在`block`执行之前`age =20`，为什么输出是10呢？\n将这段代码转化成`c/c++`，如下所示：\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int age;//多了一个变量age,存储值是10\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        int age = 10;\n        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age));\n        age = 20;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n\n    }\n    return 0;\n}\n```\n\n结构体`__main_block_impl_0`多了一个变量`age`，在`block`转化成`c`函数的时候`__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)`直接将age的值存储在`__main_block_impl_0.age`中，此时`__main_block_impl_0.age`是存储在堆上的，之前的`age`是存储在数据段的，执行`block`访问的变量是堆上的``__main_block_impl_0.age`,所以最终输出来`age is 10`。\n\n\n#### static变量捕获\n我们通过一个例子来讲解static和auto区别：\n\n```\nvoid(^block)(void);\nvoid test(){\n    int age = 10;\n    static int level = 12;\n    block = ^(void){\n        NSLog(@\"age is %d,level is %d\",age,level);\n    };\n    age = 20;\n    level = 13;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        test();\n        block();\n    }\n    return 0;\n}\n\n//输出：age is 10,level is 13\n```\n\n转化成源码：\n\n```\nvoid(*block)(void);\n\nstruct __test_block_impl_0 {\n  struct __block_impl impl;\n  struct __test_block_desc_0* Desc;\n  int age;\n  int *level;\n  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __test_block_func_0(struct __test_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n  int *level = __cself->level; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));\n    }\n\nstatic struct __test_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __test_block_desc_0_DATA = { 0, sizeof(struct __test_block_impl_0)};\nvoid test(){\n    int age = 10;\n    static int level = 12;\n    block = ((void (*)())&__test_block_impl_0((void *)__test_block_func_0, &__test_block_desc_0_DATA, age, &level));\n    age = 20;\n    level = 13;\n}\n\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        test();\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n当执行完`test()`函数，`age`变量已经被收回，但是`age`的值存储在`block`结构体中，`level`的地址存储在`__test_block_impl_0.level`,可以看到`level`类型是指针类型，读取值的时候也是`*level`，则不管什么时间改动`level`的值，读`level`的值都是最新的，因为它是从地址直接读的。所以结果是`age is 10,level is 13`。\n\n#### 全局变量\n\n全局不用捕获的，访问的时候直接访问。我们来测试下\n\n```\nint age = 10;\nstatic int level = 12;\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        void(^block)(void) = ^(void){\n            NSLog(@\"age is %d,level is %d\",age,level);\n        };\n        age = 20;\n        level = 13;\n        block();\n    }\n    return 0;\n}\n```\n\n转化成`c/c++`\n\n```\nint age = 10;\nstatic int level = 12;\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);\n        }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\n        void(*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));\n        age = 20;\n        level = 13;\n        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n    }\n    return 0;\n}\n```\n\n可以看出来编译之后仅仅是多了两行`int age = 10;\nstatic int level = 12;`，结构体`__main_block_impl_0`内部和构造函数并没有专门来存储值或者指针，原因是当执行`__main_block_func_0`，可以直接访问变量`age `和 `level`，因为全局变量有效区域是全局，不会出了`main`函数就消失。\n**基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。**\n\n我们再看下更复杂的情况，对象类型的引用是如何处理的？\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString * name;\n@end\n\n@implementation FYPerson\n- (void)test{\n    void (^block)(void) = ^{\n        NSLog(@\"person is %@\",self);\n    };\n    \n    void (^block2)(void) = ^{\n        NSLog(@\"name is %@\",_name);\n    };\n}\n@end\n\n\n\n\nstruct __FYPerson__test_block_impl_0 {\n  struct __block_impl impl;\n  struct __FYPerson__test_block_desc_0* Desc;\n  FYPerson *self;\n  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) {\n  FYPerson *self = __cself->self; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);\n    }\nstatic void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __FYPerson__test_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);\n  void (*dispose)(struct __FYPerson__test_block_impl_0*);\n} __FYPerson__test_block_desc_0_DATA = { 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0};\n\nstruct __FYPerson__test_block_impl_1 {\n  struct __block_impl impl;\n  struct __FYPerson__test_block_desc_1* Desc;\n  FYPerson *self;\n  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) {\n  FYPerson *self = __cself->self; // bound by copy\n\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));\n    }\nstatic void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __FYPerson__test_block_desc_1 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);\n  void (*dispose)(struct __FYPerson__test_block_impl_1*);\n} __FYPerson__test_block_desc_1_DATA = { 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1};\n\nstatic void _I_FYPerson_test(FYPerson * self, SEL _cmd) {\n    void (*block)(void) = ((void (*)())&__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &__FYPerson__test_block_desc_0_DATA, self, 570425344));\n\n    void (*block2)(void) = ((void (*)())&__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &__FYPerson__test_block_desc_1_DATA, self, 570425344));\n}\n```\n\n`block`和`block2`都是结构体`__FYPerson__test_block_impl_1`内部引用了一个`FYPerson`对象指针，`FYPerson`对象属于局部变量，需要捕获。第2个`block`访问`_name`捕捉的也是`FYPerson`对象，访问`_name`，需要先访问`FYPerson`对象，然后再访问`_name`，本质上是访问`person.name`,所以捕捉的是`FYPerson`对象。\n\n#### 验证block是对象类型：\n\n```\n//ARC环境下\nvoid(^block)(void)=^{\n\t\t\tNSLog(@\"Hello, World!\");\n\t\t};\n\t\tNSLog(@\"自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@\",[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);\n\t\t//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject\n```\n\n可以了解到`block`是继承与基类的，所以`block`也是OC对象。\n\n#### block的分类\n`block`有3种类型，如下所示，可以通过调用`class`方法或者`isa`指针查看具体类型，最终都是继承来自`NSBlock`类型。\n- __NSGlobalBLock__（_NSConcreteGLobalBlock）\n- __NSStackBlock__（_NSConcreteStackBlock）\n- __NSMallocBLock__（_NSConcreteMallocBlock）\n\n在应用程序中内存分配是这样子的：\n\n```\n---------------\n程序区域 .text区\n---------------\n数据区域 .data区     <--------- _NSConcreteGlobalBlock(存储全局变量)\n---------------\n堆                  <--------- _NSConcreteMallocBlock(动态申请释放内存区域)\n---------------\n栈                  <--------- _NSConcreteStackBlock(存储存局部变量)\n---------------\n\n```\n\n\n|block类型|环境|\n|---|----|\n|__NSGlobalBLock__|没有访问auto变量|\n|__NSStackBlock__|访问auto变量|\n|__NSMallocBLock__|__NSStackBlock__ 调用copy|\n\n\n\n验证需要设置成MRC，找到工程文件，设置`project->Object-C Automatic Reference Counting=`为`NO`\n\n```\nint age = 10;\n\nvoid(^block1)(void)=^{\n\tNSLog(@\"block1\");\n};\nvoid(^block2)(void)=^{\n\tNSLog(@\"block2 %d\",age);\n};\nvoid(^block3)(void)=[block2 copy];\nNSLog(@\"block1:%@   block2:%@ block3:%@ \",[block1 class],[block2 class],[block3 class]);\n\n//输出\nblock1:__NSGlobalBlock__   \nblock2:__NSStackBlock__ \nblock3:__NSMallocBlock__\n```\n\n没有访问`auto`变量的`block`属于`__NSGlobalBlock__`，访问了auto变量的是`__NSStackBlock__`，手动调用了`copy`的`block`属于`__NSMallocBlock__`。`__NSMallocBlock__`是在堆上，需要程序员手动释放`[block3 release];`，不释放会造成内存泄露。\n\n\n\n每一种类型的`block`调用`copy`后的结果如下\n\n|block类型|副本源的配置存储域|复制效果|\n|---|----|---------|\n|__NSGlobalBLock__|堆|从栈复制到堆|\n|__NSStackBlock__|程序的数据区域|什么也不做|\n|__NSMallocBLock__|堆|引用计数+1|\n\n#### 在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\n\n- block作为函数返回值时\n- 将block赋值给__strong指针时\n- block作为Cocoa API中方法名含有usingBlock的方法参数时\n- block作为GCD API的方法参数时\n\n\n在ARC环境下测试:\n\n```\ntypedef void (^FYBlock)(void);\ntypedef void (^FYBlockInt)(int);\nFYBlock myBlock(){\n\treturn ^{\n\t\tNSLog(@\"哈哈\");\n\t};\n};\nFYBlock myBlock2(){\n\tint age = 10;\n\treturn ^{\n\t\tNSLog(@\"哈哈 %d\",age);\n\t};\n};\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\tFYBlock block = myBlock();\n\t\tFYBlock block2 = myBlock2();\n\t\tint age = 10;\n\t\tFYBlock block3= ^{\n\t\t\tNSLog(@\"强指针block %d\",age);\n\t\t};\n\t\tNSLog(@\"没访问变量:%@ 访问布局变量：%@ 强指针:%@\",[block class],[block2 class],[block3 class]);\n\t}\n\treturn 0;\n}\n//输出\n没访问变量:__NSGlobalBlock__ \n访问局部变量：__NSMallocBlock__ \n强指针:__NSMallocBlock__\n```\n\n`arc`环境下，没访问变量的`block`是`__NSGlobalBlock__`，访问了局部变量是`__NSMallocBlock__`,有强指针引用的是`__NSMallocBlock__`,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。\n\n**所以有以下建议：**\n\nMRC下block属性的建议写法\n- @property (copy, nonatomic) void (^block)(void);\n\nARC下block属性的建议写法\n- @property (strong, nonatomic) void (^block)(void);\n- @property (copy, nonatomic) void (^block)(void);\n\n\n### 对象类型数据和block交互\n\n平时我们使用`block`，对象类型来传递数据的比较多，对象类型读取到`block`中用`__block`修饰符，会把对象地址直接读取到`block`结构体内，`__weak`修饰的对象是弱引用，默认是强引用，我们看下这段代码\n\n```\n//FYPerson.h\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age;\n@end\n\n//FYPerson.m\n@implementation FYPerson\n@end\n\n//main.m\ntypedef void (^FYBlock)(void);\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\tFYBlock block ;\n\t\t\tFYPerson *person = [[FYPerson alloc]init];\n\t\t\tperson.age = 10;\n\t\t__weak typeof(person) __weakPerson = person;\n\t\t\tblock = ^{\n\t\t\t\tNSLog(@\" %d\",__weakPerson.age);\n\t\t\t};\n\t\t\n\t\tblock();\n\t}\n\treturn 0;\n}\n```\n\n使用下面该命令转化成`cpp`\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp\n```\n\n摘取关键结构体代码：\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  FYPerson *__weak __weakPerson;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  FYPerson *__weak __weakPerson = __cself->__weakPerson; // bound by copy\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(\"age\")));\n   }\n```\n\n`FYPerson *__weak __weakPerson`是`__weak`修饰的对象\n当block内部换成`block = ^{\n\t\t\t\tNSLog(@\" %d\",person.age);\n\t\t\t};`，转换源码之后是\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  FYPerson *__strong person;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n`person`默认是使用`__storng`来修饰的，`arc`中，`block`引用外界变量，系统执行了`copy`操作，将`block` `copy`到堆上，由开发者自己管理，转`c/c++`中结构体描述为\n\n```\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)\n\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->__weakPerson, (void*)src->__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n\n```\n\n有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数`void (*copy)`和`void (*dispose)`就是对block的引用计数的`+1`和`-1`。\n\n如果block被拷贝到堆上\n\n- 会调用block内部的copy函数\n- copy函数内部会调用_Block_object_assign函数\n- _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用\n\n如果block从堆上移除\n- 会调用block内部的dispose函数\n- dispose函数内部会调用_Block_object_dispose函数\n- _Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）\n\n|函数|调用时机|\n|:-:|:-:|\n|copy函数|栈上的Block复制到堆时|\n|dispose函数|堆上的Block被废弃时|\n\n#### 题目\nperson什么时间释放？\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",person.age);\n});\n}\n```\n\n3s后释放，`dispatch`对`block`强引用，`block`强引用`person`，在`block`释放的时候，`person`没其他的引用，就释放掉了。\n\n变换1：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak FYPerson *__weakPerosn = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",__weakPerosn.age);\n});\n```\n\n`__weak`没有对`perosn`进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。\n变换2：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak typeof(person) __weakPerson = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",__weakPerson.age);\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\tNSLog(@\"---%d\",person.age);\n\t});\n});\n```\n\n`person`被内部`block`强引用，则`block`销毁之前`person`不会释放，`__weakPerson`执行完`person`不会销毁，`NSLog(@\"---%d\",person.age)`执行完毕之后，`person`销毁。答案是4秒之后`NSLog(@\"---%d\",person.age)`执行完毕之后，`person`销毁。\n\n变换3：`person`什么时间释放\n\n```\nFYPerson *person = [[FYPerson alloc]init];\nperson.age = 10;\n__weak typeof(person) __weakPerson = person;\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\tNSLog(@\"---%d\",person.age);\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\tNSLog(@\"---%d\",__weakPerson.age);\n\t});\n});\n```\n\n`person`被强引用于第一层`block`，第二层弱引用`person`，仅仅当第一层block执行完毕的时候，`person`释放。\n\n\n\n#### 修改block外部变量\n想要修改变量，首先要变量的有效区域，或者block持有变量的地址。\n例子1：\n\n```\nint age = 10;\nFYBlock block = ^{\n    age = 20;//会报错\n};\n```\n\n报错的原因是`age`是值传递，想要不报错只需要将`int age = 10`改成`static int age = 10`，就由值传递变成地址传递，有了`age`的地址，在`block`的内部就可以更改`age`的值了。或者将`int age = 10`改成全局变量，全局变量在`block`中不用捕获，`block`本质会编译成`c`函数，`c`函数访问全局变量在任意地方都可以直接访问。\n\n#### __block本质\n`__block`本质上是修饰的对象或基本类型，编译之后会生成一个结构体`__Block_byref_age_0`,结构体中`*__forwarding`指向结构体自己，通过\n`(age->__forwarding->age) = 20`来修改变量的值。\n\n```\nstruct __Block_byref_age_0 {\n  void *__isa;\n__Block_byref_age_0 *__forwarding;\n int __flags;\n int __size;\n int age;//10\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_age_0 *age; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  __Block_byref_age_0 *age = __cself->age; // bound by ref\n            (age->__forwarding->age) = 20;\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age->__forwarding->age));\n        }\n```\n\n`age`在`block`外部有一个，在`block`内部有一个，他们是同一个吗？我们来探究一下：\n\n```\ntypedef   void (^FYBlock)(void);\nstruct __Block_byref_age_0 {\n    void *__isa;\n    struct __Block_byref_age_0 *__forwarding;\n    int __flags;\n    int __size;\n    int age;//10\n};\nstruct __main_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(void);\n    void (*dispose)(void);\n};\nstruct __block_impl {\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    struct __Block_byref_age_0 *age; // by ref\n};\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t__block\tint age = 10;\n        NSLog(@\" age1:%p\",&age);\n        FYBlock block = ^{\n            age = 20;\n            NSLog(@\"age is %d\",age);\n        };\n        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;\n        NSLog(@\" age1:%p age2:%p\",&age,&(main->age->__forwarding->age));\n\t}\n\treturn 0;\n}\n输出：\nage1:0x7ffeefbff548\nage1:0x100605358 age2:0x100605358\n```\n\n经过`__block`修饰之后，之后访问的`age`和结构体`__Block_byref_age_0`中的`age`地址是一样的，可以判定`age`被系统`copy`了一份。\n\n例子：\n\n```\n\t__block\tint age = 10;\n        NSLog(@\" age1:%p\",&age);\n        NSObject *obj=[[NSObject alloc]init];\n        FYBlock block = ^{\n            \n            NSLog(@\"age is %d,obj is %p\",age,&obj);\n        };\n```\n\n使用命令编译\n\n```\nxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m\n```\n\n摘录主要函数：\n\n```\nstruct __Block_byref_age_0 {\n  void *__isa;\n__Block_byref_age_0 *__forwarding;\n int __flags;\n int __size;\n int age;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  NSObject *__strong obj;\n  __Block_byref_age_0 *age; // by ref\n};\n``` \n\n`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0->__forwarding->age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。\n\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n    _Block_object_assign((void*)&dst->age, (void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);\n    _Block_object_assign((void*)&dst->obj, (void*)src->obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n    \n    static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->age, 8/*BLOCK_FIELD_IS_BYREF*/);\n    _Block_object_dispose((void*)src->obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n```\n\n`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。\n\n看一下循环引用是反面教材\n\n```\ntypedef   void (^FYBlock)(void);\n@interface FYPerson : NSObject\n\n@property (nonatomic,copy) FYBlock blcok;\n@end\n\n@implementation FYPerson\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\n\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n        NSLog(@\" age1:%p\",&age);\n        FYPerson *obj=[[FYPerson alloc]init];\n\t\t[obj setBlcok:^{\n\t\t\tNSLog(@\"%p\",&obj);\n\t\t}];\n\t\tNSLog(@\"--------------\");\n\t}\n\treturn 0;\n}\n```\n\n输出是：\n\n```\nage1:0x7ffeefbff4e8\nblock 执行完毕--------------\n```\n\n`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A<---->B`，相互引用导致执行结束应该释放的时候无法释放。\n将`main`改成\n\n```\nFYPerson *obj=[[FYPerson alloc]init];\n\t\t__weak typeof(obj) weakObj = obj;\n\t\t[obj setBlcok:^{\n\t\t\tNSLog(@\"%p\",&weakObj);\n\t\t}];\n```\n\n结果是\n\n```\nage1:0x7ffeefbff4e8\nblock 执行完毕--------------\n-[FYPerson dealloc]\n```\n\n使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。\n#### `__weak`和`__unsafe__unretain`\n`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。\n下面我们来具体验证一下该结论：\n\n```\ntypedef   void (^FYBlock)(void);\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age ;\n@end\n@implementation FYPerson\n-(void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\nstruct __Block_byref_age_0 {\n\tvoid *__isa;\n\tstruct __Block_byref_age_0 *__forwarding;\n\tint __flags;\n\tint __size;\n\tint age;\n};\nstruct __block_impl {\n\tvoid *isa;\n\tint Flags;\n\tint Reserved;\n\tvoid *FuncPtr;\n};\nstruct __main_block_desc_0 {\n\tsize_t reserved;\n\tsize_t Block_size;\n\tvoid (*copy)(void);\n\tvoid (*dispose)(void);\n};\nstruct __main_block_impl_0 {\n\tstruct __block_impl impl;\n\tstruct __main_block_desc_0* Desc;\n\tFYPerson *__unsafe_unretained __unsafe_obj;\n};\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t    // insert code here...\n\t\tFYBlock block;\n\t\t{\n\t\t\tFYPerson *obj=[[FYPerson alloc]init];\n\t\t\tobj.age = 5;\n\t\t\t__weak typeof(obj) __unsafe_obj = obj;\n\t\t\tblock = ^{\n\t\t\t\t\n\t\t\t\tNSLog(@\"obj->age is %d obj:%p\",__unsafe_obj.age,&__unsafe_obj);\n\t\t\t};\n\t\t\tstruct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n\t\t\tNSLog(@\"inside struct->obj:%p\",suct->__unsafe_obj);//断点1\n\t\t}\n\t\tstruct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n\t\tNSLog(@\"outside struct->obj:%p\",suct->__unsafe_obj);//断点2\n\t\tblock();\n\t\tNSLog(@\"----end------\");\n\t}\n\treturn 0;\n}\n```\n\n根据文中提示断点1处使用`lldb`打印`obj`命令\n\n```\n(lldb) p suct->__unsafe_obj->_age\n(int) $0 = 5 //年龄5还是存储在这里的\ninside struct->obj:0x102929d80\n\n```\n\n在断点2处再次查看`obj`的值，报错不可读取该内存\n\n```\n-[FYPerson dealloc]\noutside struct->obj:0x0\np suct->__unsafe_obj->_age\nerror: Couldn't apply expression side effects : Couldn't dematerialize a result variable: couldn't read its memory\n```\n\n已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。\n上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：\n\n```\n(lldb) p suct->__unsafe_obj->_age\n(int) $0 = 5\ninside struct->obj:0x10078c0c0\n\n```\n\n在断点2出再次查看地址并查看`age`的值\n\n```\n-[FYPerson dealloc]\noutside struct->obj:0x10078c0c0\n(lldb) p suct->__unsafe_obj->_age\n(int) $1 = 5\n```\n\n`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。\n\n\n当我们离开某个页面需要再执行的操作，那么我们改怎么办？\n实际应用A:\n\n```\n-(void)test{\n\t__weak typeof(self) __weakself = self;\n\t[self setBlcok:^{\n\t\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\t\tNSLog(@\"perosn :%p\",__weakself);\n\t\t});\n\t}];\n\tself.blcok();\n}\n\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {\n\t\t{\n        \tFYPerson *obj=[[FYPerson alloc]init];\n\t\t\t[obj test];\n\t\t\tNSLog(@\"block 执行完毕--------------\");\n\t\t}\n\t\tNSLog(@\"person 死了\");\n\t}\n\treturn 0;\n}\n输出：\nblock 执行完毕--------------\n-[FYPerson dealloc]\nperson 死了\n```\n\n猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。\n那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：\n\n```\n    __block typeof(self) __weakSelf = self;//__block或者没有修饰符\n    dispatch_async(dispatch_get_main_queue(), ^{\n        sleep(2);\n        NSLog(@\"obj:%@\",__weakSelf->_obj);\n    });\n//perosn :0x0\n```\n\n当`self`不持用`block`的时候，`block`可以强引用`self`,`block`执行完毕自己释放，也会释放`self`，当`self`持有`block`，`block`必须弱引用`self`,则释放`self`,`block`也会释放，否则会循环引用。\n\n\n### 总结\n- `block`本质是一个封装了函数调用以及调用环境的`结构体`对象\n- `__block`修饰的变量会被封装成`结构体`对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决`auto`对象在`block`内部无法修改的问题，在`MRC`环境下,`__block`不会对变量产生强引用.\n- `block`不使用`copy`则不会从全局或者栈区域移动到堆上，使用`copy`之后有由发者管理\n- 使用`block`要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。\n- `__weak`修饰的对象，`block`不会对对象强引用，在执行`block`的时候有可能会值已经被系统置为`nil`,`__unsafe_unretained`修饰的销毁之后内存不会及时重置为空。\n\n\n我们看的`cpp`是编译之后的代码，`runtime`是否和我们看到的一致呢？请听下回分解。\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n 本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n\n\n\n\n\n\n\n\n广告时间\n\n![](../images/0.png)\n\n\n","slug":"iOS底层原理  block本质 --(5)","published":1,"updated":"2019-12-03T05:02:14.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2g000g9zsksrops5wt","content":"<p>本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。</p>\n<h3 id=\"block本质\"><a href=\"#block本质\" class=\"headerlink\" title=\"block本质\"></a>block本质</h3><p>前几篇文章讲过了，<code>class</code>是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？<code>block</code>具有这几个特点：</p>\n<ul>\n<li>block本质上也是一个OC对象，它内部也有isa指针</li>\n<li>block是封装了函数调用以及函数调用环境的oc对象</li>\n</ul>\n<p>先简单来看一下<code>block</code>编译之后的样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        void (^block)(void) = ^(void)&#123;</div><div class=\"line\">            NSLog(@&quot;hello word&quot;);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        block();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>命令行执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp</code>,来到<code>main.cpp</code>内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">    //构造函数 类似OC init函数</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;//block类型</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;// 执行函数的地址</div><div class=\"line\">    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">    //block 内部代码封装成函数</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;//存储结构体占用空间的大小</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">//定义block</div><div class=\"line\">        void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class=\"line\">        //执行block</div><div class=\"line\">        block-&gt;FuncPtr(block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终<code>block</code>转化成<code>__main_block_impl_0</code>结构体，赋值给变量<code>block</code>，传入参数是<code>__main_block_func_0</code>和<code>__main_block_desc_0_DATA</code>来执行<code>__main_block_impl_0</code>的构造函数，<code>__main_block_desc_0_DATA</code>函数赋值给<code>__main_block_impl_0-&gt;FuncPtr</code>，执行函数是<code>block-&gt;FuncPtr(block)</code>，删除冗余代码之前是<code>((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code>，那么为什么<code>block</code>可以直接强制转化成<code>__block_impl</code>呢？因为<code>__main_block_impl_0</code>结构体的第一行变量是<code>__block_impl</code>，相当于<code>__main_block_impl_0</code>的内存地址和<code>__block_impl</code>的内存地址一样，强制转化也不会有问题。</p>\n<h3 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h3><p>变量捕获分为3种：</p>\n<table>\n<thead>\n<tr>\n<th>变量类型</th>\n<th>是否会捕获到block内部</th>\n<th>访问方式</th>\n<th>内部变量假定是a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>局部变量 auto</td>\n<td>会</td>\n<td>值传递</td>\n<td>a</td>\n</tr>\n<tr>\n<td>局部变量 static</td>\n<td>会</td>\n<td>指针传递</td>\n<td>*a</td>\n</tr>\n<tr>\n<td>全局变量</td>\n<td>不会</td>\n<td>直接访问</td>\n<td>空</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"auto变量捕获\"><a href=\"#auto变量捕获\" class=\"headerlink\" title=\"auto变量捕获\"></a>auto变量捕获</h4><p><code>auto</code> 变量，一般<code>auto</code>是省略不写的，访问方式是值传递，关于值传递不懂的话可以看<a href=\"https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&amp;oq=%E5%80%BC%E4%BC%A0%E9%80%92&amp;aqs=chrome..69i57.5169j0j4&amp;sourceid=chrome&amp;ie=UTF-8\" target=\"_blank\" rel=\"external\">这篇博客</a>，<br>看下这个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">void (^block)(void) = ^(void)&#123;</div><div class=\"line\">    NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">&#125;;</div><div class=\"line\">age = 20;</div><div class=\"line\">block();</div><div class=\"line\">//实际输出是 age is 10</div></pre></td></tr></table></figure>\n<p>有没有疑问呢？在<code>block</code>执行之前<code>age =20</code>，为什么输出是10呢？<br>将这段代码转化成<code>c/c++</code>，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  int age;//多了一个变量age,存储值是10</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  int age = __cself-&gt;age; // bound by copy</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">        int age = 10;</div><div class=\"line\">        void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</div><div class=\"line\">        age = 20;</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结构体<code>__main_block_impl_0</code>多了一个变量<code>age</code>，在<code>block</code>转化成<code>c</code>函数的时候<code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)</code>直接将age的值存储在<code>__main_block_impl_0.age</code>中，此时<code>__main_block_impl_0.age</code>是存储在堆上的，之前的<code>age</code>是存储在数据段的，执行<code>block</code>访问的变量是堆上的<code>`__main_block_impl_0.age</code>,所以最终输出来<code>age is 10</code>。</p>\n<h4 id=\"static变量捕获\"><a href=\"#static变量捕获\" class=\"headerlink\" title=\"static变量捕获\"></a>static变量捕获</h4><p>我们通过一个例子来讲解static和auto区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(^block)(void);</div><div class=\"line\">void test()&#123;</div><div class=\"line\">    int age = 10;</div><div class=\"line\">    static int level = 12;</div><div class=\"line\">    block = ^(void)&#123;</div><div class=\"line\">        NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    age = 20;</div><div class=\"line\">    level = 13;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        test();</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出：age is 10,level is 13</div></pre></td></tr></table></figure>\n<p>转化成源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(*block)(void);</div><div class=\"line\"></div><div class=\"line\">struct __test_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __test_block_desc_0* Desc;</div><div class=\"line\">  int age;</div><div class=\"line\">  int *level;</div><div class=\"line\">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</div><div class=\"line\">  int age = __cself-&gt;age; // bound by copy</div><div class=\"line\">  int *level = __cself-&gt;level; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __test_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</div><div class=\"line\">void test()&#123;</div><div class=\"line\">    int age = 10;</div><div class=\"line\">    static int level = 12;</div><div class=\"line\">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, age, &amp;level));</div><div class=\"line\">    age = 20;</div><div class=\"line\">    level = 13;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">        test();</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当执行完<code>test()</code>函数，<code>age</code>变量已经被收回，但是<code>age</code>的值存储在<code>block</code>结构体中，<code>level</code>的地址存储在<code>__test_block_impl_0.level</code>,可以看到<code>level</code>类型是指针类型，读取值的时候也是<code>*level</code>，则不管什么时间改动<code>level</code>的值，读<code>level</code>的值都是最新的，因为它是从地址直接读的。所以结果是<code>age is 10,level is 13</code>。</p>\n<h4 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h4><p>全局不用捕获的，访问的时候直接访问。我们来测试下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">static int level = 12;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\"></div><div class=\"line\">        void(^block)(void) = ^(void)&#123;</div><div class=\"line\">            NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        age = 20;</div><div class=\"line\">        level = 13;</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转化成<code>c/c++</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">static int level = 12;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\"></div><div class=\"line\">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">        age = 20;</div><div class=\"line\">        level = 13;</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来编译之后仅仅是多了两行<code>int age = 10;\nstatic int level = 12;</code>，结构体<code>__main_block_impl_0</code>内部和构造函数并没有专门来存储值或者指针，原因是当执行<code>__main_block_func_0</code>，可以直接访问变量<code>age</code>和 <code>level</code>，因为全局变量有效区域是全局，不会出了<code>main</code>函数就消失。<br><strong>基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。</strong></p>\n<p>我们再看下更复杂的情况，对象类型的引用是如何处理的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    void (^block)(void) = ^&#123;</div><div class=\"line\">        NSLog(@&quot;person is %@&quot;,self);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    void (^block2)(void) = ^&#123;</div><div class=\"line\">        NSLog(@&quot;name is %@&quot;,_name);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct __FYPerson__test_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __FYPerson__test_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *self;</div><div class=\"line\">  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) &#123;</div><div class=\"line\">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);</div><div class=\"line\">    &#125;</div><div class=\"line\">static void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __FYPerson__test_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);</div><div class=\"line\">  void (*dispose)(struct __FYPerson__test_block_impl_0*);</div><div class=\"line\">&#125; __FYPerson__test_block_desc_0_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __FYPerson__test_block_impl_1 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __FYPerson__test_block_desc_1* Desc;</div><div class=\"line\">  FYPerson *self;</div><div class=\"line\">  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) &#123;</div><div class=\"line\">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));</div><div class=\"line\">    &#125;</div><div class=\"line\">static void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __FYPerson__test_block_desc_1 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);</div><div class=\"line\">  void (*dispose)(struct __FYPerson__test_block_impl_1*);</div><div class=\"line\">&#125; __FYPerson__test_block_desc_1_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1&#125;;</div><div class=\"line\"></div><div class=\"line\">static void _I_FYPerson_test(FYPerson * self, SEL _cmd) &#123;</div><div class=\"line\">    void (*block)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &amp;__FYPerson__test_block_desc_0_DATA, self, 570425344));</div><div class=\"line\"></div><div class=\"line\">    void (*block2)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &amp;__FYPerson__test_block_desc_1_DATA, self, 570425344));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>block</code>和<code>block2</code>都是结构体<code>__FYPerson__test_block_impl_1</code>内部引用了一个<code>FYPerson</code>对象指针，<code>FYPerson</code>对象属于局部变量，需要捕获。第2个<code>block</code>访问<code>_name</code>捕捉的也是<code>FYPerson</code>对象，访问<code>_name</code>，需要先访问<code>FYPerson</code>对象，然后再访问<code>_name</code>，本质上是访问<code>person.name</code>,所以捕捉的是<code>FYPerson</code>对象。</p>\n<h4 id=\"验证block是对象类型：\"><a href=\"#验证block是对象类型：\" class=\"headerlink\" title=\"验证block是对象类型：\"></a>验证block是对象类型：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//ARC环境下</div><div class=\"line\">void(^block)(void)=^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;Hello, World!&quot;);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tNSLog(@&quot;自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@&quot;,[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);</div><div class=\"line\">\t\t//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject</div></pre></td></tr></table></figure>\n<p>可以了解到<code>block</code>是继承与基类的，所以<code>block</code>也是OC对象。</p>\n<h4 id=\"block的分类\"><a href=\"#block的分类\" class=\"headerlink\" title=\"block的分类\"></a>block的分类</h4><p><code>block</code>有3种类型，如下所示，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承来自<code>NSBlock</code>类型。</p>\n<ul>\n<li><strong>NSGlobalBLock</strong>（_NSConcreteGLobalBlock）</li>\n<li><strong>NSStackBlock</strong>（_NSConcreteStackBlock）</li>\n<li><strong>NSMallocBLock</strong>（_NSConcreteMallocBlock）</li>\n</ul>\n<p>在应用程序中内存分配是这样子的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">---------------</div><div class=\"line\">程序区域 .text区</div><div class=\"line\">---------------</div><div class=\"line\">数据区域 .data区     &lt;--------- _NSConcreteGlobalBlock(存储全局变量)</div><div class=\"line\">---------------</div><div class=\"line\">堆                  &lt;--------- _NSConcreteMallocBlock(动态申请释放内存区域)</div><div class=\"line\">---------------</div><div class=\"line\">栈                  &lt;--------- _NSConcreteStackBlock(存储存局部变量)</div><div class=\"line\">---------------</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>block类型</th>\n<th>环境</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NSGlobalBLock</strong></td>\n<td>没有访问auto变量</td>\n</tr>\n<tr>\n<td><strong>NSStackBlock</strong></td>\n<td>访问auto变量</td>\n</tr>\n<tr>\n<td><strong>NSMallocBLock</strong></td>\n<td><strong>NSStackBlock</strong> 调用copy</td>\n</tr>\n</tbody>\n</table>\n<p>验证需要设置成MRC，找到工程文件，设置<code>project-&gt;Object-C Automatic Reference Counting=</code>为<code>NO</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\"></div><div class=\"line\">void(^block1)(void)=^&#123;</div><div class=\"line\">\tNSLog(@&quot;block1&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\">void(^block2)(void)=^&#123;</div><div class=\"line\">\tNSLog(@&quot;block2 %d&quot;,age);</div><div class=\"line\">&#125;;</div><div class=\"line\">void(^block3)(void)=[block2 copy];</div><div class=\"line\">NSLog(@&quot;block1:%@   block2:%@ block3:%@ &quot;,[block1 class],[block2 class],[block3 class]);</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">block1:__NSGlobalBlock__   </div><div class=\"line\">block2:__NSStackBlock__ </div><div class=\"line\">block3:__NSMallocBlock__</div></pre></td></tr></table></figure>\n<p>没有访问<code>auto</code>变量的<code>block</code>属于<code>__NSGlobalBlock__</code>，访问了auto变量的是<code>__NSStackBlock__</code>，手动调用了<code>copy</code>的<code>block</code>属于<code>__NSMallocBlock__</code>。<code>__NSMallocBlock__</code>是在堆上，需要程序员手动释放<code>[block3 release];</code>，不释放会造成内存泄露。</p>\n<p>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下</p>\n<table>\n<thead>\n<tr>\n<th>block类型</th>\n<th>副本源的配置存储域</th>\n<th>复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NSGlobalBLock</strong></td>\n<td>堆</td>\n<td>从栈复制到堆</td>\n</tr>\n<tr>\n<td><strong>NSStackBlock</strong></td>\n<td>程序的数据区域</td>\n<td>什么也不做</td>\n</tr>\n<tr>\n<td><strong>NSMallocBLock</strong></td>\n<td>堆</td>\n<td>引用计数+1</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\"><a href=\"#在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\" class=\"headerlink\" title=\"在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\"></a>在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况</h4><ul>\n<li>block作为函数返回值时</li>\n<li>将block赋值给__strong指针时</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>\n<li>block作为GCD API的方法参数时</li>\n</ul>\n<p>在ARC环境下测试:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void (^FYBlock)(void);</div><div class=\"line\">typedef void (^FYBlockInt)(int);</div><div class=\"line\">FYBlock myBlock()&#123;</div><div class=\"line\">\treturn ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;哈哈&quot;);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">FYBlock myBlock2()&#123;</div><div class=\"line\">\tint age = 10;</div><div class=\"line\">\treturn ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;哈哈 %d&quot;,age);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t\tFYBlock block = myBlock();</div><div class=\"line\">\t\tFYBlock block2 = myBlock2();</div><div class=\"line\">\t\tint age = 10;</div><div class=\"line\">\t\tFYBlock block3= ^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;强指针block %d&quot;,age);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tNSLog(@&quot;没访问变量:%@ 访问布局变量：%@ 强指针:%@&quot;,[block class],[block2 class],[block3 class]);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">没访问变量:__NSGlobalBlock__ </div><div class=\"line\">访问局部变量：__NSMallocBlock__ </div><div class=\"line\">强指针:__NSMallocBlock__</div></pre></td></tr></table></figure>\n<p><code>arc</code>环境下，没访问变量的<code>block</code>是<code>__NSGlobalBlock__</code>，访问了局部变量是<code>__NSMallocBlock__</code>,有强指针引用的是<code>__NSMallocBlock__</code>,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。</p>\n<p><strong>所以有以下建议：</strong></p>\n<p>MRC下block属性的建议写法</p>\n<ul>\n<li>@property (copy, nonatomic) void (^block)(void);</li>\n</ul>\n<p>ARC下block属性的建议写法</p>\n<ul>\n<li>@property (strong, nonatomic) void (^block)(void);</li>\n<li>@property (copy, nonatomic) void (^block)(void);</li>\n</ul>\n<h3 id=\"对象类型数据和block交互\"><a href=\"#对象类型数据和block交互\" class=\"headerlink\" title=\"对象类型数据和block交互\"></a>对象类型数据和block交互</h3><p>平时我们使用<code>block</code>，对象类型来传递数据的比较多，对象类型读取到<code>block</code>中用<code>__block</code>修饰符，会把对象地址直接读取到<code>block</code>结构体内，<code>__weak</code>修饰的对象是弱引用，默认是强引用，我们看下这段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//FYPerson.h</div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) int age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//FYPerson.m</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//main.m</div><div class=\"line\">typedef void (^FYBlock)(void);</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t\tFYBlock block ;</div><div class=\"line\">\t\t\tFYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">\t\t\tperson.age = 10;</div><div class=\"line\">\t\t__weak typeof(person) __weakPerson = person;</div><div class=\"line\">\t\t\tblock = ^&#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot; %d&quot;,__weakPerson.age);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tblock();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用下面该命令转化成<code>cpp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp</div></pre></td></tr></table></figure>\n<p>摘取关键结构体代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *__weak __weakPerson;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  FYPerson *__weak __weakPerson = __cself-&gt;__weakPerson; // bound by copy</div><div class=\"line\"></div><div class=\"line\">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(&quot;age&quot;)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><code>FYPerson *__weak __weakPerson</code>是<code>__weak</code>修饰的对象<br>当block内部换成<code>block = ^{\n                NSLog(@&quot; %d&quot;,person.age);\n            };</code>，转换源码之后是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *__strong person;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>person</code>默认是使用<code>__storng</code>来修饰的，<code>arc</code>中，<code>block</code>引用外界变量，系统执行了<code>copy</code>操作，将<code>block</code> <code>copy</code>到堆上，由开发者自己管理，转<code>c/c++</code>中结构体描述为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">  void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)</div><div class=\"line\"></div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;__weakPerson, (void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div></pre></td></tr></table></figure>\n<p>有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数<code>void (*copy)</code>和<code>void (*dispose)</code>就是对block的引用计数的<code>+1</code>和<code>-1</code>。</p>\n<p>如果block被拷贝到堆上</p>\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li>\n</ul>\n<p>如果block从堆上移除</p>\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">调用时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">copy函数</td>\n<td style=\"text-align:center\">栈上的Block复制到堆时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dispose函数</td>\n<td style=\"text-align:center\">堆上的Block被废弃时</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>person什么时间释放？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3s后释放，<code>dispatch</code>对<code>block</code>强引用，<code>block</code>强引用<code>person</code>，在<code>block</code>释放的时候，<code>person</code>没其他的引用，就释放掉了。</p>\n<p>变换1：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak FYPerson *__weakPerosn = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,__weakPerosn.age);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>__weak</code>没有对<code>perosn</code>进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。<br>变换2：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak typeof(person) __weakPerson = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>person</code>被内部<code>block</code>强引用，则<code>block</code>销毁之前<code>person</code>不会释放，<code>__weakPerson</code>执行完<code>person</code>不会销毁，<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。答案是4秒之后<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。</p>\n<p>变换3：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak typeof(person) __weakPerson = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>person</code>被强引用于第一层<code>block</code>，第二层弱引用<code>person</code>，仅仅当第一层block执行完毕的时候，<code>person</code>释放。</p>\n<h4 id=\"修改block外部变量\"><a href=\"#修改block外部变量\" class=\"headerlink\" title=\"修改block外部变量\"></a>修改block外部变量</h4><p>想要修改变量，首先要变量的有效区域，或者block持有变量的地址。<br>例子1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">FYBlock block = ^&#123;</div><div class=\"line\">    age = 20;//会报错</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>报错的原因是<code>age</code>是值传递，想要不报错只需要将<code>int age = 10</code>改成<code>static int age = 10</code>，就由值传递变成地址传递，有了<code>age</code>的地址，在<code>block</code>的内部就可以更改<code>age</code>的值了。或者将<code>int age = 10</code>改成全局变量，全局变量在<code>block</code>中不用捕获，<code>block</code>本质会编译成<code>c</code>函数，<code>c</code>函数访问全局变量在任意地方都可以直接访问。</p>\n<h4 id=\"block本质-1\"><a href=\"#block本质-1\" class=\"headerlink\" title=\"__block本质\"></a>__block本质</h4><p><code>__block</code>本质上是修饰的对象或基本类型，编译之后会生成一个结构体<code>__Block_byref_age_0</code>,结构体中<code>*__forwarding</code>指向结构体自己，通过<br><code>(age-&gt;__forwarding-&gt;age) = 20</code>来修改变量的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">  void *__isa;</div><div class=\"line\">__Block_byref_age_0 *__forwarding;</div><div class=\"line\"> int __flags;</div><div class=\"line\"> int __size;</div><div class=\"line\"> int age;//10</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __Block_byref_age_0 *age; // by ref</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</div><div class=\"line\">            (age-&gt;__forwarding-&gt;age) = 20;</div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age-&gt;__forwarding-&gt;age));</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p><code>age</code>在<code>block</code>外部有一个，在<code>block</code>内部有一个，他们是同一个吗？我们来探究一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef   void (^FYBlock)(void);</div><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    struct __Block_byref_age_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int age;//10</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(void);</div><div class=\"line\">    void (*dispose)(void);</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __block_impl &#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    struct __Block_byref_age_0 *age; // by ref</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t__block\tint age = 10;</div><div class=\"line\">        NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class=\"line\">        FYBlock block = ^&#123;</div><div class=\"line\">            age = 20;</div><div class=\"line\">            NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;</div><div class=\"line\">        NSLog(@&quot; age1:%p age2:%p&quot;,&amp;age,&amp;(main-&gt;age-&gt;__forwarding-&gt;age));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">age1:0x7ffeefbff548</div><div class=\"line\">age1:0x100605358 age2:0x100605358</div></pre></td></tr></table></figure>\n<p>经过<code>__block</code>修饰之后，之后访问的<code>age</code>和结构体<code>__Block_byref_age_0</code>中的<code>age</code>地址是一样的，可以判定<code>age</code>被系统<code>copy</code>了一份。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block\tint age = 10;</div><div class=\"line\">       NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class=\"line\">       NSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">       FYBlock block = ^&#123;</div><div class=\"line\">           </div><div class=\"line\">           NSLog(@&quot;age is %d,obj is %p&quot;,age,&amp;obj);</div><div class=\"line\">       &#125;;</div></pre></td></tr></table></figure>\n<p>使用命令编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</div></pre></td></tr></table></figure>\n<p>摘录主要函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">  void *__isa;</div><div class=\"line\">__Block_byref_age_0 *__forwarding;</div><div class=\"line\"> int __flags;</div><div class=\"line\"> int __size;</div><div class=\"line\"> int age;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  NSObject *__strong obj;</div><div class=\"line\">  __Block_byref_age_0 *age; // by ref</div><div class=\"line\">&#125;;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0-&gt;__forwarding-&gt;age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。</div></pre></td></tr></table></figure>\n<p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {<br>    _Block_object_assign((void<em>)&amp;dst-&gt;age, (void</em>)src-&gt;age, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>    _Block_object_assign((void<em>)&amp;dst-&gt;obj, (void</em>)src-&gt;obj, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/);}</p>\n<pre><code>static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);\n_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。</div><div class=\"line\"></div><div class=\"line\">看一下循环引用是反面教材</div></pre></td></tr></table></figure>\n<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject</p>\n<p>@property (nonatomic,copy) FYBlock blcok;<br>@end</p>\n<p>@implementation FYPerson</p>\n<ul>\n<li>(void)dealloc{<br>  NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end</li>\n</ul>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSLog(@” age1:%p”,&amp;age);<br>        FYPerson </em>obj=[[FYPerson alloc]init];<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;obj);<br>        }];<br>        NSLog(@”————–”);<br>    }<br>    return 0;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">输出是：</div></pre></td></tr></table></figure></p>\n<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A&lt;----&gt;B`，相互引用导致执行结束应该释放的时候无法释放。</div><div class=\"line\">将`main`改成</div></pre></td></tr></table></figure></p>\n<p>FYPerson *obj=[[FYPerson alloc]init];<br>        __weak typeof(obj) weakObj = obj;<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;weakObj);<br>        }];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">结果是</div></pre></td></tr></table></figure></p>\n<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br>-[FYPerson dealloc]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。</div><div class=\"line\">#### `__weak`和`__unsafe__unretain`</div><div class=\"line\">`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。</div><div class=\"line\">下面我们来具体验证一下该结论：</div></pre></td></tr></table></figure></p>\n<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject<br>@property (nonatomic,assign) int age ;<br>@end<br>@implementation FYPerson<br>-(void)dealloc{<br>    NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end<br>struct <strong>Block_byref_age_0 {<br>    void *</strong>isa;<br>    struct <strong>Block_byref_age_0 *</strong>forwarding;<br>    int <strong>flags;<br>    int </strong>size;<br>    int age;<br>};<br>struct <strong>block_impl {<br>    void <em>isa;<br>    int Flags;<br>    int Reserved;<br>    void </em>FuncPtr;<br>};<br>struct </strong>main_block_desc_0 {<br>    size_t reserved;<br>    size_t Block_size;<br>    void (<em>copy)(void);<br>    void (</em>dispose)(void);<br>};<br>struct <strong>main_block_impl_0 {<br>    struct </strong>block_impl impl;<br>    struct <strong>main_block_desc_0<em> Desc;<br>    FYPerson </em></strong>unsafe_unretained __unsafe_obj;<br>};</p>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        // insert code here…<br>        FYBlock block;<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            obj.age = 5;<br>            <strong>weak typeof(obj) </strong>unsafe_obj = obj;<br>            block = ^{</p>\n<pre><code>            NSLog(@&quot;obj-&gt;age is %d obj:%p&quot;,__unsafe_obj.age,&amp;__unsafe_obj);\n        };\n        struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n        NSLog(@&quot;inside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点1\n    }\n    struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n    NSLog(@&quot;outside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点2\n    block();\n    NSLog(@&quot;----end------&quot;);\n}\nreturn 0;\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">根据文中提示断点1处使用`lldb`打印`obj`命令</div></pre></td></tr></table></figure></p>\n<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5 //年龄5还是存储在这里的<br>inside struct-&gt;obj:0x102929d80</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在断点2处再次查看`obj`的值，报错不可读取该内存</div></pre></td></tr></table></figure>\n<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x0<br>p suct-&gt;__unsafe_obj-&gt;_age<br>error: Couldn’t apply expression side effects : Couldn’t dematerialize a result variable: couldn’t read its memory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。</div><div class=\"line\">上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：</div></pre></td></tr></table></figure></p>\n<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5<br>inside struct-&gt;obj:0x10078c0c0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在断点2出再次查看地址并查看`age`的值</div></pre></td></tr></table></figure>\n<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x10078c0c0<br>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $1 = 5<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">当我们离开某个页面需要再执行的操作，那么我们改怎么办？</div><div class=\"line\">实际应用A:</div></pre></td></tr></table></figure></p>\n<p>-(void)test{<br>    <strong>weak typeof(self) </strong>weakself = self;<br>    [self setBlcok:^{<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>            NSLog(@”perosn :%p”,__weakself);<br>        });<br>    }];<br>    self.blcok();<br>}</p>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            [obj test];<br>            NSLog(@”block 执行完毕————–”);<br>        }<br>        NSLog(@”person 死了”);<br>    }<br>    return 0;<br>}<br>输出：<br>block 执行完毕————–<br>-[FYPerson dealloc]<br>person 死了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。</div><div class=\"line\">那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：</div></pre></td></tr></table></figure></p>\n<pre><code>__block typeof(self) __weakSelf = self;//__block或者没有修饰符\ndispatch_async(dispatch_get_main_queue(), ^{\n    sleep(2);\n    NSLog(@&quot;obj:%@&quot;,__weakSelf-&gt;_obj);\n});\n</code></pre><p>//perosn :0x0<br>```</p>\n<p>当<code>self</code>不持用<code>block</code>的时候，<code>block</code>可以强引用<code>self</code>,<code>block</code>执行完毕自己释放，也会释放<code>self</code>，当<code>self</code>持有<code>block</code>，<code>block</code>必须弱引用<code>self</code>,则释放<code>self</code>,<code>block</code>也会释放，否则会循环引用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><code>block</code>本质是一个封装了函数调用以及调用环境的<code>结构体</code>对象</li>\n<li><code>__block</code>修饰的变量会被封装成<code>结构体</code>对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决<code>auto</code>对象在<code>block</code>内部无法修改的问题，在<code>MRC</code>环境下,<code>__block</code>不会对变量产生强引用.</li>\n<li><code>block</code>不使用<code>copy</code>则不会从全局或者栈区域移动到堆上，使用<code>copy</code>之后有由发者管理</li>\n<li>使用<code>block</code>要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。</li>\n<li><code>__weak</code>修饰的对象，<code>block</code>不会对对象强引用，在执行<code>block</code>的时候有可能会值已经被系统置为<code>nil</code>,<code>__unsafe_unretained</code>修饰的销毁之后内存不会及时重置为空。</li>\n</ul>\n<p>我们看的<code>cpp</code>是编译之后的代码，<code>runtime</code>是否和我们看到的一致呢？请听下回分解。</p>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n</li>\n</ul>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本章讲解block的用法和底层数据结构，以及使用过程中需要注意的点。</p>\n<h3 id=\"block本质\"><a href=\"#block本质\" class=\"headerlink\" title=\"block本质\"></a>block本质</h3><p>前几篇文章讲过了，<code>class</code>是对象，元类也是对象，本质是结构体，那么block是否也是如此呢？<code>block</code>具有这几个特点：</p>\n<ul>\n<li>block本质上也是一个OC对象，它内部也有isa指针</li>\n<li>block是封装了函数调用以及函数调用环境的oc对象</li>\n</ul>\n<p>先简单来看一下<code>block</code>编译之后的样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        void (^block)(void) = ^(void)&#123;</div><div class=\"line\">            NSLog(@&quot;hello word&quot;);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        block();</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>命令行执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.mm -o main.cpp</code>,来到<code>main.cpp</code>内部，已经去除多余的转化函数，剩余骨架，可以看得更清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">    //构造函数 类似OC init函数</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;//block类型</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;// 执行函数的地址</div><div class=\"line\">    Desc = desc;//desc 存储 __main_block_desc_0（0，sizeof(__main_block_impl_0)）的值</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">    //block 内部代码封装成函数</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b7cca8_mii_0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;//存储结构体占用空间的大小</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">//定义block</div><div class=\"line\">        void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class=\"line\">        //执行block</div><div class=\"line\">        block-&gt;FuncPtr(block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终<code>block</code>转化成<code>__main_block_impl_0</code>结构体，赋值给变量<code>block</code>，传入参数是<code>__main_block_func_0</code>和<code>__main_block_desc_0_DATA</code>来执行<code>__main_block_impl_0</code>的构造函数，<code>__main_block_desc_0_DATA</code>函数赋值给<code>__main_block_impl_0-&gt;FuncPtr</code>，执行函数是<code>block-&gt;FuncPtr(block)</code>，删除冗余代码之前是<code>((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code>，那么为什么<code>block</code>可以直接强制转化成<code>__block_impl</code>呢？因为<code>__main_block_impl_0</code>结构体的第一行变量是<code>__block_impl</code>，相当于<code>__main_block_impl_0</code>的内存地址和<code>__block_impl</code>的内存地址一样，强制转化也不会有问题。</p>\n<h3 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h3><p>变量捕获分为3种：</p>\n<table>\n<thead>\n<tr>\n<th>变量类型</th>\n<th>是否会捕获到block内部</th>\n<th>访问方式</th>\n<th>内部变量假定是a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>局部变量 auto</td>\n<td>会</td>\n<td>值传递</td>\n<td>a</td>\n</tr>\n<tr>\n<td>局部变量 static</td>\n<td>会</td>\n<td>指针传递</td>\n<td>*a</td>\n</tr>\n<tr>\n<td>全局变量</td>\n<td>不会</td>\n<td>直接访问</td>\n<td>空</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"auto变量捕获\"><a href=\"#auto变量捕获\" class=\"headerlink\" title=\"auto变量捕获\"></a>auto变量捕获</h4><p><code>auto</code> 变量，一般<code>auto</code>是省略不写的，访问方式是值传递，关于值传递不懂的话可以看<a href=\"https://www.google.com/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&amp;oq=%E5%80%BC%E4%BC%A0%E9%80%92&amp;aqs=chrome..69i57.5169j0j4&amp;sourceid=chrome&amp;ie=UTF-8\" target=\"_blank\" rel=\"external\">这篇博客</a>，<br>看下这个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">void (^block)(void) = ^(void)&#123;</div><div class=\"line\">    NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">&#125;;</div><div class=\"line\">age = 20;</div><div class=\"line\">block();</div><div class=\"line\">//实际输出是 age is 10</div></pre></td></tr></table></figure>\n<p>有没有疑问呢？在<code>block</code>执行之前<code>age =20</code>，为什么输出是10呢？<br>将这段代码转化成<code>c/c++</code>，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  int age;//多了一个变量age,存储值是10</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  int age = __cself-&gt;age; // bound by copy</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_baf352_mii_0,age);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">        int age = 10;</div><div class=\"line\">        void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</div><div class=\"line\">        age = 20;</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结构体<code>__main_block_impl_0</code>多了一个变量<code>age</code>，在<code>block</code>转化成<code>c</code>函数的时候<code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age)</code>直接将age的值存储在<code>__main_block_impl_0.age</code>中，此时<code>__main_block_impl_0.age</code>是存储在堆上的，之前的<code>age</code>是存储在数据段的，执行<code>block</code>访问的变量是堆上的<code>`__main_block_impl_0.age</code>,所以最终输出来<code>age is 10</code>。</p>\n<h4 id=\"static变量捕获\"><a href=\"#static变量捕获\" class=\"headerlink\" title=\"static变量捕获\"></a>static变量捕获</h4><p>我们通过一个例子来讲解static和auto区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(^block)(void);</div><div class=\"line\">void test()&#123;</div><div class=\"line\">    int age = 10;</div><div class=\"line\">    static int level = 12;</div><div class=\"line\">    block = ^(void)&#123;</div><div class=\"line\">        NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    age = 20;</div><div class=\"line\">    level = 13;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        test();</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出：age is 10,level is 13</div></pre></td></tr></table></figure>\n<p>转化成源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(*block)(void);</div><div class=\"line\"></div><div class=\"line\">struct __test_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __test_block_desc_0* Desc;</div><div class=\"line\">  int age;</div><div class=\"line\">  int *level;</div><div class=\"line\">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _age, int *_level, int flags=0) : age(_age), level(_level) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</div><div class=\"line\">  int age = __cself-&gt;age; // bound by copy</div><div class=\"line\">  int *level = __cself-&gt;level; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_b26797_mii_0,age,(*level));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __test_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</div><div class=\"line\">void test()&#123;</div><div class=\"line\">    int age = 10;</div><div class=\"line\">    static int level = 12;</div><div class=\"line\">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, age, &amp;level));</div><div class=\"line\">    age = 20;</div><div class=\"line\">    level = 13;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\">        test();</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当执行完<code>test()</code>函数，<code>age</code>变量已经被收回，但是<code>age</code>的值存储在<code>block</code>结构体中，<code>level</code>的地址存储在<code>__test_block_impl_0.level</code>,可以看到<code>level</code>类型是指针类型，读取值的时候也是<code>*level</code>，则不管什么时间改动<code>level</code>的值，读<code>level</code>的值都是最新的，因为它是从地址直接读的。所以结果是<code>age is 10,level is 13</code>。</p>\n<h4 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h4><p>全局不用捕获的，访问的时候直接访问。我们来测试下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">static int level = 12;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\"></div><div class=\"line\">        void(^block)(void) = ^(void)&#123;</div><div class=\"line\">            NSLog(@&quot;age is %d,level is %d&quot;,age,level);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        age = 20;</div><div class=\"line\">        level = 13;</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转化成<code>c/c++</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">static int level = 12;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\"></div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_45cab9_mii_0,age,level);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class=\"line\"></div><div class=\"line\">        void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class=\"line\">        age = 20;</div><div class=\"line\">        level = 13;</div><div class=\"line\">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来编译之后仅仅是多了两行<code>int age = 10;\nstatic int level = 12;</code>，结构体<code>__main_block_impl_0</code>内部和构造函数并没有专门来存储值或者指针，原因是当执行<code>__main_block_func_0</code>，可以直接访问变量<code>age</code>和 <code>level</code>，因为全局变量有效区域是全局，不会出了<code>main</code>函数就消失。<br><strong>基本概括来讲就是超出执行区域与可能消失的会捕获，一定不会消失的不会捕获。</strong></p>\n<p>我们再看下更复杂的情况，对象类型的引用是如何处理的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    void (^block)(void) = ^&#123;</div><div class=\"line\">        NSLog(@&quot;person is %@&quot;,self);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    void (^block2)(void) = ^&#123;</div><div class=\"line\">        NSLog(@&quot;name is %@&quot;,_name);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct __FYPerson__test_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __FYPerson__test_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *self;</div><div class=\"line\">  __FYPerson__test_block_impl_0(void *fp, struct __FYPerson__test_block_desc_0 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __FYPerson__test_block_func_0(struct __FYPerson__test_block_impl_0 *__cself) &#123;</div><div class=\"line\">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_0,self);</div><div class=\"line\">    &#125;</div><div class=\"line\">static void __FYPerson__test_block_copy_0(struct __FYPerson__test_block_impl_0*dst, struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __FYPerson__test_block_dispose_0(struct __FYPerson__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __FYPerson__test_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __FYPerson__test_block_impl_0*, struct __FYPerson__test_block_impl_0*);</div><div class=\"line\">  void (*dispose)(struct __FYPerson__test_block_impl_0*);</div><div class=\"line\">&#125; __FYPerson__test_block_desc_0_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_0), __FYPerson__test_block_copy_0, __FYPerson__test_block_dispose_0&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __FYPerson__test_block_impl_1 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __FYPerson__test_block_desc_1* Desc;</div><div class=\"line\">  FYPerson *self;</div><div class=\"line\">  __FYPerson__test_block_impl_1(void *fp, struct __FYPerson__test_block_desc_1 *desc, FYPerson *_self, int flags=0) : self(_self) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __FYPerson__test_block_func_1(struct __FYPerson__test_block_impl_1 *__cself) &#123;</div><div class=\"line\">  FYPerson *self = __cself-&gt;self; // bound by copy</div><div class=\"line\"></div><div class=\"line\">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_FYPerson_c624e0_mi_1,(*(NSString * _Nonnull *)((char *)self + OBJC_IVAR_$_FYPerson$_name)));</div><div class=\"line\">    &#125;</div><div class=\"line\">static void __FYPerson__test_block_copy_1(struct __FYPerson__test_block_impl_1*dst, struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __FYPerson__test_block_dispose_1(struct __FYPerson__test_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static struct __FYPerson__test_block_desc_1 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __FYPerson__test_block_impl_1*, struct __FYPerson__test_block_impl_1*);</div><div class=\"line\">  void (*dispose)(struct __FYPerson__test_block_impl_1*);</div><div class=\"line\">&#125; __FYPerson__test_block_desc_1_DATA = &#123; 0, sizeof(struct __FYPerson__test_block_impl_1), __FYPerson__test_block_copy_1, __FYPerson__test_block_dispose_1&#125;;</div><div class=\"line\"></div><div class=\"line\">static void _I_FYPerson_test(FYPerson * self, SEL _cmd) &#123;</div><div class=\"line\">    void (*block)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_0((void *)__FYPerson__test_block_func_0, &amp;__FYPerson__test_block_desc_0_DATA, self, 570425344));</div><div class=\"line\"></div><div class=\"line\">    void (*block2)(void) = ((void (*)())&amp;__FYPerson__test_block_impl_1((void *)__FYPerson__test_block_func_1, &amp;__FYPerson__test_block_desc_1_DATA, self, 570425344));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>block</code>和<code>block2</code>都是结构体<code>__FYPerson__test_block_impl_1</code>内部引用了一个<code>FYPerson</code>对象指针，<code>FYPerson</code>对象属于局部变量，需要捕获。第2个<code>block</code>访问<code>_name</code>捕捉的也是<code>FYPerson</code>对象，访问<code>_name</code>，需要先访问<code>FYPerson</code>对象，然后再访问<code>_name</code>，本质上是访问<code>person.name</code>,所以捕捉的是<code>FYPerson</code>对象。</p>\n<h4 id=\"验证block是对象类型：\"><a href=\"#验证block是对象类型：\" class=\"headerlink\" title=\"验证block是对象类型：\"></a>验证block是对象类型：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//ARC环境下</div><div class=\"line\">void(^block)(void)=^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;Hello, World!&quot;);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tNSLog(@&quot;自己class：%@ 它爹class:%@  它爷爷class:%@ 它老爷爷的tclass:%@&quot;,[block class],[[block class] superclass],[[[block class] superclass]superclass],[[[[block class] superclass]superclass] superclass]);</div><div class=\"line\">\t\t//输出是：自己class：__NSGlobalBlock__ 它爹class:__NSGlobalBlock  它爷爷class:NSBlock 它老爷爷的tclass:NSObject</div></pre></td></tr></table></figure>\n<p>可以了解到<code>block</code>是继承与基类的，所以<code>block</code>也是OC对象。</p>\n<h4 id=\"block的分类\"><a href=\"#block的分类\" class=\"headerlink\" title=\"block的分类\"></a>block的分类</h4><p><code>block</code>有3种类型，如下所示，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承来自<code>NSBlock</code>类型。</p>\n<ul>\n<li><strong>NSGlobalBLock</strong>（_NSConcreteGLobalBlock）</li>\n<li><strong>NSStackBlock</strong>（_NSConcreteStackBlock）</li>\n<li><strong>NSMallocBLock</strong>（_NSConcreteMallocBlock）</li>\n</ul>\n<p>在应用程序中内存分配是这样子的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">---------------</div><div class=\"line\">程序区域 .text区</div><div class=\"line\">---------------</div><div class=\"line\">数据区域 .data区     &lt;--------- _NSConcreteGlobalBlock(存储全局变量)</div><div class=\"line\">---------------</div><div class=\"line\">堆                  &lt;--------- _NSConcreteMallocBlock(动态申请释放内存区域)</div><div class=\"line\">---------------</div><div class=\"line\">栈                  &lt;--------- _NSConcreteStackBlock(存储存局部变量)</div><div class=\"line\">---------------</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>block类型</th>\n<th>环境</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NSGlobalBLock</strong></td>\n<td>没有访问auto变量</td>\n</tr>\n<tr>\n<td><strong>NSStackBlock</strong></td>\n<td>访问auto变量</td>\n</tr>\n<tr>\n<td><strong>NSMallocBLock</strong></td>\n<td><strong>NSStackBlock</strong> 调用copy</td>\n</tr>\n</tbody>\n</table>\n<p>验证需要设置成MRC，找到工程文件，设置<code>project-&gt;Object-C Automatic Reference Counting=</code>为<code>NO</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\"></div><div class=\"line\">void(^block1)(void)=^&#123;</div><div class=\"line\">\tNSLog(@&quot;block1&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\">void(^block2)(void)=^&#123;</div><div class=\"line\">\tNSLog(@&quot;block2 %d&quot;,age);</div><div class=\"line\">&#125;;</div><div class=\"line\">void(^block3)(void)=[block2 copy];</div><div class=\"line\">NSLog(@&quot;block1:%@   block2:%@ block3:%@ &quot;,[block1 class],[block2 class],[block3 class]);</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">block1:__NSGlobalBlock__   </div><div class=\"line\">block2:__NSStackBlock__ </div><div class=\"line\">block3:__NSMallocBlock__</div></pre></td></tr></table></figure>\n<p>没有访问<code>auto</code>变量的<code>block</code>属于<code>__NSGlobalBlock__</code>，访问了auto变量的是<code>__NSStackBlock__</code>，手动调用了<code>copy</code>的<code>block</code>属于<code>__NSMallocBlock__</code>。<code>__NSMallocBlock__</code>是在堆上，需要程序员手动释放<code>[block3 release];</code>，不释放会造成内存泄露。</p>\n<p>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下</p>\n<table>\n<thead>\n<tr>\n<th>block类型</th>\n<th>副本源的配置存储域</th>\n<th>复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>NSGlobalBLock</strong></td>\n<td>堆</td>\n<td>从栈复制到堆</td>\n</tr>\n<tr>\n<td><strong>NSStackBlock</strong></td>\n<td>程序的数据区域</td>\n<td>什么也不做</td>\n</tr>\n<tr>\n<td><strong>NSMallocBLock</strong></td>\n<td>堆</td>\n<td>引用计数+1</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\"><a href=\"#在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\" class=\"headerlink\" title=\"在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况\"></a>在ARC环境下，编译器会根据自身情况自动将栈上的block复制到堆上，比如下列情况</h4><ul>\n<li>block作为函数返回值时</li>\n<li>将block赋值给__strong指针时</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>\n<li>block作为GCD API的方法参数时</li>\n</ul>\n<p>在ARC环境下测试:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void (^FYBlock)(void);</div><div class=\"line\">typedef void (^FYBlockInt)(int);</div><div class=\"line\">FYBlock myBlock()&#123;</div><div class=\"line\">\treturn ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;哈哈&quot;);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">FYBlock myBlock2()&#123;</div><div class=\"line\">\tint age = 10;</div><div class=\"line\">\treturn ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;哈哈 %d&quot;,age);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t\tFYBlock block = myBlock();</div><div class=\"line\">\t\tFYBlock block2 = myBlock2();</div><div class=\"line\">\t\tint age = 10;</div><div class=\"line\">\t\tFYBlock block3= ^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;强指针block %d&quot;,age);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\tNSLog(@&quot;没访问变量:%@ 访问布局变量：%@ 强指针:%@&quot;,[block class],[block2 class],[block3 class]);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">没访问变量:__NSGlobalBlock__ </div><div class=\"line\">访问局部变量：__NSMallocBlock__ </div><div class=\"line\">强指针:__NSMallocBlock__</div></pre></td></tr></table></figure>\n<p><code>arc</code>环境下，没访问变量的<code>block</code>是<code>__NSGlobalBlock__</code>，访问了局部变量是<code>__NSMallocBlock__</code>,有强指针引用的是<code>__NSMallocBlock__</code>,强指针系统自动执行了copy操作，由栈区复制到堆区，由系统管理改为开发者手动管理。</p>\n<p><strong>所以有以下建议：</strong></p>\n<p>MRC下block属性的建议写法</p>\n<ul>\n<li>@property (copy, nonatomic) void (^block)(void);</li>\n</ul>\n<p>ARC下block属性的建议写法</p>\n<ul>\n<li>@property (strong, nonatomic) void (^block)(void);</li>\n<li>@property (copy, nonatomic) void (^block)(void);</li>\n</ul>\n<h3 id=\"对象类型数据和block交互\"><a href=\"#对象类型数据和block交互\" class=\"headerlink\" title=\"对象类型数据和block交互\"></a>对象类型数据和block交互</h3><p>平时我们使用<code>block</code>，对象类型来传递数据的比较多，对象类型读取到<code>block</code>中用<code>__block</code>修饰符，会把对象地址直接读取到<code>block</code>结构体内，<code>__weak</code>修饰的对象是弱引用，默认是强引用，我们看下这段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//FYPerson.h</div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) int age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//FYPerson.m</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//main.m</div><div class=\"line\">typedef void (^FYBlock)(void);</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t\tFYBlock block ;</div><div class=\"line\">\t\t\tFYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">\t\t\tperson.age = 10;</div><div class=\"line\">\t\t__weak typeof(person) __weakPerson = person;</div><div class=\"line\">\t\t\tblock = ^&#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot; %d&quot;,__weakPerson.age);</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tblock();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用下面该命令转化成<code>cpp</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main.cpp</div></pre></td></tr></table></figure>\n<p>摘取关键结构体代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *__weak __weakPerson;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__weak ___weakPerson, int flags=0) : __weakPerson(___weakPerson) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  FYPerson *__weak __weakPerson = __cself-&gt;__weakPerson; // bound by copy</div><div class=\"line\"></div><div class=\"line\">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c0_7nm4_r7s4xd0mbs67ljb_b8m0000gn_T_main_7f0272_mi_0,((int (*)(id, SEL))(void *)objc_msgSend)((id)__weakPerson, sel_registerName(&quot;age&quot;)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><code>FYPerson *__weak __weakPerson</code>是<code>__weak</code>修饰的对象<br>当block内部换成<code>block = ^{\n                NSLog(@&quot; %d&quot;,person.age);\n            };</code>，转换源码之后是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  FYPerson *__strong person;</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, FYPerson *__strong _person, int flags=0) : person(_person) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>person</code>默认是使用<code>__storng</code>来修饰的，<code>arc</code>中，<code>block</code>引用外界变量，系统执行了<code>copy</code>操作，将<code>block</code> <code>copy</code>到堆上，由开发者自己管理，转<code>c/c++</code>中结构体描述为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">static struct __main_block_desc_0 &#123;</div><div class=\"line\">  size_t reserved;</div><div class=\"line\">  size_t Block_size;</div><div class=\"line\">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">  void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)</div><div class=\"line\"></div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;__weakPerson, (void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class=\"line\"></div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;__weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div></pre></td></tr></table></figure>\n<p>有对象的使用，则有内存管理，既然是arc，则是系统帮开发者管理内存，函数<code>void (*copy)</code>和<code>void (*dispose)</code>就是对block的引用计数的<code>+1</code>和<code>-1</code>。</p>\n<p>如果block被拷贝到堆上</p>\n<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li>\n</ul>\n<p>如果block从堆上移除</p>\n<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_dispose函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量（release，引用计数-1，若为0，则销毁）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">调用时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">copy函数</td>\n<td style=\"text-align:center\">栈上的Block复制到堆时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dispose函数</td>\n<td style=\"text-align:center\">堆上的Block被废弃时</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>person什么时间释放？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3s后释放，<code>dispatch</code>对<code>block</code>强引用，<code>block</code>强引用<code>person</code>，在<code>block</code>释放的时候，<code>person</code>没其他的引用，就释放掉了。</p>\n<p>变换1：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak FYPerson *__weakPerosn = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,__weakPerosn.age);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>__weak</code>没有对<code>perosn</code>进行强引用，咋执行完dispatch_block则立马释放，答案是立即释放。<br>变换2：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak typeof(person) __weakPerson = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>person</code>被内部<code>block</code>强引用，则<code>block</code>销毁之前<code>person</code>不会释放，<code>__weakPerson</code>执行完<code>person</code>不会销毁，<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。答案是4秒之后<code>NSLog(@&quot;---%d&quot;,person.age)</code>执行完毕之后，<code>person</code>销毁。</p>\n<p>变换3：<code>person</code>什么时间释放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *person = [[FYPerson alloc]init];</div><div class=\"line\">person.age = 10;</div><div class=\"line\">__weak typeof(person) __weakPerson = person;</div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\tNSLog(@&quot;---%d&quot;,person.age);</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;---%d&quot;,__weakPerson.age);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>person</code>被强引用于第一层<code>block</code>，第二层弱引用<code>person</code>，仅仅当第一层block执行完毕的时候，<code>person</code>释放。</p>\n<h4 id=\"修改block外部变量\"><a href=\"#修改block外部变量\" class=\"headerlink\" title=\"修改block外部变量\"></a>修改block外部变量</h4><p>想要修改变量，首先要变量的有效区域，或者block持有变量的地址。<br>例子1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int age = 10;</div><div class=\"line\">FYBlock block = ^&#123;</div><div class=\"line\">    age = 20;//会报错</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>报错的原因是<code>age</code>是值传递，想要不报错只需要将<code>int age = 10</code>改成<code>static int age = 10</code>，就由值传递变成地址传递，有了<code>age</code>的地址，在<code>block</code>的内部就可以更改<code>age</code>的值了。或者将<code>int age = 10</code>改成全局变量，全局变量在<code>block</code>中不用捕获，<code>block</code>本质会编译成<code>c</code>函数，<code>c</code>函数访问全局变量在任意地方都可以直接访问。</p>\n<h4 id=\"block本质-1\"><a href=\"#block本质-1\" class=\"headerlink\" title=\"__block本质\"></a>__block本质</h4><p><code>__block</code>本质上是修饰的对象或基本类型，编译之后会生成一个结构体<code>__Block_byref_age_0</code>,结构体中<code>*__forwarding</code>指向结构体自己，通过<br><code>(age-&gt;__forwarding-&gt;age) = 20</code>来修改变量的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">  void *__isa;</div><div class=\"line\">__Block_byref_age_0 *__forwarding;</div><div class=\"line\"> int __flags;</div><div class=\"line\"> int __size;</div><div class=\"line\"> int age;//10</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  __Block_byref_age_0 *age; // by ref</div><div class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</div><div class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">    impl.Flags = flags;</div><div class=\"line\">    impl.FuncPtr = fp;</div><div class=\"line\">    Desc = desc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class=\"line\">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</div><div class=\"line\">            (age-&gt;__forwarding-&gt;age) = 20;</div><div class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5p_cwsr3ytd5md9r_kgb2fv_2c40000gn_T_main_043d00_mi_0,(age-&gt;__forwarding-&gt;age));</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p><code>age</code>在<code>block</code>外部有一个，在<code>block</code>内部有一个，他们是同一个吗？我们来探究一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef   void (^FYBlock)(void);</div><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    struct __Block_byref_age_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int age;//10</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_desc_0 &#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(void);</div><div class=\"line\">    void (*dispose)(void);</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __block_impl &#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    struct __Block_byref_age_0 *age; // by ref</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;</div><div class=\"line\">\t    // insert code here...</div><div class=\"line\">\t__block\tint age = 10;</div><div class=\"line\">        NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class=\"line\">        FYBlock block = ^&#123;</div><div class=\"line\">            age = 20;</div><div class=\"line\">            NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        struct __main_block_impl_0 *main= (__bridge struct __main_block_impl_0 *)block;</div><div class=\"line\">        NSLog(@&quot; age1:%p age2:%p&quot;,&amp;age,&amp;(main-&gt;age-&gt;__forwarding-&gt;age));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">age1:0x7ffeefbff548</div><div class=\"line\">age1:0x100605358 age2:0x100605358</div></pre></td></tr></table></figure>\n<p>经过<code>__block</code>修饰之后，之后访问的<code>age</code>和结构体<code>__Block_byref_age_0</code>中的<code>age</code>地址是一样的，可以判定<code>age</code>被系统<code>copy</code>了一份。</p>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block\tint age = 10;</div><div class=\"line\">       NSLog(@&quot; age1:%p&quot;,&amp;age);</div><div class=\"line\">       NSObject *obj=[[NSObject alloc]init];</div><div class=\"line\">       FYBlock block = ^&#123;</div><div class=\"line\">           </div><div class=\"line\">           NSLog(@&quot;age is %d,obj is %p&quot;,age,&amp;obj);</div><div class=\"line\">       &#125;;</div></pre></td></tr></table></figure>\n<p>使用命令编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</div></pre></td></tr></table></figure>\n<p>摘录主要函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __Block_byref_age_0 &#123;</div><div class=\"line\">  void *__isa;</div><div class=\"line\">__Block_byref_age_0 *__forwarding;</div><div class=\"line\"> int __flags;</div><div class=\"line\"> int __size;</div><div class=\"line\"> int age;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct __main_block_impl_0 &#123;</div><div class=\"line\">  struct __block_impl impl;</div><div class=\"line\">  struct __main_block_desc_0* Desc;</div><div class=\"line\">  NSObject *__strong obj;</div><div class=\"line\">  __Block_byref_age_0 *age; // by ref</div><div class=\"line\">&#125;;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">`__main_block_impl_0`结构体对`age`进行了一个强引用并持有该结构体的地址，将`age`复制到了堆上，`age`转化成`__Block_byref_age_0`对象，`__main_block_impl_0`可以对`__Block_byref_age_0-&gt;__forwarding-&gt;age`进行赋值。`__Block_byref_age_0`既然是对象，就需要内存管理，`__main_block_copy_0`出现了`_Block_object_assign`和`_Block_object_dispose`对`__Block_byref_age_0`进行内存管理的代码。</div></pre></td></tr></table></figure>\n<p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {<br>    _Block_object_assign((void<em>)&amp;dst-&gt;age, (void</em>)src-&gt;age, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>    _Block_object_assign((void<em>)&amp;dst-&gt;obj, (void</em>)src-&gt;obj, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/);}</p>\n<pre><code>static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);\n_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`age`和`obj`是一个对象结构体，`obj`只是一个强引用而没有地址变换原因是`obj`本身就在堆上，`block`也在堆上，故无需复制出新的`obj`来进行管理。</div><div class=\"line\"></div><div class=\"line\">看一下循环引用是反面教材</div></pre></td></tr></table></figure>\n<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject</p>\n<p>@property (nonatomic,copy) FYBlock blcok;<br>@end</p>\n<p>@implementation FYPerson</p>\n<ul>\n<li>(void)dealloc{<br>  NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end</li>\n</ul>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        NSLog(@” age1:%p”,&amp;age);<br>        FYPerson </em>obj=[[FYPerson alloc]init];<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;obj);<br>        }];<br>        NSLog(@”————–”);<br>    }<br>    return 0;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">输出是：</div></pre></td></tr></table></figure></p>\n<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`obj`通过`copy`操作强引用`block`,`block`通过默认`__strong`强制引用`obj`,这就是`A&lt;----&gt;B`，相互引用导致执行结束应该释放的时候无法释放。</div><div class=\"line\">将`main`改成</div></pre></td></tr></table></figure></p>\n<p>FYPerson *obj=[[FYPerson alloc]init];<br>        __weak typeof(obj) weakObj = obj;<br>        [obj setBlcok:^{<br>            NSLog(@”%p”,&amp;weakObj);<br>        }];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">结果是</div></pre></td></tr></table></figure></p>\n<p>age1:0x7ffeefbff4e8<br>block 执行完毕————–<br>-[FYPerson dealloc]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">使用`__weak`或`__unsafe__unretain`弱引用`obj`,在`block`执行完毕的时候，`obj`释放，`block`释放，无相互强引用，正常释放。</div><div class=\"line\">#### `__weak`和`__unsafe__unretain`</div><div class=\"line\">`__weak`和`__unsafe__unretain`都是弱引用`obj`,都是不影响`obj`正常释放，区别是`__weak`在释放之后会将值为nil，`__unsafe__unretain`不对该内存处理。</div><div class=\"line\">下面我们来具体验证一下该结论：</div></pre></td></tr></table></figure></p>\n<p>typedef   void (^FYBlock)(void);<br>@interface FYPerson : NSObject<br>@property (nonatomic,assign) int age ;<br>@end<br>@implementation FYPerson<br>-(void)dealloc{<br>    NSLog(@”%s”,<strong>func</strong>);<br>}<br>@end<br>struct <strong>Block_byref_age_0 {<br>    void *</strong>isa;<br>    struct <strong>Block_byref_age_0 *</strong>forwarding;<br>    int <strong>flags;<br>    int </strong>size;<br>    int age;<br>};<br>struct <strong>block_impl {<br>    void <em>isa;<br>    int Flags;<br>    int Reserved;<br>    void </em>FuncPtr;<br>};<br>struct </strong>main_block_desc_0 {<br>    size_t reserved;<br>    size_t Block_size;<br>    void (<em>copy)(void);<br>    void (</em>dispose)(void);<br>};<br>struct <strong>main_block_impl_0 {<br>    struct </strong>block_impl impl;<br>    struct <strong>main_block_desc_0<em> Desc;<br>    FYPerson </em></strong>unsafe_unretained __unsafe_obj;<br>};</p>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        // insert code here…<br>        FYBlock block;<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            obj.age = 5;<br>            <strong>weak typeof(obj) </strong>unsafe_obj = obj;<br>            block = ^{</p>\n<pre><code>            NSLog(@&quot;obj-&gt;age is %d obj:%p&quot;,__unsafe_obj.age,&amp;__unsafe_obj);\n        };\n        struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n        NSLog(@&quot;inside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点1\n    }\n    struct __main_block_impl_0 *suct = (__bridge struct __main_block_desc_0 *)block;\n    NSLog(@&quot;outside struct-&gt;obj:%p&quot;,suct-&gt;__unsafe_obj);//断点2\n    block();\n    NSLog(@&quot;----end------&quot;);\n}\nreturn 0;\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">根据文中提示断点1处使用`lldb`打印`obj`命令</div></pre></td></tr></table></figure></p>\n<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5 //年龄5还是存储在这里的<br>inside struct-&gt;obj:0x102929d80</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在断点2处再次查看`obj`的值，报错不可读取该内存</div></pre></td></tr></table></figure>\n<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x0<br>p suct-&gt;__unsafe_obj-&gt;_age<br>error: Couldn’t apply expression side effects : Couldn’t dematerialize a result variable: couldn’t read its memory<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">已经超出了`obj`的有效范围，`obj`已经重置为nil，也就是`0x0000000000000000`。</div><div class=\"line\">上文代码`__weak`改为`__unsafe_unretained`再次在`obj`断点1查看地址：</div></pre></td></tr></table></figure></p>\n<p>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $0 = 5<br>inside struct-&gt;obj:0x10078c0c0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在断点2出再次查看地址并查看`age`的值</div></pre></td></tr></table></figure>\n<p>-[FYPerson dealloc]<br>outside struct-&gt;obj:0x10078c0c0<br>(lldb) p suct-&gt;__unsafe_obj-&gt;_age<br>(int) $1 = 5<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">`__unsafe_unretained`在`obj`销毁之后内存并没有及时重置为空。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">当我们离开某个页面需要再执行的操作，那么我们改怎么办？</div><div class=\"line\">实际应用A:</div></pre></td></tr></table></figure></p>\n<p>-(void)test{<br>    <strong>weak typeof(self) </strong>weakself = self;<br>    [self setBlcok:^{<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>            NSLog(@”perosn :%p”,__weakself);<br>        });<br>    }];<br>    self.blcok();<br>}</p>\n<p>int main(int argc, const char <em> argv[]) {<br>    @autoreleasepool {<br>        {<br>            FYPerson </em>obj=[[FYPerson alloc]init];<br>            [obj test];<br>            NSLog(@”block 执行完毕————–”);<br>        }<br>        NSLog(@”person 死了”);<br>    }<br>    return 0;<br>}<br>输出：<br>block 执行完毕————–<br>-[FYPerson dealloc]<br>person 死了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">猛的一看，哪里都对！使用`__weak`对`self`进行弱引用，不会导致死循环，在`self`死的时候，`block`也会死，就会导致一个问题，`self`和`block`共存亡，但是这个需要3秒后再执行，3秒后，`self`已经死了，`block`也死了，显然不符合我们的业务需求。</div><div class=\"line\">那么我们剥离`block`和`self`的关系，让`block`强引用`self`,`self`不持有`block`就能满足业务了。如下所示：</div></pre></td></tr></table></figure></p>\n<pre><code>__block typeof(self) __weakSelf = self;//__block或者没有修饰符\ndispatch_async(dispatch_get_main_queue(), ^{\n    sleep(2);\n    NSLog(@&quot;obj:%@&quot;,__weakSelf-&gt;_obj);\n});\n</code></pre><p>//perosn :0x0<br>```</p>\n<p>当<code>self</code>不持用<code>block</code>的时候，<code>block</code>可以强引用<code>self</code>,<code>block</code>执行完毕自己释放，也会释放<code>self</code>，当<code>self</code>持有<code>block</code>，<code>block</code>必须弱引用<code>self</code>,则释放<code>self</code>,<code>block</code>也会释放，否则会循环引用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><code>block</code>本质是一个封装了函数调用以及调用环境的<code>结构体</code>对象</li>\n<li><code>__block</code>修饰的变量会被封装成<code>结构体</code>对象，之前在数据段的会被复制到堆上，之前在堆上的则不受影响，解决<code>auto</code>对象在<code>block</code>内部无法修改的问题，在<code>MRC</code>环境下,<code>__block</code>不会对变量产生强引用.</li>\n<li><code>block</code>不使用<code>copy</code>则不会从全局或者栈区域移动到堆上，使用<code>copy</code>之后有由发者管理</li>\n<li>使用<code>block</code>要注意不能产生循环引用，引用不能变成一个环，主动使其中一个引用成弱引用，则不会产生循环引用。</li>\n<li><code>__weak</code>修饰的对象，<code>block</code>不会对对象强引用，在执行<code>block</code>的时候有可能会值已经被系统置为<code>nil</code>,<code>__unsafe_unretained</code>修饰的销毁之后内存不会及时重置为空。</li>\n</ul>\n<p>我们看的<code>cpp</code>是编译之后的代码，<code>runtime</code>是否和我们看到的一致呢？请听下回分解。</p>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n</li>\n</ul>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理 Category与关联对象本质--(4)","date":"2019-12-01T03:14:58.000Z","_content":"\n 今天我们再看一下`Category`的底层原理。\n 先看一下`Category`的简单使用，首先新增一个类的`Category`，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:\n \n \n```\n@interface FYPerson : NSObject\n- (void)run;\n@end\n@implementation FYPerson\n-(void)run{\n\tNSLog(@\"run is run\");\n}\n@end\n\n\n//类别\n@interface FYPerson (test)\n- (void)test;\n@end\n@implementation FYPerson (test)\n- (void)test{\n\tNSLog(@\"test is run\");\n}\n@end\n\n\n//使用\n#import \"FYPerson.h\"\n#import \"FYPerson+test.h\"\n\n\nFYPerson *person=[[FYPerson alloc]init];\n[person test];\n[person run];\n```\n  类别使用就是这么简单。\n  那么类别的本质是什么呢？类的方法是存储在什么地方呢？\n  第一篇[类的本质](https://juejin.im/post/5d15887ee51d45108126d28d)已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体`fy_objc_class`中的`class_data_bits_t->data()->method_list_t`中的，那么类别方法也是存储在`method_list_t`和取元类对象的`method_list_t`中的。编译的时候类别编译成结构体`_category_t`,然后`runtime`在运行时动态将方法添加到`method_list_t`中。运行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp`进入到`FYPerson+test.cpp`内部查看编译之后的代码\n  \n```\n  struct _category_t {\n\tconst char *name; //\"FYPerson\"\n\tstruct _class_t *cls;\n\tconst struct _method_list_t *instance_methods;\n\tconst struct _method_list_t *class_methods;\n\tconst struct _protocol_list_t *protocols;\n\tconst struct _prop_list_t *properties;\n};\n//存储 test方法\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t1,\n\t{{(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_FYPerson_test_test}}\n};\n\nextern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;\n\n//_category_t 存储FYPerson的分类的数据\nstatic struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"FYPerson\",\n\t0, // &OBJC_CLASS_$_FYPerson,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法\n\t0,//类方法\n\t0,//协议方法\n\t0,//属性\n};\n```\n\n存储在`_category_t`中的数据是什么时间加载到`FYPerson`的`class_data_bits_t.data`呢？我们探究一下，打开[源码](https://opensource.apple.com/tarballs/objc4/)下载打开工程阅读源码找到`objc-os.mm`,通过查找函数运行顺序得到`_objec_init->map_images->map_images_noljock->_read_images->remethodizeClass(cls)->attachCategories(cls, cats, true /*flush caches*/)`，最终进入到`attachCategories`关键函数内部：\n  \n```\n  // Attach method lists and properties and protocols from categories to a class.\n// Assumes the categories in cats are all loaded and sorted by load order, \n// oldest categories first.\nstatic void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n\t//属性数组\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n\t//协议数组\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    //最后的编译文件放到最前边\n    while (i--) {\n\t\t//取出某个分类\n        auto& entry = cats->list[i];\n//取出分类 的 instance方法或者class方法\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist; //mlists 接受所有分类方法\n            fromBundle |= entry.hi->isBundle();\n        }\n//proplist 接受所有分类属性\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n//proplist 接受所有协议方法\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n//收集了所有协议 分类方法\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n\t//追加所有分类方法\n    rw->methods.attachLists(mlists, mcount);\n\t//释放数组\n    free(mlists);\n\t//刷新该类的缓存\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n//追加所有分类属性\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);//释放数组\n//追加所有分类协议\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);//释放数组\n}\n```\n`attachCategories`是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到`rw->protocols.attachLists`内部：\n\n```\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count;\n\t\t\t//一共需要的数量\n            uint32_t newCount = oldCount + addedCount;\n\t\t\t//分配内存 内存不够用了，需要扩容\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n\t\t\t//赋值count\n            array()->count = newCount;\n\t\t\t// array()->lists：原来的方法列表向后移动 oldCount * sizeof(array()->lists[0]个长度\n            memmove(array()->lists + addedCount/*指针移动到数组末尾*/, array()->lists/*数组*/,\n                    oldCount * sizeof(array()->lists[0])/*移动数据的大小*/);\n\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()->lists[0])\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n\t\t\t/*\n\t\t\t图示讲解：\n\t\t\tarray()->lists:A->B->C->D->E\n\t\taddedCount:3\n\t\taddedLists:P->L->V\n\t\t\tmemmove之后：nil->nil->nil->A->B->C->D->E\n\t\t\t然后再讲addedLists插入到数组前边,最终array()->lists的值是：\n\t\t\tP->L->V->A->B->C->D->E\n\t\t\t */\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n可以看出来：\n1. 首先通过`runtime`加载某个类的所有Category数据\n2. 把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边\n3. 将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。\n\n具体的编译顺序是project文件中->Build Phases->Complile Sources的顺序。\n\n### 调用顺序\n#### +load加载顺序 \n\n每个类和分类都会加载的时候调用`+load`方法，具体是怎么调用呢？我们查看源码`_objc_init->load_images->call_load_methods`\n\n\n```\nvoid call_load_methods(void)\n{\n    static bool loading = NO;\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // Re-entrant calls do nothing; the outermost call will finish the job.\n    if (loading) return;\n    loading = YES;\n\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 1. Repeatedly call class +loads until there aren't any more\n        //执行class+load直到完成\n        while (loadable_classes_used > 0) {\n            call_class_loads();\n        }\n//执行Category +load 一次\n        // 2. Call category +loads ONCE\n        more_categories = call_category_loads();\n\n        // 3. Run more +loads if there are classes OR more untried categories\n    } while (loadable_classes_used > 0  ||  more_categories);\n\n    objc_autoreleasePoolPop(pool);\n\n    loading = NO;\n}\n```\n\n类`+load`在`Category+load`前边执行，当类的`+load`执行完毕然后再去执行`Category+load`,而且只有一次。\n当class有子类的时候加载顺序呢？其实所有类都是基于`NSObject`，那么我们假设按照编译顺序加载`Class+load`，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类`+load`中的操作是第一个执行的，其他子类是按照`superclass->class->sonclass`的顺序执行的。\n查看源码`_objc_init->load_images->prepare_load_methods((const headerType *)mh)->schedule_class_load`在`objc-runtime-new.mm`2856行\n\n```\n/***********************************************************************\n* Schedule +load for classes in this image, any un-+load-ed \n* superclasses in other images, and any categories in this image.\n**********************************************************************/\n// Recursively schedule +load for cls and any un-+load-ed superclasses.\n// cls must already be connected.\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    assert(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return;\n\n    // Ensure superclass-first ordering\n    //递归调用自己直到调用clas->self\n    schedule_class_load(cls->superclass);\n//添加class\n    add_class_to_loadable_list(cls);\n    cls->setInfo(RW_LOADED); \n}\n```\n\n可以了解到该函数递归调用自己，直到`+load`方法已经调用过为止，所以不管编译顺序是高低，`+load`的加载顺序始终是`NSObject->FYPrson->FYStudent`。多个类平行关系的话，按照编译顺序加载。\n下边是稍微复杂点的类关系：\n\n```\n\nNSObject\n    Person\n        Student\nNSObjet\n    Car\n        BigCar\n            BigOrSmallCar\n```\n\n编译顺序是\n\n```\nPerson\nStudent\nCar\nBigOrSmallCar\n```\n\n那么他们`+load`的加载顺序是：\n\n```\n\nNSobject->Person->Student->Car->BigCar->BigOrSmallCar\n\n```\n\n看着不是很明白的 可以再看一下刚才的`schedule_class_load`函数。\n加载成功之后，是按照`objc_msgsend()`流程发送的吗？我们进入到`call_class_loads`内部\n\n```\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        (*load_method)(cls, SEL_load);\n    }\n    if (classes) free(classes);\n}\n```\n\n可以找到` (*load_method)(cls, SEL_load);`该函数，该函数是直接使用`IMP`执行的，`IMP`就是函数地址，可以直接访问函数而不用消息的转发流程。\n\n####  +initialize调用\n- +initialize方法会在类第一次接收到消息时调用\n- 先调用父类的+initialize，再调用子类的+initialize\n- 先初始化父类，再初始化子类，每个类只会初始化1次\n\n`objc`源码解读过程`objc-msg-arm64.x->objc_msgSend->objc->runtime-new->class_getinstanceMethod->lookUpImpOrNil->lookUpImpOrForward->_clas_initialize->callInitialize->objc_msgSend(cls,SEL_Initialize)`\n在`runtime-new.h`4819行\n\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    lookUpImpOrNil(cls, sel, nil, \n                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);\n\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n根据`lookUpImpOrNil`查看4916行\n\n```\nIMP lookUpImpOrForward(Class cls, SEL sel, id inst, \n                       bool initialize, bool cache, bool resolver)\n{\n    IMP imp = nil;\n    bool triedResolver = NO;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (cache) {\n        imp = cache_getImp(cls, sel);\n        if (imp) return imp;\n    }\n\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n\n    if (!cls->isRealized()) {\n        realizeClass(cls);\n    }\n\n    if (initialize  &&  !cls->isInitialized()) {\n        runtimeLock.unlock();\n        _class_initialize (_class_getNonMetaClass(cls, inst));\n        runtimeLock.lock();\n      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化\n      }\n retry:    \n    runtimeLock.assertLocked();\n    imp = cache_getImp(cls, sel);\n    if (imp) goto done;\n   // Try this class's method lists.\n    //在本类中查找method\n    {\n        Method meth = getMethodNoSuper_nolock(cls, sel);\n        if (meth) {\n            log_and_fill_cache(cls, meth->imp, sel, inst, cls);\n            imp = meth->imp;\n            goto done;\n        }\n    }\n\n    // Try superclass caches and method lists.\n    {\n        unsigned attempts = unreasonableClassCount();\n        for (Class curClass = cls->superclass;\n             curClass != nil;\n             curClass = curClass->superclass)\n        {\n            // Halt if there is a cycle in the superclass chain.\n            if (--attempts == 0) {\n                _objc_fatal(\"Memory corruption in class list.\");\n            }\n            \n            // Superclass cache.\n            imp = cache_getImp(curClass, sel);\n            if (imp) {\n                if (imp != (IMP)_objc_msgForward_impcache) {\n                    // Found the method in a superclass. Cache it in this class.\n                    log_and_fill_cache(cls, imp, sel, inst, curClass);\n                    goto done;\n                }\n                else {\n                    // Found a forward:: entry in a superclass.\n                    // Stop searching, but don't cache yet; call method \n                    // resolver for this class first.\n                    break;\n                }\n            }\n            \n            // Superclass method list.\n            Method meth = getMethodNoSuper_nolock(curClass, sel);\n            if (meth) {\n                log_and_fill_cache(cls, meth->imp, sel, inst, curClass);\n                imp = meth->imp;\n                goto done;\n            }\n        }\n    }\n\n    // No implementation found. Try method resolver once.\n\n    if (resolver  &&  !triedResolver) {\n        runtimeLock.unlock();\n        _class_resolveMethod(cls, sel, inst);\n        runtimeLock.lock();\n        // Don't cache the result; we don't hold the lock so it may have \n        // changed already. Re-do the search from scratch instead.\n        triedResolver = YES;\n        goto retry;\n    }\n\n    // No implementation found, and method resolver didn't help. \n    // Use forwarding.\n\n    imp = (IMP)_objc_msgForward_impcache;\n    cache_fill(cls, sel, imp, inst);\n\n done:\n    runtimeLock.unlock();\n\n    return imp;\n}\n```\n\n当第一次收到消息，cls没有初始化，则调用`_class_initialize`进行初始化\n我们进入到`_class_initialize`内部`objc-initialize.mm`484行\n\n```\nvoid _class_initialize(Class cls)\n{\n    assert(!cls->isMetaClass());\n\n    Class supercls;\n    bool reallyInitialize = NO;\n\n    // Make sure super is done initializing BEFORE beginning to initialize cls.\n    // See note about deadlock above.\n    //递归调用父类是否有初始化和是否有父类\n    supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) {\n        _class_initialize(supercls);\n    }\n    \n    // Try to atomically set CLS_INITIALIZING.\n    {\n        monitor_locker_t lock(classInitLock);\n        if (!cls->isInitialized() && !cls->isInitializing()) {\n            cls->setInitializing();\n            reallyInitialize = YES;\n        }\n    }\n    \n    if (reallyInitialize) {\n        // We successfully set the CLS_INITIALIZING bit. Initialize the class.\n        \n        // Record that we're initializing this class so we can message it.\n        _setThisThreadIsInitializingClass(cls);\n\n        if (MultithreadedForkChild) {\n            // LOL JK we don't really call +initialize methods after fork().\n            performForkChildInitialize(cls, supercls);\n            return;\n        }\n        \n        // Send the +initialize message.\n        // Note that +initialize is sent to the superclass (again) if \n        // this class doesn't implement +initialize. 2157218\n        if (PrintInitializing) {\n            _objc_inform(\"INITIALIZE: thread %p: calling +[%s initialize]\",\n                         pthread_self(), cls->nameForLogging());\n        }\n\n        // Exceptions: A +initialize call that throws an exception \n        // is deemed to be a complete and successful +initialize.\n        //\n        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a\n        // bootstrapping problem of this versus CF's call to\n        // objc_exception_set_functions().\n#if __OBJC2__\n        @try\n#endif\n        {\n            callInitialize(cls);\n\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: finished +[%s initialize]\",\n                             pthread_self(), cls->nameForLogging());\n            }\n        }\n#if __OBJC2__\n        @catch (...) {\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: +[%s initialize] \"\n                             \"threw an exception\",\n                             pthread_self(), cls->nameForLogging());\n            }\n            @throw;\n        }\n        @finally\n#endif\n        {\n            // Done initializing.\n            lockAndFinishInitializing(cls, supercls);\n        }\n        return;\n    }\n    \n    else if (cls->isInitializing()) {\n        // We couldn't set INITIALIZING because INITIALIZING was already set.\n        // If this thread set it earlier, continue normally.\n        // If some other thread set it, block until initialize is done.\n        // It's ok if INITIALIZING changes to INITIALIZED while we're here, \n        //   because we safely check for INITIALIZED inside the lock \n        //   before blocking.\n        if (_thisThreadIsInitializingClass(cls)) {\n            return;\n        } else if (!MultithreadedForkChild) {\n            waitForInitializeToComplete(cls);\n            return;\n        } else {\n            // We're on the child side of fork(), facing a class that\n            // was initializing by some other thread when fork() was called.\n            _setThisThreadIsInitializingClass(cls);\n            performForkChildInitialize(cls, supercls);\n        }\n    }\n    \n    else if (cls->isInitialized()) {\n        // Set CLS_INITIALIZING failed because someone else already \n        //   initialized the class. Continue normally.\n        // NOTE this check must come AFTER the ISINITIALIZING case.\n        // Otherwise: Another thread is initializing this class. ISINITIALIZED \n        //   is false. Skip this clause. Then the other thread finishes \n        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. \n        //   Skip the ISINITIALIZING clause. Die horribly.\n        return;\n    }\n    \n    else {\n        // We shouldn't be here. \n        _objc_fatal(\"thread-safe class init in objc runtime is buggy!\");\n    }\n}\n```\n\n可以看出来，和`+load`方法一样，先父类后子类。然后赋值`reallyInitialize = YES;`，后边使用`try`主动调用`callInitialize(cls);`，来到`callInitialize(cls);`内部：\n\n```\nvoid callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);\n    asm(\"\");\n}\n```\n\n可以看到最终还是使用`((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)`主动调用了该函数。\n### 区别\n`+initialize`和`+load`的很大区别是，`+initialize`是通过`objc_msgSend`进行调用的，所以有以下特点\n如果子类没有实现`+initialize`，会调用父类的`+initialize`（所以父类的`+initialize`可能会被调用多次）\n如果分类实现了`+initialize`，就覆盖类本身的`+initialize`调用\n\n用伪代码实现以下思路：\n\n```\n    if(class 没有初始化){\n        父类初始化\n        子类初始化\n        调用initialize\n    }\n    如果子类没有实现initialize，则去调用父类initialize。\n```\n\n至于子类没有实现的话是直接调用父类的`initialize`，是使用`objc-msgsend`的原因。\n\n### 验证\n\n```\n@interface FYPerson : NSObject\n\n@end\n+(void)initialize{\n\tprintf(\"\\n%s\",__func__);\n\n}\n+(void)load{\n\tprintf(\"\\n%s\",__func__);\n\n}\n@interface FYPerson (test1)\n\n@end\n\n+(void)initialize{\n\tprintf(\"\\n%s\",__func__);\n\n}\n+(void)load{\n\tprintf(\"\\n%s\",__func__);\n\n}\n//输出\n+[FYPerson load]\n+[FYPerson(test2) load]\n+[FYPerson(test1) load]\n\n```\n### 总结\n- `+load`是根据函数地址直接调用，`initialize`是通过`objc_msgSend`调用\n- `+load`是runtime加载类、分类时候调用（只会调用一次）\n- `initialize`是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）\n- `+load`调用优先于`initialize`,子类调用`+load`之前会调用父类的`+load`，再调用分类的`+load`,分类之间先编译，先调用。\n- `initialize`先初始化父类，再初始化子类（可能最终调用父类的`initialize`）\n\n### 关联对象本质\n#### 关联对象的本质-结构体\n继承`NSObject`是可以可以直接使用`@property (nonatomic,assign) int age;\n`，但是在`Category`中会报错，那么怎么实现和继承基类一样的效果呢？\n我们查看`Category`结构体\n\n```\n  struct _category_t {\n\tconst char *name; //\"FYPerson\"\n\tstruct _class_t *cls;\n\tconst struct _method_list_t *instance_methods;\n\tconst struct _method_list_t *class_methods;\n\tconst struct _protocol_list_t *protocols;\n\tconst struct _prop_list_t *properties;\n};\n```\n\n其中`const struct _prop_list_t *properties;`是存储属性的，但是缺少成员变量，而我们也不能主动在`_category_t`插入`ivar`，那么我们可以使用`objc_setAssociatedObject`将属性的值存储全局的`AssociationsHashMap`中，使用的时候`objc_getAssociatedObject(id object, const void *key) `,不使用的时候删除使用`objc_removeAssociatedObjects`删除。\n\n我们进入到`objc_setAssociatedObject`内部,`objc-references.mm`275行\n\n```\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n\t//根据key value 处理\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n\t\t//生成一个全局的 HashMap\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n\t\t//有value 就处理\n        if (new_value) {\n            // break any existing association.\n//\t\t\t遍历 hashMap是否有该obj\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n\t\t\t\t//有的话 更新其 value\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n\t\t\t\t//没有的话 赋值给 refs\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                object->setHasAssociatedObjects();\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    //删除refs \n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n\n```\n\n通过该函数我们了解到\n- 关联对象并不是存储在关联对象的本身内存中\n- 关联对象是存储在全局统一的`AssociationsManager`管理的`AssociationsHashMap`中\n- 传入value =nil，会移除该关联对线\n`AssociationsManager`其实是管理了已`key为id object`对应的`AssociationsHashMap`，`AssociationsHashMap`存储了`key`对应的`ObjcAssociation`，`ObjcAssociation`是存储了`value` 和`policy`，`ObjcAssociation`的数据结构如下：\n\n```\nclass ObjcAssociation {\n        uintptr_t _policy;\n        id _value;\n        *****\n        }\n```\n具体抽象关系见下图\n\n```\nAssociationsManager --> AssociationsHashMap --> ObjectAssociationMap\n-->void * ObjectAssociation -->uintprt_t _policy ,id _value;\n```\n\n简单来讲就是一个全局变量保存了以`class`为`key`对应的`AssociationsHashMap`，这个`AssociationsHashMap`存储了一个`key`对应的`ObjectAssociation`，`ObjectAssociation`包含了`value`和`_policy`。通过2层map保存了数据。\n\n#### 关联对象的使用\n\n|objc_setAssociatedObject|obj,key,value,policy|\n|------------------------|-------------------|\n|objc_getAssociatedObject|根据 obj 和 key获取值|\n|void objc_removeAssociatedObjects(id object)|根据obj 删除关联函数|\n\n`objc_AssociationPolicy`的类型：\n\n|OBJC_ASSOCIATION_ASSIGN|weak 引用|\n|------|--------|\n|OBJC_ASSOCIATION_RETAIN_NONATOMIC|非原子强引用|\n|OBJC_ASSOCIATION_COPY_NONATOMIC|非原子相当于copy|\n|OBJC_ASSOCIATION_RETAIN|强引用|\n|OBJC_ASSOCIATION_COPY| 原子操作，相当于copy|\n\n#### 代码示例\n\n```\n@interface NSObject (test)\n@property (nonatomic,assign) NSString * name;\n@end\n\n#import \"NSObject+test.h\"\n#import \"objc/runtime.h\"\n@implementation NSObject (test)\n-(void)setName:(NSString *)name{\n\tobjc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);\n}\n- (NSString *)name{\n\treturn  objc_getAssociatedObject(self, @selector(name));\n}\n@end\n\n\n\nNSObject *obj =[[NSObject alloc]init];\nobj.name = @\"老弟来了\";\nprintf(\"%s\",obj.name.UTF8String);\n//老弟来了\n```\n\n这段代码我们实现了给基类添加一个成员变量`name`，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。\n\n### 总结\n- Category `+load`在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。\n- Category `+initialize`在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用`objc-msgsend`机制调用。\n- Category 可以利用`Associative`添加和读取属性的值\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n  本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n  广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 Category与关联对象本质--(4).md","raw":"title: iOS底层原理 Category与关联对象本质--(4)\ndate: 2019-12-1 11:14:58\ntags:\n- iOS\ncategories: iOS\n---\n\n 今天我们再看一下`Category`的底层原理。\n 先看一下`Category`的简单使用，首先新增一个类的`Category`，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:\n \n \n```\n@interface FYPerson : NSObject\n- (void)run;\n@end\n@implementation FYPerson\n-(void)run{\n\tNSLog(@\"run is run\");\n}\n@end\n\n\n//类别\n@interface FYPerson (test)\n- (void)test;\n@end\n@implementation FYPerson (test)\n- (void)test{\n\tNSLog(@\"test is run\");\n}\n@end\n\n\n//使用\n#import \"FYPerson.h\"\n#import \"FYPerson+test.h\"\n\n\nFYPerson *person=[[FYPerson alloc]init];\n[person test];\n[person run];\n```\n  类别使用就是这么简单。\n  那么类别的本质是什么呢？类的方法是存储在什么地方呢？\n  第一篇[类的本质](https://juejin.im/post/5d15887ee51d45108126d28d)已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体`fy_objc_class`中的`class_data_bits_t->data()->method_list_t`中的，那么类别方法也是存储在`method_list_t`和取元类对象的`method_list_t`中的。编译的时候类别编译成结构体`_category_t`,然后`runtime`在运行时动态将方法添加到`method_list_t`中。运行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp`进入到`FYPerson+test.cpp`内部查看编译之后的代码\n  \n```\n  struct _category_t {\n\tconst char *name; //\"FYPerson\"\n\tstruct _class_t *cls;\n\tconst struct _method_list_t *instance_methods;\n\tconst struct _method_list_t *class_methods;\n\tconst struct _protocol_list_t *protocols;\n\tconst struct _prop_list_t *properties;\n};\n//存储 test方法\nstatic struct /*_method_list_t*/ {\n\tunsigned int entsize;  // sizeof(struct _objc_method)\n\tunsigned int method_count;\n\tstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\n\tsizeof(_objc_method),\n\t1,\n\t{{(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_FYPerson_test_test}}\n};\n\nextern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;\n\n//_category_t 存储FYPerson的分类的数据\nstatic struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"FYPerson\",\n\t0, // &OBJC_CLASS_$_FYPerson,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法\n\t0,//类方法\n\t0,//协议方法\n\t0,//属性\n};\n```\n\n存储在`_category_t`中的数据是什么时间加载到`FYPerson`的`class_data_bits_t.data`呢？我们探究一下，打开[源码](https://opensource.apple.com/tarballs/objc4/)下载打开工程阅读源码找到`objc-os.mm`,通过查找函数运行顺序得到`_objec_init->map_images->map_images_noljock->_read_images->remethodizeClass(cls)->attachCategories(cls, cats, true /*flush caches*/)`，最终进入到`attachCategories`关键函数内部：\n  \n```\n  // Attach method lists and properties and protocols from categories to a class.\n// Assumes the categories in cats are all loaded and sorted by load order, \n// oldest categories first.\nstatic void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n\t//属性数组\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n\t//协议数组\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    //最后的编译文件放到最前边\n    while (i--) {\n\t\t//取出某个分类\n        auto& entry = cats->list[i];\n//取出分类 的 instance方法或者class方法\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist; //mlists 接受所有分类方法\n            fromBundle |= entry.hi->isBundle();\n        }\n//proplist 接受所有分类属性\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n//proplist 接受所有协议方法\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n//收集了所有协议 分类方法\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n\t//追加所有分类方法\n    rw->methods.attachLists(mlists, mcount);\n\t//释放数组\n    free(mlists);\n\t//刷新该类的缓存\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n//追加所有分类属性\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);//释放数组\n//追加所有分类协议\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);//释放数组\n}\n```\n`attachCategories`是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到`rw->protocols.attachLists`内部：\n\n```\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count;\n\t\t\t//一共需要的数量\n            uint32_t newCount = oldCount + addedCount;\n\t\t\t//分配内存 内存不够用了，需要扩容\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n\t\t\t//赋值count\n            array()->count = newCount;\n\t\t\t// array()->lists：原来的方法列表向后移动 oldCount * sizeof(array()->lists[0]个长度\n            memmove(array()->lists + addedCount/*指针移动到数组末尾*/, array()->lists/*数组*/,\n                    oldCount * sizeof(array()->lists[0])/*移动数据的大小*/);\n\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()->lists[0])\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n\t\t\t/*\n\t\t\t图示讲解：\n\t\t\tarray()->lists:A->B->C->D->E\n\t\taddedCount:3\n\t\taddedLists:P->L->V\n\t\t\tmemmove之后：nil->nil->nil->A->B->C->D->E\n\t\t\t然后再讲addedLists插入到数组前边,最终array()->lists的值是：\n\t\t\tP->L->V->A->B->C->D->E\n\t\t\t */\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n可以看出来：\n1. 首先通过`runtime`加载某个类的所有Category数据\n2. 把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边\n3. 将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。\n\n具体的编译顺序是project文件中->Build Phases->Complile Sources的顺序。\n\n### 调用顺序\n#### +load加载顺序 \n\n每个类和分类都会加载的时候调用`+load`方法，具体是怎么调用呢？我们查看源码`_objc_init->load_images->call_load_methods`\n\n\n```\nvoid call_load_methods(void)\n{\n    static bool loading = NO;\n    bool more_categories;\n\n    loadMethodLock.assertLocked();\n\n    // Re-entrant calls do nothing; the outermost call will finish the job.\n    if (loading) return;\n    loading = YES;\n\n    void *pool = objc_autoreleasePoolPush();\n\n    do {\n        // 1. Repeatedly call class +loads until there aren't any more\n        //执行class+load直到完成\n        while (loadable_classes_used > 0) {\n            call_class_loads();\n        }\n//执行Category +load 一次\n        // 2. Call category +loads ONCE\n        more_categories = call_category_loads();\n\n        // 3. Run more +loads if there are classes OR more untried categories\n    } while (loadable_classes_used > 0  ||  more_categories);\n\n    objc_autoreleasePoolPop(pool);\n\n    loading = NO;\n}\n```\n\n类`+load`在`Category+load`前边执行，当类的`+load`执行完毕然后再去执行`Category+load`,而且只有一次。\n当class有子类的时候加载顺序呢？其实所有类都是基于`NSObject`，那么我们假设按照编译顺序加载`Class+load`，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类`+load`中的操作是第一个执行的，其他子类是按照`superclass->class->sonclass`的顺序执行的。\n查看源码`_objc_init->load_images->prepare_load_methods((const headerType *)mh)->schedule_class_load`在`objc-runtime-new.mm`2856行\n\n```\n/***********************************************************************\n* Schedule +load for classes in this image, any un-+load-ed \n* superclasses in other images, and any categories in this image.\n**********************************************************************/\n// Recursively schedule +load for cls and any un-+load-ed superclasses.\n// cls must already be connected.\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    assert(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return;\n\n    // Ensure superclass-first ordering\n    //递归调用自己直到调用clas->self\n    schedule_class_load(cls->superclass);\n//添加class\n    add_class_to_loadable_list(cls);\n    cls->setInfo(RW_LOADED); \n}\n```\n\n可以了解到该函数递归调用自己，直到`+load`方法已经调用过为止，所以不管编译顺序是高低，`+load`的加载顺序始终是`NSObject->FYPrson->FYStudent`。多个类平行关系的话，按照编译顺序加载。\n下边是稍微复杂点的类关系：\n\n```\n\nNSObject\n    Person\n        Student\nNSObjet\n    Car\n        BigCar\n            BigOrSmallCar\n```\n\n编译顺序是\n\n```\nPerson\nStudent\nCar\nBigOrSmallCar\n```\n\n那么他们`+load`的加载顺序是：\n\n```\n\nNSobject->Person->Student->Car->BigCar->BigOrSmallCar\n\n```\n\n看着不是很明白的 可以再看一下刚才的`schedule_class_load`函数。\n加载成功之后，是按照`objc_msgsend()`流程发送的吗？我们进入到`call_class_loads`内部\n\n```\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        (*load_method)(cls, SEL_load);\n    }\n    if (classes) free(classes);\n}\n```\n\n可以找到` (*load_method)(cls, SEL_load);`该函数，该函数是直接使用`IMP`执行的，`IMP`就是函数地址，可以直接访问函数而不用消息的转发流程。\n\n####  +initialize调用\n- +initialize方法会在类第一次接收到消息时调用\n- 先调用父类的+initialize，再调用子类的+initialize\n- 先初始化父类，再初始化子类，每个类只会初始化1次\n\n`objc`源码解读过程`objc-msg-arm64.x->objc_msgSend->objc->runtime-new->class_getinstanceMethod->lookUpImpOrNil->lookUpImpOrForward->_clas_initialize->callInitialize->objc_msgSend(cls,SEL_Initialize)`\n在`runtime-new.h`4819行\n\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    lookUpImpOrNil(cls, sel, nil, \n                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);\n\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n根据`lookUpImpOrNil`查看4916行\n\n```\nIMP lookUpImpOrForward(Class cls, SEL sel, id inst, \n                       bool initialize, bool cache, bool resolver)\n{\n    IMP imp = nil;\n    bool triedResolver = NO;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (cache) {\n        imp = cache_getImp(cls, sel);\n        if (imp) return imp;\n    }\n\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n\n    if (!cls->isRealized()) {\n        realizeClass(cls);\n    }\n\n    if (initialize  &&  !cls->isInitialized()) {\n        runtimeLock.unlock();\n        _class_initialize (_class_getNonMetaClass(cls, inst));\n        runtimeLock.lock();\n      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化\n      }\n retry:    \n    runtimeLock.assertLocked();\n    imp = cache_getImp(cls, sel);\n    if (imp) goto done;\n   // Try this class's method lists.\n    //在本类中查找method\n    {\n        Method meth = getMethodNoSuper_nolock(cls, sel);\n        if (meth) {\n            log_and_fill_cache(cls, meth->imp, sel, inst, cls);\n            imp = meth->imp;\n            goto done;\n        }\n    }\n\n    // Try superclass caches and method lists.\n    {\n        unsigned attempts = unreasonableClassCount();\n        for (Class curClass = cls->superclass;\n             curClass != nil;\n             curClass = curClass->superclass)\n        {\n            // Halt if there is a cycle in the superclass chain.\n            if (--attempts == 0) {\n                _objc_fatal(\"Memory corruption in class list.\");\n            }\n            \n            // Superclass cache.\n            imp = cache_getImp(curClass, sel);\n            if (imp) {\n                if (imp != (IMP)_objc_msgForward_impcache) {\n                    // Found the method in a superclass. Cache it in this class.\n                    log_and_fill_cache(cls, imp, sel, inst, curClass);\n                    goto done;\n                }\n                else {\n                    // Found a forward:: entry in a superclass.\n                    // Stop searching, but don't cache yet; call method \n                    // resolver for this class first.\n                    break;\n                }\n            }\n            \n            // Superclass method list.\n            Method meth = getMethodNoSuper_nolock(curClass, sel);\n            if (meth) {\n                log_and_fill_cache(cls, meth->imp, sel, inst, curClass);\n                imp = meth->imp;\n                goto done;\n            }\n        }\n    }\n\n    // No implementation found. Try method resolver once.\n\n    if (resolver  &&  !triedResolver) {\n        runtimeLock.unlock();\n        _class_resolveMethod(cls, sel, inst);\n        runtimeLock.lock();\n        // Don't cache the result; we don't hold the lock so it may have \n        // changed already. Re-do the search from scratch instead.\n        triedResolver = YES;\n        goto retry;\n    }\n\n    // No implementation found, and method resolver didn't help. \n    // Use forwarding.\n\n    imp = (IMP)_objc_msgForward_impcache;\n    cache_fill(cls, sel, imp, inst);\n\n done:\n    runtimeLock.unlock();\n\n    return imp;\n}\n```\n\n当第一次收到消息，cls没有初始化，则调用`_class_initialize`进行初始化\n我们进入到`_class_initialize`内部`objc-initialize.mm`484行\n\n```\nvoid _class_initialize(Class cls)\n{\n    assert(!cls->isMetaClass());\n\n    Class supercls;\n    bool reallyInitialize = NO;\n\n    // Make sure super is done initializing BEFORE beginning to initialize cls.\n    // See note about deadlock above.\n    //递归调用父类是否有初始化和是否有父类\n    supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) {\n        _class_initialize(supercls);\n    }\n    \n    // Try to atomically set CLS_INITIALIZING.\n    {\n        monitor_locker_t lock(classInitLock);\n        if (!cls->isInitialized() && !cls->isInitializing()) {\n            cls->setInitializing();\n            reallyInitialize = YES;\n        }\n    }\n    \n    if (reallyInitialize) {\n        // We successfully set the CLS_INITIALIZING bit. Initialize the class.\n        \n        // Record that we're initializing this class so we can message it.\n        _setThisThreadIsInitializingClass(cls);\n\n        if (MultithreadedForkChild) {\n            // LOL JK we don't really call +initialize methods after fork().\n            performForkChildInitialize(cls, supercls);\n            return;\n        }\n        \n        // Send the +initialize message.\n        // Note that +initialize is sent to the superclass (again) if \n        // this class doesn't implement +initialize. 2157218\n        if (PrintInitializing) {\n            _objc_inform(\"INITIALIZE: thread %p: calling +[%s initialize]\",\n                         pthread_self(), cls->nameForLogging());\n        }\n\n        // Exceptions: A +initialize call that throws an exception \n        // is deemed to be a complete and successful +initialize.\n        //\n        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a\n        // bootstrapping problem of this versus CF's call to\n        // objc_exception_set_functions().\n#if __OBJC2__\n        @try\n#endif\n        {\n            callInitialize(cls);\n\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: finished +[%s initialize]\",\n                             pthread_self(), cls->nameForLogging());\n            }\n        }\n#if __OBJC2__\n        @catch (...) {\n            if (PrintInitializing) {\n                _objc_inform(\"INITIALIZE: thread %p: +[%s initialize] \"\n                             \"threw an exception\",\n                             pthread_self(), cls->nameForLogging());\n            }\n            @throw;\n        }\n        @finally\n#endif\n        {\n            // Done initializing.\n            lockAndFinishInitializing(cls, supercls);\n        }\n        return;\n    }\n    \n    else if (cls->isInitializing()) {\n        // We couldn't set INITIALIZING because INITIALIZING was already set.\n        // If this thread set it earlier, continue normally.\n        // If some other thread set it, block until initialize is done.\n        // It's ok if INITIALIZING changes to INITIALIZED while we're here, \n        //   because we safely check for INITIALIZED inside the lock \n        //   before blocking.\n        if (_thisThreadIsInitializingClass(cls)) {\n            return;\n        } else if (!MultithreadedForkChild) {\n            waitForInitializeToComplete(cls);\n            return;\n        } else {\n            // We're on the child side of fork(), facing a class that\n            // was initializing by some other thread when fork() was called.\n            _setThisThreadIsInitializingClass(cls);\n            performForkChildInitialize(cls, supercls);\n        }\n    }\n    \n    else if (cls->isInitialized()) {\n        // Set CLS_INITIALIZING failed because someone else already \n        //   initialized the class. Continue normally.\n        // NOTE this check must come AFTER the ISINITIALIZING case.\n        // Otherwise: Another thread is initializing this class. ISINITIALIZED \n        //   is false. Skip this clause. Then the other thread finishes \n        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. \n        //   Skip the ISINITIALIZING clause. Die horribly.\n        return;\n    }\n    \n    else {\n        // We shouldn't be here. \n        _objc_fatal(\"thread-safe class init in objc runtime is buggy!\");\n    }\n}\n```\n\n可以看出来，和`+load`方法一样，先父类后子类。然后赋值`reallyInitialize = YES;`，后边使用`try`主动调用`callInitialize(cls);`，来到`callInitialize(cls);`内部：\n\n```\nvoid callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);\n    asm(\"\");\n}\n```\n\n可以看到最终还是使用`((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)`主动调用了该函数。\n### 区别\n`+initialize`和`+load`的很大区别是，`+initialize`是通过`objc_msgSend`进行调用的，所以有以下特点\n如果子类没有实现`+initialize`，会调用父类的`+initialize`（所以父类的`+initialize`可能会被调用多次）\n如果分类实现了`+initialize`，就覆盖类本身的`+initialize`调用\n\n用伪代码实现以下思路：\n\n```\n    if(class 没有初始化){\n        父类初始化\n        子类初始化\n        调用initialize\n    }\n    如果子类没有实现initialize，则去调用父类initialize。\n```\n\n至于子类没有实现的话是直接调用父类的`initialize`，是使用`objc-msgsend`的原因。\n\n### 验证\n\n```\n@interface FYPerson : NSObject\n\n@end\n+(void)initialize{\n\tprintf(\"\\n%s\",__func__);\n\n}\n+(void)load{\n\tprintf(\"\\n%s\",__func__);\n\n}\n@interface FYPerson (test1)\n\n@end\n\n+(void)initialize{\n\tprintf(\"\\n%s\",__func__);\n\n}\n+(void)load{\n\tprintf(\"\\n%s\",__func__);\n\n}\n//输出\n+[FYPerson load]\n+[FYPerson(test2) load]\n+[FYPerson(test1) load]\n\n```\n### 总结\n- `+load`是根据函数地址直接调用，`initialize`是通过`objc_msgSend`调用\n- `+load`是runtime加载类、分类时候调用（只会调用一次）\n- `initialize`是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）\n- `+load`调用优先于`initialize`,子类调用`+load`之前会调用父类的`+load`，再调用分类的`+load`,分类之间先编译，先调用。\n- `initialize`先初始化父类，再初始化子类（可能最终调用父类的`initialize`）\n\n### 关联对象本质\n#### 关联对象的本质-结构体\n继承`NSObject`是可以可以直接使用`@property (nonatomic,assign) int age;\n`，但是在`Category`中会报错，那么怎么实现和继承基类一样的效果呢？\n我们查看`Category`结构体\n\n```\n  struct _category_t {\n\tconst char *name; //\"FYPerson\"\n\tstruct _class_t *cls;\n\tconst struct _method_list_t *instance_methods;\n\tconst struct _method_list_t *class_methods;\n\tconst struct _protocol_list_t *protocols;\n\tconst struct _prop_list_t *properties;\n};\n```\n\n其中`const struct _prop_list_t *properties;`是存储属性的，但是缺少成员变量，而我们也不能主动在`_category_t`插入`ivar`，那么我们可以使用`objc_setAssociatedObject`将属性的值存储全局的`AssociationsHashMap`中，使用的时候`objc_getAssociatedObject(id object, const void *key) `,不使用的时候删除使用`objc_removeAssociatedObjects`删除。\n\n我们进入到`objc_setAssociatedObject`内部,`objc-references.mm`275行\n\n```\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n\t//根据key value 处理\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n\t\t//生成一个全局的 HashMap\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n\t\t//有value 就处理\n        if (new_value) {\n            // break any existing association.\n//\t\t\t遍历 hashMap是否有该obj\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n\t\t\t\t//有的话 更新其 value\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n\t\t\t\t//没有的话 赋值给 refs\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                object->setHasAssociatedObjects();\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    //删除refs \n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n\n```\n\n通过该函数我们了解到\n- 关联对象并不是存储在关联对象的本身内存中\n- 关联对象是存储在全局统一的`AssociationsManager`管理的`AssociationsHashMap`中\n- 传入value =nil，会移除该关联对线\n`AssociationsManager`其实是管理了已`key为id object`对应的`AssociationsHashMap`，`AssociationsHashMap`存储了`key`对应的`ObjcAssociation`，`ObjcAssociation`是存储了`value` 和`policy`，`ObjcAssociation`的数据结构如下：\n\n```\nclass ObjcAssociation {\n        uintptr_t _policy;\n        id _value;\n        *****\n        }\n```\n具体抽象关系见下图\n\n```\nAssociationsManager --> AssociationsHashMap --> ObjectAssociationMap\n-->void * ObjectAssociation -->uintprt_t _policy ,id _value;\n```\n\n简单来讲就是一个全局变量保存了以`class`为`key`对应的`AssociationsHashMap`，这个`AssociationsHashMap`存储了一个`key`对应的`ObjectAssociation`，`ObjectAssociation`包含了`value`和`_policy`。通过2层map保存了数据。\n\n#### 关联对象的使用\n\n|objc_setAssociatedObject|obj,key,value,policy|\n|------------------------|-------------------|\n|objc_getAssociatedObject|根据 obj 和 key获取值|\n|void objc_removeAssociatedObjects(id object)|根据obj 删除关联函数|\n\n`objc_AssociationPolicy`的类型：\n\n|OBJC_ASSOCIATION_ASSIGN|weak 引用|\n|------|--------|\n|OBJC_ASSOCIATION_RETAIN_NONATOMIC|非原子强引用|\n|OBJC_ASSOCIATION_COPY_NONATOMIC|非原子相当于copy|\n|OBJC_ASSOCIATION_RETAIN|强引用|\n|OBJC_ASSOCIATION_COPY| 原子操作，相当于copy|\n\n#### 代码示例\n\n```\n@interface NSObject (test)\n@property (nonatomic,assign) NSString * name;\n@end\n\n#import \"NSObject+test.h\"\n#import \"objc/runtime.h\"\n@implementation NSObject (test)\n-(void)setName:(NSString *)name{\n\tobjc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);\n}\n- (NSString *)name{\n\treturn  objc_getAssociatedObject(self, @selector(name));\n}\n@end\n\n\n\nNSObject *obj =[[NSObject alloc]init];\nobj.name = @\"老弟来了\";\nprintf(\"%s\",obj.name.UTF8String);\n//老弟来了\n```\n\n这段代码我们实现了给基类添加一个成员变量`name`，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。\n\n### 总结\n- Category `+load`在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。\n- Category `+initialize`在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用`objc-msgsend`机制调用。\n- Category 可以利用`Associative`添加和读取属性的值\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n  本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n  广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 Category与关联对象本质--(4)","published":1,"updated":"2019-12-03T06:30:32.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2g000h9zskdzpj6sih","content":"<p> 今天我们再看一下<code>Category</code>的底层原理。<br> 先看一下<code>Category</code>的简单使用，首先新增一个类的<code>Category</code>，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(void)run&#123;</div><div class=\"line\">\tNSLog(@&quot;run is run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//类别</div><div class=\"line\">@interface FYPerson (test)</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson (test)</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;test is run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//使用</div><div class=\"line\">#import &quot;FYPerson.h&quot;</div><div class=\"line\">#import &quot;FYPerson+test.h&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *person=[[FYPerson alloc]init];</div><div class=\"line\">[person test];</div><div class=\"line\">[person run];</div></pre></td></tr></table></figure>\n<p>  类别使用就是这么简单。<br>  那么类别的本质是什么呢？类的方法是存储在什么地方呢？<br>  第一篇<a href=\"https://juejin.im/post/5d15887ee51d45108126d28d\" target=\"_blank\" rel=\"external\">类的本质</a>已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体<code>fy_objc_class</code>中的<code>class_data_bits_t-&gt;data()-&gt;method_list_t</code>中的，那么类别方法也是存储在<code>method_list_t</code>和取元类对象的<code>method_list_t</code>中的。编译的时候类别编译成结构体<code>_category_t</code>,然后<code>runtime</code>在运行时动态将方法添加到<code>method_list_t</code>中。运行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp</code>进入到<code>FYPerson+test.cpp</code>内部查看编译之后的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">  struct _category_t &#123;</div><div class=\"line\">\tconst char *name; //&quot;FYPerson&quot;</div><div class=\"line\">\tstruct _class_t *cls;</div><div class=\"line\">\tconst struct _method_list_t *instance_methods;</div><div class=\"line\">\tconst struct _method_list_t *class_methods;</div><div class=\"line\">\tconst struct _protocol_list_t *protocols;</div><div class=\"line\">\tconst struct _prop_list_t *properties;</div><div class=\"line\">&#125;;</div><div class=\"line\">//存储 test方法</div><div class=\"line\">static struct /*_method_list_t*/ &#123;</div><div class=\"line\">\tunsigned int entsize;  // sizeof(struct _objc_method)</div><div class=\"line\">\tunsigned int method_count;</div><div class=\"line\">\tstruct _objc_method method_list[1];</div><div class=\"line\">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">\tsizeof(_objc_method),</div><div class=\"line\">\t1,</div><div class=\"line\">\t&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_FYPerson_test_test&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;</div><div class=\"line\"></div><div class=\"line\">//_category_t 存储FYPerson的分类的数据</div><div class=\"line\">static struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </div><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;FYPerson&quot;,</div><div class=\"line\">\t0, // &amp;OBJC_CLASS_$_FYPerson,</div><div class=\"line\">\t(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法</div><div class=\"line\">\t0,//类方法</div><div class=\"line\">\t0,//协议方法</div><div class=\"line\">\t0,//属性</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>存储在<code>_category_t</code>中的数据是什么时间加载到<code>FYPerson</code>的<code>class_data_bits_t.data</code>呢？我们探究一下，打开<a href=\"https://opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">源码</a>下载打开工程阅读源码找到<code>objc-os.mm</code>,通过查找函数运行顺序得到<code>_objec_init-&gt;map_images-&gt;map_images_noljock-&gt;_read_images-&gt;remethodizeClass(cls)-&gt;attachCategories(cls, cats, true /*flush caches*/)</code>，最终进入到<code>attachCategories</code>关键函数内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">  // Attach method lists and properties and protocols from categories to a class.</div><div class=\"line\">// Assumes the categories in cats are all loaded and sorted by load order, </div><div class=\"line\">// oldest categories first.</div><div class=\"line\">static void </div><div class=\"line\">attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    // fixme rearrange to remove these intermediate allocations</div><div class=\"line\">\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\">\t//属性数组</div><div class=\"line\">    property_list_t **proplists = (property_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class=\"line\">\t//协议数组</div><div class=\"line\">    protocol_list_t **protolists = (protocol_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int propcount = 0;</div><div class=\"line\">    int protocount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    bool fromBundle = NO;</div><div class=\"line\">    //最后的编译文件放到最前边</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">\t\t//取出某个分类</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\">//取出分类 的 instance方法或者class方法</div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有分类属性</div><div class=\"line\">        property_list_t *proplist = </div><div class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class=\"line\">        if (proplist) &#123;</div><div class=\"line\">            proplists[propcount++] = proplist;</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有协议方法</div><div class=\"line\">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class=\"line\">        if (protolist) &#123;</div><div class=\"line\">            protolists[protocount++] = protolist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//收集了所有协议 分类方法</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class=\"line\">\t//追加所有分类方法</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">\t//释放数组</div><div class=\"line\">    free(mlists);</div><div class=\"line\">\t//刷新该类的缓存</div><div class=\"line\">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class=\"line\">//追加所有分类属性</div><div class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class=\"line\">    free(proplists);//释放数组</div><div class=\"line\">//追加所有分类协议</div><div class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class=\"line\">    free(protolists);//释放数组</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>attachCategories</code>是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到<code>rw-&gt;protocols.attachLists</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">        if (addedCount == 0) return;</div><div class=\"line\">        if (hasArray()) &#123;</div><div class=\"line\">            // many lists -&gt; many lists</div><div class=\"line\">            uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">\t\t\t//一共需要的数量</div><div class=\"line\">            uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">\t\t\t//分配内存 内存不够用了，需要扩容</div><div class=\"line\">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">\t\t\t//赋值count</div><div class=\"line\">            array()-&gt;count = newCount;</div><div class=\"line\">\t\t\t// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class=\"line\">            memmove(array()-&gt;lists + addedCount/*指针移动到数组末尾*/, array()-&gt;lists/*数组*/,</div><div class=\"line\">                    oldCount * sizeof(array()-&gt;lists[0])/*移动数据的大小*/);</div><div class=\"line\">\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class=\"line\">            memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">\t\t\t/*</div><div class=\"line\">\t\t\t图示讲解：</div><div class=\"line\">\t\t\tarray()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\taddedCount:3</div><div class=\"line\">\t\taddedLists:P-&gt;L-&gt;V</div><div class=\"line\">\t\t\tmemmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t\t然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class=\"line\">\t\t\tP-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t\t */</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class=\"line\">            // 0 lists -&gt; 1 list</div><div class=\"line\">            list = addedLists[0];</div><div class=\"line\">        &#125; </div><div class=\"line\">        else &#123;</div><div class=\"line\">            // 1 list -&gt; many lists</div><div class=\"line\">            List* oldList = list;</div><div class=\"line\">            uint32_t oldCount = oldList ? 1 : 0;</div><div class=\"line\">            uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class=\"line\">            array()-&gt;count = newCount;</div><div class=\"line\">            if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class=\"line\">            memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>可以看出来：</p>\n<ol>\n<li>首先通过<code>runtime</code>加载某个类的所有Category数据</li>\n<li>把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边</li>\n<li>将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。</li>\n</ol>\n<p>具体的编译顺序是project文件中-&gt;Build Phases-&gt;Complile Sources的顺序。</p>\n<h3 id=\"调用顺序\"><a href=\"#调用顺序\" class=\"headerlink\" title=\"调用顺序\"></a>调用顺序</h3><h4 id=\"load加载顺序\"><a href=\"#load加载顺序\" class=\"headerlink\" title=\"+load加载顺序\"></a>+load加载顺序</h4><p>每个类和分类都会加载的时候调用<code>+load</code>方法，具体是怎么调用呢？我们查看源码<code>_objc_init-&gt;load_images-&gt;call_load_methods</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">void call_load_methods(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    static bool loading = NO;</div><div class=\"line\">    bool more_categories;</div><div class=\"line\"></div><div class=\"line\">    loadMethodLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    // Re-entrant calls do nothing; the outermost call will finish the job.</div><div class=\"line\">    if (loading) return;</div><div class=\"line\">    loading = YES;</div><div class=\"line\"></div><div class=\"line\">    void *pool = objc_autoreleasePoolPush();</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">        // 1. Repeatedly call class +loads until there aren&apos;t any more</div><div class=\"line\">        //执行class+load直到完成</div><div class=\"line\">        while (loadable_classes_used &gt; 0) &#123;</div><div class=\"line\">            call_class_loads();</div><div class=\"line\">        &#125;</div><div class=\"line\">//执行Category +load 一次</div><div class=\"line\">        // 2. Call category +loads ONCE</div><div class=\"line\">        more_categories = call_category_loads();</div><div class=\"line\"></div><div class=\"line\">        // 3. Run more +loads if there are classes OR more untried categories</div><div class=\"line\">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</div><div class=\"line\"></div><div class=\"line\">    objc_autoreleasePoolPop(pool);</div><div class=\"line\"></div><div class=\"line\">    loading = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类<code>+load</code>在<code>Category+load</code>前边执行，当类的<code>+load</code>执行完毕然后再去执行<code>Category+load</code>,而且只有一次。<br>当class有子类的时候加载顺序呢？其实所有类都是基于<code>NSObject</code>，那么我们假设按照编译顺序加载<code>Class+load</code>，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类<code>+load</code>中的操作是第一个执行的，其他子类是按照<code>superclass-&gt;class-&gt;sonclass</code>的顺序执行的。<br>查看源码<code>_objc_init-&gt;load_images-&gt;prepare_load_methods((const headerType *)mh)-&gt;schedule_class_load</code>在<code>objc-runtime-new.mm</code>2856行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* Schedule +load for classes in this image, any un-+load-ed </div><div class=\"line\">* superclasses in other images, and any categories in this image.</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">// Recursively schedule +load for cls and any un-+load-ed superclasses.</div><div class=\"line\">// cls must already be connected.</div><div class=\"line\">static void schedule_class_load(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return;</div><div class=\"line\">    assert(cls-&gt;isRealized());  // _read_images should realize</div><div class=\"line\"></div><div class=\"line\">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</div><div class=\"line\"></div><div class=\"line\">    // Ensure superclass-first ordering</div><div class=\"line\">    //递归调用自己直到调用clas-&gt;self</div><div class=\"line\">    schedule_class_load(cls-&gt;superclass);</div><div class=\"line\">//添加class</div><div class=\"line\">    add_class_to_loadable_list(cls);</div><div class=\"line\">    cls-&gt;setInfo(RW_LOADED); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以了解到该函数递归调用自己，直到<code>+load</code>方法已经调用过为止，所以不管编译顺序是高低，<code>+load</code>的加载顺序始终是<code>NSObject-&gt;FYPrson-&gt;FYStudent</code>。多个类平行关系的话，按照编译顺序加载。<br>下边是稍微复杂点的类关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">NSObject</div><div class=\"line\">    Person</div><div class=\"line\">        Student</div><div class=\"line\">NSObjet</div><div class=\"line\">    Car</div><div class=\"line\">        BigCar</div><div class=\"line\">            BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>编译顺序是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person</div><div class=\"line\">Student</div><div class=\"line\">Car</div><div class=\"line\">BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>那么他们<code>+load</code>的加载顺序是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">NSobject-&gt;Person-&gt;Student-&gt;Car-&gt;BigCar-&gt;BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>看着不是很明白的 可以再看一下刚才的<code>schedule_class_load</code>函数。<br>加载成功之后，是按照<code>objc_msgsend()</code>流程发送的吗？我们进入到<code>call_class_loads</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void call_class_loads(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    int i;</div><div class=\"line\">    </div><div class=\"line\">    // Detach current loadable list.</div><div class=\"line\">    struct loadable_class *classes = loadable_classes;</div><div class=\"line\">    int used = loadable_classes_used;</div><div class=\"line\">    loadable_classes = nil;</div><div class=\"line\">    loadable_classes_allocated = 0;</div><div class=\"line\">    loadable_classes_used = 0;</div><div class=\"line\">    </div><div class=\"line\">    // Call all +loads for the detached list.</div><div class=\"line\">    for (i = 0; i &lt; used; i++) &#123;</div><div class=\"line\">        Class cls = classes[i].cls;</div><div class=\"line\">        load_method_t load_method = (load_method_t)classes[i].method;</div><div class=\"line\">        if (!cls) continue; </div><div class=\"line\"></div><div class=\"line\">        if (PrintLoading) &#123;</div><div class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</div><div class=\"line\">        &#125;</div><div class=\"line\">        (*load_method)(cls, SEL_load);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (classes) free(classes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以找到<code>(*load_method)(cls, SEL_load);</code>该函数，该函数是直接使用<code>IMP</code>执行的，<code>IMP</code>就是函数地址，可以直接访问函数而不用消息的转发流程。</p>\n<h4 id=\"initialize调用\"><a href=\"#initialize调用\" class=\"headerlink\" title=\"+initialize调用\"></a>+initialize调用</h4><ul>\n<li>+initialize方法会在类第一次接收到消息时调用</li>\n<li>先调用父类的+initialize，再调用子类的+initialize</li>\n<li>先初始化父类，再初始化子类，每个类只会初始化1次</li>\n</ul>\n<p><code>objc</code>源码解读过程<code>objc-msg-arm64.x-&gt;objc_msgSend-&gt;objc-&gt;runtime-new-&gt;class_getinstanceMethod-&gt;lookUpImpOrNil-&gt;lookUpImpOrForward-&gt;_clas_initialize-&gt;callInitialize-&gt;objc_msgSend(cls,SEL_Initialize)</code><br>在<code>runtime-new.h</code>4819行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method class_getInstanceMethod(Class cls, SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls  ||  !sel) return nil;</div><div class=\"line\"></div><div class=\"line\">    lookUpImpOrNil(cls, sel, nil, </div><div class=\"line\">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    return _class_getMethod(cls, sel);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据<code>lookUpImpOrNil</code>查看4916行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class=\"line\">                       bool initialize, bool cache, bool resolver)</div><div class=\"line\">&#123;</div><div class=\"line\">    IMP imp = nil;</div><div class=\"line\">    bool triedResolver = NO;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.assertUnlocked();</div><div class=\"line\"></div><div class=\"line\">    // Optimistic cache lookup</div><div class=\"line\">    if (cache) &#123;</div><div class=\"line\">        imp = cache_getImp(cls, sel);</div><div class=\"line\">        if (imp) return imp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.lock();</div><div class=\"line\">    checkIsKnownClass(cls);</div><div class=\"line\"></div><div class=\"line\">    if (!cls-&gt;isRealized()) &#123;</div><div class=\"line\">        realizeClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化</div><div class=\"line\">      &#125;</div><div class=\"line\"> retry:    </div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\">    imp = cache_getImp(cls, sel);</div><div class=\"line\">    if (imp) goto done;</div><div class=\"line\">   // Try this class&apos;s method lists.</div><div class=\"line\">    //在本类中查找method</div><div class=\"line\">    &#123;</div><div class=\"line\">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class=\"line\">        if (meth) &#123;</div><div class=\"line\">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class=\"line\">            imp = meth-&gt;imp;</div><div class=\"line\">            goto done;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Try superclass caches and method lists.</div><div class=\"line\">    &#123;</div><div class=\"line\">        unsigned attempts = unreasonableClassCount();</div><div class=\"line\">        for (Class curClass = cls-&gt;superclass;</div><div class=\"line\">             curClass != nil;</div><div class=\"line\">             curClass = curClass-&gt;superclass)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Halt if there is a cycle in the superclass chain.</div><div class=\"line\">            if (--attempts == 0) &#123;</div><div class=\"line\">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass cache.</div><div class=\"line\">            imp = cache_getImp(curClass, sel);</div><div class=\"line\">            if (imp) &#123;</div><div class=\"line\">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class=\"line\">                    // Found the method in a superclass. Cache it in this class.</div><div class=\"line\">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class=\"line\">                    goto done;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    // Found a forward:: entry in a superclass.</div><div class=\"line\">                    // Stop searching, but don&apos;t cache yet; call method </div><div class=\"line\">                    // resolver for this class first.</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass method list.</div><div class=\"line\">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class=\"line\">            if (meth) &#123;</div><div class=\"line\">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class=\"line\">                imp = meth-&gt;imp;</div><div class=\"line\">                goto done;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // No implementation found. Try method resolver once.</div><div class=\"line\"></div><div class=\"line\">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_resolveMethod(cls, sel, inst);</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">        // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </div><div class=\"line\">        // changed already. Re-do the search from scratch instead.</div><div class=\"line\">        triedResolver = YES;</div><div class=\"line\">        goto retry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // No implementation found, and method resolver didn&apos;t help. </div><div class=\"line\">    // Use forwarding.</div><div class=\"line\"></div><div class=\"line\">    imp = (IMP)_objc_msgForward_impcache;</div><div class=\"line\">    cache_fill(cls, sel, imp, inst);</div><div class=\"line\"></div><div class=\"line\"> done:</div><div class=\"line\">    runtimeLock.unlock();</div><div class=\"line\"></div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当第一次收到消息，cls没有初始化，则调用<code>_class_initialize</code>进行初始化<br>我们进入到<code>_class_initialize</code>内部<code>objc-initialize.mm</code>484行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _class_initialize(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(!cls-&gt;isMetaClass());</div><div class=\"line\"></div><div class=\"line\">    Class supercls;</div><div class=\"line\">    bool reallyInitialize = NO;</div><div class=\"line\"></div><div class=\"line\">    // Make sure super is done initializing BEFORE beginning to initialize cls.</div><div class=\"line\">    // See note about deadlock above.</div><div class=\"line\">    //递归调用父类是否有初始化和是否有父类</div><div class=\"line\">    supercls = cls-&gt;superclass;</div><div class=\"line\">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</div><div class=\"line\">        _class_initialize(supercls);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // Try to atomically set CLS_INITIALIZING.</div><div class=\"line\">    &#123;</div><div class=\"line\">        monitor_locker_t lock(classInitLock);</div><div class=\"line\">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</div><div class=\"line\">            cls-&gt;setInitializing();</div><div class=\"line\">            reallyInitialize = YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (reallyInitialize) &#123;</div><div class=\"line\">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</div><div class=\"line\">        </div><div class=\"line\">        // Record that we&apos;re initializing this class so we can message it.</div><div class=\"line\">        _setThisThreadIsInitializingClass(cls);</div><div class=\"line\"></div><div class=\"line\">        if (MultithreadedForkChild) &#123;</div><div class=\"line\">            // LOL JK we don&apos;t really call +initialize methods after fork().</div><div class=\"line\">            performForkChildInitialize(cls, supercls);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        // Send the +initialize message.</div><div class=\"line\">        // Note that +initialize is sent to the superclass (again) if </div><div class=\"line\">        // this class doesn&apos;t implement +initialize. 2157218</div><div class=\"line\">        if (PrintInitializing) &#123;</div><div class=\"line\">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</div><div class=\"line\">                         pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Exceptions: A +initialize call that throws an exception </div><div class=\"line\">        // is deemed to be a complete and successful +initialize.</div><div class=\"line\">        //</div><div class=\"line\">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</div><div class=\"line\">        // bootstrapping problem of this versus CF&apos;s call to</div><div class=\"line\">        // objc_exception_set_functions().</div><div class=\"line\">#if __OBJC2__</div><div class=\"line\">        @try</div><div class=\"line\">#endif</div><div class=\"line\">        &#123;</div><div class=\"line\">            callInitialize(cls);</div><div class=\"line\"></div><div class=\"line\">            if (PrintInitializing) &#123;</div><div class=\"line\">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</div><div class=\"line\">                             pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if __OBJC2__</div><div class=\"line\">        @catch (...) &#123;</div><div class=\"line\">            if (PrintInitializing) &#123;</div><div class=\"line\">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</div><div class=\"line\">                             &quot;threw an exception&quot;,</div><div class=\"line\">                             pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">            &#125;</div><div class=\"line\">            @throw;</div><div class=\"line\">        &#125;</div><div class=\"line\">        @finally</div><div class=\"line\">#endif</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Done initializing.</div><div class=\"line\">            lockAndFinishInitializing(cls, supercls);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else if (cls-&gt;isInitializing()) &#123;</div><div class=\"line\">        // We couldn&apos;t set INITIALIZING because INITIALIZING was already set.</div><div class=\"line\">        // If this thread set it earlier, continue normally.</div><div class=\"line\">        // If some other thread set it, block until initialize is done.</div><div class=\"line\">        // It&apos;s ok if INITIALIZING changes to INITIALIZED while we&apos;re here, </div><div class=\"line\">        //   because we safely check for INITIALIZED inside the lock </div><div class=\"line\">        //   before blocking.</div><div class=\"line\">        if (_thisThreadIsInitializingClass(cls)) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else if (!MultithreadedForkChild) &#123;</div><div class=\"line\">            waitForInitializeToComplete(cls);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We&apos;re on the child side of fork(), facing a class that</div><div class=\"line\">            // was initializing by some other thread when fork() was called.</div><div class=\"line\">            _setThisThreadIsInitializingClass(cls);</div><div class=\"line\">            performForkChildInitialize(cls, supercls);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else if (cls-&gt;isInitialized()) &#123;</div><div class=\"line\">        // Set CLS_INITIALIZING failed because someone else already </div><div class=\"line\">        //   initialized the class. Continue normally.</div><div class=\"line\">        // NOTE this check must come AFTER the ISINITIALIZING case.</div><div class=\"line\">        // Otherwise: Another thread is initializing this class. ISINITIALIZED </div><div class=\"line\">        //   is false. Skip this clause. Then the other thread finishes </div><div class=\"line\">        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. </div><div class=\"line\">        //   Skip the ISINITIALIZING clause. Die horribly.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else &#123;</div><div class=\"line\">        // We shouldn&apos;t be here. </div><div class=\"line\">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来，和<code>+load</code>方法一样，先父类后子类。然后赋值<code>reallyInitialize = YES;</code>，后边使用<code>try</code>主动调用<code>callInitialize(cls);</code>，来到<code>callInitialize(cls);</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callInitialize(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</div><div class=\"line\">    asm(&quot;&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到最终还是使用<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</code>主动调用了该函数。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点<br>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>可能会被调用多次）<br>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用</p>\n<p>用伪代码实现以下思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(class 没有初始化)&#123;</div><div class=\"line\">    父类初始化</div><div class=\"line\">    子类初始化</div><div class=\"line\">    调用initialize</div><div class=\"line\">&#125;</div><div class=\"line\">如果子类没有实现initialize，则去调用父类initialize。</div></pre></td></tr></table></figure>\n<p>至于子类没有实现的话是直接调用父类的<code>initialize</code>，是使用<code>objc-msgsend</code>的原因。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">+(void)initialize&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">@interface FYPerson (test1)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">+(void)initialize&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">+[FYPerson load]</div><div class=\"line\">+[FYPerson(test2) load]</div><div class=\"line\">+[FYPerson(test1) load]</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><code>+load</code>是根据函数地址直接调用，<code>initialize</code>是通过<code>objc_msgSend</code>调用</li>\n<li><code>+load</code>是runtime加载类、分类时候调用（只会调用一次）</li>\n<li><code>initialize</code>是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）</li>\n<li><code>+load</code>调用优先于<code>initialize</code>,子类调用<code>+load</code>之前会调用父类的<code>+load</code>，再调用分类的<code>+load</code>,分类之间先编译，先调用。</li>\n<li><code>initialize</code>先初始化父类，再初始化子类（可能最终调用父类的<code>initialize</code>）</li>\n</ul>\n<h3 id=\"关联对象本质\"><a href=\"#关联对象本质\" class=\"headerlink\" title=\"关联对象本质\"></a>关联对象本质</h3><h4 id=\"关联对象的本质-结构体\"><a href=\"#关联对象的本质-结构体\" class=\"headerlink\" title=\"关联对象的本质-结构体\"></a>关联对象的本质-结构体</h4><p>继承<code>NSObject</code>是可以可以直接使用<code>@property (nonatomic,assign) int age;</code>，但是在<code>Category</code>中会报错，那么怎么实现和继承基类一样的效果呢？<br>我们查看<code>Category</code>结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  struct _category_t &#123;</div><div class=\"line\">\tconst char *name; //&quot;FYPerson&quot;</div><div class=\"line\">\tstruct _class_t *cls;</div><div class=\"line\">\tconst struct _method_list_t *instance_methods;</div><div class=\"line\">\tconst struct _method_list_t *class_methods;</div><div class=\"line\">\tconst struct _protocol_list_t *protocols;</div><div class=\"line\">\tconst struct _prop_list_t *properties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中<code>const struct _prop_list_t *properties;</code>是存储属性的，但是缺少成员变量，而我们也不能主动在<code>_category_t</code>插入<code>ivar</code>，那么我们可以使用<code>objc_setAssociatedObject</code>将属性的值存储全局的<code>AssociationsHashMap</code>中，使用的时候<code>objc_getAssociatedObject(id object, const void *key)</code>,不使用的时候删除使用<code>objc_removeAssociatedObjects</code>删除。</p>\n<p>我们进入到<code>objc_setAssociatedObject</code>内部,<code>objc-references.mm</code>275行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class=\"line\">    // retain the new value (if any) outside the lock.</div><div class=\"line\">    ObjcAssociation old_association(0, nil);</div><div class=\"line\">\t//根据key value 处理</div><div class=\"line\">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class=\"line\">    &#123;</div><div class=\"line\">        AssociationsManager manager;</div><div class=\"line\">\t\t//生成一个全局的 HashMap</div><div class=\"line\">        AssociationsHashMap &amp;associations(manager.associations());</div><div class=\"line\">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class=\"line\">\t\t//有value 就处理</div><div class=\"line\">        if (new_value) &#123;</div><div class=\"line\">            // break any existing association.</div><div class=\"line\">//\t\t\t遍历 hashMap是否有该obj</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i != associations.end()) &#123;</div><div class=\"line\">                // secondary table exists</div><div class=\"line\">\t\t\t\t//有的话 更新其 value</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // create the new association (first time).</div><div class=\"line\">\t\t\t\t//没有的话 赋值给 refs</div><div class=\"line\">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class=\"line\">                associations[disguised_object] = refs;</div><div class=\"line\">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                object-&gt;setHasAssociatedObjects();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // setting the association to nil breaks the association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i !=  associations.end()) &#123;</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    //删除refs </div><div class=\"line\">                    refs-&gt;erase(j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // release the old value (outside of the lock).</div><div class=\"line\">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过该函数我们了解到</p>\n<ul>\n<li>关联对象并不是存储在关联对象的本身内存中</li>\n<li>关联对象是存储在全局统一的<code>AssociationsManager</code>管理的<code>AssociationsHashMap</code>中</li>\n<li>传入value =nil，会移除该关联对线<br><code>AssociationsManager</code>其实是管理了已<code>key为id object</code>对应的<code>AssociationsHashMap</code>，<code>AssociationsHashMap</code>存储了<code>key</code>对应的<code>ObjcAssociation</code>，<code>ObjcAssociation</code>是存储了<code>value</code> 和<code>policy</code>，<code>ObjcAssociation</code>的数据结构如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ObjcAssociation &#123;</div><div class=\"line\">        uintptr_t _policy;</div><div class=\"line\">        id _value;</div><div class=\"line\">        *****</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>具体抽象关系见下图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AssociationsManager --&gt; AssociationsHashMap --&gt; ObjectAssociationMap</div><div class=\"line\">--&gt;void * ObjectAssociation --&gt;uintprt_t _policy ,id _value;</div></pre></td></tr></table></figure>\n<p>简单来讲就是一个全局变量保存了以<code>class</code>为<code>key</code>对应的<code>AssociationsHashMap</code>，这个<code>AssociationsHashMap</code>存储了一个<code>key</code>对应的<code>ObjectAssociation</code>，<code>ObjectAssociation</code>包含了<code>value</code>和<code>_policy</code>。通过2层map保存了数据。</p>\n<h4 id=\"关联对象的使用\"><a href=\"#关联对象的使用\" class=\"headerlink\" title=\"关联对象的使用\"></a>关联对象的使用</h4><table>\n<thead>\n<tr>\n<th>objc_setAssociatedObject</th>\n<th>obj,key,value,policy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>objc_getAssociatedObject</td>\n<td>根据 obj 和 key获取值</td>\n</tr>\n<tr>\n<td>void objc_removeAssociatedObjects(id object)</td>\n<td>根据obj 删除关联函数</td>\n</tr>\n</tbody>\n</table>\n<p><code>objc_AssociationPolicy</code>的类型：</p>\n<table>\n<thead>\n<tr>\n<th>OBJC_ASSOCIATION_ASSIGN</th>\n<th>weak 引用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td>非原子强引用</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td>非原子相当于copy</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN</td>\n<td>强引用</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY</td>\n<td>原子操作，相当于copy</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (test)</div><div class=\"line\">@property (nonatomic,assign) NSString * name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;NSObject+test.h&quot;</div><div class=\"line\">#import &quot;objc/runtime.h&quot;</div><div class=\"line\">@implementation NSObject (test)</div><div class=\"line\">-(void)setName:(NSString *)name&#123;</div><div class=\"line\">\tobjc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString *)name&#123;</div><div class=\"line\">\treturn  objc_getAssociatedObject(self, @selector(name));</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSObject *obj =[[NSObject alloc]init];</div><div class=\"line\">obj.name = @&quot;老弟来了&quot;;</div><div class=\"line\">printf(&quot;%s&quot;,obj.name.UTF8String);</div><div class=\"line\">//老弟来了</div></pre></td></tr></table></figure>\n<p>这段代码我们实现了给基类添加一个成员变量<code>name</code>，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>Category <code>+load</code>在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。</li>\n<li>Category <code>+initialize</code>在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用<code>objc-msgsend</code>机制调用。</li>\n<li>Category 可以利用<code>Associative</code>添加和读取属性的值</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n</li>\n</ul>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p> 今天我们再看一下<code>Category</code>的底层原理。<br> 先看一下<code>Category</code>的简单使用，首先新增一个类的<code>Category</code>，然后添加需要的函数，然后在使用的文件中导入就可以直接使用了。代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(void)run&#123;</div><div class=\"line\">\tNSLog(@&quot;run is run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//类别</div><div class=\"line\">@interface FYPerson (test)</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson (test)</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;test is run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//使用</div><div class=\"line\">#import &quot;FYPerson.h&quot;</div><div class=\"line\">#import &quot;FYPerson+test.h&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *person=[[FYPerson alloc]init];</div><div class=\"line\">[person test];</div><div class=\"line\">[person run];</div></pre></td></tr></table></figure>\n<p>  类别使用就是这么简单。<br>  那么类别的本质是什么呢？类的方法是存储在什么地方呢？<br>  第一篇<a href=\"https://juejin.im/post/5d15887ee51d45108126d28d\" target=\"_blank\" rel=\"external\">类的本质</a>已经讲过了，运行时中，类对象是有一份，方法都存储在类对象结构体<code>fy_objc_class</code>中的<code>class_data_bits_t-&gt;data()-&gt;method_list_t</code>中的，那么类别方法也是存储在<code>method_list_t</code>和取元类对象的<code>method_list_t</code>中的。编译的时候类别编译成结构体<code>_category_t</code>,然后<code>runtime</code>在运行时动态将方法添加到<code>method_list_t</code>中。运行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc FYPerson+test.m -o FYPerson+test.cpp</code>进入到<code>FYPerson+test.cpp</code>内部查看编译之后的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">  struct _category_t &#123;</div><div class=\"line\">\tconst char *name; //&quot;FYPerson&quot;</div><div class=\"line\">\tstruct _class_t *cls;</div><div class=\"line\">\tconst struct _method_list_t *instance_methods;</div><div class=\"line\">\tconst struct _method_list_t *class_methods;</div><div class=\"line\">\tconst struct _protocol_list_t *protocols;</div><div class=\"line\">\tconst struct _prop_list_t *properties;</div><div class=\"line\">&#125;;</div><div class=\"line\">//存储 test方法</div><div class=\"line\">static struct /*_method_list_t*/ &#123;</div><div class=\"line\">\tunsigned int entsize;  // sizeof(struct _objc_method)</div><div class=\"line\">\tunsigned int method_count;</div><div class=\"line\">\tstruct _objc_method method_list[1];</div><div class=\"line\">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">\tsizeof(_objc_method),</div><div class=\"line\">\t1,</div><div class=\"line\">\t&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_FYPerson_test_test&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_FYPerson;</div><div class=\"line\"></div><div class=\"line\">//_category_t 存储FYPerson的分类的数据</div><div class=\"line\">static struct _category_t _OBJC_$_CATEGORY_FYPerson_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </div><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;FYPerson&quot;,</div><div class=\"line\">\t0, // &amp;OBJC_CLASS_$_FYPerson,</div><div class=\"line\">\t(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_FYPerson_$_test,//instace方法</div><div class=\"line\">\t0,//类方法</div><div class=\"line\">\t0,//协议方法</div><div class=\"line\">\t0,//属性</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>存储在<code>_category_t</code>中的数据是什么时间加载到<code>FYPerson</code>的<code>class_data_bits_t.data</code>呢？我们探究一下，打开<a href=\"https://opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">源码</a>下载打开工程阅读源码找到<code>objc-os.mm</code>,通过查找函数运行顺序得到<code>_objec_init-&gt;map_images-&gt;map_images_noljock-&gt;_read_images-&gt;remethodizeClass(cls)-&gt;attachCategories(cls, cats, true /*flush caches*/)</code>，最终进入到<code>attachCategories</code>关键函数内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">  // Attach method lists and properties and protocols from categories to a class.</div><div class=\"line\">// Assumes the categories in cats are all loaded and sorted by load order, </div><div class=\"line\">// oldest categories first.</div><div class=\"line\">static void </div><div class=\"line\">attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    // fixme rearrange to remove these intermediate allocations</div><div class=\"line\">\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\">\t//属性数组</div><div class=\"line\">    property_list_t **proplists = (property_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class=\"line\">\t//协议数组</div><div class=\"line\">    protocol_list_t **protolists = (protocol_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int propcount = 0;</div><div class=\"line\">    int protocount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    bool fromBundle = NO;</div><div class=\"line\">    //最后的编译文件放到最前边</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">\t\t//取出某个分类</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\">//取出分类 的 instance方法或者class方法</div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有分类属性</div><div class=\"line\">        property_list_t *proplist = </div><div class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class=\"line\">        if (proplist) &#123;</div><div class=\"line\">            proplists[propcount++] = proplist;</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有协议方法</div><div class=\"line\">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class=\"line\">        if (protolist) &#123;</div><div class=\"line\">            protolists[protocount++] = protolist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//收集了所有协议 分类方法</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class=\"line\">\t//追加所有分类方法</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">\t//释放数组</div><div class=\"line\">    free(mlists);</div><div class=\"line\">\t//刷新该类的缓存</div><div class=\"line\">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class=\"line\">//追加所有分类属性</div><div class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class=\"line\">    free(proplists);//释放数组</div><div class=\"line\">//追加所有分类协议</div><div class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class=\"line\">    free(protolists);//释放数组</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>attachCategories</code>是将所有的分类方法和协议，属性倒序添加到类中，具体添加的优先级是怎么操作的？进入到<code>rw-&gt;protocols.attachLists</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">        if (addedCount == 0) return;</div><div class=\"line\">        if (hasArray()) &#123;</div><div class=\"line\">            // many lists -&gt; many lists</div><div class=\"line\">            uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">\t\t\t//一共需要的数量</div><div class=\"line\">            uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">\t\t\t//分配内存 内存不够用了，需要扩容</div><div class=\"line\">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">\t\t\t//赋值count</div><div class=\"line\">            array()-&gt;count = newCount;</div><div class=\"line\">\t\t\t// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class=\"line\">            memmove(array()-&gt;lists + addedCount/*指针移动到数组末尾*/, array()-&gt;lists/*数组*/,</div><div class=\"line\">                    oldCount * sizeof(array()-&gt;lists[0])/*移动数据的大小*/);</div><div class=\"line\">\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class=\"line\">            memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">\t\t\t/*</div><div class=\"line\">\t\t\t图示讲解：</div><div class=\"line\">\t\t\tarray()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\taddedCount:3</div><div class=\"line\">\t\taddedLists:P-&gt;L-&gt;V</div><div class=\"line\">\t\t\tmemmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t\t然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class=\"line\">\t\t\tP-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t\t */</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class=\"line\">            // 0 lists -&gt; 1 list</div><div class=\"line\">            list = addedLists[0];</div><div class=\"line\">        &#125; </div><div class=\"line\">        else &#123;</div><div class=\"line\">            // 1 list -&gt; many lists</div><div class=\"line\">            List* oldList = list;</div><div class=\"line\">            uint32_t oldCount = oldList ? 1 : 0;</div><div class=\"line\">            uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class=\"line\">            array()-&gt;count = newCount;</div><div class=\"line\">            if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class=\"line\">            memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                   addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>可以看出来：</p>\n<ol>\n<li>首先通过<code>runtime</code>加载某个类的所有Category数据</li>\n<li>把所有Category的方法，属性，协议数据合并到一个大数组中，后面参与编译的数组会出现在数组前边</li>\n<li>将合并后的分类数组(方法，属性，协议)插入到类原来的数据的前面。</li>\n</ol>\n<p>具体的编译顺序是project文件中-&gt;Build Phases-&gt;Complile Sources的顺序。</p>\n<h3 id=\"调用顺序\"><a href=\"#调用顺序\" class=\"headerlink\" title=\"调用顺序\"></a>调用顺序</h3><h4 id=\"load加载顺序\"><a href=\"#load加载顺序\" class=\"headerlink\" title=\"+load加载顺序\"></a>+load加载顺序</h4><p>每个类和分类都会加载的时候调用<code>+load</code>方法，具体是怎么调用呢？我们查看源码<code>_objc_init-&gt;load_images-&gt;call_load_methods</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">void call_load_methods(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    static bool loading = NO;</div><div class=\"line\">    bool more_categories;</div><div class=\"line\"></div><div class=\"line\">    loadMethodLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    // Re-entrant calls do nothing; the outermost call will finish the job.</div><div class=\"line\">    if (loading) return;</div><div class=\"line\">    loading = YES;</div><div class=\"line\"></div><div class=\"line\">    void *pool = objc_autoreleasePoolPush();</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">        // 1. Repeatedly call class +loads until there aren&apos;t any more</div><div class=\"line\">        //执行class+load直到完成</div><div class=\"line\">        while (loadable_classes_used &gt; 0) &#123;</div><div class=\"line\">            call_class_loads();</div><div class=\"line\">        &#125;</div><div class=\"line\">//执行Category +load 一次</div><div class=\"line\">        // 2. Call category +loads ONCE</div><div class=\"line\">        more_categories = call_category_loads();</div><div class=\"line\"></div><div class=\"line\">        // 3. Run more +loads if there are classes OR more untried categories</div><div class=\"line\">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</div><div class=\"line\"></div><div class=\"line\">    objc_autoreleasePoolPop(pool);</div><div class=\"line\"></div><div class=\"line\">    loading = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>类<code>+load</code>在<code>Category+load</code>前边执行，当类的<code>+load</code>执行完毕然后再去执行<code>Category+load</code>,而且只有一次。<br>当class有子类的时候加载顺序呢？其实所有类都是基于<code>NSObject</code>，那么我们假设按照编译顺序加载<code>Class+load</code>，就有一个问题是父类+load执行的操作岂不是在子类执行的时候还没有执行吗？这个假设明显不对，基类<code>+load</code>中的操作是第一个执行的，其他子类是按照<code>superclass-&gt;class-&gt;sonclass</code>的顺序执行的。<br>查看源码<code>_objc_init-&gt;load_images-&gt;prepare_load_methods((const headerType *)mh)-&gt;schedule_class_load</code>在<code>objc-runtime-new.mm</code>2856行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* Schedule +load for classes in this image, any un-+load-ed </div><div class=\"line\">* superclasses in other images, and any categories in this image.</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">// Recursively schedule +load for cls and any un-+load-ed superclasses.</div><div class=\"line\">// cls must already be connected.</div><div class=\"line\">static void schedule_class_load(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls) return;</div><div class=\"line\">    assert(cls-&gt;isRealized());  // _read_images should realize</div><div class=\"line\"></div><div class=\"line\">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</div><div class=\"line\"></div><div class=\"line\">    // Ensure superclass-first ordering</div><div class=\"line\">    //递归调用自己直到调用clas-&gt;self</div><div class=\"line\">    schedule_class_load(cls-&gt;superclass);</div><div class=\"line\">//添加class</div><div class=\"line\">    add_class_to_loadable_list(cls);</div><div class=\"line\">    cls-&gt;setInfo(RW_LOADED); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以了解到该函数递归调用自己，直到<code>+load</code>方法已经调用过为止，所以不管编译顺序是高低，<code>+load</code>的加载顺序始终是<code>NSObject-&gt;FYPrson-&gt;FYStudent</code>。多个类平行关系的话，按照编译顺序加载。<br>下边是稍微复杂点的类关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">NSObject</div><div class=\"line\">    Person</div><div class=\"line\">        Student</div><div class=\"line\">NSObjet</div><div class=\"line\">    Car</div><div class=\"line\">        BigCar</div><div class=\"line\">            BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>编译顺序是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person</div><div class=\"line\">Student</div><div class=\"line\">Car</div><div class=\"line\">BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>那么他们<code>+load</code>的加载顺序是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">NSobject-&gt;Person-&gt;Student-&gt;Car-&gt;BigCar-&gt;BigOrSmallCar</div></pre></td></tr></table></figure>\n<p>看着不是很明白的 可以再看一下刚才的<code>schedule_class_load</code>函数。<br>加载成功之后，是按照<code>objc_msgsend()</code>流程发送的吗？我们进入到<code>call_class_loads</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void call_class_loads(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    int i;</div><div class=\"line\">    </div><div class=\"line\">    // Detach current loadable list.</div><div class=\"line\">    struct loadable_class *classes = loadable_classes;</div><div class=\"line\">    int used = loadable_classes_used;</div><div class=\"line\">    loadable_classes = nil;</div><div class=\"line\">    loadable_classes_allocated = 0;</div><div class=\"line\">    loadable_classes_used = 0;</div><div class=\"line\">    </div><div class=\"line\">    // Call all +loads for the detached list.</div><div class=\"line\">    for (i = 0; i &lt; used; i++) &#123;</div><div class=\"line\">        Class cls = classes[i].cls;</div><div class=\"line\">        load_method_t load_method = (load_method_t)classes[i].method;</div><div class=\"line\">        if (!cls) continue; </div><div class=\"line\"></div><div class=\"line\">        if (PrintLoading) &#123;</div><div class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</div><div class=\"line\">        &#125;</div><div class=\"line\">        (*load_method)(cls, SEL_load);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (classes) free(classes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以找到<code>(*load_method)(cls, SEL_load);</code>该函数，该函数是直接使用<code>IMP</code>执行的，<code>IMP</code>就是函数地址，可以直接访问函数而不用消息的转发流程。</p>\n<h4 id=\"initialize调用\"><a href=\"#initialize调用\" class=\"headerlink\" title=\"+initialize调用\"></a>+initialize调用</h4><ul>\n<li>+initialize方法会在类第一次接收到消息时调用</li>\n<li>先调用父类的+initialize，再调用子类的+initialize</li>\n<li>先初始化父类，再初始化子类，每个类只会初始化1次</li>\n</ul>\n<p><code>objc</code>源码解读过程<code>objc-msg-arm64.x-&gt;objc_msgSend-&gt;objc-&gt;runtime-new-&gt;class_getinstanceMethod-&gt;lookUpImpOrNil-&gt;lookUpImpOrForward-&gt;_clas_initialize-&gt;callInitialize-&gt;objc_msgSend(cls,SEL_Initialize)</code><br>在<code>runtime-new.h</code>4819行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method class_getInstanceMethod(Class cls, SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cls  ||  !sel) return nil;</div><div class=\"line\"></div><div class=\"line\">    lookUpImpOrNil(cls, sel, nil, </div><div class=\"line\">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    return _class_getMethod(cls, sel);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据<code>lookUpImpOrNil</code>查看4916行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class=\"line\">                       bool initialize, bool cache, bool resolver)</div><div class=\"line\">&#123;</div><div class=\"line\">    IMP imp = nil;</div><div class=\"line\">    bool triedResolver = NO;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.assertUnlocked();</div><div class=\"line\"></div><div class=\"line\">    // Optimistic cache lookup</div><div class=\"line\">    if (cache) &#123;</div><div class=\"line\">        imp = cache_getImp(cls, sel);</div><div class=\"line\">        if (imp) return imp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.lock();</div><div class=\"line\">    checkIsKnownClass(cls);</div><div class=\"line\"></div><div class=\"line\">    if (!cls-&gt;isRealized()) &#123;</div><div class=\"line\">        realizeClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">      //当第一次收到消息，cls没有初始化，则调用_class_initialize进行初始化</div><div class=\"line\">      &#125;</div><div class=\"line\"> retry:    </div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\">    imp = cache_getImp(cls, sel);</div><div class=\"line\">    if (imp) goto done;</div><div class=\"line\">   // Try this class&apos;s method lists.</div><div class=\"line\">    //在本类中查找method</div><div class=\"line\">    &#123;</div><div class=\"line\">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class=\"line\">        if (meth) &#123;</div><div class=\"line\">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class=\"line\">            imp = meth-&gt;imp;</div><div class=\"line\">            goto done;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Try superclass caches and method lists.</div><div class=\"line\">    &#123;</div><div class=\"line\">        unsigned attempts = unreasonableClassCount();</div><div class=\"line\">        for (Class curClass = cls-&gt;superclass;</div><div class=\"line\">             curClass != nil;</div><div class=\"line\">             curClass = curClass-&gt;superclass)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Halt if there is a cycle in the superclass chain.</div><div class=\"line\">            if (--attempts == 0) &#123;</div><div class=\"line\">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass cache.</div><div class=\"line\">            imp = cache_getImp(curClass, sel);</div><div class=\"line\">            if (imp) &#123;</div><div class=\"line\">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class=\"line\">                    // Found the method in a superclass. Cache it in this class.</div><div class=\"line\">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class=\"line\">                    goto done;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    // Found a forward:: entry in a superclass.</div><div class=\"line\">                    // Stop searching, but don&apos;t cache yet; call method </div><div class=\"line\">                    // resolver for this class first.</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass method list.</div><div class=\"line\">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class=\"line\">            if (meth) &#123;</div><div class=\"line\">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class=\"line\">                imp = meth-&gt;imp;</div><div class=\"line\">                goto done;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // No implementation found. Try method resolver once.</div><div class=\"line\"></div><div class=\"line\">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_resolveMethod(cls, sel, inst);</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">        // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </div><div class=\"line\">        // changed already. Re-do the search from scratch instead.</div><div class=\"line\">        triedResolver = YES;</div><div class=\"line\">        goto retry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // No implementation found, and method resolver didn&apos;t help. </div><div class=\"line\">    // Use forwarding.</div><div class=\"line\"></div><div class=\"line\">    imp = (IMP)_objc_msgForward_impcache;</div><div class=\"line\">    cache_fill(cls, sel, imp, inst);</div><div class=\"line\"></div><div class=\"line\"> done:</div><div class=\"line\">    runtimeLock.unlock();</div><div class=\"line\"></div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当第一次收到消息，cls没有初始化，则调用<code>_class_initialize</code>进行初始化<br>我们进入到<code>_class_initialize</code>内部<code>objc-initialize.mm</code>484行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _class_initialize(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(!cls-&gt;isMetaClass());</div><div class=\"line\"></div><div class=\"line\">    Class supercls;</div><div class=\"line\">    bool reallyInitialize = NO;</div><div class=\"line\"></div><div class=\"line\">    // Make sure super is done initializing BEFORE beginning to initialize cls.</div><div class=\"line\">    // See note about deadlock above.</div><div class=\"line\">    //递归调用父类是否有初始化和是否有父类</div><div class=\"line\">    supercls = cls-&gt;superclass;</div><div class=\"line\">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</div><div class=\"line\">        _class_initialize(supercls);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // Try to atomically set CLS_INITIALIZING.</div><div class=\"line\">    &#123;</div><div class=\"line\">        monitor_locker_t lock(classInitLock);</div><div class=\"line\">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</div><div class=\"line\">            cls-&gt;setInitializing();</div><div class=\"line\">            reallyInitialize = YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (reallyInitialize) &#123;</div><div class=\"line\">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</div><div class=\"line\">        </div><div class=\"line\">        // Record that we&apos;re initializing this class so we can message it.</div><div class=\"line\">        _setThisThreadIsInitializingClass(cls);</div><div class=\"line\"></div><div class=\"line\">        if (MultithreadedForkChild) &#123;</div><div class=\"line\">            // LOL JK we don&apos;t really call +initialize methods after fork().</div><div class=\"line\">            performForkChildInitialize(cls, supercls);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        // Send the +initialize message.</div><div class=\"line\">        // Note that +initialize is sent to the superclass (again) if </div><div class=\"line\">        // this class doesn&apos;t implement +initialize. 2157218</div><div class=\"line\">        if (PrintInitializing) &#123;</div><div class=\"line\">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</div><div class=\"line\">                         pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Exceptions: A +initialize call that throws an exception </div><div class=\"line\">        // is deemed to be a complete and successful +initialize.</div><div class=\"line\">        //</div><div class=\"line\">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</div><div class=\"line\">        // bootstrapping problem of this versus CF&apos;s call to</div><div class=\"line\">        // objc_exception_set_functions().</div><div class=\"line\">#if __OBJC2__</div><div class=\"line\">        @try</div><div class=\"line\">#endif</div><div class=\"line\">        &#123;</div><div class=\"line\">            callInitialize(cls);</div><div class=\"line\"></div><div class=\"line\">            if (PrintInitializing) &#123;</div><div class=\"line\">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</div><div class=\"line\">                             pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if __OBJC2__</div><div class=\"line\">        @catch (...) &#123;</div><div class=\"line\">            if (PrintInitializing) &#123;</div><div class=\"line\">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</div><div class=\"line\">                             &quot;threw an exception&quot;,</div><div class=\"line\">                             pthread_self(), cls-&gt;nameForLogging());</div><div class=\"line\">            &#125;</div><div class=\"line\">            @throw;</div><div class=\"line\">        &#125;</div><div class=\"line\">        @finally</div><div class=\"line\">#endif</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Done initializing.</div><div class=\"line\">            lockAndFinishInitializing(cls, supercls);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else if (cls-&gt;isInitializing()) &#123;</div><div class=\"line\">        // We couldn&apos;t set INITIALIZING because INITIALIZING was already set.</div><div class=\"line\">        // If this thread set it earlier, continue normally.</div><div class=\"line\">        // If some other thread set it, block until initialize is done.</div><div class=\"line\">        // It&apos;s ok if INITIALIZING changes to INITIALIZED while we&apos;re here, </div><div class=\"line\">        //   because we safely check for INITIALIZED inside the lock </div><div class=\"line\">        //   before blocking.</div><div class=\"line\">        if (_thisThreadIsInitializingClass(cls)) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else if (!MultithreadedForkChild) &#123;</div><div class=\"line\">            waitForInitializeToComplete(cls);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We&apos;re on the child side of fork(), facing a class that</div><div class=\"line\">            // was initializing by some other thread when fork() was called.</div><div class=\"line\">            _setThisThreadIsInitializingClass(cls);</div><div class=\"line\">            performForkChildInitialize(cls, supercls);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else if (cls-&gt;isInitialized()) &#123;</div><div class=\"line\">        // Set CLS_INITIALIZING failed because someone else already </div><div class=\"line\">        //   initialized the class. Continue normally.</div><div class=\"line\">        // NOTE this check must come AFTER the ISINITIALIZING case.</div><div class=\"line\">        // Otherwise: Another thread is initializing this class. ISINITIALIZED </div><div class=\"line\">        //   is false. Skip this clause. Then the other thread finishes </div><div class=\"line\">        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. </div><div class=\"line\">        //   Skip the ISINITIALIZING clause. Die horribly.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    else &#123;</div><div class=\"line\">        // We shouldn&apos;t be here. </div><div class=\"line\">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来，和<code>+load</code>方法一样，先父类后子类。然后赋值<code>reallyInitialize = YES;</code>，后边使用<code>try</code>主动调用<code>callInitialize(cls);</code>，来到<code>callInitialize(cls);</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void callInitialize(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</div><div class=\"line\">    asm(&quot;&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到最终还是使用<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</code>主动调用了该函数。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点<br>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>可能会被调用多次）<br>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用</p>\n<p>用伪代码实现以下思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(class 没有初始化)&#123;</div><div class=\"line\">    父类初始化</div><div class=\"line\">    子类初始化</div><div class=\"line\">    调用initialize</div><div class=\"line\">&#125;</div><div class=\"line\">如果子类没有实现initialize，则去调用父类initialize。</div></pre></td></tr></table></figure>\n<p>至于子类没有实现的话是直接调用父类的<code>initialize</code>，是使用<code>objc-msgsend</code>的原因。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">+(void)initialize&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">@interface FYPerson (test1)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">+(void)initialize&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load&#123;</div><div class=\"line\">\tprintf(&quot;\\n%s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">+[FYPerson load]</div><div class=\"line\">+[FYPerson(test2) load]</div><div class=\"line\">+[FYPerson(test1) load]</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><code>+load</code>是根据函数地址直接调用，<code>initialize</code>是通过<code>objc_msgSend</code>调用</li>\n<li><code>+load</code>是runtime加载类、分类时候调用（只会调用一次）</li>\n<li><code>initialize</code>是第一次接受消息的时候调用，每个类只会调用一次（子类没实现，父类可能被调用多次）</li>\n<li><code>+load</code>调用优先于<code>initialize</code>,子类调用<code>+load</code>之前会调用父类的<code>+load</code>，再调用分类的<code>+load</code>,分类之间先编译，先调用。</li>\n<li><code>initialize</code>先初始化父类，再初始化子类（可能最终调用父类的<code>initialize</code>）</li>\n</ul>\n<h3 id=\"关联对象本质\"><a href=\"#关联对象本质\" class=\"headerlink\" title=\"关联对象本质\"></a>关联对象本质</h3><h4 id=\"关联对象的本质-结构体\"><a href=\"#关联对象的本质-结构体\" class=\"headerlink\" title=\"关联对象的本质-结构体\"></a>关联对象的本质-结构体</h4><p>继承<code>NSObject</code>是可以可以直接使用<code>@property (nonatomic,assign) int age;</code>，但是在<code>Category</code>中会报错，那么怎么实现和继承基类一样的效果呢？<br>我们查看<code>Category</code>结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  struct _category_t &#123;</div><div class=\"line\">\tconst char *name; //&quot;FYPerson&quot;</div><div class=\"line\">\tstruct _class_t *cls;</div><div class=\"line\">\tconst struct _method_list_t *instance_methods;</div><div class=\"line\">\tconst struct _method_list_t *class_methods;</div><div class=\"line\">\tconst struct _protocol_list_t *protocols;</div><div class=\"line\">\tconst struct _prop_list_t *properties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中<code>const struct _prop_list_t *properties;</code>是存储属性的，但是缺少成员变量，而我们也不能主动在<code>_category_t</code>插入<code>ivar</code>，那么我们可以使用<code>objc_setAssociatedObject</code>将属性的值存储全局的<code>AssociationsHashMap</code>中，使用的时候<code>objc_getAssociatedObject(id object, const void *key)</code>,不使用的时候删除使用<code>objc_removeAssociatedObjects</code>删除。</p>\n<p>我们进入到<code>objc_setAssociatedObject</code>内部,<code>objc-references.mm</code>275行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class=\"line\">    // retain the new value (if any) outside the lock.</div><div class=\"line\">    ObjcAssociation old_association(0, nil);</div><div class=\"line\">\t//根据key value 处理</div><div class=\"line\">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class=\"line\">    &#123;</div><div class=\"line\">        AssociationsManager manager;</div><div class=\"line\">\t\t//生成一个全局的 HashMap</div><div class=\"line\">        AssociationsHashMap &amp;associations(manager.associations());</div><div class=\"line\">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class=\"line\">\t\t//有value 就处理</div><div class=\"line\">        if (new_value) &#123;</div><div class=\"line\">            // break any existing association.</div><div class=\"line\">//\t\t\t遍历 hashMap是否有该obj</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i != associations.end()) &#123;</div><div class=\"line\">                // secondary table exists</div><div class=\"line\">\t\t\t\t//有的话 更新其 value</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // create the new association (first time).</div><div class=\"line\">\t\t\t\t//没有的话 赋值给 refs</div><div class=\"line\">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class=\"line\">                associations[disguised_object] = refs;</div><div class=\"line\">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                object-&gt;setHasAssociatedObjects();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // setting the association to nil breaks the association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i !=  associations.end()) &#123;</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    //删除refs </div><div class=\"line\">                    refs-&gt;erase(j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // release the old value (outside of the lock).</div><div class=\"line\">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过该函数我们了解到</p>\n<ul>\n<li>关联对象并不是存储在关联对象的本身内存中</li>\n<li>关联对象是存储在全局统一的<code>AssociationsManager</code>管理的<code>AssociationsHashMap</code>中</li>\n<li>传入value =nil，会移除该关联对线<br><code>AssociationsManager</code>其实是管理了已<code>key为id object</code>对应的<code>AssociationsHashMap</code>，<code>AssociationsHashMap</code>存储了<code>key</code>对应的<code>ObjcAssociation</code>，<code>ObjcAssociation</code>是存储了<code>value</code> 和<code>policy</code>，<code>ObjcAssociation</code>的数据结构如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ObjcAssociation &#123;</div><div class=\"line\">        uintptr_t _policy;</div><div class=\"line\">        id _value;</div><div class=\"line\">        *****</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>具体抽象关系见下图</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AssociationsManager --&gt; AssociationsHashMap --&gt; ObjectAssociationMap</div><div class=\"line\">--&gt;void * ObjectAssociation --&gt;uintprt_t _policy ,id _value;</div></pre></td></tr></table></figure>\n<p>简单来讲就是一个全局变量保存了以<code>class</code>为<code>key</code>对应的<code>AssociationsHashMap</code>，这个<code>AssociationsHashMap</code>存储了一个<code>key</code>对应的<code>ObjectAssociation</code>，<code>ObjectAssociation</code>包含了<code>value</code>和<code>_policy</code>。通过2层map保存了数据。</p>\n<h4 id=\"关联对象的使用\"><a href=\"#关联对象的使用\" class=\"headerlink\" title=\"关联对象的使用\"></a>关联对象的使用</h4><table>\n<thead>\n<tr>\n<th>objc_setAssociatedObject</th>\n<th>obj,key,value,policy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>objc_getAssociatedObject</td>\n<td>根据 obj 和 key获取值</td>\n</tr>\n<tr>\n<td>void objc_removeAssociatedObjects(id object)</td>\n<td>根据obj 删除关联函数</td>\n</tr>\n</tbody>\n</table>\n<p><code>objc_AssociationPolicy</code>的类型：</p>\n<table>\n<thead>\n<tr>\n<th>OBJC_ASSOCIATION_ASSIGN</th>\n<th>weak 引用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td>非原子强引用</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td>非原子相当于copy</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN</td>\n<td>强引用</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY</td>\n<td>原子操作，相当于copy</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (test)</div><div class=\"line\">@property (nonatomic,assign) NSString * name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;NSObject+test.h&quot;</div><div class=\"line\">#import &quot;objc/runtime.h&quot;</div><div class=\"line\">@implementation NSObject (test)</div><div class=\"line\">-(void)setName:(NSString *)name&#123;</div><div class=\"line\">\tobjc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString *)name&#123;</div><div class=\"line\">\treturn  objc_getAssociatedObject(self, @selector(name));</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSObject *obj =[[NSObject alloc]init];</div><div class=\"line\">obj.name = @&quot;老弟来了&quot;;</div><div class=\"line\">printf(&quot;%s&quot;,obj.name.UTF8String);</div><div class=\"line\">//老弟来了</div></pre></td></tr></table></figure>\n<p>这段代码我们实现了给基类添加一个成员变量<code>name</code>，然后又成功取出了值，标示我们做新增的保存成员变量的值是对的。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>Category <code>+load</code>在冷启动时候执行，执行顺序和编译顺序成弱相关，先父类，后子类，而且每个类执行一次，执行是直接调用函数地址。</li>\n<li>Category <code>+initialize</code>在第一次接受消息执行，先父类，后子类，子类没实现，会调用父类，利用<code>objc-msgsend</code>机制调用。</li>\n<li>Category 可以利用<code>Associative</code>添加和读取属性的值</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n</li>\n</ul>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"MVC、MVP、MVVM、分层设计浅谈 — (13)","date":"2019-12-01T03:23:58.000Z","_content":"\n这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到\n> 1. MVC\n> 2. MVC变种\n> 3. MVP\n> 4. MVVM\n> 5. 分层设计的优缺点\n\n没有最好的架构，只有最适合业务的架构。\n\n### MVC\n苹果版本的`MVC`是`Model`和`VC`和交互，`VC`和`View`交互\n\n- 优点：`View`和`Model`可以重复利用，可以独立使用\n\n- 缺点：`Controller`的代码过于臃肿\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65c373454277a?w=801&h=274&f=png&s=17358)\n\n代码：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadData];\n}\n- (void)loadData{\n    self.data=[NSMutableArray array];\n    for (int i = 0; i < 20; i ++) {\n        FYNews *item=[FYNews new];\n        item.title =[NSString stringWithFormat:@\"title-%d\",i];\n        item.name =[NSString stringWithFormat:@\"name-%d\",i];\n        [self.data addObject:item];\n    }\n}\n\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n    return 1;\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.data.count;\n}\n\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\" forIndexPath:indexPath];\n    \n    // Configure the cell...\n    FYNews *item =[self.data objectAtIndex:indexPath.row];\n    cell.detailTextLabel.text =item.title;\n    cell.textLabel.text = item.name;\n    return cell;\n}\n\n//model\n\n@interface FYNews : NSObject\n@property (nonatomic,copy) NSString *title;\n@property (nonatomic,copy) NSString *name;\n@end\n```\n\n这里是`VC`中组装了`tableview`，`model`的数据在`VC`中在`view`中显示出来，当需要另外的数据的时候，只需要将`model`改成需要的`model`而无需更改`tableview`的代码兼容性较好。\n\n### MVC变种\n\n`MVC`变种，其实就是将`model`和`view`建立了联系，`view`依据`Model`来展示数据，`VC`组装`Model`，组装展示是在`view`中实现。\n\n- 优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现\n\n- 缺点：view依赖于Model\n\n\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65cb8ad888abf?w=735&h=364&f=png&s=25874)\n\n代码实现\n\n```\n//.h\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong) FYItemModel *model;\n@end\n\n//.m\n@interface FYAppleView()\n@property (nonatomic,strong) UILabel *nameLabel;\n@end\n\n@implementation FYAppleView\n-(instancetype)initWithFrame:(CGRect)frame{\n    if (self =[super initWithFrame:frame]) {\n        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];\n        [self addSubview:_nameLabel];\n    }\n    return self;\n}\n/*\n  mvc的变种\n */\n- (void)setModel:(FYItemModel *)model{\n    _model = model;\n    _nameLabel.textColor = model.bgColor;\n    _nameLabel.text = model.name;\n}\n@end\n\n//FYItemModel\n@interface FYItemModel : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,strong) UIColor *bgColor;\n@end\n\n\n//ViewController\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadViewOtherMVC];\n}\n//变种MVC 把View和Model建立起连接\n//等以后更新view数据只需要 view.model = item;Controllr少了许多代码\n- (void)loadViewOtherMVC{\n    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];\n    FYItemModel *item=[[FYItemModel alloc]init];\n    item.name = @\"校长来了\";\n    item.bgColor = [UIColor redColor];\n    view.model = item;\n    [self.view addSubview:view];\n}\n@end\n```\n\n可以看到`model`组装到`view`展示内容是在`view`实现的，外部不知道细节，只需要将`model`给`view`即可，但是只能传输过来`model`或者他子类，业务更改的话，需要修改`view`的内部`model`才能将变更过的数据重新展示出来。\n\n想要监听view的点击事件来做一些操作，那么我们可以使用代理和`block`,这里`id`是实现了`FYAppleViewProtocol`协议的，`weak`修饰防止循环引用，使用协议实现了和`VC`的通信。\n\n```\n@class FYAppleView;\n@protocol FYAppleViewProtocol <NSObject>\n- (void)FYAppleViewDidClick:(FYAppleView*)view;\n@end\n\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n@property (nonatomic,weak) id<FYAppleViewProtocol> delegate;\n@property (nonatomic,strong) FYItemModel *model;\n@end\n```\n\n稍作更改还是`apple-MVC`\n\n```\n// .h\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n@end\n```\n将`View`属性`nameLabel`暴露出来，但是不允许外界进行更改，去掉`model`则是`MVC`。\n\n\n\n###  MVP\n\n`MVP`和`MVC`很像，只是将`VC`换成了`Presenter`，`vc`和`Present`做的事情基本一致，将`view`和`Model`通信改到了都和`Presenter`通信。\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65f39c348e3e9?w=610&h=215&f=png&s=12793)\n代码\n\n```\n//MVP\n//.h\n@interface FYNewsPresenter : NSObject\n\n@property (nonatomic,weak) UIViewController *vc;\n//初始化\n- (void)setup;\n@end\n\n.m\n#import \"FYNewsPresenter.h\"\n@interface FYNewsPresenter()<FYAppleViewProtocol>\n@end\n\n@implementation FYNewsPresenter\n- (void)setup{\n\tFYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];\n\tFYItemModel *item=[[FYItemModel alloc]init];\n\titem.name = @\"校长来了\";\n\titem.bgColor = [UIColor redColor];\n\tview.model = item;\n\t[self.vc.view addSubview:view];\n}\n- (void)FYAppleViewDidClick:(FYAppleView *)view{\n\tNSLog(@\"点击了我\");\n}\n@end\n\n\n//VC中\n@interface ViewController ()\n@property (nonatomic,strong) FYNewsPresenter *presenter;\n@end\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\t_presenter=[FYNewsPresenter new];\n\t_presenter.vc = self;\n\t[_presenter setup];\n}\n@end\n```\n再次对`VC`进行了瘦身，将更多的业务逻辑搬到了`FYNewsPresenter`处理，其实全部搬过去，意义比不大，`FYNewsPresenter`也会臃肿，也会出现和`VC`一样的困惑。\n\n###  MVVM\n`MVVM`是将`FYNewsPresenter`都搬到了`FYNewsViewModel`中，然后对`FYNewsViewModel`和`View`进行了一个双向绑定，双向绑定可以使用代理，`block`或者`KVO`实现。\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c6603450d271bb?w=642&h=237&f=png&s=13181)\n代码实现\n\n```\n@interface FYNewsViewModel : NSObject\n\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,strong) UIColor *bgColor;\n\n@property (nonatomic,weak) UIViewController *vc;\n\n- (instancetype)initWithController:(UIViewController *)vc;\n@end\n\n\n\n#import \"FYNewsViewModel.h\"\n@interface FYNewsViewModel()<FYAppleViewProtocol>\n\n\n@end\n@implementation FYNewsViewModel\n- (instancetype)initWithController:(UIViewController *)vc{\n    if (self =[super init]) {\n        self.vc = vc;\n        \n        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];\n        //    view.model = item;\n        view.delegate = self;\n        view.viewModel = self; //建立kvo\n        \n        view.backgroundColor = [UIColor lightGrayColor];\n        [vc.view addSubview:view];\n        \n        \n        \n        FYItemModel *item=[[FYItemModel alloc]init];\n        item.name = @\"校长来了\";\n        item.bgColor = [UIColor redColor];\n        \n        self.name = item.name;\n        self.bgColor = item.bgColor;\n    }\n    return self;\n}\n- (void)FYAppleViewDidClick:(FYAppleView *)view{\n\tNSLog(@\"点击了我\");\n}\n@end\n```\n在`view`实现\n\n```\n@class FYAppleView,FYNewsViewModel;\n@protocol FYAppleViewProtocol <NSObject>\n\n- (void)FYAppleViewDidClick:(FYAppleView*)view;\n\n@end\n\n@class FYItemModel;\n\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n\n@property (nonatomic,weak) id<FYAppleViewProtocol> delegate;\n@property (nonatomic,weak) FYNewsViewModel *viewModel;\n\n@property (nonatomic,strong) FYItemModel *model;\n@end\n\n\n@interface FYAppleView()\n@property (nonatomic,strong) UILabel *nameLabel;\n@end\n@implementation FYAppleView\n-(instancetype)initWithFrame:(CGRect)frame{\n    if (self =[super initWithFrame:frame]) {\n        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];\n        [self addSubview:_nameLabel];\n    }\n    return self;\n}\n/*\n  mvc的变种\n */\n- (void)setModel:(FYItemModel *)model{\n    _model = model;\n    _nameLabel.textColor = model.bgColor;\n    _nameLabel.text = model.name;\n\t\n \n}\n\n- (void)setViewModel:(FYNewsViewModel *)viewModel{\n    _viewModel = viewModel;\n   [_viewModel addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];\n   //使用FBKVO实现 或者自己使用KVO实现\n//    __weak typeof(self) waekSelf = self;\n//    [self.KVOController observe:viewModel keyPath:@\"name\"\n//                        options:NSKeyValueObservingOptionNew\n//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];\n//    }];\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n    if ([keyPath isEqualToString:@\"name\"]) {\n        self.nameLabel.text = change[NSKeyValueChangeNewKey];\n    }\n}\n\n//添加点击事件\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tif ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) {\n\t\t[self.delegate FYAppleViewDidClick:self];\n\t}\n}\n\n-(void)dealloc{\n    [_viewModel removeObserver:self\n                    forKeyPath:@\"name\"];\n}\n@end\n```\n使用`KVO`或者`FBKVO`或者`RAC`都是可以的，本章节例子给出了`FBKVO`或者自己使用`KVO`的实现。\n\n\n\n### 分层设计\n三层架构：\n> 三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层\n\n- 目的: “高内聚，低耦合”的思想 \n\n- 优点: 降低层与层之间的依赖 标准化 \n\n- 缺点: 系统架构复杂，不适合小型项目\n\n#### 三层原理\n> 3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。\n所谓三层体系结构，是在客户端与数据库之间加入了一个`中间层`，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有`B/S`应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。\n\n> 三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过`COM/DCOM`通讯与中间层建立连接，再经由中间层与数据库进行交互。\n\n> 三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用`COM/DCOM`通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互\n\n`MVC`、`MVVM`、`MVP`属于界面层，\n当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了\n\n分层之后，得到了一个三层架构或四层架构\n\n![三层架构](https://user-gold-cdn.xitu.io/2019/8/6/16c6623d82034790?w=536&h=281&f=png&s=23627)\n\n数据层也可以分为两层，分为网络请求和db层。\n\n![四层架构](https://user-gold-cdn.xitu.io/2019/8/6/16c6624a552bd892?w=568&h=370&f=png&s=29291)\n\n具体在工程中我们通常这样体现\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c66313fbdd90a3?w=270&h=432&f=png&s=24528)\n\n在`vc`中获取数据\n\n```\n@interface ViewController ()\n@property (nonatomic,strong) FYDBPool *db;\n@property (nonatomic,strong) FYHttpPool *http;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t//当有业务层\n\t[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) {\n\t\t\n\t} fail:^{\n\t\t\n\t}];\n\t//当没有有业务层\n\tself.db=[FYDBPool new];\n\tself.http=[FYHttpPool new];\n\t[self.db loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\tif ([ret count]) {\n\t\t\tNSLog(@\"数据获取成功\");\n\t\t}else{\n\t\t\t[self.http loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\t\t\tNSLog(@\"数据获取成功\");\n\t\t\t} fail:^{\n\t\t\t\tNSLog(@\"数据获取失败\");\n\t\t\t}];\n\t\t}\n\t} fail:^{\n\t\t[self.http loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\t\tNSLog(@\"数据获取成功\");\n\t\t} fail:^{\n\t\t\tNSLog(@\"数据获取失败\");\n\t\t}];\n\t}];\n}\n\n```\n在业务层\n\n```\n@interface FYNewsService ()\n@property (nonatomic,strong) FYDBPool *db;\n@property (nonatomic,strong) FYHttpPool *http;\n\n@end\n@implementation FYNewsService\n-(instancetype)init{\n\tif (self = [super init]) {\n\t\tself.db=[FYDBPool new];\n\t\tself.http=[FYHttpPool new];\n\t}\n\treturn self;\n}\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock{\n\t[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\tif ([ret count]) {\n\t\t\tsuccblock(ret);\n\t\t}else{\n\t\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\t\t\tsuccblock(ret);\n\t\t\t} fail:failBlock];\n\t\t}\n\t} fail:^{\n\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\t\tsuccblock(ret);\n\t\t} fail:failBlock];\n\t}];\n}\n@end\n```\n在db层\n\n```\ntypedef void(^succcessCallback)(NSArray *);\n@interface FYDBPool : NSObject\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock;\n@end\n```\n在网络请求层\n\n```\ntypedef void(^succcessCallback)(NSArray *);\n@interface FYHttpPool : NSObject\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock;\n@end\n```\n\n分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或`db`，当`db`足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。\n不同的人来处理不同的分层，相互影响也比较小，降低耦合。\n\n\n**当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。**\n\n### 后记\n优雅的代码总是伴随着各种传统设计模式的搭配\n#### 设计模式\n> 设计模式（Design Pattern）\n是一套被反复使用、代码设计经验的总结\n使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性\n一般与编程语言无关，是一套比较成熟的编程思想\n\n设计模式可以分为三大类\n1. 创建型模式：对象实例化的模式，用于解耦对象的实例化过程\n单例模式、工厂方法模式，等等\n\n2. 结构型模式：把类或对象结合在一起形成一个更大的结构\n代理模式、适配器模式、组合模式、装饰模式，等等\n\n3. 行为型模式：类或对象之间如何交互，及划分责任和算法\n观察者模式、命令模式、责任链模式，等等\n\n\n### 总结\n- 适合项目的才是最好的架构\n\n### 资料参考\n- [三层架构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84)\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&h=268&f=jpeg&s=27083)","source":"_posts/iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13).md","raw":" \ntitle: MVC、MVP、MVVM、分层设计浅谈 — (13)\ndate: 2019-12-1 11:23:58\ntags:\n- iOS\ncategories: iOS\n---\n\n这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到\n> 1. MVC\n> 2. MVC变种\n> 3. MVP\n> 4. MVVM\n> 5. 分层设计的优缺点\n\n没有最好的架构，只有最适合业务的架构。\n\n### MVC\n苹果版本的`MVC`是`Model`和`VC`和交互，`VC`和`View`交互\n\n- 优点：`View`和`Model`可以重复利用，可以独立使用\n\n- 缺点：`Controller`的代码过于臃肿\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65c373454277a?w=801&h=274&f=png&s=17358)\n\n代码：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadData];\n}\n- (void)loadData{\n    self.data=[NSMutableArray array];\n    for (int i = 0; i < 20; i ++) {\n        FYNews *item=[FYNews new];\n        item.title =[NSString stringWithFormat:@\"title-%d\",i];\n        item.name =[NSString stringWithFormat:@\"name-%d\",i];\n        [self.data addObject:item];\n    }\n}\n\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n    return 1;\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.data.count;\n}\n\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\" forIndexPath:indexPath];\n    \n    // Configure the cell...\n    FYNews *item =[self.data objectAtIndex:indexPath.row];\n    cell.detailTextLabel.text =item.title;\n    cell.textLabel.text = item.name;\n    return cell;\n}\n\n//model\n\n@interface FYNews : NSObject\n@property (nonatomic,copy) NSString *title;\n@property (nonatomic,copy) NSString *name;\n@end\n```\n\n这里是`VC`中组装了`tableview`，`model`的数据在`VC`中在`view`中显示出来，当需要另外的数据的时候，只需要将`model`改成需要的`model`而无需更改`tableview`的代码兼容性较好。\n\n### MVC变种\n\n`MVC`变种，其实就是将`model`和`view`建立了联系，`view`依据`Model`来展示数据，`VC`组装`Model`，组装展示是在`view`中实现。\n\n- 优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现\n\n- 缺点：view依赖于Model\n\n\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65cb8ad888abf?w=735&h=364&f=png&s=25874)\n\n代码实现\n\n```\n//.h\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong) FYItemModel *model;\n@end\n\n//.m\n@interface FYAppleView()\n@property (nonatomic,strong) UILabel *nameLabel;\n@end\n\n@implementation FYAppleView\n-(instancetype)initWithFrame:(CGRect)frame{\n    if (self =[super initWithFrame:frame]) {\n        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];\n        [self addSubview:_nameLabel];\n    }\n    return self;\n}\n/*\n  mvc的变种\n */\n- (void)setModel:(FYItemModel *)model{\n    _model = model;\n    _nameLabel.textColor = model.bgColor;\n    _nameLabel.text = model.name;\n}\n@end\n\n//FYItemModel\n@interface FYItemModel : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,strong) UIColor *bgColor;\n@end\n\n\n//ViewController\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self loadViewOtherMVC];\n}\n//变种MVC 把View和Model建立起连接\n//等以后更新view数据只需要 view.model = item;Controllr少了许多代码\n- (void)loadViewOtherMVC{\n    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];\n    FYItemModel *item=[[FYItemModel alloc]init];\n    item.name = @\"校长来了\";\n    item.bgColor = [UIColor redColor];\n    view.model = item;\n    [self.view addSubview:view];\n}\n@end\n```\n\n可以看到`model`组装到`view`展示内容是在`view`实现的，外部不知道细节，只需要将`model`给`view`即可，但是只能传输过来`model`或者他子类，业务更改的话，需要修改`view`的内部`model`才能将变更过的数据重新展示出来。\n\n想要监听view的点击事件来做一些操作，那么我们可以使用代理和`block`,这里`id`是实现了`FYAppleViewProtocol`协议的，`weak`修饰防止循环引用，使用协议实现了和`VC`的通信。\n\n```\n@class FYAppleView;\n@protocol FYAppleViewProtocol <NSObject>\n- (void)FYAppleViewDidClick:(FYAppleView*)view;\n@end\n\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n@property (nonatomic,weak) id<FYAppleViewProtocol> delegate;\n@property (nonatomic,strong) FYItemModel *model;\n@end\n```\n\n稍作更改还是`apple-MVC`\n\n```\n// .h\n@class FYItemModel;\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n@end\n```\n将`View`属性`nameLabel`暴露出来，但是不允许外界进行更改，去掉`model`则是`MVC`。\n\n\n\n###  MVP\n\n`MVP`和`MVC`很像，只是将`VC`换成了`Presenter`，`vc`和`Present`做的事情基本一致，将`view`和`Model`通信改到了都和`Presenter`通信。\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c65f39c348e3e9?w=610&h=215&f=png&s=12793)\n代码\n\n```\n//MVP\n//.h\n@interface FYNewsPresenter : NSObject\n\n@property (nonatomic,weak) UIViewController *vc;\n//初始化\n- (void)setup;\n@end\n\n.m\n#import \"FYNewsPresenter.h\"\n@interface FYNewsPresenter()<FYAppleViewProtocol>\n@end\n\n@implementation FYNewsPresenter\n- (void)setup{\n\tFYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];\n\tFYItemModel *item=[[FYItemModel alloc]init];\n\titem.name = @\"校长来了\";\n\titem.bgColor = [UIColor redColor];\n\tview.model = item;\n\t[self.vc.view addSubview:view];\n}\n- (void)FYAppleViewDidClick:(FYAppleView *)view{\n\tNSLog(@\"点击了我\");\n}\n@end\n\n\n//VC中\n@interface ViewController ()\n@property (nonatomic,strong) FYNewsPresenter *presenter;\n@end\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\t_presenter=[FYNewsPresenter new];\n\t_presenter.vc = self;\n\t[_presenter setup];\n}\n@end\n```\n再次对`VC`进行了瘦身，将更多的业务逻辑搬到了`FYNewsPresenter`处理，其实全部搬过去，意义比不大，`FYNewsPresenter`也会臃肿，也会出现和`VC`一样的困惑。\n\n###  MVVM\n`MVVM`是将`FYNewsPresenter`都搬到了`FYNewsViewModel`中，然后对`FYNewsViewModel`和`View`进行了一个双向绑定，双向绑定可以使用代理，`block`或者`KVO`实现。\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c6603450d271bb?w=642&h=237&f=png&s=13181)\n代码实现\n\n```\n@interface FYNewsViewModel : NSObject\n\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,strong) UIColor *bgColor;\n\n@property (nonatomic,weak) UIViewController *vc;\n\n- (instancetype)initWithController:(UIViewController *)vc;\n@end\n\n\n\n#import \"FYNewsViewModel.h\"\n@interface FYNewsViewModel()<FYAppleViewProtocol>\n\n\n@end\n@implementation FYNewsViewModel\n- (instancetype)initWithController:(UIViewController *)vc{\n    if (self =[super init]) {\n        self.vc = vc;\n        \n        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];\n        //    view.model = item;\n        view.delegate = self;\n        view.viewModel = self; //建立kvo\n        \n        view.backgroundColor = [UIColor lightGrayColor];\n        [vc.view addSubview:view];\n        \n        \n        \n        FYItemModel *item=[[FYItemModel alloc]init];\n        item.name = @\"校长来了\";\n        item.bgColor = [UIColor redColor];\n        \n        self.name = item.name;\n        self.bgColor = item.bgColor;\n    }\n    return self;\n}\n- (void)FYAppleViewDidClick:(FYAppleView *)view{\n\tNSLog(@\"点击了我\");\n}\n@end\n```\n在`view`实现\n\n```\n@class FYAppleView,FYNewsViewModel;\n@protocol FYAppleViewProtocol <NSObject>\n\n- (void)FYAppleViewDidClick:(FYAppleView*)view;\n\n@end\n\n@class FYItemModel;\n\n@interface FYAppleView : UIView\n@property (nonatomic,strong,readonly) UILabel *nameLabel;\n\n@property (nonatomic,weak) id<FYAppleViewProtocol> delegate;\n@property (nonatomic,weak) FYNewsViewModel *viewModel;\n\n@property (nonatomic,strong) FYItemModel *model;\n@end\n\n\n@interface FYAppleView()\n@property (nonatomic,strong) UILabel *nameLabel;\n@end\n@implementation FYAppleView\n-(instancetype)initWithFrame:(CGRect)frame{\n    if (self =[super initWithFrame:frame]) {\n        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];\n        [self addSubview:_nameLabel];\n    }\n    return self;\n}\n/*\n  mvc的变种\n */\n- (void)setModel:(FYItemModel *)model{\n    _model = model;\n    _nameLabel.textColor = model.bgColor;\n    _nameLabel.text = model.name;\n\t\n \n}\n\n- (void)setViewModel:(FYNewsViewModel *)viewModel{\n    _viewModel = viewModel;\n   [_viewModel addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];\n   //使用FBKVO实现 或者自己使用KVO实现\n//    __weak typeof(self) waekSelf = self;\n//    [self.KVOController observe:viewModel keyPath:@\"name\"\n//                        options:NSKeyValueObservingOptionNew\n//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary<NSKeyValueChangeKey,id> * _Nonnull change) {\n//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];\n//    }];\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n    if ([keyPath isEqualToString:@\"name\"]) {\n        self.nameLabel.text = change[NSKeyValueChangeNewKey];\n    }\n}\n\n//添加点击事件\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tif ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) {\n\t\t[self.delegate FYAppleViewDidClick:self];\n\t}\n}\n\n-(void)dealloc{\n    [_viewModel removeObserver:self\n                    forKeyPath:@\"name\"];\n}\n@end\n```\n使用`KVO`或者`FBKVO`或者`RAC`都是可以的，本章节例子给出了`FBKVO`或者自己使用`KVO`的实现。\n\n\n\n### 分层设计\n三层架构：\n> 三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层\n\n- 目的: “高内聚，低耦合”的思想 \n\n- 优点: 降低层与层之间的依赖 标准化 \n\n- 缺点: 系统架构复杂，不适合小型项目\n\n#### 三层原理\n> 3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。\n所谓三层体系结构，是在客户端与数据库之间加入了一个`中间层`，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有`B/S`应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。\n\n> 三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过`COM/DCOM`通讯与中间层建立连接，再经由中间层与数据库进行交互。\n\n> 三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用`COM/DCOM`通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互\n\n`MVC`、`MVVM`、`MVP`属于界面层，\n当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了\n\n分层之后，得到了一个三层架构或四层架构\n\n![三层架构](https://user-gold-cdn.xitu.io/2019/8/6/16c6623d82034790?w=536&h=281&f=png&s=23627)\n\n数据层也可以分为两层，分为网络请求和db层。\n\n![四层架构](https://user-gold-cdn.xitu.io/2019/8/6/16c6624a552bd892?w=568&h=370&f=png&s=29291)\n\n具体在工程中我们通常这样体现\n\n![](https://user-gold-cdn.xitu.io/2019/8/6/16c66313fbdd90a3?w=270&h=432&f=png&s=24528)\n\n在`vc`中获取数据\n\n```\n@interface ViewController ()\n@property (nonatomic,strong) FYDBPool *db;\n@property (nonatomic,strong) FYHttpPool *http;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t//当有业务层\n\t[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) {\n\t\t\n\t} fail:^{\n\t\t\n\t}];\n\t//当没有有业务层\n\tself.db=[FYDBPool new];\n\tself.http=[FYHttpPool new];\n\t[self.db loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\tif ([ret count]) {\n\t\t\tNSLog(@\"数据获取成功\");\n\t\t}else{\n\t\t\t[self.http loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\t\t\tNSLog(@\"数据获取成功\");\n\t\t\t} fail:^{\n\t\t\t\tNSLog(@\"数据获取失败\");\n\t\t\t}];\n\t\t}\n\t} fail:^{\n\t\t[self.http loadNewsWithInfo:@{} success:^(NSArray * _Nonnull ret) {\n\t\t\tNSLog(@\"数据获取成功\");\n\t\t} fail:^{\n\t\t\tNSLog(@\"数据获取失败\");\n\t\t}];\n\t}];\n}\n\n```\n在业务层\n\n```\n@interface FYNewsService ()\n@property (nonatomic,strong) FYDBPool *db;\n@property (nonatomic,strong) FYHttpPool *http;\n\n@end\n@implementation FYNewsService\n-(instancetype)init{\n\tif (self = [super init]) {\n\t\tself.db=[FYDBPool new];\n\t\tself.http=[FYHttpPool new];\n\t}\n\treturn self;\n}\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock{\n\t[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\tif ([ret count]) {\n\t\t\tsuccblock(ret);\n\t\t}else{\n\t\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\t\t\tsuccblock(ret);\n\t\t\t} fail:failBlock];\n\t\t}\n\t} fail:^{\n\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) {\n\t\t\tsuccblock(ret);\n\t\t} fail:failBlock];\n\t}];\n}\n@end\n```\n在db层\n\n```\ntypedef void(^succcessCallback)(NSArray *);\n@interface FYDBPool : NSObject\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock;\n@end\n```\n在网络请求层\n\n```\ntypedef void(^succcessCallback)(NSArray *);\n@interface FYHttpPool : NSObject\n- (void)loadNewsWithInfo:(NSDictionary *)info\n\t\t\t\t success:(succcessCallback )succblock\n\t\t\t\t\tfail:(dispatch_block_t)failBlock;\n@end\n```\n\n分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或`db`，当`db`足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。\n不同的人来处理不同的分层，相互影响也比较小，降低耦合。\n\n\n**当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。**\n\n### 后记\n优雅的代码总是伴随着各种传统设计模式的搭配\n#### 设计模式\n> 设计模式（Design Pattern）\n是一套被反复使用、代码设计经验的总结\n使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性\n一般与编程语言无关，是一套比较成熟的编程思想\n\n设计模式可以分为三大类\n1. 创建型模式：对象实例化的模式，用于解耦对象的实例化过程\n单例模式、工厂方法模式，等等\n\n2. 结构型模式：把类或对象结合在一起形成一个更大的结构\n代理模式、适配器模式、组合模式、装饰模式，等等\n\n3. 行为型模式：类或对象之间如何交互，及划分责任和算法\n观察者模式、命令模式、责任链模式，等等\n\n\n### 总结\n- 适合项目的才是最好的架构\n\n### 资料参考\n- [三层架构](https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84)\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&h=268&f=jpeg&s=27083)","slug":"iOS底层原理 MVC、MVP、MVVM、分层设计浅谈 — (13)","published":1,"updated":"2019-12-03T03:15:52.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2h000i9zskqk03vx1p","content":"<p>这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到</p>\n<blockquote>\n<ol>\n<li>MVC</li>\n<li>MVC变种</li>\n<li>MVP</li>\n<li>MVVM</li>\n<li>分层设计的优缺点</li>\n</ol>\n</blockquote>\n<p>没有最好的架构，只有最适合业务的架构。</p>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>苹果版本的<code>MVC</code>是<code>Model</code>和<code>VC</code>和交互，<code>VC</code>和<code>View</code>交互</p>\n<ul>\n<li><p>优点：<code>View</code>和<code>Model</code>可以重复利用，可以独立使用</p>\n</li>\n<li><p>缺点：<code>Controller</code>的代码过于臃肿</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65c373454277a?w=801&amp;h=274&amp;f=png&amp;s=17358\" alt=\"\"></p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    [self loadData];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)loadData&#123;</div><div class=\"line\">    self.data=[NSMutableArray array];</div><div class=\"line\">    for (int i = 0; i &lt; 20; i ++) &#123;</div><div class=\"line\">        FYNews *item=[FYNews new];</div><div class=\"line\">        item.title =[NSString stringWithFormat:@&quot;title-%d&quot;,i];</div><div class=\"line\">        item.name =[NSString stringWithFormat:@&quot;name-%d&quot;,i];</div><div class=\"line\">        [self.data addObject:item];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class=\"line\">    return self.data.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</div><div class=\"line\">    </div><div class=\"line\">    // Configure the cell...</div><div class=\"line\">    FYNews *item =[self.data objectAtIndex:indexPath.row];</div><div class=\"line\">    cell.detailTextLabel.text =item.title;</div><div class=\"line\">    cell.textLabel.text = item.name;</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//model</div><div class=\"line\"></div><div class=\"line\">@interface FYNews : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *title;</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这里是<code>VC</code>中组装了<code>tableview</code>，<code>model</code>的数据在<code>VC</code>中在<code>view</code>中显示出来，当需要另外的数据的时候，只需要将<code>model</code>改成需要的<code>model</code>而无需更改<code>tableview</code>的代码兼容性较好。</p>\n<h3 id=\"MVC变种\"><a href=\"#MVC变种\" class=\"headerlink\" title=\"MVC变种\"></a>MVC变种</h3><p><code>MVC</code>变种，其实就是将<code>model</code>和<code>view</code>建立了联系，<code>view</code>依据<code>Model</code>来展示数据，<code>VC</code>组装<code>Model</code>，组装展示是在<code>view</code>中实现。</p>\n<ul>\n<li><p>优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现</p>\n</li>\n<li><p>缺点：view依赖于Model</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65cb8ad888abf?w=735&amp;h=364&amp;f=png&amp;s=25874\" alt=\"\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">//.h</div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//.m</div><div class=\"line\">@interface FYAppleView()</div><div class=\"line\">@property (nonatomic,strong) UILabel *nameLabel;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYAppleView</div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class=\"line\">    if (self =[super initWithFrame:frame]) &#123;</div><div class=\"line\">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">        [self addSubview:_nameLabel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">/*</div><div class=\"line\">  mvc的变种</div><div class=\"line\"> */</div><div class=\"line\">- (void)setModel:(FYItemModel *)model&#123;</div><div class=\"line\">    _model = model;</div><div class=\"line\">    _nameLabel.textColor = model.bgColor;</div><div class=\"line\">    _nameLabel.text = model.name;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//FYItemModel</div><div class=\"line\">@interface FYItemModel : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,strong) UIColor *bgColor;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//ViewController</div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    [self loadViewOtherMVC];</div><div class=\"line\">&#125;</div><div class=\"line\">//变种MVC 把View和Model建立起连接</div><div class=\"line\">//等以后更新view数据只需要 view.model = item;Controllr少了许多代码</div><div class=\"line\">- (void)loadViewOtherMVC&#123;</div><div class=\"line\">    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class=\"line\">    FYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">    item.name = @&quot;校长来了&quot;;</div><div class=\"line\">    item.bgColor = [UIColor redColor];</div><div class=\"line\">    view.model = item;</div><div class=\"line\">    [self.view addSubview:view];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>可以看到<code>model</code>组装到<code>view</code>展示内容是在<code>view</code>实现的，外部不知道细节，只需要将<code>model</code>给<code>view</code>即可，但是只能传输过来<code>model</code>或者他子类，业务更改的话，需要修改<code>view</code>的内部<code>model</code>才能将变更过的数据重新展示出来。</p>\n<p>想要监听view的点击事件来做一些操作，那么我们可以使用代理和<code>block</code>,这里<code>id</code>是实现了<code>FYAppleViewProtocol</code>协议的，<code>weak</code>修饰防止循环引用，使用协议实现了和<code>VC</code>的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@class FYAppleView;</div><div class=\"line\">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>稍作更改还是<code>apple-MVC</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// .h</div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>将<code>View</code>属性<code>nameLabel</code>暴露出来，但是不允许外界进行更改，去掉<code>model</code>则是<code>MVC</code>。</p>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p><code>MVP</code>和<code>MVC</code>很像，只是将<code>VC</code>换成了<code>Presenter</code>，<code>vc</code>和<code>Present</code>做的事情基本一致，将<code>view</code>和<code>Model</code>通信改到了都和<code>Presenter</code>通信。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65f39c348e3e9?w=610&amp;h=215&amp;f=png&amp;s=12793\" alt=\"\"><br>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">//MVP</div><div class=\"line\">//.h</div><div class=\"line\">@interface FYNewsPresenter : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) UIViewController *vc;</div><div class=\"line\">//初始化</div><div class=\"line\">- (void)setup;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">.m</div><div class=\"line\">#import &quot;FYNewsPresenter.h&quot;</div><div class=\"line\">@interface FYNewsPresenter()&lt;FYAppleViewProtocol&gt;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYNewsPresenter</div><div class=\"line\">- (void)setup&#123;</div><div class=\"line\">\tFYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class=\"line\">\tFYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">\titem.name = @&quot;校长来了&quot;;</div><div class=\"line\">\titem.bgColor = [UIColor redColor];</div><div class=\"line\">\tview.model = item;</div><div class=\"line\">\t[self.vc.view addSubview:view];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class=\"line\">\tNSLog(@&quot;点击了我&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//VC中</div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong) FYNewsPresenter *presenter;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">\t_presenter=[FYNewsPresenter new];</div><div class=\"line\">\t_presenter.vc = self;</div><div class=\"line\">\t[_presenter setup];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>再次对<code>VC</code>进行了瘦身，将更多的业务逻辑搬到了<code>FYNewsPresenter</code>处理，其实全部搬过去，意义比不大，<code>FYNewsPresenter</code>也会臃肿，也会出现和<code>VC</code>一样的困惑。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p><code>MVVM</code>是将<code>FYNewsPresenter</code>都搬到了<code>FYNewsViewModel</code>中，然后对<code>FYNewsViewModel</code>和<code>View</code>进行了一个双向绑定，双向绑定可以使用代理，<code>block</code>或者<code>KVO</code>实现。<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6603450d271bb?w=642&amp;h=237&amp;f=png&amp;s=13181\" alt=\"\"><br>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNewsViewModel : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,strong) UIColor *bgColor;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) UIViewController *vc;</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithController:(UIViewController *)vc;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;FYNewsViewModel.h&quot;</div><div class=\"line\">@interface FYNewsViewModel()&lt;FYAppleViewProtocol&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYNewsViewModel</div><div class=\"line\">- (instancetype)initWithController:(UIViewController *)vc&#123;</div><div class=\"line\">    if (self =[super init]) &#123;</div><div class=\"line\">        self.vc = vc;</div><div class=\"line\">        </div><div class=\"line\">        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];</div><div class=\"line\">        //    view.model = item;</div><div class=\"line\">        view.delegate = self;</div><div class=\"line\">        view.viewModel = self; //建立kvo</div><div class=\"line\">        </div><div class=\"line\">        view.backgroundColor = [UIColor lightGrayColor];</div><div class=\"line\">        [vc.view addSubview:view];</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">        FYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">        item.name = @&quot;校长来了&quot;;</div><div class=\"line\">        item.bgColor = [UIColor redColor];</div><div class=\"line\">        </div><div class=\"line\">        self.name = item.name;</div><div class=\"line\">        self.bgColor = item.bgColor;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class=\"line\">\tNSLog(@&quot;点击了我&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在<code>view</code>实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">@class FYAppleView,FYNewsViewModel;</div><div class=\"line\">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@class FYItemModel;</div><div class=\"line\"></div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class=\"line\">@property (nonatomic,weak) FYNewsViewModel *viewModel;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@interface FYAppleView()</div><div class=\"line\">@property (nonatomic,strong) UILabel *nameLabel;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYAppleView</div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class=\"line\">    if (self =[super initWithFrame:frame]) &#123;</div><div class=\"line\">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">        [self addSubview:_nameLabel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">/*</div><div class=\"line\">  mvc的变种</div><div class=\"line\"> */</div><div class=\"line\">- (void)setModel:(FYItemModel *)model&#123;</div><div class=\"line\">    _model = model;</div><div class=\"line\">    _nameLabel.textColor = model.bgColor;</div><div class=\"line\">    _nameLabel.text = model.name;</div><div class=\"line\">\t</div><div class=\"line\"> </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setViewModel:(FYNewsViewModel *)viewModel&#123;</div><div class=\"line\">    _viewModel = viewModel;</div><div class=\"line\">   [_viewModel addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class=\"line\">   //使用FBKVO实现 或者自己使用KVO实现</div><div class=\"line\">//    __weak typeof(self) waekSelf = self;</div><div class=\"line\">//    [self.KVOController observe:viewModel keyPath:@&quot;name&quot;</div><div class=\"line\">//                        options:NSKeyValueObservingOptionNew</div><div class=\"line\">//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123;</div><div class=\"line\">//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class=\"line\">//    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</div><div class=\"line\">        self.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//添加点击事件</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tif ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) &#123;</div><div class=\"line\">\t\t[self.delegate FYAppleViewDidClick:self];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">    [_viewModel removeObserver:self</div><div class=\"line\">                    forKeyPath:@&quot;name&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>使用<code>KVO</code>或者<code>FBKVO</code>或者<code>RAC</code>都是可以的，本章节例子给出了<code>FBKVO</code>或者自己使用<code>KVO</code>的实现。</p>\n<h3 id=\"分层设计\"><a href=\"#分层设计\" class=\"headerlink\" title=\"分层设计\"></a>分层设计</h3><p>三层架构：</p>\n<blockquote>\n<p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层</p>\n</blockquote>\n<ul>\n<li><p>目的: “高内聚，低耦合”的思想 </p>\n</li>\n<li><p>优点: 降低层与层之间的依赖 标准化 </p>\n</li>\n<li><p>缺点: 系统架构复杂，不适合小型项目</p>\n</li>\n</ul>\n<h4 id=\"三层原理\"><a href=\"#三层原理\" class=\"headerlink\" title=\"三层原理\"></a>三层原理</h4><blockquote>\n<p>3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。<br>所谓三层体系结构，是在客户端与数据库之间加入了一个<code>中间层</code>，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有<code>B/S</code>应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。</p>\n<p>三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过<code>COM/DCOM</code>通讯与中间层建立连接，再经由中间层与数据库进行交互。</p>\n<p>三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用<code>COM/DCOM</code>通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互</p>\n</blockquote>\n<p><code>MVC</code>、<code>MVVM</code>、<code>MVP</code>属于界面层，<br>当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了</p>\n<p>分层之后，得到了一个三层架构或四层架构</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6623d82034790?w=536&amp;h=281&amp;f=png&amp;s=23627\" alt=\"三层架构\"></p>\n<p>数据层也可以分为两层，分为网络请求和db层。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6624a552bd892?w=568&amp;h=370&amp;f=png&amp;s=29291\" alt=\"四层架构\"></p>\n<p>具体在工程中我们通常这样体现</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c66313fbdd90a3?w=270&amp;h=432&amp;f=png&amp;s=24528\" alt=\"\"></p>\n<p>在<code>vc</code>中获取数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong) FYDBPool *db;</div><div class=\"line\">@property (nonatomic,strong) FYHttpPool *http;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">\t//当有业务层</div><div class=\"line\">\t[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) &#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;];</div><div class=\"line\">\t//当没有有业务层</div><div class=\"line\">\tself.db=[FYDBPool new];</div><div class=\"line\">\tself.http=[FYHttpPool new];</div><div class=\"line\">\t[self.db loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\tif ([ret count]) &#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t\t&#125; fail:^&#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;数据获取失败&quot;);</div><div class=\"line\">\t\t\t&#125;];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t&#125; fail:^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取失败&quot;);</div><div class=\"line\">\t\t&#125;];</div><div class=\"line\">\t&#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在业务层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNewsService ()</div><div class=\"line\">@property (nonatomic,strong) FYDBPool *db;</div><div class=\"line\">@property (nonatomic,strong) FYHttpPool *http;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYNewsService</div><div class=\"line\">-(instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\tself.db=[FYDBPool new];</div><div class=\"line\">\t\tself.http=[FYHttpPool new];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock&#123;</div><div class=\"line\">\t[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\tif ([ret count]) &#123;</div><div class=\"line\">\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t\t&#125; fail:failBlock];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t&#125; fail:failBlock];</div><div class=\"line\">\t&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在db层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^succcessCallback)(NSArray *);</div><div class=\"line\">@interface FYDBPool : NSObject</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在网络请求层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^succcessCallback)(NSArray *);</div><div class=\"line\">@interface FYHttpPool : NSObject</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或<code>db</code>，当<code>db</code>足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。<br>不同的人来处理不同的分层，相互影响也比较小，降低耦合。</p>\n<p><strong>当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。</strong></p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>优雅的代码总是伴随着各种传统设计模式的搭配</p>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><blockquote>\n<p>设计模式（Design Pattern）<br>是一套被反复使用、代码设计经验的总结<br>使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性<br>一般与编程语言无关，是一套比较成熟的编程思想</p>\n</blockquote>\n<p>设计模式可以分为三大类</p>\n<ol>\n<li><p>创建型模式：对象实例化的模式，用于解耦对象的实例化过程<br>单例模式、工厂方法模式，等等</p>\n</li>\n<li><p>结构型模式：把类或对象结合在一起形成一个更大的结构<br>代理模式、适配器模式、组合模式、装饰模式，等等</p>\n</li>\n<li><p>行为型模式：类或对象之间如何交互，及划分责任和算法<br>观察者模式、命令模式、责任链模式，等等</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>适合项目的才是最好的架构</li>\n</ul>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"external\">三层架构</a><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&amp;h=268&amp;f=jpeg&amp;s=27083\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇文章主要讲解关于架构的一些思考，通过这篇文章你将了解到</p>\n<blockquote>\n<ol>\n<li>MVC</li>\n<li>MVC变种</li>\n<li>MVP</li>\n<li>MVVM</li>\n<li>分层设计的优缺点</li>\n</ol>\n</blockquote>\n<p>没有最好的架构，只有最适合业务的架构。</p>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>苹果版本的<code>MVC</code>是<code>Model</code>和<code>VC</code>和交互，<code>VC</code>和<code>View</code>交互</p>\n<ul>\n<li><p>优点：<code>View</code>和<code>Model</code>可以重复利用，可以独立使用</p>\n</li>\n<li><p>缺点：<code>Controller</code>的代码过于臃肿</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65c373454277a?w=801&amp;h=274&amp;f=png&amp;s=17358\" alt=\"\"></p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    [self loadData];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)loadData&#123;</div><div class=\"line\">    self.data=[NSMutableArray array];</div><div class=\"line\">    for (int i = 0; i &lt; 20; i ++) &#123;</div><div class=\"line\">        FYNews *item=[FYNews new];</div><div class=\"line\">        item.title =[NSString stringWithFormat:@&quot;title-%d&quot;,i];</div><div class=\"line\">        item.name =[NSString stringWithFormat:@&quot;name-%d&quot;,i];</div><div class=\"line\">        [self.data addObject:item];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class=\"line\">    return self.data.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</div><div class=\"line\">    </div><div class=\"line\">    // Configure the cell...</div><div class=\"line\">    FYNews *item =[self.data objectAtIndex:indexPath.row];</div><div class=\"line\">    cell.detailTextLabel.text =item.title;</div><div class=\"line\">    cell.textLabel.text = item.name;</div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//model</div><div class=\"line\"></div><div class=\"line\">@interface FYNews : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *title;</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这里是<code>VC</code>中组装了<code>tableview</code>，<code>model</code>的数据在<code>VC</code>中在<code>view</code>中显示出来，当需要另外的数据的时候，只需要将<code>model</code>改成需要的<code>model</code>而无需更改<code>tableview</code>的代码兼容性较好。</p>\n<h3 id=\"MVC变种\"><a href=\"#MVC变种\" class=\"headerlink\" title=\"MVC变种\"></a>MVC变种</h3><p><code>MVC</code>变种，其实就是将<code>model</code>和<code>view</code>建立了联系，<code>view</code>依据<code>Model</code>来展示数据，<code>VC</code>组装<code>Model</code>，组装展示是在<code>view</code>中实现。</p>\n<ul>\n<li><p>优点：对Controller进行瘦身，将View的内部细节封装起来了，外界不知道View内部的具体实现</p>\n</li>\n<li><p>缺点：view依赖于Model</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65cb8ad888abf?w=735&amp;h=364&amp;f=png&amp;s=25874\" alt=\"\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">//.h</div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//.m</div><div class=\"line\">@interface FYAppleView()</div><div class=\"line\">@property (nonatomic,strong) UILabel *nameLabel;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYAppleView</div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class=\"line\">    if (self =[super initWithFrame:frame]) &#123;</div><div class=\"line\">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">        [self addSubview:_nameLabel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">/*</div><div class=\"line\">  mvc的变种</div><div class=\"line\"> */</div><div class=\"line\">- (void)setModel:(FYItemModel *)model&#123;</div><div class=\"line\">    _model = model;</div><div class=\"line\">    _nameLabel.textColor = model.bgColor;</div><div class=\"line\">    _nameLabel.text = model.name;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//FYItemModel</div><div class=\"line\">@interface FYItemModel : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,strong) UIColor *bgColor;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//ViewController</div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    [self loadViewOtherMVC];</div><div class=\"line\">&#125;</div><div class=\"line\">//变种MVC 把View和Model建立起连接</div><div class=\"line\">//等以后更新view数据只需要 view.model = item;Controllr少了许多代码</div><div class=\"line\">- (void)loadViewOtherMVC&#123;</div><div class=\"line\">    FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class=\"line\">    FYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">    item.name = @&quot;校长来了&quot;;</div><div class=\"line\">    item.bgColor = [UIColor redColor];</div><div class=\"line\">    view.model = item;</div><div class=\"line\">    [self.view addSubview:view];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>可以看到<code>model</code>组装到<code>view</code>展示内容是在<code>view</code>实现的，外部不知道细节，只需要将<code>model</code>给<code>view</code>即可，但是只能传输过来<code>model</code>或者他子类，业务更改的话，需要修改<code>view</code>的内部<code>model</code>才能将变更过的数据重新展示出来。</p>\n<p>想要监听view的点击事件来做一些操作，那么我们可以使用代理和<code>block</code>,这里<code>id</code>是实现了<code>FYAppleViewProtocol</code>协议的，<code>weak</code>修饰防止循环引用，使用协议实现了和<code>VC</code>的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@class FYAppleView;</div><div class=\"line\">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>稍作更改还是<code>apple-MVC</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// .h</div><div class=\"line\">@class FYItemModel;</div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>将<code>View</code>属性<code>nameLabel</code>暴露出来，但是不允许外界进行更改，去掉<code>model</code>则是<code>MVC</code>。</p>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p><code>MVP</code>和<code>MVC</code>很像，只是将<code>VC</code>换成了<code>Presenter</code>，<code>vc</code>和<code>Present</code>做的事情基本一致，将<code>view</code>和<code>Model</code>通信改到了都和<code>Presenter</code>通信。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c65f39c348e3e9?w=610&amp;h=215&amp;f=png&amp;s=12793\" alt=\"\"><br>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">//MVP</div><div class=\"line\">//.h</div><div class=\"line\">@interface FYNewsPresenter : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) UIViewController *vc;</div><div class=\"line\">//初始化</div><div class=\"line\">- (void)setup;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">.m</div><div class=\"line\">#import &quot;FYNewsPresenter.h&quot;</div><div class=\"line\">@interface FYNewsPresenter()&lt;FYAppleViewProtocol&gt;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYNewsPresenter</div><div class=\"line\">- (void)setup&#123;</div><div class=\"line\">\tFYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(200, 200, 100, 30)];</div><div class=\"line\">\tFYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">\titem.name = @&quot;校长来了&quot;;</div><div class=\"line\">\titem.bgColor = [UIColor redColor];</div><div class=\"line\">\tview.model = item;</div><div class=\"line\">\t[self.vc.view addSubview:view];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class=\"line\">\tNSLog(@&quot;点击了我&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//VC中</div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong) FYNewsPresenter *presenter;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">\t_presenter=[FYNewsPresenter new];</div><div class=\"line\">\t_presenter.vc = self;</div><div class=\"line\">\t[_presenter setup];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>再次对<code>VC</code>进行了瘦身，将更多的业务逻辑搬到了<code>FYNewsPresenter</code>处理，其实全部搬过去，意义比不大，<code>FYNewsPresenter</code>也会臃肿，也会出现和<code>VC</code>一样的困惑。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p><code>MVVM</code>是将<code>FYNewsPresenter</code>都搬到了<code>FYNewsViewModel</code>中，然后对<code>FYNewsViewModel</code>和<code>View</code>进行了一个双向绑定，双向绑定可以使用代理，<code>block</code>或者<code>KVO</code>实现。<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6603450d271bb?w=642&amp;h=237&amp;f=png&amp;s=13181\" alt=\"\"><br>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNewsViewModel : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,strong) UIColor *bgColor;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) UIViewController *vc;</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithController:(UIViewController *)vc;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;FYNewsViewModel.h&quot;</div><div class=\"line\">@interface FYNewsViewModel()&lt;FYAppleViewProtocol&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYNewsViewModel</div><div class=\"line\">- (instancetype)initWithController:(UIViewController *)vc&#123;</div><div class=\"line\">    if (self =[super init]) &#123;</div><div class=\"line\">        self.vc = vc;</div><div class=\"line\">        </div><div class=\"line\">        FYAppleView * view =[[FYAppleView alloc]initWithFrame:CGRectMake(100, 200, 100, 50)];</div><div class=\"line\">        //    view.model = item;</div><div class=\"line\">        view.delegate = self;</div><div class=\"line\">        view.viewModel = self; //建立kvo</div><div class=\"line\">        </div><div class=\"line\">        view.backgroundColor = [UIColor lightGrayColor];</div><div class=\"line\">        [vc.view addSubview:view];</div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">        </div><div class=\"line\">        FYItemModel *item=[[FYItemModel alloc]init];</div><div class=\"line\">        item.name = @&quot;校长来了&quot;;</div><div class=\"line\">        item.bgColor = [UIColor redColor];</div><div class=\"line\">        </div><div class=\"line\">        self.name = item.name;</div><div class=\"line\">        self.bgColor = item.bgColor;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView *)view&#123;</div><div class=\"line\">\tNSLog(@&quot;点击了我&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在<code>view</code>实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">@class FYAppleView,FYNewsViewModel;</div><div class=\"line\">@protocol FYAppleViewProtocol &lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">- (void)FYAppleViewDidClick:(FYAppleView*)view;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@class FYItemModel;</div><div class=\"line\"></div><div class=\"line\">@interface FYAppleView : UIView</div><div class=\"line\">@property (nonatomic,strong,readonly) UILabel *nameLabel;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,weak) id&lt;FYAppleViewProtocol&gt; delegate;</div><div class=\"line\">@property (nonatomic,weak) FYNewsViewModel *viewModel;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,strong) FYItemModel *model;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@interface FYAppleView()</div><div class=\"line\">@property (nonatomic,strong) UILabel *nameLabel;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYAppleView</div><div class=\"line\">-(instancetype)initWithFrame:(CGRect)frame&#123;</div><div class=\"line\">    if (self =[super initWithFrame:frame]) &#123;</div><div class=\"line\">        _nameLabel=[[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 30)];</div><div class=\"line\">        [self addSubview:_nameLabel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">/*</div><div class=\"line\">  mvc的变种</div><div class=\"line\"> */</div><div class=\"line\">- (void)setModel:(FYItemModel *)model&#123;</div><div class=\"line\">    _model = model;</div><div class=\"line\">    _nameLabel.textColor = model.bgColor;</div><div class=\"line\">    _nameLabel.text = model.name;</div><div class=\"line\">\t</div><div class=\"line\"> </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setViewModel:(FYNewsViewModel *)viewModel&#123;</div><div class=\"line\">    _viewModel = viewModel;</div><div class=\"line\">   [_viewModel addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class=\"line\">   //使用FBKVO实现 或者自己使用KVO实现</div><div class=\"line\">//    __weak typeof(self) waekSelf = self;</div><div class=\"line\">//    [self.KVOController observe:viewModel keyPath:@&quot;name&quot;</div><div class=\"line\">//                        options:NSKeyValueObservingOptionNew</div><div class=\"line\">//                          block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) &#123;</div><div class=\"line\">//        waekSelf.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class=\"line\">//    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</div><div class=\"line\">        self.nameLabel.text = change[NSKeyValueChangeNewKey];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//添加点击事件</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tif ([self.delegate respondsToSelector:@selector(FYAppleViewDidClick:)]) &#123;</div><div class=\"line\">\t\t[self.delegate FYAppleViewDidClick:self];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">    [_viewModel removeObserver:self</div><div class=\"line\">                    forKeyPath:@&quot;name&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>使用<code>KVO</code>或者<code>FBKVO</code>或者<code>RAC</code>都是可以的，本章节例子给出了<code>FBKVO</code>或者自己使用<code>KVO</code>的实现。</p>\n<h3 id=\"分层设计\"><a href=\"#分层设计\" class=\"headerlink\" title=\"分层设计\"></a>分层设计</h3><p>三层架构：</p>\n<blockquote>\n<p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层</p>\n</blockquote>\n<ul>\n<li><p>目的: “高内聚，低耦合”的思想 </p>\n</li>\n<li><p>优点: 降低层与层之间的依赖 标准化 </p>\n</li>\n<li><p>缺点: 系统架构复杂，不适合小型项目</p>\n</li>\n</ul>\n<h4 id=\"三层原理\"><a href=\"#三层原理\" class=\"headerlink\" title=\"三层原理\"></a>三层原理</h4><blockquote>\n<p>3个层次中，系统主要功能和业务逻辑都在业务逻辑层进行处理。<br>所谓三层体系结构，是在客户端与数据库之间加入了一个<code>中间层</code>，也叫组件层。这里所说的三层体系，不是指物理上的三层，不是简单地放置三台机器就是三层体系结构，也不仅仅有<code>B/S</code>应用才是三层体系结构，三层是指逻辑上的三层，即把这三个层放置到一台机器上。</p>\n<p>三层体系的应用程序将业务规则、数据访问、合法性校验等工作放到了中间层进行处理。通常情况下，客户端不直接与数据库进行交互，而是通过<code>COM/DCOM</code>通讯与中间层建立连接，再经由中间层与数据库进行交互。</p>\n<p>三层架构中主要功能与业务逻辑一般要在业务逻辑层进行信息处理和实现，其中三层体系架构中的客户端和数据库要预设中间层，成为组建层。三层架构中的三层具有一定的逻辑性，即是将三层设置到同一个计算机系统中，把业务协议、合法校验以及数据访问等程序归置到中间层进行信息处理，一般客户端无法和数据库进行数据传输，主要是利用<code>COM/DCOM</code>通讯和中间层构建衔接通道，实现中间层与数据库的数据传输，进而实现客户端与是数据库的交互</p>\n</blockquote>\n<p><code>MVC</code>、<code>MVVM</code>、<code>MVP</code>属于界面层，<br>当业务复杂，网络请求和db操作达到了一个新的高度，界面复杂到需要好多人来做，那么界面、业务、数据需要分层了</p>\n<p>分层之后，得到了一个三层架构或四层架构</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6623d82034790?w=536&amp;h=281&amp;f=png&amp;s=23627\" alt=\"三层架构\"></p>\n<p>数据层也可以分为两层，分为网络请求和db层。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c6624a552bd892?w=568&amp;h=370&amp;f=png&amp;s=29291\" alt=\"四层架构\"></p>\n<p>具体在工程中我们通常这样体现</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/6/16c66313fbdd90a3?w=270&amp;h=432&amp;f=png&amp;s=24528\" alt=\"\"></p>\n<p>在<code>vc</code>中获取数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong) FYDBPool *db;</div><div class=\"line\">@property (nonatomic,strong) FYHttpPool *http;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">\t//当有业务层</div><div class=\"line\">\t[[FYNewsService new] loadNewsWithInfo:nil success:^(NSArray * _Nonnull) &#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;];</div><div class=\"line\">\t//当没有有业务层</div><div class=\"line\">\tself.db=[FYDBPool new];</div><div class=\"line\">\tself.http=[FYHttpPool new];</div><div class=\"line\">\t[self.db loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\tif ([ret count]) &#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t\t&#125; fail:^&#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;数据获取失败&quot;);</div><div class=\"line\">\t\t\t&#125;];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t[self.http loadNewsWithInfo:@&#123;&#125; success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取成功&quot;);</div><div class=\"line\">\t\t&#125; fail:^&#123;</div><div class=\"line\">\t\t\tNSLog(@&quot;数据获取失败&quot;);</div><div class=\"line\">\t\t&#125;];</div><div class=\"line\">\t&#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在业务层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNewsService ()</div><div class=\"line\">@property (nonatomic,strong) FYDBPool *db;</div><div class=\"line\">@property (nonatomic,strong) FYHttpPool *http;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYNewsService</div><div class=\"line\">-(instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\tself.db=[FYDBPool new];</div><div class=\"line\">\t\tself.http=[FYHttpPool new];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock&#123;</div><div class=\"line\">\t[self.db loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\tif ([ret count]) &#123;</div><div class=\"line\">\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t\t&#125; fail:failBlock];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125; fail:^&#123;</div><div class=\"line\">\t\t[self.http loadNewsWithInfo:info success:^(NSArray * _Nonnull ret) &#123;</div><div class=\"line\">\t\t\tsuccblock(ret);</div><div class=\"line\">\t\t&#125; fail:failBlock];</div><div class=\"line\">\t&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在db层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^succcessCallback)(NSArray *);</div><div class=\"line\">@interface FYDBPool : NSObject</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>在网络请求层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef void(^succcessCallback)(NSArray *);</div><div class=\"line\">@interface FYHttpPool : NSObject</div><div class=\"line\">- (void)loadNewsWithInfo:(NSDictionary *)info</div><div class=\"line\">\t\t\t\t success:(succcessCallback )succblock</div><div class=\"line\">\t\t\t\t\tfail:(dispatch_block_t)failBlock;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>分层目的是瘦身，逻辑清晰，业务清晰，降低耦合，当某一块足够复杂时候，都可以进行分层，不局限于网络或<code>db</code>，当<code>db</code>足够复杂，也需要进行一个分层来解决复杂调用和处理的问题。<br>不同的人来处理不同的分层，相互影响也比较小，降低耦合。</p>\n<p><strong>当逻辑层足够完善，则UI层如何变动都不需要更改逻辑层。</strong></p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>优雅的代码总是伴随着各种传统设计模式的搭配</p>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><blockquote>\n<p>设计模式（Design Pattern）<br>是一套被反复使用、代码设计经验的总结<br>使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性<br>一般与编程语言无关，是一套比较成熟的编程思想</p>\n</blockquote>\n<p>设计模式可以分为三大类</p>\n<ol>\n<li><p>创建型模式：对象实例化的模式，用于解耦对象的实例化过程<br>单例模式、工厂方法模式，等等</p>\n</li>\n<li><p>结构型模式：把类或对象结合在一起形成一个更大的结构<br>代理模式、适配器模式、组合模式、装饰模式，等等</p>\n</li>\n<li><p>行为型模式：类或对象之间如何交互，及划分责任和算法<br>观察者模式、命令模式、责任链模式，等等</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>适合项目的才是最好的架构</li>\n</ul>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"external\">三层架构</a><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/8/16c71b57f7f1624a?w=655&amp;h=268&amp;f=jpeg&amp;s=27083\" alt=\"\"></p>\n"},{"title":"iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)","date":"2019-12-01T03:19:58.000Z","_content":"\n使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的`jsonToModel`,`iOS`除了`runtime`还有一个东西的叫做`runloop`，各位看官老爷一定都有了解，那么今天这篇文章初识一下`runloop`。\n\n### 什么是runloop\n简单来讲`runloop`就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了`runloop`，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个`runloop`其实是这样子的\n\n```\nint ret = 0;\ndo {\n    //睡眠中等待消息\n    int messgae = sleep_and_wait();\n    //处理消息\n    ret = process_message(messgae);\n} while (ret == 0);\n```\n\n\n### 获取runloop\n\niOS中有两套可以获取runloop代码，一个是`Foundation`、一个是`Core Foundation`。\n`Foundation`其实是对`Core Foundation`的一个封装，\n\n```\nNSRunLoop * runloop1 = [NSRunLoop currentRunLoop];\nNSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];\n\nCFRunLoopRef runloop2= CFRunLoopGetCurrent();\nCFRunLoopRef mainloop2 = CFRunLoopGetMain();\nNSLog(@\"%p %p %p %p\",runloop1,mainloop1,runloop2,mainloop2);\nNSLog(@\"%@\",runloop1);\n//打印\nrunlopp1:0x600001bc58c0 \nmainloop1:0x600001bc58c0 \nrunloop2:0x6000003cc300 \nmainloop1:0x6000003cc300\n\nrunloop1:<CFRunLoop 0x6000003cc300 [0x10b2e9ae8]>.....\n\n```\n`runloop1`和`mainloop1`地址一致，说明当前的`runloop`是`mainrunloop`,`runloop1`作为对象输出的结果其实也是`runloop2`的地址，证明`Foundation runloop`是对`Core Foundation`的一个封装。\n\n`RunLoop`底层我们猜测应该是结构体，我们都了解到其实`OC`就是封装了`c/c++`，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下`runloop`的真是模样，通过`CFRunLoopRef *runloop = CFRunLoopGetMain();`查看`CFRunloop`是`typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;`，我们常用的`CFRunLoopRef`是`__CFRunLoop *`类型的，那么再在[源码(可以下载最新的源码)](https://opensource.apple.com/tarballs/CF/)中搜索一下 `struct __CFRunLoop {`在`runloop.c 637行`如下所示：\n\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* model list 锁 */\n    __CFPort _wakeUpPort;\t\t\t// 接受 CFRunLoopWakeUp的端口\n    Boolean _unused;//是否使用\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread; //线程\n    uint32_t _winthread;//win线程\n    CFMutableSetRef _commonModes; //modes\n    CFMutableSetRef _commonModeItems; //modeItems\n    CFRunLoopModeRef _currentMode; //当前的mode\n    CFMutableSetRef _modes; //所有的modes\n    struct _block_item *_blocks_head; //待执行的block列表头部\n    struct _block_item *_blocks_tail; //待执行的block 尾部\n    CFAbsoluteTime _runTime; //runtime\n    CFAbsoluteTime _sleepTime; //sleeptime\n    CFTypeRef _counterpart; //\n};\n```\n\n经过简化之后：\n\n```\nstruct __CFRunLoop {\n    pthread_t _pthread; //线程\n    CFMutableSetRef _commonModes; //modes\n    CFMutableSetRef _commonModeItems; //modeItems\n    CFRunLoopModeRef _currentMode; //当前的mode\n    CFMutableSetRef _modes; //所有的modes\n}\n```\n\n1. `runloop`中包含一个线程`_pthread`，一一对应的\n2. `CFMutableSetRef _modes`可以有多个`mode`\n3. `CFRunLoopModeRef _currentMode`当前`mode`只能有一个\n\n那么mode里边有什么内容呢？我们猜测他应该和`runloop`类似，在源码中搜索`CFRuntimeBase _base`看到在`runloop.c  line 524`看到具体的内容：\n\n```\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n经过简化之后是：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;//当前mode的名字\n    CFMutableSetRef _sources0;//souces0\n    CFMutableSetRef _sources1;//sources1\n    CFMutableArrayRef _observers;//observers\n    CFMutableArrayRef _timers;//timers\n}\n```\n\n一个`mode`可以有多个`timer`、`souces0`、`souces1`、`observers`、`timers`\n那么使用图更直观的来表示：\n\n![](../images/9-1.png)\n\n一个`runloop`包含多个`mode`，但是同时只能运行一个`mode`，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个`mode`被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。\n#### souces0\n- 触摸事件\n- performSelector:onThread:\n\n测试下点击事件处理源\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);//此处断点\n}\n\n(LLDB) bt //输出当前调用栈\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=\"touchesBegan:withEvent:\", touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2\n    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353\n    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49\n    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869\n    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079\n    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356\n    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232\n    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911\n    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17\n    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243\n    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231\n    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626\n    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65\n    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140\n    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13\n    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1\n    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1\n```\n\n`#1`看到现在是在队列queue = 'com.apple.main-thread'中，`#10` `Runloop`启动，`#9`进入到`__CFRunLoopDoSources0`,最终`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__`调用了`__handleEventQueueInternal`->`[UIApplication sendEvent:]`->`[UIWindow sendEvent:]`->`[UIWindow _sendTouchesForEvent:]`->`[UIResponder touchesBegan:withEvent:]`->`-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=\"touchesBegan:withEvent:\", touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2`，可以看到另外一个知识点，手势的传递是从上往下的，顺序是`UIApplication -> UIWindow -> UIResponder -> ViewController`。\n#### Source1\n- 基于Port的线程间通信\n- 系统事件捕捉\n\n\n#### Timers\n- NSTimer\n- performSelector:withObject:afterDelay:\n\n```\n\ttimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n\tstatic int count = 5;\n\tdispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n\tdispatch_source_set_event_handler(timer, ^{\n\t\tNSLog(@\"-------：%d \\n\",count++);\n\t});\n\tdispatch_resume(timer);\n\t//log\n\t(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33\n    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8\n    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552\n    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249\n    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073\n    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9\n    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310\n    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626\n\t\n```\n\n最终进入函数`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__`调用了[libdispatch](https://opensource.apple.com/tarballs/libdispatch/)的`_dispatch_main_queue_callback_4CF`函数，具体实现有兴趣的大佬可以看下源码的实现。\n\n#### Observers\n- 用于监听RunLoop的状态\n- UI刷新（BeforeWaiting）\n- Autorelease pool（BeforeWaiting）\n\n\n\n\n`Mode`类型都多个,系统暴露在外的就两个，\n\n```\nCF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;\nCF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;\n```\n\n那么这两个Mode都是在什么情况下运行的呢？\n1. `kCFRunLoopDefaultMode（NSDefaultRunLoopMode）`：`App`的默认`Mode`，通常主线程是在这个`Mode`下运行\n2. `UITrackingRunLoopMode`：界面跟踪` Mode`，用于`ScrollView` 追踪触摸滑动，保证界面滑动时不受其他`Mode`影响\n\n进入到某个`Mode`，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的`status`，系统已经准备了`CFRunLoopActivity`来表示当前的状态\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0), //即将进入loop\n    kCFRunLoopBeforeTimers = (1UL << 1),//即将处理timers\n    kCFRunLoopBeforeSources = (1UL << 2), //即将处理sourcs\n    kCFRunLoopBeforeWaiting = (1UL << 5),//即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),//即将从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),//即将退出\n    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态\n};\n```\n\n`1UL`表示无符号长整形数字`1`，再次看到这个`(1UL << 1)`我么猜测用到了[位域或者联合体](https://juejin.im/post/5d2bcf3df265da1b67213d69)，达到省空间的目的。`kCFRunLoopAllActivities = 0x0FFFFFFFU`转换成二进制就是28个`1`，再进行`mask`的时候，所有的值都能取出来。\n\n\n现在我们了解到：\n1. `CFRunloopRef`代表`RunLoop`的运行模式\n2. 一个`Runloop`包含若干个`Mode`,每个`Mode`包含若干个`Source0/Source1/Timer/Obser`\n3. `Runloop`启动只能选择一个`Mode`作为`currentMode`\n4. 如果需要切换`Mode`，只能退出当前`Loop`，再重新选择一个`Mode`进入\n5. 不同组的`Source0/Source1/Timer/Observer`能分隔开来，互不影响\n6. 如果`Mode`没有任何`Source0/Source1/Timer/Observer`，`Runloop`立马退出。\n\n##### runloop切换Mode\n\n```\nCFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n    switch (activity) {\n    \tcase kCFRunLoopEntry:{\n    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n    \t\tNSLog(@\"即将进入 mode:%@\",m);\n    \t\tCFRelease(m);\n    \t\tbreak;\n    \t}\n    \t\t\n    \tcase kCFRunLoopExit:\n    \t{\n    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n    \t\tNSLog(@\"即将退出 mode:%@\",m);\n    \t\tCFRelease(m);\n    \t\tbreak;\n    \t}\n    \tdefault:\n    \t\tbreak;\n    }\n\t});\n\tCFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);\n\tCFRelease(obs);\n\t\n\t//当滑动tb的时候log\n\t\n即将退出 mode:kCFRunLoopDefaultMode\n即将进入 mode:UITrackingRunLoopMode\n即将退出 mode:UITrackingRunLoopMode\n即将进入 mode:kCFRunLoopDefaultMode\n```\n\n当`runloop`切换`mode`的时候，会退出当前`kCFRunLoopDefaultMode`，加入到其他的`UITrackingRunLoopMode`，当前`UITrackingRunLoopMode`完成之后再退出之后再加入到`kCFRunLoopDefaultMode`。\n\n我们再探究下`runloop`的循环的状态到底是怎样来变更的。\n\n```\n//\t//获取loop\n\tCFRunLoopRef ref = CFRunLoopGetMain();\n\t//获取obs\n\tCFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);\n\t//添加监听\n\tCFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));\n\tCFRelease(obs);\n\t\n\t\nint count = 0;//定义全局变量来计算一个mode中状态切换的统计数据\nvoid callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){\n\tprintf(\"- \");\n\tcount ++;\n\tprintf(\"%d\",count);\n\tswitch (activity) {\n\t\tcase kCFRunLoopEntry:\n\t\t\tprintf(\"即将进入 \\n\");\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tcase kCFRunLoopExit:\n\t\t\tprintf(\"即将退出 \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopAfterWaiting:\n\t\t\tprintf(\"即将从休眠中唤醒 \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeTimers:\n\t\t\tprintf(\"即将进入处理 timers \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeSources:\n\t\t\tprintf(\"即将进入 sources \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeWaiting:\n\t\t\tprintf(\"即将进入 休眠 \\n\");\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\n//点击的时候 会出发loop来处理触摸事件\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n-[ViewController touchesBegan:withEvent:]\n- 4即将进入处理 timers \n- 5即将进入 sources \n- 6即将进入处理 timers \n- 7即将进入 sources \n- 8即将进入处理 timers \n- 9即将进入 sources \n- 10即将进入 休眠 \n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n- 4即将进入处理 timers \n- 5即将进入 sources \n- 6即将进入 休眠 \n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n- 4即将进入 休眠 \n```\n\n`runloop`唤醒之后不是立马处理事件的，而是看看`timer`有没有事情，然后是`sources`,发现有触摸事件就处理了，然后又循环查看`timer`和`sources`一般循环2次进入休眠状态，处理`source`之后是循环三次。\n##### RunLoop在不获取的时候不存在,获取才生成\n`RunLoop`是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下`CFRunLoopGetCurrent`\n\n```\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n看到到这里相信大家已经对`runloop`有了基本的认识，那么我们再探究一下底层`runloop`是怎么运转的。\n\n首先看官方给的图：\n\n![](../images/9-2.png)\n那我又整理了一个表格来更直观的了解状态运转\n|步骤|任务|\n|:-:|:-:|\n|1|通知Observers:进入Loop|\n|2|通知Observers:即将处理Timers|\n|3|通知Observers:即将处理Sources|\n|4|处理blocks|\n|5|处理Source0(可能再处理Blocks)|\n|6|如果存在Source1，跳转第8步|\n|7|通知Observers:开始休眠|\n|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|\n|9|处理Blocks|\n|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|\n|11|通知Observers:退出Loop|\n\n查看[runloop源码](https://opensource.apple.com/tarballs/CF/)中`runloop.c`2333行\n\n```\n//入口函数\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();\n\n    if (__CFRunLoopIsStopped(rl)) {\n        __CFRunLoopUnsetStopped(rl);\n\treturn kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n\trlm->_stopped = false;\n\treturn kCFRunLoopRunStopped;\n    }\n    \n    mach_port_name_t dispatchPort = MACH_PORT_NULL;\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();\n    \n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    mach_port_name_t modeQueuePort = MACH_PORT_NULL;\n    if (rlm->_queue) {\n        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n        if (!modeQueuePort) {\n            CRASH(\"Unable to get port for run loop mode queue (%d)\", -1);\n        }\n    }\n#endif\n    \n    dispatch_source_t timeout_timer = NULL;\n    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));\n    if (seconds <= 0.0) { // instant timeout\n        seconds = 0.0;\n        timeout_context->termTSR = 0ULL;\n    } else if (seconds <= TIMER_INTERVAL_LIMIT) {\n\tdispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();\n\ttimeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n        dispatch_retain(timeout_timer);\n\ttimeout_context->ds = timeout_timer;\n\ttimeout_context->rl = (CFRunLoopRef)CFRetain(rl);\n\ttimeout_context->termTSR = startTSR + __CFTimeIntervalToTSR(seconds);\n\tdispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context\n\tdispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);\n        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);\n        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);\n        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);\n        dispatch_resume(timeout_timer);\n    } else { // infinite timeout\n        seconds = 9999999999.0;\n        timeout_context->termTSR = UINT64_MAX;\n    }\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;\n        voucher_t voucherCopy = NULL;\n#endif\n        uint8_t msg_buffer[3 * 1024];\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        mach_msg_header_t *msg = NULL;\n        mach_port_t livePort = MACH_PORT_NULL;\n#endif\n\t__CFPortSet waitSet = rlm->_portSet;\n\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n//通知即将处理Timers\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n//通知即将处理Sources\n        if (rlm->_observerMask & kCFRunLoopBeforeSources)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n//处理Blocks\n\t__CFRunLoopDoBlocks(rl, rlm);\n//处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n\t//处理Block\n            __CFRunLoopDoBlocks(rl, rlm);\n\t}\n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n\n        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            msg = (mach_msg_header_t *)msg_buffer;\n\t//y判断是否有Source1\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n\t//有则去 handle_msg\n                goto handle_msg;\n            }\n#endif\n        }\n        didDispatchPortLastTime = false;\n//即将进入休眠\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n\t//开始休眠\n\t__CFRunLoopSetSleeping(rl);\n\n    __CFPortSetInsert(dispatchPort, waitSet);\n        \n\t__CFRunLoopModeUnlock(rlm);\n\t__CFRunLoopUnlock(rl);\n\n        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();\n\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            //等待消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n\t\t\t\n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n          (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n#else\n        if (kCFUseCollectableAllocator) {\n            memset(msg_buffer, 0, sizeof(msg_buffer));\n        }\n        msg = (mach_msg_header_t *)msg_buffer;\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n#endif\n        \n        __CFRunLoopLock(rl);\n        __CFRunLoopModeLock(rlm);\n\n        rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));\n\n        __CFPortSetRemove(dispatchPort, waitSet);\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n\n        // user callouts now OK again\n\t__CFRunLoopUnsetSleeping(rl);\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting))\n\t//结束休眠\n\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n//标签 handle_msg\n        handle_msg:;\n        __CFRunLoopSetIgnoreWakeUps(rl);\n\t\t\n        if (MACH_PORT_NULL == livePort) {\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n\t\t\t\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n\t//被timer唤醒\n\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t//被GCD换醒\n        else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);\n\t//处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);\n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            didDispatchPortLastTime = true;\n        } else {\n\t//处理Source1\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n\t\t\t\n            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);\n\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n\t\tmach_msg_header_t *reply = NULL;\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n\t\tif (NULL != reply) {\n\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n\t\t}\n#endif\n\t    }\n            \n            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);\n        }\n        //处理bBlock\n\t__CFRunLoopDoBlocks(rl, rlm);\n        \n//设置返回值\n\tif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_revert(voucherState);\n        os_release(voucherCopy);\n#endif\n    } while (0 == retVal);\n    if (timeout_timer) {\n        dispatch_source_cancel(timeout_timer);\n        dispatch_release(timeout_timer);\n    } else {\n        free(timeout_context);\n    }\n    return retVal;\n}\n```\n\n经过及进一步精简\n\n```\n//入口函数\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();\n\n    if (__CFRunLoopIsStopped(rl)) {\n        __CFRunLoopUnsetStopped(rl);\n\treturn kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n\trlm->_stopped = false;\n\treturn kCFRunLoopRunStopped;\n    }\n\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n//通知即将处理Timers\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n//通知即将处理Sources\n        if (rlm->_observerMask & kCFRunLoopBeforeSources)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n//处理Blocks\n\t__CFRunLoopDoBlocks(rl, rlm);\n//处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n\t//处理Block\n            __CFRunLoopDoBlocks(rl, rlm);\n\t}\n            msg = (mach_msg_header_t *)msg_buffer;\n\t//y判断是否有Source1\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n\t//有则去 handle_msg\n                goto handle_msg;\n            }\n\n//即将进入休眠\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n\t//开始休眠\n\t__CFRunLoopSetSleeping(rl);\n        do {\n    //等待消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1);\n#else\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting))\n\t//结束休眠\n\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n//标签 handle_msg\n        handle_msg:;\n\t//被timer唤醒\n\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t//被GCD换醒\n        else if (livePort == dispatchPort) {\n\t//处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else {\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n\t//处理Source1\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n            // Restore the previous voucher\n            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);\n        }\n        //处理bBlock\n\t__CFRunLoopDoBlocks(rl, rlm);\n        \n    //设置返回值\n\tif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n    } while (0 == retVal);\n    return retVal;\n}\n```\n\n精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。\n这里的线程休眠`__CFRunLoopServiceMachPort`是调用内核函数[mach_msg()](http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html)进行休眠，和我们平时`while(1)`大不同，`while(1)`叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。\n\n\n#### 保活机制\n一个程序运行完毕结束了就死掉了，`timer`和变量也一样，运行完毕就结束了，那么我们怎么可以保证`timer`一直活跃和线程不结束呢？\n##### timer保活和多mode运行\n`timer`可以添加到`self`的属性保证一直活着，只要`self`不死，`timer`就不死。`timer`默认是添加到`NSDefaultRunLoopMode`模式中，因为`RunLoop`同时运行只能有一个模式，那么在滑动`scroller`的时候怎`Timer`会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？\n`Foundation`提供了一个API`(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode`添加上，`mode`值为`NSRunLoopCommonModes`可以保证同时兼顾2种模式。\n\n\n\n\n测试代码：\n\n```\nstatic int i = 0;\nNSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n\tNSLog(@\"%d\",++i);\n}];\n//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记\n//timer在设置为common模式下能运行\n//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行\n//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n\n//log\n\t\n2019-07-23 15:14:31 CFRunloop[62358:34093079] 1\n2019-07-23 15:14:32 CFRunloop[62358:34093079] 2\n2019-07-23 15:14:33 CFRunloop[62358:34093079] 3\n2019-07-23 15:14:34 CFRunloop[62358:34093079] 4\n2019-07-23 15:14:35 CFRunloop[62358:34093079] 5\n2019-07-23 15:14:36 CFRunloop[62358:34093079] 6\n2019-07-23 15:14:37 CFRunloop[62358:34093079] 7\n2019-07-23 15:14:38 CFRunloop[62358:34093079] 8\n```\n\n当滑动的时候`timer`的时候，`timer`还是如此丝滑，没有一点停顿。\n没有卡顿之后我们`VC -> dealloc`中`timer`还是在执行，那么需要在`dealloc`中去下和删除观察者\n\n```\n-(void)dealloc{\n\tNSLog(@\"%s\",__func__);\n\tCFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);\n\tdispatch_source_cancel(timer);\n}\n```\n\n退出`vc`之后`dealloc`照常执行，日志只有`-[ViewController dealloc]`，而且数字没有继续输出，说明删除观察者和取消`source`都成功了。\n\n那么`NSRunLoopCommonModes`是另外一种模式吗？\n\n通过源码查看得知，在`runloop.c line:1632  line:2608 `\n\n```\nif (CFStringGetTypeID() == CFGetTypeID(curr->_mode)) {\n    doit = CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n    } else {\n    doit = CFSetContainsValue((CFSetRef)curr->_mode, curMode) || (CFSetContainsValue((CFSetRef)curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n    }\n```\n\n还有很多地方均可以看出，当是`currentMode`需要和`_mode`相等才去执行，当是`kCFRunLoopCommonModes`的时候，只需要包含`curMode`即可执行。可见`kCFRunLoopCommonModes`其实是一个集合，不是某个特定的`mode`。\n\n##### 线程保活\n线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了\n`runloop`需要有任务才能不退出，总不可能直接让他执行`while(1)`吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用\n\n```\n[[NSRunLoop currentRunLoop] addPort:[NSPort port] \n                            forMode:NSRunLoopCommonModes];\n```\n\n来保活。\n在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。\n\n验证线程保活\n\n```\n@property (nonatomic,strong) FYThread *thread;\n\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];\n\t_thread.name = @\"test thread\";\n\t[_thread start];\n}\n- (void)test {\n//添加端口\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\t[[NSRunLoop currentRunLoop] run];\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//log\n//注释掉添加端口代码\n<FYThread: 0x6000013a9540>{number = 3, name = test thread}\n--start--\n--end--\n-[ViewController touchesBegan:withEvent:]\n执行完毕了子线程\n\n\n\n//注释放开的时候点击触发log\n<FYThread: 0x6000013a9540>{number = 3, name = test thread}\n--start--\n\n-[ViewController touchesBegan:withEvent:]\n执行完毕了子线程\n我还活着呢-><FYThread: 0x6000017e5c80>{number = 3, name = test thread}\n```\n\n`[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]`添加端口注释掉，直接执行了`--end--`，线程虽然`strong`强引用，但是`runloop`已经退出了，所以函数`alive`没有执行，不注释的话，`alive`还会执行，`end`一直不会执行，因为进入了`runloop`，而且没有退出，代码就不会向下执行。\n\n那我们测试下该线程声明周期多长？\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];\n\t_thread.name = @\"test thread\";\n\t[_thread start];\n}\n- (void)test {\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t//获取obs\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\t/*\n\t If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.\n\t */\n\t[[NSRunLoop currentRunLoop] run];\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//返回上页\n- (IBAction)popVC:(id)sender {\n\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//停止子线程线程\n- (void)stop{\n\tCFRunLoopStop(CFRunLoopGetCurrent());\n\tNSLog(@\"%s\",__func__);\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n<FYThread: 0x600003394780>{number = 3, name = test thread}\n--start--\n-[ViewController stop]\n-[ViewController stop]\n\n```\n\n拥有该线程的是`VC`，点击`pop`的时候，但是`VC`和`thread`没释放掉,好像`thread`和`VC`建立的循环引用，当`self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];`注释了，则`VC`可以进行正常释放。\n\n通过测试了解到\n这个线程达到了**永生**，就是你杀不死他，简直了**死待**。查找了不少资料才发现官方文档才是最稳的。有对这句`[[NSRunLoop currentRunLoop] run]`的解释\n> If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.\n\n就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用\n`runMode:beforeDate:`，那么该怎么办呢？\n官方文档给出了解决方案\n\n```\n\nBOOL shouldKeepRunning = YES; // global\nNSRunLoop *theRL = [NSRunLoop currentRunLoop];\nwhile (shouldKeepRunning && [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);\n```\n\n将代码改成下面的成功将**死待**杀死了。\n\n```\n- (void)test {\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t//获取obs\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\tself.shouldKeepRunning = YES;//默认运行\n\tNSRunLoop *theRL = [NSRunLoop currentRunLoop];\n\twhile (_shouldKeepRunning && [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//返回上页\n- (IBAction)popVC:(id)sender {\n\tself.shouldKeepRunning = NO;\n\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//停止子线程线程\n- (void)stop{\n\tCFRunLoopStop(CFRunLoopGetCurrent());\n\tNSLog(@\"%s\",__func__);\n\t[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];\n}\n- (void)pop{\n\t[self.navigationController popViewControllerAnimated:YES];\n\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n<FYThread: 0x600002699fc0>{number = 3, name = test thread}\n--start--\n-[ViewController stop]\n--end--\n-[ViewController dealloc]\n-[FYThread dealloc]\n```\n\n点击`popVC:`首先将`self.shouldKeepRunning = NO`，然后**子线程**执行`CFRunLoopStop(CFRunLoopGetCurrent())`，然后在**主线程**执行`pop`函数，最终返回上级页面而且成功杀死`VC`和**死待**。\n当然这个**死待**其实也是有用处的，当使用单例模式作为下载器的时候使用**死待**也没问题。这样子处理比较复杂，我们可以放在`VC`的`dealloc`看看是否能成功。\n关键函数稍微更改：\n\n```\n//停止子线程线程\n- (void)stop{\n    if (self.thread == nil) {\n        return;\n    }\n\tNSLog(@\"%s\",__func__);\n        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n- (void)stopThread{\n    self.shouldKeepRunning = NO;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc{\n    [self stop];\n\tNSLog(@\"%s\",__func__);\n}\n```\n\n当点击返回按钮`VC`和线程都没死，原来他们形成了强引用无法释放,就是`VC`始终无法执行`dealloc`。将函数改成`block`实现\n\n```\n    __weak typeof(self) __weakSelf = self;\n    self.thread = [[FYThread alloc]initWithBlock:^{\n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n        NSLog(@\"%@\",[NSThread currentThread]);\n        NSLog(@\"--start--\");\n        __weakSelf.shouldKeepRunning = YES;//默认运行\n        NSRunLoop *theRL = [NSRunLoop currentRunLoop];\n        while (__weakSelf && __weakSelf.shouldKeepRunning  ){\n            [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        };\n        NSLog(@\"--end--\");\n    }];\n```\n\n测试下崩溃了，崩溃到了：\n\n```\nwhile (__weakSelf.shouldKeepRunning  ){\n        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方\n    };\n```\n\n怎么想感觉不对劲啊，怎么会不行呢？`VC`销毁的时候调用子线程`stop`,最后打断点发现到了崩溃的地方`self`已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了`    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];`，表示不用等待`stopThread`函数执行时间，直接向前继续执行，所以`VC`释放掉了，`while (__weakSelf.shouldKeepRunning )`是`true`，还真进去了，访问了`exe_bad_access`，所以改成`while (__weakSelf&&__weakSelf.shouldKeepRunning )`再跑一下\n\n```\n//log\n\n--start--\n-[ViewController stop]\n-[ViewController dealloc]\n--end--\n-[FYThread dealloc]\n```\n\n如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。\n使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！\n\n### 资料参考\n- [runloop源码](https://opensource.apple.com/tarballs/CF/)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n- [thread保活c语言版本](https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80)\n- [thread 保活](https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9).md","raw":"title: iOS底层原理  RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)\ndate: 2019-12-1 11:19:58\ntags:\n- iOS\ncategories: iOS\n---\n\n使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的`jsonToModel`,`iOS`除了`runtime`还有一个东西的叫做`runloop`，各位看官老爷一定都有了解，那么今天这篇文章初识一下`runloop`。\n\n### 什么是runloop\n简单来讲`runloop`就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了`runloop`，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个`runloop`其实是这样子的\n\n```\nint ret = 0;\ndo {\n    //睡眠中等待消息\n    int messgae = sleep_and_wait();\n    //处理消息\n    ret = process_message(messgae);\n} while (ret == 0);\n```\n\n\n### 获取runloop\n\niOS中有两套可以获取runloop代码，一个是`Foundation`、一个是`Core Foundation`。\n`Foundation`其实是对`Core Foundation`的一个封装，\n\n```\nNSRunLoop * runloop1 = [NSRunLoop currentRunLoop];\nNSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];\n\nCFRunLoopRef runloop2= CFRunLoopGetCurrent();\nCFRunLoopRef mainloop2 = CFRunLoopGetMain();\nNSLog(@\"%p %p %p %p\",runloop1,mainloop1,runloop2,mainloop2);\nNSLog(@\"%@\",runloop1);\n//打印\nrunlopp1:0x600001bc58c0 \nmainloop1:0x600001bc58c0 \nrunloop2:0x6000003cc300 \nmainloop1:0x6000003cc300\n\nrunloop1:<CFRunLoop 0x6000003cc300 [0x10b2e9ae8]>.....\n\n```\n`runloop1`和`mainloop1`地址一致，说明当前的`runloop`是`mainrunloop`,`runloop1`作为对象输出的结果其实也是`runloop2`的地址，证明`Foundation runloop`是对`Core Foundation`的一个封装。\n\n`RunLoop`底层我们猜测应该是结构体，我们都了解到其实`OC`就是封装了`c/c++`，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下`runloop`的真是模样，通过`CFRunLoopRef *runloop = CFRunLoopGetMain();`查看`CFRunloop`是`typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;`，我们常用的`CFRunLoopRef`是`__CFRunLoop *`类型的，那么再在[源码(可以下载最新的源码)](https://opensource.apple.com/tarballs/CF/)中搜索一下 `struct __CFRunLoop {`在`runloop.c 637行`如下所示：\n\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t\t\t/* model list 锁 */\n    __CFPort _wakeUpPort;\t\t\t// 接受 CFRunLoopWakeUp的端口\n    Boolean _unused;//是否使用\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread; //线程\n    uint32_t _winthread;//win线程\n    CFMutableSetRef _commonModes; //modes\n    CFMutableSetRef _commonModeItems; //modeItems\n    CFRunLoopModeRef _currentMode; //当前的mode\n    CFMutableSetRef _modes; //所有的modes\n    struct _block_item *_blocks_head; //待执行的block列表头部\n    struct _block_item *_blocks_tail; //待执行的block 尾部\n    CFAbsoluteTime _runTime; //runtime\n    CFAbsoluteTime _sleepTime; //sleeptime\n    CFTypeRef _counterpart; //\n};\n```\n\n经过简化之后：\n\n```\nstruct __CFRunLoop {\n    pthread_t _pthread; //线程\n    CFMutableSetRef _commonModes; //modes\n    CFMutableSetRef _commonModeItems; //modeItems\n    CFRunLoopModeRef _currentMode; //当前的mode\n    CFMutableSetRef _modes; //所有的modes\n}\n```\n\n1. `runloop`中包含一个线程`_pthread`，一一对应的\n2. `CFMutableSetRef _modes`可以有多个`mode`\n3. `CFRunLoopModeRef _currentMode`当前`mode`只能有一个\n\n那么mode里边有什么内容呢？我们猜测他应该和`runloop`类似，在源码中搜索`CFRuntimeBase _base`看到在`runloop.c  line 524`看到具体的内容：\n\n```\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n经过简化之后是：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;//当前mode的名字\n    CFMutableSetRef _sources0;//souces0\n    CFMutableSetRef _sources1;//sources1\n    CFMutableArrayRef _observers;//observers\n    CFMutableArrayRef _timers;//timers\n}\n```\n\n一个`mode`可以有多个`timer`、`souces0`、`souces1`、`observers`、`timers`\n那么使用图更直观的来表示：\n\n![](../images/9-1.png)\n\n一个`runloop`包含多个`mode`，但是同时只能运行一个`mode`，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个`mode`被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。\n#### souces0\n- 触摸事件\n- performSelector:onThread:\n\n测试下点击事件处理源\n\n```\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);//此处断点\n}\n\n(LLDB) bt //输出当前调用栈\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=\"touchesBegan:withEvent:\", touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2\n    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353\n    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49\n    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869\n    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079\n    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356\n    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232\n    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911\n    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17\n    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243\n    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231\n    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626\n    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65\n    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140\n    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13\n    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1\n    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1\n```\n\n`#1`看到现在是在队列queue = 'com.apple.main-thread'中，`#10` `Runloop`启动，`#9`进入到`__CFRunLoopDoSources0`,最终`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__`调用了`__handleEventQueueInternal`->`[UIApplication sendEvent:]`->`[UIWindow sendEvent:]`->`[UIWindow _sendTouchesForEvent:]`->`[UIResponder touchesBegan:withEvent:]`->`-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=\"touchesBegan:withEvent:\", touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2`，可以看到另外一个知识点，手势的传递是从上往下的，顺序是`UIApplication -> UIWindow -> UIResponder -> ViewController`。\n#### Source1\n- 基于Port的线程间通信\n- 系统事件捕捉\n\n\n#### Timers\n- NSTimer\n- performSelector:withObject:afterDelay:\n\n```\n\ttimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n\tstatic int count = 5;\n\tdispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);\n\tdispatch_source_set_event_handler(timer, ^{\n\t\tNSLog(@\"-------：%d \\n\",count++);\n\t});\n\tdispatch_resume(timer);\n\t//log\n\t(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33\n    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8\n    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552\n    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249\n    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073\n    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9\n    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310\n    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626\n\t\n```\n\n最终进入函数`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__`调用了[libdispatch](https://opensource.apple.com/tarballs/libdispatch/)的`_dispatch_main_queue_callback_4CF`函数，具体实现有兴趣的大佬可以看下源码的实现。\n\n#### Observers\n- 用于监听RunLoop的状态\n- UI刷新（BeforeWaiting）\n- Autorelease pool（BeforeWaiting）\n\n\n\n\n`Mode`类型都多个,系统暴露在外的就两个，\n\n```\nCF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;\nCF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;\n```\n\n那么这两个Mode都是在什么情况下运行的呢？\n1. `kCFRunLoopDefaultMode（NSDefaultRunLoopMode）`：`App`的默认`Mode`，通常主线程是在这个`Mode`下运行\n2. `UITrackingRunLoopMode`：界面跟踪` Mode`，用于`ScrollView` 追踪触摸滑动，保证界面滑动时不受其他`Mode`影响\n\n进入到某个`Mode`，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的`status`，系统已经准备了`CFRunLoopActivity`来表示当前的状态\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0), //即将进入loop\n    kCFRunLoopBeforeTimers = (1UL << 1),//即将处理timers\n    kCFRunLoopBeforeSources = (1UL << 2), //即将处理sourcs\n    kCFRunLoopBeforeWaiting = (1UL << 5),//即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),//即将从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),//即将退出\n    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态\n};\n```\n\n`1UL`表示无符号长整形数字`1`，再次看到这个`(1UL << 1)`我么猜测用到了[位域或者联合体](https://juejin.im/post/5d2bcf3df265da1b67213d69)，达到省空间的目的。`kCFRunLoopAllActivities = 0x0FFFFFFFU`转换成二进制就是28个`1`，再进行`mask`的时候，所有的值都能取出来。\n\n\n现在我们了解到：\n1. `CFRunloopRef`代表`RunLoop`的运行模式\n2. 一个`Runloop`包含若干个`Mode`,每个`Mode`包含若干个`Source0/Source1/Timer/Obser`\n3. `Runloop`启动只能选择一个`Mode`作为`currentMode`\n4. 如果需要切换`Mode`，只能退出当前`Loop`，再重新选择一个`Mode`进入\n5. 不同组的`Source0/Source1/Timer/Observer`能分隔开来，互不影响\n6. 如果`Mode`没有任何`Source0/Source1/Timer/Observer`，`Runloop`立马退出。\n\n##### runloop切换Mode\n\n```\nCFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n    switch (activity) {\n    \tcase kCFRunLoopEntry:{\n    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n    \t\tNSLog(@\"即将进入 mode:%@\",m);\n    \t\tCFRelease(m);\n    \t\tbreak;\n    \t}\n    \t\t\n    \tcase kCFRunLoopExit:\n    \t{\n    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());\n    \t\tNSLog(@\"即将退出 mode:%@\",m);\n    \t\tCFRelease(m);\n    \t\tbreak;\n    \t}\n    \tdefault:\n    \t\tbreak;\n    }\n\t});\n\tCFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);\n\tCFRelease(obs);\n\t\n\t//当滑动tb的时候log\n\t\n即将退出 mode:kCFRunLoopDefaultMode\n即将进入 mode:UITrackingRunLoopMode\n即将退出 mode:UITrackingRunLoopMode\n即将进入 mode:kCFRunLoopDefaultMode\n```\n\n当`runloop`切换`mode`的时候，会退出当前`kCFRunLoopDefaultMode`，加入到其他的`UITrackingRunLoopMode`，当前`UITrackingRunLoopMode`完成之后再退出之后再加入到`kCFRunLoopDefaultMode`。\n\n我们再探究下`runloop`的循环的状态到底是怎样来变更的。\n\n```\n//\t//获取loop\n\tCFRunLoopRef ref = CFRunLoopGetMain();\n\t//获取obs\n\tCFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);\n\t//添加监听\n\tCFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));\n\tCFRelease(obs);\n\t\n\t\nint count = 0;//定义全局变量来计算一个mode中状态切换的统计数据\nvoid callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){\n\tprintf(\"- \");\n\tcount ++;\n\tprintf(\"%d\",count);\n\tswitch (activity) {\n\t\tcase kCFRunLoopEntry:\n\t\t\tprintf(\"即将进入 \\n\");\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tcase kCFRunLoopExit:\n\t\t\tprintf(\"即将退出 \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopAfterWaiting:\n\t\t\tprintf(\"即将从休眠中唤醒 \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeTimers:\n\t\t\tprintf(\"即将进入处理 timers \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeSources:\n\t\t\tprintf(\"即将进入 sources \\n\");\n\t\t\tbreak;\n\t\tcase kCFRunLoopBeforeWaiting:\n\t\t\tprintf(\"即将进入 休眠 \\n\");\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\n//点击的时候 会出发loop来处理触摸事件\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n-[ViewController touchesBegan:withEvent:]\n- 4即将进入处理 timers \n- 5即将进入 sources \n- 6即将进入处理 timers \n- 7即将进入 sources \n- 8即将进入处理 timers \n- 9即将进入 sources \n- 10即将进入 休眠 \n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n- 4即将进入处理 timers \n- 5即将进入 sources \n- 6即将进入 休眠 \n- 1即将从休眠中唤醒 \n- 2即将进入处理 timers \n- 3即将进入 sources \n- 4即将进入 休眠 \n```\n\n`runloop`唤醒之后不是立马处理事件的，而是看看`timer`有没有事情，然后是`sources`,发现有触摸事件就处理了，然后又循环查看`timer`和`sources`一般循环2次进入休眠状态，处理`source`之后是循环三次。\n##### RunLoop在不获取的时候不存在,获取才生成\n`RunLoop`是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下`CFRunLoopGetCurrent`\n\n```\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n看到到这里相信大家已经对`runloop`有了基本的认识，那么我们再探究一下底层`runloop`是怎么运转的。\n\n首先看官方给的图：\n\n![](../images/9-2.png)\n那我又整理了一个表格来更直观的了解状态运转\n|步骤|任务|\n|:-:|:-:|\n|1|通知Observers:进入Loop|\n|2|通知Observers:即将处理Timers|\n|3|通知Observers:即将处理Sources|\n|4|处理blocks|\n|5|处理Source0(可能再处理Blocks)|\n|6|如果存在Source1，跳转第8步|\n|7|通知Observers:开始休眠|\n|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|\n|9|处理Blocks|\n|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|\n|11|通知Observers:退出Loop|\n\n查看[runloop源码](https://opensource.apple.com/tarballs/CF/)中`runloop.c`2333行\n\n```\n//入口函数\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();\n\n    if (__CFRunLoopIsStopped(rl)) {\n        __CFRunLoopUnsetStopped(rl);\n\treturn kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n\trlm->_stopped = false;\n\treturn kCFRunLoopRunStopped;\n    }\n    \n    mach_port_name_t dispatchPort = MACH_PORT_NULL;\n    Boolean libdispatchQSafe = pthread_main_np() && ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY && 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));\n    if (libdispatchQSafe && (CFRunLoopGetMain() == rl) && CFSetContainsValue(rl->_commonModes, rlm->_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();\n    \n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    mach_port_name_t modeQueuePort = MACH_PORT_NULL;\n    if (rlm->_queue) {\n        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);\n        if (!modeQueuePort) {\n            CRASH(\"Unable to get port for run loop mode queue (%d)\", -1);\n        }\n    }\n#endif\n    \n    dispatch_source_t timeout_timer = NULL;\n    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));\n    if (seconds <= 0.0) { // instant timeout\n        seconds = 0.0;\n        timeout_context->termTSR = 0ULL;\n    } else if (seconds <= TIMER_INTERVAL_LIMIT) {\n\tdispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();\n\ttimeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n        dispatch_retain(timeout_timer);\n\ttimeout_context->ds = timeout_timer;\n\ttimeout_context->rl = (CFRunLoopRef)CFRetain(rl);\n\ttimeout_context->termTSR = startTSR + __CFTimeIntervalToTSR(seconds);\n\tdispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context\n\tdispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);\n        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);\n        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);\n        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);\n        dispatch_resume(timeout_timer);\n    } else { // infinite timeout\n        seconds = 9999999999.0;\n        timeout_context->termTSR = UINT64_MAX;\n    }\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;\n        voucher_t voucherCopy = NULL;\n#endif\n        uint8_t msg_buffer[3 * 1024];\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        mach_msg_header_t *msg = NULL;\n        mach_port_t livePort = MACH_PORT_NULL;\n#endif\n\t__CFPortSet waitSet = rlm->_portSet;\n\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n//通知即将处理Timers\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n//通知即将处理Sources\n        if (rlm->_observerMask & kCFRunLoopBeforeSources)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n//处理Blocks\n\t__CFRunLoopDoBlocks(rl, rlm);\n//处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n\t//处理Block\n            __CFRunLoopDoBlocks(rl, rlm);\n\t}\n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n\n        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            msg = (mach_msg_header_t *)msg_buffer;\n\t//y判断是否有Source1\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n\t//有则去 handle_msg\n                goto handle_msg;\n            }\n#endif\n        }\n        didDispatchPortLastTime = false;\n//即将进入休眠\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n\t//开始休眠\n\t__CFRunLoopSetSleeping(rl);\n\n    __CFPortSetInsert(dispatchPort, waitSet);\n        \n\t__CFRunLoopModeUnlock(rlm);\n\t__CFRunLoopUnlock(rl);\n\n        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();\n\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        do {\n            if (kCFUseCollectableAllocator) {\n\n                memset(msg_buffer, 0, sizeof(msg_buffer));\n            }\n            msg = (mach_msg_header_t *)msg_buffer;\n            //等待消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n\t\t\t\n            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n          (_dispatch_runloop_root_queue_perform_4CF(rlm->_queue));\n                if (rlm->_timerFired) {\n\n                    rlm->_timerFired = false;\n                    break;\n                } else {\n                    if (msg && msg != (mach_msg_header_t *)msg_buffer) free(msg);\n                }\n            } else {\n                // Go ahead and leave the inner loop.\n                break;\n            }\n        } while (1);\n#else\n        if (kCFUseCollectableAllocator) {\n            memset(msg_buffer, 0, sizeof(msg_buffer));\n        }\n        msg = (mach_msg_header_t *)msg_buffer;\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n#endif\n        \n        __CFRunLoopLock(rl);\n        __CFRunLoopModeLock(rlm);\n\n        rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));\n\n        __CFPortSetRemove(dispatchPort, waitSet);\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n\n        // user callouts now OK again\n\t__CFRunLoopUnsetSleeping(rl);\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting))\n\t//结束休眠\n\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n//标签 handle_msg\n        handle_msg:;\n        __CFRunLoopSetIgnoreWakeUps(rl);\n\t\t\n        if (MACH_PORT_NULL == livePort) {\n            CFRUNLOOP_WAKEUP_FOR_NOTHING();\n            // handle nothing\n        } else if (livePort == rl->_wakeUpPort) {\n            CFRUNLOOP_WAKEUP_FOR_WAKEUP();\n\t\t\t\n        }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n\t//被timer唤醒\n\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t//被GCD换醒\n        else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            __CFRunLoopModeUnlock(rlm);\n            __CFRunLoopUnlock(rl);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);\n\t//处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);\n            __CFRunLoopLock(rl);\n            __CFRunLoopModeLock(rlm);\n            sourceHandledThisLoop = true;\n            didDispatchPortLastTime = true;\n        } else {\n\t//处理Source1\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n\t\t\t\n            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);\n\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n\t\tmach_msg_header_t *reply = NULL;\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n\t\tif (NULL != reply) {\n\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n\t\t}\n#endif\n\t    }\n            \n            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);\n        }\n        //处理bBlock\n\t__CFRunLoopDoBlocks(rl, rlm);\n        \n//设置返回值\n\tif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        voucher_mach_msg_revert(voucherState);\n        os_release(voucherCopy);\n#endif\n    } while (0 == retVal);\n    if (timeout_timer) {\n        dispatch_source_cancel(timeout_timer);\n        dispatch_release(timeout_timer);\n    } else {\n        free(timeout_context);\n    }\n    return retVal;\n}\n```\n\n经过及进一步精简\n\n```\n//入口函数\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    uint64_t startTSR = mach_absolute_time();\n\n    if (__CFRunLoopIsStopped(rl)) {\n        __CFRunLoopUnsetStopped(rl);\n\treturn kCFRunLoopRunStopped;\n    } else if (rlm->_stopped) {\n\trlm->_stopped = false;\n\treturn kCFRunLoopRunStopped;\n    }\n\n    Boolean didDispatchPortLastTime = true;\n    int32_t retVal = 0;\n    do {\n        __CFRunLoopUnsetIgnoreWakeUps(rl);\n//通知即将处理Timers\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n//通知即将处理Sources\n        if (rlm->_observerMask & kCFRunLoopBeforeSources)\n\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n//处理Blocks\n\t__CFRunLoopDoBlocks(rl, rlm);\n//处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n\t//处理Block\n            __CFRunLoopDoBlocks(rl, rlm);\n\t}\n            msg = (mach_msg_header_t *)msg_buffer;\n\t//y判断是否有Source1\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n\t//有则去 handle_msg\n                goto handle_msg;\n            }\n\n//即将进入休眠\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n\t//开始休眠\n\t__CFRunLoopSetSleeping(rl);\n        do {\n    //等待消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1);\n#else\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting))\n\t//结束休眠\n\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n//标签 handle_msg\n        handle_msg:;\n\t//被timer唤醒\n\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n\n#if USE_MK_TIMER_TOO\n        else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        }\n#endif\n\t//被GCD换醒\n        else if (livePort == dispatchPort) {\n\t//处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else {\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n\t//处理Source1\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n            // Restore the previous voucher\n            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);\n        }\n        //处理bBlock\n\t__CFRunLoopDoBlocks(rl, rlm);\n        \n    //设置返回值\n\tif (sourceHandledThisLoop && stopAfterHandle) {\n\t    retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n\t} else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (rlm->_stopped) {\n\t    rlm->_stopped = false;\n\t    retVal = kCFRunLoopRunStopped;\n\t} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n\t    retVal = kCFRunLoopRunFinished;\n\t}\n    } while (0 == retVal);\n    return retVal;\n}\n```\n\n精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。\n这里的线程休眠`__CFRunLoopServiceMachPort`是调用内核函数[mach_msg()](http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html)进行休眠，和我们平时`while(1)`大不同，`while(1)`叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。\n\n\n#### 保活机制\n一个程序运行完毕结束了就死掉了，`timer`和变量也一样，运行完毕就结束了，那么我们怎么可以保证`timer`一直活跃和线程不结束呢？\n##### timer保活和多mode运行\n`timer`可以添加到`self`的属性保证一直活着，只要`self`不死，`timer`就不死。`timer`默认是添加到`NSDefaultRunLoopMode`模式中，因为`RunLoop`同时运行只能有一个模式，那么在滑动`scroller`的时候怎`Timer`会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？\n`Foundation`提供了一个API`(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode`添加上，`mode`值为`NSRunLoopCommonModes`可以保证同时兼顾2种模式。\n\n\n\n\n测试代码：\n\n```\nstatic int i = 0;\nNSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n\tNSLog(@\"%d\",++i);\n}];\n//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记\n//timer在设置为common模式下能运行\n//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行\n//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n\n//log\n\t\n2019-07-23 15:14:31 CFRunloop[62358:34093079] 1\n2019-07-23 15:14:32 CFRunloop[62358:34093079] 2\n2019-07-23 15:14:33 CFRunloop[62358:34093079] 3\n2019-07-23 15:14:34 CFRunloop[62358:34093079] 4\n2019-07-23 15:14:35 CFRunloop[62358:34093079] 5\n2019-07-23 15:14:36 CFRunloop[62358:34093079] 6\n2019-07-23 15:14:37 CFRunloop[62358:34093079] 7\n2019-07-23 15:14:38 CFRunloop[62358:34093079] 8\n```\n\n当滑动的时候`timer`的时候，`timer`还是如此丝滑，没有一点停顿。\n没有卡顿之后我们`VC -> dealloc`中`timer`还是在执行，那么需要在`dealloc`中去下和删除观察者\n\n```\n-(void)dealloc{\n\tNSLog(@\"%s\",__func__);\n\tCFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);\n\tdispatch_source_cancel(timer);\n}\n```\n\n退出`vc`之后`dealloc`照常执行，日志只有`-[ViewController dealloc]`，而且数字没有继续输出，说明删除观察者和取消`source`都成功了。\n\n那么`NSRunLoopCommonModes`是另外一种模式吗？\n\n通过源码查看得知，在`runloop.c line:1632  line:2608 `\n\n```\nif (CFStringGetTypeID() == CFGetTypeID(curr->_mode)) {\n    doit = CFEqual(curr->_mode, curMode) || (CFEqual(curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n    } else {\n    doit = CFSetContainsValue((CFSetRef)curr->_mode, curMode) || (CFSetContainsValue((CFSetRef)curr->_mode, kCFRunLoopCommonModes) && CFSetContainsValue(commonModes, curMode));\n    }\n```\n\n还有很多地方均可以看出，当是`currentMode`需要和`_mode`相等才去执行，当是`kCFRunLoopCommonModes`的时候，只需要包含`curMode`即可执行。可见`kCFRunLoopCommonModes`其实是一个集合，不是某个特定的`mode`。\n\n##### 线程保活\n线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了\n`runloop`需要有任务才能不退出，总不可能直接让他执行`while(1)`吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用\n\n```\n[[NSRunLoop currentRunLoop] addPort:[NSPort port] \n                            forMode:NSRunLoopCommonModes];\n```\n\n来保活。\n在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。\n\n验证线程保活\n\n```\n@property (nonatomic,strong) FYThread *thread;\n\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];\n\t_thread.name = @\"test thread\";\n\t[_thread start];\n}\n- (void)test {\n//添加端口\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\t[[NSRunLoop currentRunLoop] run];\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//log\n//注释掉添加端口代码\n<FYThread: 0x6000013a9540>{number = 3, name = test thread}\n--start--\n--end--\n-[ViewController touchesBegan:withEvent:]\n执行完毕了子线程\n\n\n\n//注释放开的时候点击触发log\n<FYThread: 0x6000013a9540>{number = 3, name = test thread}\n--start--\n\n-[ViewController touchesBegan:withEvent:]\n执行完毕了子线程\n我还活着呢-><FYThread: 0x6000017e5c80>{number = 3, name = test thread}\n```\n\n`[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]`添加端口注释掉，直接执行了`--end--`，线程虽然`strong`强引用，但是`runloop`已经退出了，所以函数`alive`没有执行，不注释的话，`alive`还会执行，`end`一直不会执行，因为进入了`runloop`，而且没有退出，代码就不会向下执行。\n\n那我们测试下该线程声明周期多长？\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];\n\t_thread.name = @\"test thread\";\n\t[_thread start];\n}\n- (void)test {\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t//获取obs\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\t/*\n\t If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.\n\t */\n\t[[NSRunLoop currentRunLoop] run];\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//返回上页\n- (IBAction)popVC:(id)sender {\n\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//停止子线程线程\n- (void)stop{\n\tCFRunLoopStop(CFRunLoopGetCurrent());\n\tNSLog(@\"%s\",__func__);\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n<FYThread: 0x600003394780>{number = 3, name = test thread}\n--start--\n-[ViewController stop]\n-[ViewController stop]\n\n```\n\n拥有该线程的是`VC`，点击`pop`的时候，但是`VC`和`thread`没释放掉,好像`thread`和`VC`建立的循环引用，当`self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];`注释了，则`VC`可以进行正常释放。\n\n通过测试了解到\n这个线程达到了**永生**，就是你杀不死他，简直了**死待**。查找了不少资料才发现官方文档才是最稳的。有对这句`[[NSRunLoop currentRunLoop] run]`的解释\n> If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.\n\n就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用\n`runMode:beforeDate:`，那么该怎么办呢？\n官方文档给出了解决方案\n\n```\n\nBOOL shouldKeepRunning = YES; // global\nNSRunLoop *theRL = [NSRunLoop currentRunLoop];\nwhile (shouldKeepRunning && [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);\n```\n\n将代码改成下面的成功将**死待**杀死了。\n\n```\n- (void)test {\n\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n\t//获取obs\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\tNSLog(@\"--start--\");\n\tself.shouldKeepRunning = YES;//默认运行\n\tNSRunLoop *theRL = [NSRunLoop currentRunLoop];\n\twhile (_shouldKeepRunning && [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);\n\tNSLog(@\"--end--\");\n}\n\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tNSLog(@\"%s\",__func__);\n\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];\n\tNSLog(@\"执行完毕了子线程\");//不执行 因为子线程保活了 不会执行完毕\n}\n//返回上页\n- (IBAction)popVC:(id)sender {\n\tself.shouldKeepRunning = NO;\n\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n//测试子线程是否还活着\n- (void)alive{\n\tNSLog(@\"我还活着呢->%@\",[NSThread currentThread]);\n}\n//停止子线程线程\n- (void)stop{\n\tCFRunLoopStop(CFRunLoopGetCurrent());\n\tNSLog(@\"%s\",__func__);\n\t[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];\n}\n- (void)pop{\n\t[self.navigationController popViewControllerAnimated:YES];\n\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n\n<FYThread: 0x600002699fc0>{number = 3, name = test thread}\n--start--\n-[ViewController stop]\n--end--\n-[ViewController dealloc]\n-[FYThread dealloc]\n```\n\n点击`popVC:`首先将`self.shouldKeepRunning = NO`，然后**子线程**执行`CFRunLoopStop(CFRunLoopGetCurrent())`，然后在**主线程**执行`pop`函数，最终返回上级页面而且成功杀死`VC`和**死待**。\n当然这个**死待**其实也是有用处的，当使用单例模式作为下载器的时候使用**死待**也没问题。这样子处理比较复杂，我们可以放在`VC`的`dealloc`看看是否能成功。\n关键函数稍微更改：\n\n```\n//停止子线程线程\n- (void)stop{\n    if (self.thread == nil) {\n        return;\n    }\n\tNSLog(@\"%s\",__func__);\n        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];\n}\n- (void)stopThread{\n    self.shouldKeepRunning = NO;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n- (void)dealloc{\n    [self stop];\n\tNSLog(@\"%s\",__func__);\n}\n```\n\n当点击返回按钮`VC`和线程都没死，原来他们形成了强引用无法释放,就是`VC`始终无法执行`dealloc`。将函数改成`block`实现\n\n```\n    __weak typeof(self) __weakSelf = self;\n    self.thread = [[FYThread alloc]initWithBlock:^{\n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n        NSLog(@\"%@\",[NSThread currentThread]);\n        NSLog(@\"--start--\");\n        __weakSelf.shouldKeepRunning = YES;//默认运行\n        NSRunLoop *theRL = [NSRunLoop currentRunLoop];\n        while (__weakSelf && __weakSelf.shouldKeepRunning  ){\n            [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n        };\n        NSLog(@\"--end--\");\n    }];\n```\n\n测试下崩溃了，崩溃到了：\n\n```\nwhile (__weakSelf.shouldKeepRunning  ){\n        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方\n    };\n```\n\n怎么想感觉不对劲啊，怎么会不行呢？`VC`销毁的时候调用子线程`stop`,最后打断点发现到了崩溃的地方`self`已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了`    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];`，表示不用等待`stopThread`函数执行时间，直接向前继续执行，所以`VC`释放掉了，`while (__weakSelf.shouldKeepRunning )`是`true`，还真进去了，访问了`exe_bad_access`，所以改成`while (__weakSelf&&__weakSelf.shouldKeepRunning )`再跑一下\n\n```\n//log\n\n--start--\n-[ViewController stop]\n-[ViewController dealloc]\n--end--\n-[FYThread dealloc]\n```\n\n如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。\n使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！\n\n### 资料参考\n- [runloop源码](https://opensource.apple.com/tarballs/CF/)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n- [thread保活c语言版本](https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80)\n- [thread 保活](https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 RunLoop基础总结和随心所欲掌握子线程RunLoop生命周期 --(9)","published":1,"updated":"2019-12-03T05:04:59.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2i000j9zskv3miql05","content":"<p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>\n<h3 id=\"什么是runloop\"><a href=\"#什么是runloop\" class=\"headerlink\" title=\"什么是runloop\"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int ret = 0;</div><div class=\"line\">do &#123;</div><div class=\"line\">    //睡眠中等待消息</div><div class=\"line\">    int messgae = sleep_and_wait();</div><div class=\"line\">    //处理消息</div><div class=\"line\">    ret = process_message(messgae);</div><div class=\"line\">&#125; while (ret == 0);</div></pre></td></tr></table></figure>\n<h3 id=\"获取runloop\"><a href=\"#获取runloop\" class=\"headerlink\" title=\"获取runloop\"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</div><div class=\"line\">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</div><div class=\"line\"></div><div class=\"line\">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</div><div class=\"line\">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</div><div class=\"line\">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</div><div class=\"line\">NSLog(@&quot;%@&quot;,runloop1);</div><div class=\"line\">//打印</div><div class=\"line\">runlopp1:0x600001bc58c0 </div><div class=\"line\">mainloop1:0x600001bc58c0 </div><div class=\"line\">runloop2:0x6000003cc300 </div><div class=\"line\">mainloop1:0x6000003cc300</div><div class=\"line\"></div><div class=\"line\">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</div></pre></td></tr></table></figure>\n<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>\n<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t\t\t/* model list 锁 */</div><div class=\"line\">    __CFPort _wakeUpPort;\t\t\t// 接受 CFRunLoopWakeUp的端口</div><div class=\"line\">    Boolean _unused;//是否使用</div><div class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class=\"line\">    pthread_t _pthread; //线程</div><div class=\"line\">    uint32_t _winthread;//win线程</div><div class=\"line\">    CFMutableSetRef _commonModes; //modes</div><div class=\"line\">    CFMutableSetRef _commonModeItems; //modeItems</div><div class=\"line\">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class=\"line\">    CFMutableSetRef _modes; //所有的modes</div><div class=\"line\">    struct _block_item *_blocks_head; //待执行的block列表头部</div><div class=\"line\">    struct _block_item *_blocks_tail; //待执行的block 尾部</div><div class=\"line\">    CFAbsoluteTime _runTime; //runtime</div><div class=\"line\">    CFAbsoluteTime _sleepTime; //sleeptime</div><div class=\"line\">    CFTypeRef _counterpart; //</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>经过简化之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    pthread_t _pthread; //线程</div><div class=\"line\">    CFMutableSetRef _commonModes; //modes</div><div class=\"line\">    CFMutableSetRef _commonModeItems; //modeItems</div><div class=\"line\">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class=\"line\">    CFMutableSetRef _modes; //所有的modes</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>\n<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>\n<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>\n</ol>\n<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */</div><div class=\"line\">    CFStringRef _name;</div><div class=\"line\">    Boolean _stopped;</div><div class=\"line\">    char _padding[3];</div><div class=\"line\">    CFMutableSetRef _sources0;</div><div class=\"line\">    CFMutableSetRef _sources1;</div><div class=\"line\">    CFMutableArrayRef _observers;</div><div class=\"line\">    CFMutableArrayRef _timers;</div><div class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class=\"line\">    __CFPortSet _portSet;</div><div class=\"line\">    CFIndex _observerMask;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    dispatch_source_t _timerSource;</div><div class=\"line\">    dispatch_queue_t _queue;</div><div class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class=\"line\">    Boolean _dispatchTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">    mach_port_t _timerPort;</div><div class=\"line\">    Boolean _mkTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    DWORD _msgQMask;</div><div class=\"line\">    void (*_msgPump)(void);</div><div class=\"line\">#endif</div><div class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</div><div class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>经过简化之后是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFStringRef _name;//当前mode的名字</div><div class=\"line\">    CFMutableSetRef _sources0;//souces0</div><div class=\"line\">    CFMutableSetRef _sources1;//sources1</div><div class=\"line\">    CFMutableArrayRef _observers;//observers</div><div class=\"line\">    CFMutableArrayRef _timers;//timers</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>\n<p><img src=\"../images/9-1.png\" alt=\"\"></p>\n<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>\n<h4 id=\"souces0\"><a href=\"#souces0\" class=\"headerlink\" title=\"souces0\"></a>souces0</h4><ul>\n<li>触摸事件</li>\n<li>performSelector:onThread:</li>\n</ul>\n<p>测试下点击事件处理源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);//此处断点</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">(LLDB) bt //输出当前调用栈</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</div><div class=\"line\">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</div><div class=\"line\">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</div><div class=\"line\">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</div><div class=\"line\">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</div><div class=\"line\">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</div><div class=\"line\">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</div><div class=\"line\">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</div><div class=\"line\">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</div><div class=\"line\">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</div><div class=\"line\">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</div><div class=\"line\">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</div><div class=\"line\">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</div><div class=\"line\">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</div><div class=\"line\">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</div><div class=\"line\">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</div><div class=\"line\">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>\n<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>\n<h4 id=\"Source1\"><a href=\"#Source1\" class=\"headerlink\" title=\"Source1\"></a>Source1</h4><ul>\n<li>基于Port的线程间通信</li>\n<li>系统事件捕捉</li>\n</ul>\n<h4 id=\"Timers\"><a href=\"#Timers\" class=\"headerlink\" title=\"Timers\"></a>Timers</h4><ul>\n<li>NSTimer</li>\n<li>performSelector:withObject:afterDelay:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">\tstatic int count = 5;</div><div class=\"line\">\tdispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class=\"line\">\tdispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;-------：%d \\n&quot;,count++);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_resume(timer);</div><div class=\"line\">\t//log</div><div class=\"line\">\t(lldb) bt</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</div><div class=\"line\">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</div><div class=\"line\">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</div><div class=\"line\">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</div><div class=\"line\">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</div><div class=\"line\">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</div><div class=\"line\">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</div><div class=\"line\">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</div></pre></td></tr></table></figure>\n<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>\n<h4 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h4><ul>\n<li>用于监听RunLoop的状态</li>\n<li>UI刷新（BeforeWaiting）</li>\n<li>Autorelease pool（BeforeWaiting）</li>\n</ul>\n<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</div><div class=\"line\">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</div></pre></td></tr></table></figure>\n<p>那么这两个Mode都是在什么情况下运行的呢？</p>\n<ol>\n<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>\n<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>\n</ol>\n<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</div><div class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</div><div class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</div><div class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href=\"https://juejin.im/post/5d2bcf3df265da1b67213d69\" target=\"_blank\" rel=\"external\">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>\n<p>现在我们了解到：</p>\n<ol>\n<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>\n<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>\n<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>\n<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>\n<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>\n<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>\n</ol>\n<h5 id=\"runloop切换Mode\"><a href=\"#runloop切换Mode\" class=\"headerlink\" title=\"runloop切换Mode\"></a>runloop切换Mode</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class=\"line\">    switch (activity) &#123;</div><div class=\"line\">    \tcase kCFRunLoopEntry:&#123;</div><div class=\"line\">    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class=\"line\">    \t\tNSLog(@&quot;即将进入 mode:%@&quot;,m);</div><div class=\"line\">    \t\tCFRelease(m);</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    \t\t</div><div class=\"line\">    \tcase kCFRunLoopExit:</div><div class=\"line\">    \t&#123;</div><div class=\"line\">    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class=\"line\">    \t\tNSLog(@&quot;即将退出 mode:%@&quot;,m);</div><div class=\"line\">    \t\tCFRelease(m);</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    \tdefault:</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tCFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</div><div class=\"line\">\tCFRelease(obs);</div><div class=\"line\">\t</div><div class=\"line\">\t//当滑动tb的时候log</div><div class=\"line\">\t</div><div class=\"line\">即将退出 mode:kCFRunLoopDefaultMode</div><div class=\"line\">即将进入 mode:UITrackingRunLoopMode</div><div class=\"line\">即将退出 mode:UITrackingRunLoopMode</div><div class=\"line\">即将进入 mode:kCFRunLoopDefaultMode</div></pre></td></tr></table></figure>\n<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>\n<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">//\t//获取loop</div><div class=\"line\">\tCFRunLoopRef ref = CFRunLoopGetMain();</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tCFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</div><div class=\"line\">\t//添加监听</div><div class=\"line\">\tCFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</div><div class=\"line\">\tCFRelease(obs);</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</div><div class=\"line\">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</div><div class=\"line\">\tprintf(&quot;- &quot;);</div><div class=\"line\">\tcount ++;</div><div class=\"line\">\tprintf(&quot;%d&quot;,count);</div><div class=\"line\">\tswitch (activity) &#123;</div><div class=\"line\">\t\tcase kCFRunLoopEntry:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 \\n&quot;);</div><div class=\"line\">\t\t\tcount = 0;</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopExit:</div><div class=\"line\">\t\t\tprintf(&quot;即将退出 \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopAfterWaiting:</div><div class=\"line\">\t\t\tprintf(&quot;即将从休眠中唤醒 \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeTimers:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入处理 timers \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeSources:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 sources \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeWaiting:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 休眠 \\n&quot;);</div><div class=\"line\">\t\t\tcount = 0;</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tdefault:</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//点击的时候 会出发loop来处理触摸事件</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">- 4即将进入处理 timers </div><div class=\"line\">- 5即将进入 sources </div><div class=\"line\">- 6即将进入处理 timers </div><div class=\"line\">- 7即将进入 sources </div><div class=\"line\">- 8即将进入处理 timers </div><div class=\"line\">- 9即将进入 sources </div><div class=\"line\">- 10即将进入 休眠 </div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">- 4即将进入处理 timers </div><div class=\"line\">- 5即将进入 sources </div><div class=\"line\">- 6即将进入 休眠 </div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">- 4即将进入 休眠</div></pre></td></tr></table></figure>\n<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>\n<h5 id=\"RunLoop在不获取的时候不存在-获取才生成\"><a href=\"#RunLoop在不获取的时候不存在-获取才生成\" class=\"headerlink\" title=\"RunLoop在不获取的时候不存在,获取才生成\"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class=\"line\">    if (rl) return rl;</div><div class=\"line\">    return _CFRunLoopGet0(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>\n<p>首先看官方给的图：</p>\n<p><img src=\"../images/9-2.png\" alt=\"\"><br>那我又整理了一个表格来更直观的了解状态运转<br>|步骤|任务|<br>|:-:|:-:|<br>|1|通知Observers:进入Loop|<br>|2|通知Observers:即将处理Timers|<br>|3|通知Observers:即将处理Sources|<br>|4|处理blocks|<br>|5|处理Source0(可能再处理Blocks)|<br>|6|如果存在Source1，跳转第8步|<br>|7|通知Observers:开始休眠|<br>|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|<br>|9|处理Blocks|<br>|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|<br>|11|通知Observers:退出Loop|</p>\n<p>查看<a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">runloop源码</a>中<code>runloop.c</code>2333行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div></pre></td><td class=\"code\"><pre><div class=\"line\">//入口函数</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();</div><div class=\"line\"></div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\trlm-&gt;_stopped = false;</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class=\"line\">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class=\"line\">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class=\"line\">    </div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class=\"line\">    if (rlm-&gt;_queue) &#123;</div><div class=\"line\">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class=\"line\">        if (!modeQueuePort) &#123;</div><div class=\"line\">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    </div><div class=\"line\">    dispatch_source_t timeout_timer = NULL;</div><div class=\"line\">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class=\"line\">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class=\"line\">        seconds = 0.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = 0ULL;</div><div class=\"line\">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class=\"line\">\tdispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class=\"line\">\ttimeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">        dispatch_retain(timeout_timer);</div><div class=\"line\">\ttimeout_context-&gt;ds = timeout_timer;</div><div class=\"line\">\ttimeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class=\"line\">\ttimeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class=\"line\">\tdispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class=\"line\">\tdispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class=\"line\">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class=\"line\">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class=\"line\">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class=\"line\">        dispatch_resume(timeout_timer);</div><div class=\"line\">    &#125; else &#123; // infinite timeout</div><div class=\"line\">        seconds = 9999999999.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</div><div class=\"line\">        voucher_t voucherCopy = NULL;</div><div class=\"line\">#endif</div><div class=\"line\">        uint8_t msg_buffer[3 * 1024];</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        mach_msg_header_t *msg = NULL;</div><div class=\"line\">        mach_port_t livePort = MACH_PORT_NULL;</div><div class=\"line\">#endif</div><div class=\"line\">\t__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class=\"line\"></div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">//通知即将处理Timers</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">//通知即将处理Sources</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">//处理Blocks</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">//处理Source0</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">\t//处理Block</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">\t&#125;</div><div class=\"line\">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class=\"line\"></div><div class=\"line\">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">\t//y判断是否有Source1</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class=\"line\">\t//有则去 handle_msg</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">        didDispatchPortLastTime = false;</div><div class=\"line\">//即将进入休眠</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">\t//开始休眠</div><div class=\"line\">\t__CFRunLoopSetSleeping(rl);</div><div class=\"line\"></div><div class=\"line\">    __CFPortSetInsert(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">\t__CFRunLoopModeUnlock(rlm);</div><div class=\"line\">\t__CFRunLoopUnlock(rl);</div><div class=\"line\"></div><div class=\"line\">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class=\"line\"></div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\"></div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            //等待消息来唤醒当前线程</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">\t\t\t</div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\"></div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">        if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopLock(rl);</div><div class=\"line\">        __CFRunLoopModeLock(rlm);</div><div class=\"line\"></div><div class=\"line\">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class=\"line\"></div><div class=\"line\">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\"></div><div class=\"line\">        // user callouts now OK again</div><div class=\"line\">\t__CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class=\"line\">\t//结束休眠</div><div class=\"line\">\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">//标签 handle_msg</div><div class=\"line\">        handle_msg:;</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">\t\t</div><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">\t\t\t</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">\t//被timer唤醒</div><div class=\"line\">\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t//被GCD换醒</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class=\"line\">\t//处理GCD</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            didDispatchPortLastTime = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">\t//处理Source1</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">\t\t\t</div><div class=\"line\">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class=\"line\"></div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">            if (rls) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">\t\tmach_msg_header_t *reply = NULL;</div><div class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">\t\tif (NULL != reply) &#123;</div><div class=\"line\">\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class=\"line\">\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t    &#125;</div><div class=\"line\">            </div><div class=\"line\">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //处理bBlock</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">//设置返回值</div><div class=\"line\">\tif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">\t&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\t    rlm-&gt;_stopped = false;</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunFinished;</div><div class=\"line\">\t&#125;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        voucher_mach_msg_revert(voucherState);</div><div class=\"line\">        os_release(voucherCopy);</div><div class=\"line\">#endif</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    if (timeout_timer) &#123;</div><div class=\"line\">        dispatch_source_cancel(timeout_timer);</div><div class=\"line\">        dispatch_release(timeout_timer);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        free(timeout_context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过及进一步精简</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">//入口函数</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();</div><div class=\"line\"></div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\trlm-&gt;_stopped = false;</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">//通知即将处理Timers</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">//通知即将处理Sources</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">//处理Blocks</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">//处理Source0</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">\t//处理Block</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">\t&#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">\t//y判断是否有Source1</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class=\"line\">\t//有则去 handle_msg</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">//即将进入休眠</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">\t//开始休眠</div><div class=\"line\">\t__CFRunLoopSetSleeping(rl);</div><div class=\"line\">        do &#123;</div><div class=\"line\">    //等待消息来唤醒当前线程</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class=\"line\">\t//结束休眠</div><div class=\"line\">\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">//标签 handle_msg</div><div class=\"line\">        handle_msg:;</div><div class=\"line\">\t//被timer唤醒</div><div class=\"line\">\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t//被GCD换醒</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">\t//处理GCD</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">\t//处理Source1</div><div class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">            // Restore the previous voucher</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //处理bBlock</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">    //设置返回值</div><div class=\"line\">\tif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">\t&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\t    rlm-&gt;_stopped = false;</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunFinished;</div><div class=\"line\">\t&#125;</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href=\"http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html\" target=\"_blank\" rel=\"external\">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>\n<h4 id=\"保活机制\"><a href=\"#保活机制\" class=\"headerlink\" title=\"保活机制\"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>\n<h5 id=\"timer保活和多mode运行\"><a href=\"#timer保活和多mode运行\" class=\"headerlink\" title=\"timer保活和多mode运行\"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>\n<p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int i = 0;</div><div class=\"line\">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class=\"line\">\tNSLog(@&quot;%d&quot;,++i);</div><div class=\"line\">&#125;];</div><div class=\"line\">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</div><div class=\"line\">//timer在设置为common模式下能运行</div><div class=\"line\">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</div><div class=\"line\">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</div><div class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">\t</div><div class=\"line\">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</div><div class=\"line\">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</div><div class=\"line\">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</div><div class=\"line\">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</div><div class=\"line\">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</div><div class=\"line\">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</div><div class=\"line\">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</div><div class=\"line\">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</div></pre></td></tr></table></figure>\n<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tCFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</div><div class=\"line\">\tdispatch_source_cancel(timer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>\n<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>\n<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class=\"line\">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>\n<h5 id=\"线程保活\"><a href=\"#线程保活\" class=\"headerlink\" title=\"线程保活\"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </div><div class=\"line\">                            forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>\n<p>验证线程保活</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,strong) FYThread *thread;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class=\"line\">\t_thread.name = @&quot;test thread&quot;;</div><div class=\"line\">\t[_thread start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">//添加端口</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] run];</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">//注释掉添加端口代码</div><div class=\"line\">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">--end--</div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">执行完毕了子线程</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//注释放开的时候点击触发log</div><div class=\"line\">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\"></div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">执行完毕了子线程</div><div class=\"line\">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</div></pre></td></tr></table></figure>\n<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>\n<p>那我们测试下该线程声明周期多长？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class=\"line\">\t_thread.name = @&quot;test thread&quot;;</div><div class=\"line\">\t[_thread start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\t/*</div><div class=\"line\">\t If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</div><div class=\"line\">\t */</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] run];</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//返回上页</div><div class=\"line\">- (IBAction)popVC:(id)sender &#123;</div><div class=\"line\">\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">\tCFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">-[ViewController stop]</div></pre></td></tr></table></figure>\n<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>\n<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>\n<blockquote>\n<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>\n</blockquote>\n<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">BOOL shouldKeepRunning = YES; // global</div><div class=\"line\">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure>\n<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test &#123;</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\tself.shouldKeepRunning = YES;//默认运行</div><div class=\"line\">\tNSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">\twhile (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//返回上页</div><div class=\"line\">- (IBAction)popVC:(id)sender &#123;</div><div class=\"line\">\tself.shouldKeepRunning = NO;</div><div class=\"line\">\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">\tCFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)pop&#123;</div><div class=\"line\">\t[self.navigationController popViewControllerAnimated:YES];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">--end--</div><div class=\"line\">-[ViewController dealloc]</div><div class=\"line\">-[FYThread dealloc]</div></pre></td></tr></table></figure>\n<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">    if (self.thread == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)stopThread&#123;</div><div class=\"line\">    self.shouldKeepRunning = NO;</div><div class=\"line\">    CFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">    [self stop];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self) __weakSelf = self;</div><div class=\"line\">self.thread = [[FYThread alloc]initWithBlock:^&#123;</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    NSLog(@&quot;--start--&quot;);</div><div class=\"line\">    __weakSelf.shouldKeepRunning = YES;//默认运行</div><div class=\"line\">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</div><div class=\"line\">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class=\"line\">    &#125;;</div><div class=\"line\">    NSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>测试下崩溃了，崩溃到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (__weakSelf.shouldKeepRunning  )&#123;</div><div class=\"line\">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">-[ViewController dealloc]</div><div class=\"line\">--end--</div><div class=\"line\">-[FYThread dealloc]</div></pre></td></tr></table></figure>\n<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">runloop源码</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">thread保活c语言版本</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85\" target=\"_blank\" rel=\"external\">thread 保活</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用钩子实现了对字典和数组的赋值的校验，顺便随手撸了一个简单的<code>jsonToModel</code>,<code>iOS</code>除了<code>runtime</code>还有一个东西的叫做<code>runloop</code>，各位看官老爷一定都有了解，那么今天这篇文章初识一下<code>runloop</code>。</p>\n<h3 id=\"什么是runloop\"><a href=\"#什么是runloop\" class=\"headerlink\" title=\"什么是runloop\"></a>什么是runloop</h3><p>简单来讲<code>runloop</code>就是一个循环，我们写的程序，一般没有循环的话，执行完就结束了，那么我们手机上的APP是如何一直运行不停止的呢？APP就是用到了<code>runloop</code>，保证程序一直运行不退出，在需要处理事件的时候处理事件，不处理事件的时候进行休眠，跳出循环程序就结束。用伪代码实现一个<code>runloop</code>其实是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int ret = 0;</div><div class=\"line\">do &#123;</div><div class=\"line\">    //睡眠中等待消息</div><div class=\"line\">    int messgae = sleep_and_wait();</div><div class=\"line\">    //处理消息</div><div class=\"line\">    ret = process_message(messgae);</div><div class=\"line\">&#125; while (ret == 0);</div></pre></td></tr></table></figure>\n<h3 id=\"获取runloop\"><a href=\"#获取runloop\" class=\"headerlink\" title=\"获取runloop\"></a>获取runloop</h3><p>iOS中有两套可以获取runloop代码，一个是<code>Foundation</code>、一个是<code>Core Foundation</code>。<br><code>Foundation</code>其实是对<code>Core Foundation</code>的一个封装，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSRunLoop * runloop1 = [NSRunLoop currentRunLoop];</div><div class=\"line\">NSRunLoop *mainloop1 = [NSRunLoop mainRunLoop];</div><div class=\"line\"></div><div class=\"line\">CFRunLoopRef runloop2= CFRunLoopGetCurrent();</div><div class=\"line\">CFRunLoopRef mainloop2 = CFRunLoopGetMain();</div><div class=\"line\">NSLog(@&quot;%p %p %p %p&quot;,runloop1,mainloop1,runloop2,mainloop2);</div><div class=\"line\">NSLog(@&quot;%@&quot;,runloop1);</div><div class=\"line\">//打印</div><div class=\"line\">runlopp1:0x600001bc58c0 </div><div class=\"line\">mainloop1:0x600001bc58c0 </div><div class=\"line\">runloop2:0x6000003cc300 </div><div class=\"line\">mainloop1:0x6000003cc300</div><div class=\"line\"></div><div class=\"line\">runloop1:&lt;CFRunLoop 0x6000003cc300 [0x10b2e9ae8]&gt;.....</div></pre></td></tr></table></figure>\n<p><code>runloop1</code>和<code>mainloop1</code>地址一致，说明当前的<code>runloop</code>是<code>mainrunloop</code>,<code>runloop1</code>作为对象输出的结果其实也是<code>runloop2</code>的地址，证明<code>Foundation runloop</code>是对<code>Core Foundation</code>的一个封装。</p>\n<p><code>RunLoop</code>底层我们猜测应该是结构体，我们都了解到其实<code>OC</code>就是封装了<code>c/c++</code>，那么c厉害之处就是指针和结构体基本解决常用的所有东西。我们窥探一下<code>runloop</code>的真是模样，通过<code>CFRunLoopRef *runloop = CFRunLoopGetMain();</code>查看<code>CFRunloop</code>是<code>typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</code>，我们常用的<code>CFRunLoopRef</code>是<code>__CFRunLoop *</code>类型的，那么再在<a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">源码(可以下载最新的源码)</a>中搜索一下 <code>struct __CFRunLoop {</code>在<code>runloop.c 637行</code>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t\t\t/* model list 锁 */</div><div class=\"line\">    __CFPort _wakeUpPort;\t\t\t// 接受 CFRunLoopWakeUp的端口</div><div class=\"line\">    Boolean _unused;//是否使用</div><div class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</div><div class=\"line\">    pthread_t _pthread; //线程</div><div class=\"line\">    uint32_t _winthread;//win线程</div><div class=\"line\">    CFMutableSetRef _commonModes; //modes</div><div class=\"line\">    CFMutableSetRef _commonModeItems; //modeItems</div><div class=\"line\">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class=\"line\">    CFMutableSetRef _modes; //所有的modes</div><div class=\"line\">    struct _block_item *_blocks_head; //待执行的block列表头部</div><div class=\"line\">    struct _block_item *_blocks_tail; //待执行的block 尾部</div><div class=\"line\">    CFAbsoluteTime _runTime; //runtime</div><div class=\"line\">    CFAbsoluteTime _sleepTime; //sleeptime</div><div class=\"line\">    CFTypeRef _counterpart; //</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>经过简化之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoop &#123;</div><div class=\"line\">    pthread_t _pthread; //线程</div><div class=\"line\">    CFMutableSetRef _commonModes; //modes</div><div class=\"line\">    CFMutableSetRef _commonModeItems; //modeItems</div><div class=\"line\">    CFRunLoopModeRef _currentMode; //当前的mode</div><div class=\"line\">    CFMutableSetRef _modes; //所有的modes</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><code>runloop</code>中包含一个线程<code>_pthread</code>，一一对应的</li>\n<li><code>CFMutableSetRef _modes</code>可以有多个<code>mode</code></li>\n<li><code>CFRunLoopModeRef _currentMode</code>当前<code>mode</code>只能有一个</li>\n</ol>\n<p>那么mode里边有什么内容呢？我们猜测他应该和<code>runloop</code>类似，在源码中搜索<code>CFRuntimeBase _base</code>看到在<code>runloop.c  line 524</code>看到具体的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFRuntimeBase _base;</div><div class=\"line\">    pthread_mutex_t _lock;\t/* must have the run loop locked before locking this */</div><div class=\"line\">    CFStringRef _name;</div><div class=\"line\">    Boolean _stopped;</div><div class=\"line\">    char _padding[3];</div><div class=\"line\">    CFMutableSetRef _sources0;</div><div class=\"line\">    CFMutableSetRef _sources1;</div><div class=\"line\">    CFMutableArrayRef _observers;</div><div class=\"line\">    CFMutableArrayRef _timers;</div><div class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class=\"line\">    __CFPortSet _portSet;</div><div class=\"line\">    CFIndex _observerMask;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    dispatch_source_t _timerSource;</div><div class=\"line\">    dispatch_queue_t _queue;</div><div class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class=\"line\">    Boolean _dispatchTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">    mach_port_t _timerPort;</div><div class=\"line\">    Boolean _mkTimerArmed;</div><div class=\"line\">#endif</div><div class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</div><div class=\"line\">    DWORD _msgQMask;</div><div class=\"line\">    void (*_msgPump)(void);</div><div class=\"line\">#endif</div><div class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</div><div class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>经过简化之后是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __CFRunLoopMode &#123;</div><div class=\"line\">    CFStringRef _name;//当前mode的名字</div><div class=\"line\">    CFMutableSetRef _sources0;//souces0</div><div class=\"line\">    CFMutableSetRef _sources1;//sources1</div><div class=\"line\">    CFMutableArrayRef _observers;//observers</div><div class=\"line\">    CFMutableArrayRef _timers;//timers</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一个<code>mode</code>可以有多个<code>timer</code>、<code>souces0</code>、<code>souces1</code>、<code>observers</code>、<code>timers</code><br>那么使用图更直观的来表示：</p>\n<p><img src=\"../images/9-1.png\" alt=\"\"></p>\n<p>一个<code>runloop</code>包含多个<code>mode</code>，但是同时只能运行一个<code>mode</code>，这点和大家开车的驾驶模式类似，运动模式和环保模式同时只能开一个模式，不能又运动又环保，明显相悖。多个<code>mode</code>被隔离开有点是处理事情更专一，不会因为多个同时处理事情造成卡顿或者资源竞争导致的一系列问题。</p>\n<h4 id=\"souces0\"><a href=\"#souces0\" class=\"headerlink\" title=\"souces0\"></a>souces0</h4><ul>\n<li>触摸事件</li>\n<li>performSelector:onThread:</li>\n</ul>\n<p>测试下点击事件处理源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);//此处断点</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">(LLDB) bt //输出当前调用栈</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">  * frame #0: 0x000000010c5bb66d CFRunloop`::-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</div><div class=\"line\">    frame #1: 0x0000000110685a09 UIKitCore`forwardTouchMethod + 353</div><div class=\"line\">    frame #2: 0x0000000110685897 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 49</div><div class=\"line\">    frame #3: 0x0000000110694c48 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1869</div><div class=\"line\">    frame #4: 0x00000001106965d2 UIKitCore`-[UIWindow sendEvent:] + 4079</div><div class=\"line\">    frame #5: 0x0000000110674d16 UIKitCore`-[UIApplication sendEvent:] + 356</div><div class=\"line\">    frame #6: 0x0000000110745293 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 3232</div><div class=\"line\">    frame #7: 0x0000000110747bb9 UIKitCore`__handleEventQueueInternal + 5911</div><div class=\"line\">    frame #8: 0x000000010d8eabe1 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17</div><div class=\"line\">    frame #9: 0x000000010d8ea463 CoreFoundation`__CFRunLoopDoSources0 + 243</div><div class=\"line\">    frame #10: 0x000000010d8e4b1f CoreFoundation`__CFRunLoopRun + 1231</div><div class=\"line\">    frame #11: 0x000000010d8e4302 CoreFoundation`CFRunLoopRunSpecific + 626</div><div class=\"line\">    frame #12: 0x0000000115ddc2fe GraphicsServices`GSEventRunModal + 65</div><div class=\"line\">    frame #13: 0x000000011065aba2 UIKitCore`UIApplicationMain + 140</div><div class=\"line\">    frame #14: 0x000000010c5bb760 CFRunloop`main(argc=1, argv=0x00007ffee3643f68) at main.m:14:13</div><div class=\"line\">    frame #15: 0x000000010f1cb541 libdyld.dylib`start + 1</div><div class=\"line\">    frame #16: 0x000000010f1cb541 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>\n<p><code>#1</code>看到现在是在队列queue = ‘com.apple.main-thread’中，<code>#10</code> <code>Runloop</code>启动，<code>#9</code>进入到<code>__CFRunLoopDoSources0</code>,最终<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code>调用了<code>__handleEventQueueInternal</code>-&gt;<code>[UIApplication sendEvent:]</code>-&gt;<code>[UIWindow sendEvent:]</code>-&gt;<code>[UIWindow _sendTouchesForEvent:]</code>-&gt;<code>[UIResponder touchesBegan:withEvent:]</code>-&gt;<code>-[ViewController touchesBegan:withEvent:](self=0x00007fc69ec087e0, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00006000012a01b0) at ViewController.mm:22:2</code>，可以看到另外一个知识点，手势的传递是从上往下的，顺序是<code>UIApplication -&gt; UIWindow -&gt; UIResponder -&gt; ViewController</code>。</p>\n<h4 id=\"Source1\"><a href=\"#Source1\" class=\"headerlink\" title=\"Source1\"></a>Source1</h4><ul>\n<li>基于Port的线程间通信</li>\n<li>系统事件捕捉</li>\n</ul>\n<h4 id=\"Timers\"><a href=\"#Timers\" class=\"headerlink\" title=\"Timers\"></a>Timers</h4><ul>\n<li>NSTimer</li>\n<li>performSelector:withObject:afterDelay:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">\ttimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">\tstatic int count = 5;</div><div class=\"line\">\tdispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class=\"line\">\tdispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;-------：%d \\n&quot;,count++);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_resume(timer);</div><div class=\"line\">\t//log</div><div class=\"line\">\t(lldb) bt</div><div class=\"line\">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</div><div class=\"line\">  * frame #0: 0x0000000101f26457 CFRunloop`::__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=0x0000000101f28100) at ViewController.mm:72:33</div><div class=\"line\">    frame #1: 0x0000000104ac2db5 libdispatch.dylib`_dispatch_client_callout + 8</div><div class=\"line\">    frame #2: 0x0000000104ac5c95 libdispatch.dylib`_dispatch_continuation_pop + 552</div><div class=\"line\">    frame #3: 0x0000000104ad7e93 libdispatch.dylib`_dispatch_source_invoke + 2249</div><div class=\"line\">    frame #4: 0x0000000104acfead libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1073</div><div class=\"line\">    frame #5: 0x00000001032568a9 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</div><div class=\"line\">    frame #6: 0x0000000103250f56 CoreFoundation`__CFRunLoopRun + 2310</div><div class=\"line\">    frame #7: 0x0000000103250302 CoreFoundation`CFRunLoopRunSpecific + 626</div></pre></td></tr></table></figure>\n<p>最终进入函数<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>调用了<a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a>的<code>_dispatch_main_queue_callback_4CF</code>函数，具体实现有兴趣的大佬可以看下源码的实现。</p>\n<h4 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h4><ul>\n<li>用于监听RunLoop的状态</li>\n<li>UI刷新（BeforeWaiting）</li>\n<li>Autorelease pool（BeforeWaiting）</li>\n</ul>\n<p><code>Mode</code>类型都多个,系统暴露在外的就两个，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CF_EXPORT const CFRunLoopMode kCFRunLoopDefaultMode;</div><div class=\"line\">CF_EXPORT const CFRunLoopMode kCFRunLoopCommonModes;</div></pre></td></tr></table></figure>\n<p>那么这两个Mode都是在什么情况下运行的呢？</p>\n<ol>\n<li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>\n<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>\n</ol>\n<p>进入到某个<code>Mode</code>，处理事情也应该有先后顺序和休息的时间，那么现在需要一个状态来表示此时此刻的<code>status</code>，系统已经准备了<code>CFRunLoopActivity</code>来表示当前的状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入loop</div><div class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理timers</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sourcs</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</div><div class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//即将从休眠中唤醒</div><div class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),//即将退出</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU//所有状态</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>1UL</code>表示无符号长整形数字<code>1</code>，再次看到这个<code>(1UL &lt;&lt; 1)</code>我么猜测用到了<a href=\"https://juejin.im/post/5d2bcf3df265da1b67213d69\" target=\"_blank\" rel=\"external\">位域或者联合体</a>，达到省空间的目的。<code>kCFRunLoopAllActivities = 0x0FFFFFFFU</code>转换成二进制就是28个<code>1</code>，再进行<code>mask</code>的时候，所有的值都能取出来。</p>\n<p>现在我们了解到：</p>\n<ol>\n<li><code>CFRunloopRef</code>代表<code>RunLoop</code>的运行模式</li>\n<li>一个<code>Runloop</code>包含若干个<code>Mode</code>,每个<code>Mode</code>包含若干个<code>Source0/Source1/Timer/Obser</code></li>\n<li><code>Runloop</code>启动只能选择一个<code>Mode</code>作为<code>currentMode</code></li>\n<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入</li>\n<li>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>\n<li>如果<code>Mode</code>没有任何<code>Source0/Source1/Timer/Observer</code>，<code>Runloop</code>立马退出。</li>\n</ol>\n<h5 id=\"runloop切换Mode\"><a href=\"#runloop切换Mode\" class=\"headerlink\" title=\"runloop切换Mode\"></a>runloop切换Mode</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopObserverRef obs= CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class=\"line\">    switch (activity) &#123;</div><div class=\"line\">    \tcase kCFRunLoopEntry:&#123;</div><div class=\"line\">    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class=\"line\">    \t\tNSLog(@&quot;即将进入 mode:%@&quot;,m);</div><div class=\"line\">    \t\tCFRelease(m);</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    \t\t</div><div class=\"line\">    \tcase kCFRunLoopExit:</div><div class=\"line\">    \t&#123;</div><div class=\"line\">    \t\tCFRunLoopMode m = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</div><div class=\"line\">    \t\tNSLog(@&quot;即将退出 mode:%@&quot;,m);</div><div class=\"line\">    \t\tCFRelease(m);</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    \tdefault:</div><div class=\"line\">    \t\tbreak;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tCFRunLoopAddObserver(CFRunLoopGetMain(), obs, kCFRunLoopCommonModes);</div><div class=\"line\">\tCFRelease(obs);</div><div class=\"line\">\t</div><div class=\"line\">\t//当滑动tb的时候log</div><div class=\"line\">\t</div><div class=\"line\">即将退出 mode:kCFRunLoopDefaultMode</div><div class=\"line\">即将进入 mode:UITrackingRunLoopMode</div><div class=\"line\">即将退出 mode:UITrackingRunLoopMode</div><div class=\"line\">即将进入 mode:kCFRunLoopDefaultMode</div></pre></td></tr></table></figure>\n<p>当<code>runloop</code>切换<code>mode</code>的时候，会退出当前<code>kCFRunLoopDefaultMode</code>，加入到其他的<code>UITrackingRunLoopMode</code>，当前<code>UITrackingRunLoopMode</code>完成之后再退出之后再加入到<code>kCFRunLoopDefaultMode</code>。</p>\n<p>我们再探究下<code>runloop</code>的循环的状态到底是怎样来变更的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">//\t//获取loop</div><div class=\"line\">\tCFRunLoopRef ref = CFRunLoopGetMain();</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tCFRunLoopObserverRef obs = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, callback, NULL);</div><div class=\"line\">\t//添加监听</div><div class=\"line\">\tCFRunLoopAddObserver(ref, obs, CFRunLoopCopyCurrentMode(ref));</div><div class=\"line\">\tCFRelease(obs);</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">int count = 0;//定义全局变量来计算一个mode中状态切换的统计数据</div><div class=\"line\">void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</div><div class=\"line\">\tprintf(&quot;- &quot;);</div><div class=\"line\">\tcount ++;</div><div class=\"line\">\tprintf(&quot;%d&quot;,count);</div><div class=\"line\">\tswitch (activity) &#123;</div><div class=\"line\">\t\tcase kCFRunLoopEntry:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 \\n&quot;);</div><div class=\"line\">\t\t\tcount = 0;</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopExit:</div><div class=\"line\">\t\t\tprintf(&quot;即将退出 \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopAfterWaiting:</div><div class=\"line\">\t\t\tprintf(&quot;即将从休眠中唤醒 \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeTimers:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入处理 timers \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeSources:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 sources \\n&quot;);</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tcase kCFRunLoopBeforeWaiting:</div><div class=\"line\">\t\t\tprintf(&quot;即将进入 休眠 \\n&quot;);</div><div class=\"line\">\t\t\tcount = 0;</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t\tdefault:</div><div class=\"line\">\t\t\tbreak;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//点击的时候 会出发loop来处理触摸事件</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">- 4即将进入处理 timers </div><div class=\"line\">- 5即将进入 sources </div><div class=\"line\">- 6即将进入处理 timers </div><div class=\"line\">- 7即将进入 sources </div><div class=\"line\">- 8即将进入处理 timers </div><div class=\"line\">- 9即将进入 sources </div><div class=\"line\">- 10即将进入 休眠 </div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">- 4即将进入处理 timers </div><div class=\"line\">- 5即将进入 sources </div><div class=\"line\">- 6即将进入 休眠 </div><div class=\"line\">- 1即将从休眠中唤醒 </div><div class=\"line\">- 2即将进入处理 timers </div><div class=\"line\">- 3即将进入 sources </div><div class=\"line\">- 4即将进入 休眠</div></pre></td></tr></table></figure>\n<p><code>runloop</code>唤醒之后不是立马处理事件的，而是看看<code>timer</code>有没有事情，然后是<code>sources</code>,发现有触摸事件就处理了，然后又循环查看<code>timer</code>和<code>sources</code>一般循环2次进入休眠状态，处理<code>source</code>之后是循环三次。</p>\n<h5 id=\"RunLoop在不获取的时候不存在-获取才生成\"><a href=\"#RunLoop在不获取的时候不存在-获取才生成\" class=\"headerlink\" title=\"RunLoop在不获取的时候不存在,获取才生成\"></a>RunLoop在不获取的时候不存在,获取才生成</h5><p><code>RunLoop</code>是在主动获取的时候才会生成一个，主线程是系统自己调用生成的，子线程开发者调用，我们看下<code>CFRunLoopGetCurrent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class=\"line\">    CHECK_FOR_FORK();</div><div class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class=\"line\">    if (rl) return rl;</div><div class=\"line\">    return _CFRunLoopGet0(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到到这里相信大家已经对<code>runloop</code>有了基本的认识，那么我们再探究一下底层<code>runloop</code>是怎么运转的。</p>\n<p>首先看官方给的图：</p>\n<p><img src=\"../images/9-2.png\" alt=\"\"><br>那我又整理了一个表格来更直观的了解状态运转<br>|步骤|任务|<br>|:-:|:-:|<br>|1|通知Observers:进入Loop|<br>|2|通知Observers:即将处理Timers|<br>|3|通知Observers:即将处理Sources|<br>|4|处理blocks|<br>|5|处理Source0(可能再处理Blocks)|<br>|6|如果存在Source1，跳转第8步|<br>|7|通知Observers:开始休眠|<br>|8|通知Observers:结束休眠1.处理Timer2.处理GCD Asyn To Main Queue 3.处理Source1|<br>|9|处理Blocks|<br>|10|根据前面的执行结果，决定如何操作1.返回第2步，2退出loop|<br>|11|通知Observers:退出Loop|</p>\n<p>查看<a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">runloop源码</a>中<code>runloop.c</code>2333行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div></pre></td><td class=\"code\"><pre><div class=\"line\">//入口函数</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();</div><div class=\"line\"></div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\trlm-&gt;_stopped = false;</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class=\"line\">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class=\"line\">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class=\"line\">    </div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class=\"line\">    if (rlm-&gt;_queue) &#123;</div><div class=\"line\">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class=\"line\">        if (!modeQueuePort) &#123;</div><div class=\"line\">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    </div><div class=\"line\">    dispatch_source_t timeout_timer = NULL;</div><div class=\"line\">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class=\"line\">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class=\"line\">        seconds = 0.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = 0ULL;</div><div class=\"line\">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class=\"line\">\tdispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</div><div class=\"line\">\ttimeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">        dispatch_retain(timeout_timer);</div><div class=\"line\">\ttimeout_context-&gt;ds = timeout_timer;</div><div class=\"line\">\ttimeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class=\"line\">\ttimeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class=\"line\">\tdispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class=\"line\">\tdispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class=\"line\">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class=\"line\">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class=\"line\">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class=\"line\">        dispatch_resume(timeout_timer);</div><div class=\"line\">    &#125; else &#123; // infinite timeout</div><div class=\"line\">        seconds = 9999999999.0;</div><div class=\"line\">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</div><div class=\"line\">        voucher_t voucherCopy = NULL;</div><div class=\"line\">#endif</div><div class=\"line\">        uint8_t msg_buffer[3 * 1024];</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        mach_msg_header_t *msg = NULL;</div><div class=\"line\">        mach_port_t livePort = MACH_PORT_NULL;</div><div class=\"line\">#endif</div><div class=\"line\">\t__CFPortSet waitSet = rlm-&gt;_portSet;</div><div class=\"line\"></div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">//通知即将处理Timers</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">//通知即将处理Sources</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">//处理Blocks</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">//处理Source0</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">\t//处理Block</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">\t&#125;</div><div class=\"line\">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class=\"line\"></div><div class=\"line\">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">\t//y判断是否有Source1</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class=\"line\">\t//有则去 handle_msg</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">#endif</div><div class=\"line\">        &#125;</div><div class=\"line\">        didDispatchPortLastTime = false;</div><div class=\"line\">//即将进入休眠</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">\t//开始休眠</div><div class=\"line\">\t__CFRunLoopSetSleeping(rl);</div><div class=\"line\"></div><div class=\"line\">    __CFPortSetInsert(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">\t__CFRunLoopModeUnlock(rlm);</div><div class=\"line\">\t__CFRunLoopUnlock(rl);</div><div class=\"line\"></div><div class=\"line\">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</div><div class=\"line\"></div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\"></div><div class=\"line\">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">            //等待消息来唤醒当前线程</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">\t\t\t</div><div class=\"line\">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">          (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class=\"line\">                if (rlm-&gt;_timerFired) &#123;</div><div class=\"line\"></div><div class=\"line\">                    rlm-&gt;_timerFired = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Go ahead and leave the inner loop.</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">        if (kCFUseCollectableAllocator) &#123;</div><div class=\"line\">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class=\"line\">        &#125;</div><div class=\"line\">        msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">#endif</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopLock(rl);</div><div class=\"line\">        __CFRunLoopModeLock(rlm);</div><div class=\"line\"></div><div class=\"line\">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</div><div class=\"line\"></div><div class=\"line\">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\"></div><div class=\"line\">        // user callouts now OK again</div><div class=\"line\">\t__CFRunLoopUnsetSleeping(rl);</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class=\"line\">\t//结束休眠</div><div class=\"line\">\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">//标签 handle_msg</div><div class=\"line\">        handle_msg:;</div><div class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class=\"line\">\t\t</div><div class=\"line\">        if (MACH_PORT_NULL == livePort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class=\"line\">            // handle nothing</div><div class=\"line\">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class=\"line\">\t\t\t</div><div class=\"line\">        &#125;</div><div class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class=\"line\">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class=\"line\">\t//被timer唤醒</div><div class=\"line\">\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t//被GCD换醒</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class=\"line\">            __CFRunLoopModeUnlock(rlm);</div><div class=\"line\">            __CFRunLoopUnlock(rl);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class=\"line\">\t//处理GCD</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class=\"line\">            __CFRunLoopLock(rl);</div><div class=\"line\">            __CFRunLoopModeLock(rlm);</div><div class=\"line\">            sourceHandledThisLoop = true;</div><div class=\"line\">            didDispatchPortLastTime = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">\t//处理Source1</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class=\"line\">\t\t\t</div><div class=\"line\">            voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release);</div><div class=\"line\"></div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">            if (rls) &#123;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">\t\tmach_msg_header_t *reply = NULL;</div><div class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">\t\tif (NULL != reply) &#123;</div><div class=\"line\">\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class=\"line\">\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t    &#125;</div><div class=\"line\">            </div><div class=\"line\">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //处理bBlock</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">//设置返回值</div><div class=\"line\">\tif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">\t&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\t    rlm-&gt;_stopped = false;</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunFinished;</div><div class=\"line\">\t&#125;</div><div class=\"line\">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class=\"line\">        voucher_mach_msg_revert(voucherState);</div><div class=\"line\">        os_release(voucherCopy);</div><div class=\"line\">#endif</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    if (timeout_timer) &#123;</div><div class=\"line\">        dispatch_source_cancel(timeout_timer);</div><div class=\"line\">        dispatch_release(timeout_timer);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        free(timeout_context);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过及进一步精简</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\">//入口函数</div><div class=\"line\">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class=\"line\">    uint64_t startTSR = mach_absolute_time();</div><div class=\"line\"></div><div class=\"line\">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">        __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\trlm-&gt;_stopped = false;</div><div class=\"line\">\treturn kCFRunLoopRunStopped;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Boolean didDispatchPortLastTime = true;</div><div class=\"line\">    int32_t retVal = 0;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class=\"line\">//通知即将处理Timers</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class=\"line\">//通知即将处理Sources</div><div class=\"line\">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</div><div class=\"line\">\t\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class=\"line\">//处理Blocks</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">//处理Source0</div><div class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class=\"line\">        if (sourceHandledThisLoop) &#123;</div><div class=\"line\">\t//处理Block</div><div class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">\t&#125;</div><div class=\"line\">            msg = (mach_msg_header_t *)msg_buffer;</div><div class=\"line\">\t//y判断是否有Source1</div><div class=\"line\">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</div><div class=\"line\">\t//有则去 handle_msg</div><div class=\"line\">                goto handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">//即将进入休眠</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class=\"line\">\t//开始休眠</div><div class=\"line\">\t__CFRunLoopSetSleeping(rl);</div><div class=\"line\">        do &#123;</div><div class=\"line\">    //等待消息来唤醒当前线程</div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</div><div class=\"line\">        &#125; while (1);</div><div class=\"line\">#else</div><div class=\"line\">\tif (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class=\"line\">\t//结束休眠</div><div class=\"line\">\t\t__CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class=\"line\">//标签 handle_msg</div><div class=\"line\">        handle_msg:;</div><div class=\"line\">\t//被timer唤醒</div><div class=\"line\">\t\t\tCFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">#if USE_MK_TIMER_TOO</div><div class=\"line\">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class=\"line\">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#endif</div><div class=\"line\">\t//被GCD换醒</div><div class=\"line\">        else if (livePort == dispatchPort) &#123;</div><div class=\"line\">\t//处理GCD</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class=\"line\">\t//处理Source1</div><div class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class=\"line\">            // Restore the previous voucher</div><div class=\"line\">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //处理bBlock</div><div class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm);</div><div class=\"line\">        </div><div class=\"line\">    //设置返回值</div><div class=\"line\">\tif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class=\"line\">            retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">\t&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class=\"line\">            __CFRunLoopUnsetStopped(rl);</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (rlm-&gt;_stopped) &#123;</div><div class=\"line\">\t    rlm-&gt;_stopped = false;</div><div class=\"line\">\t    retVal = kCFRunLoopRunStopped;</div><div class=\"line\">\t&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class=\"line\">\t    retVal = kCFRunLoopRunFinished;</div><div class=\"line\">\t&#125;</div><div class=\"line\">    &#125; while (0 == retVal);</div><div class=\"line\">    return retVal;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>精简到这里基本都能看懂了，还写了很多注释，基本和上面整理的表格一致。<br>这里的线程休眠<code>__CFRunLoopServiceMachPort</code>是调用内核函数<a href=\"http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html\" target=\"_blank\" rel=\"external\">mach_msg()</a>进行休眠，和我们平时<code>while(1)</code>大不同，<code>while(1)</code>叫死循环，其实系统每时每刻都在判断是否符合条件，耗费很高的CPU，内核则不同，Mach内核提供面向消息，基于基础的进程间通信。</p>\n<h4 id=\"保活机制\"><a href=\"#保活机制\" class=\"headerlink\" title=\"保活机制\"></a>保活机制</h4><p>一个程序运行完毕结束了就死掉了，<code>timer</code>和变量也一样，运行完毕就结束了，那么我们怎么可以保证<code>timer</code>一直活跃和线程不结束呢？</p>\n<h5 id=\"timer保活和多mode运行\"><a href=\"#timer保活和多mode运行\" class=\"headerlink\" title=\"timer保活和多mode运行\"></a>timer保活和多mode运行</h5><p><code>timer</code>可以添加到<code>self</code>的属性保证一直活着，只要<code>self</code>不死，<code>timer</code>就不死。<code>timer</code>默认是添加到<code>NSDefaultRunLoopMode</code>模式中，因为<code>RunLoop</code>同时运行只能有一个模式，那么在滑动<code>scroller</code>的时候怎<code>Timer</code>会卡顿停止直到再次切换回来，那么如何保证同时两个模式都可以运行呢？<br><code>Foundation</code>提供了一个API<code>(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode</code>添加上，<code>mode</code>值为<code>NSRunLoopCommonModes</code>可以保证同时兼顾2种模式。</p>\n<p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int i = 0;</div><div class=\"line\">NSTimer *timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class=\"line\">\tNSLog(@&quot;%d&quot;,++i);</div><div class=\"line\">&#125;];</div><div class=\"line\">//NSRunLoopCommonModes 并不是一个真正的模式，它这还是一个标记</div><div class=\"line\">//timer在设置为common模式下能运行</div><div class=\"line\">//NSRunLoopCommonModes 能在 _commentModes中数组中的模式都可以运行</div><div class=\"line\">//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//默认的模式</div><div class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">\t</div><div class=\"line\">2019-07-23 15:14:31 CFRunloop[62358:34093079] 1</div><div class=\"line\">2019-07-23 15:14:32 CFRunloop[62358:34093079] 2</div><div class=\"line\">2019-07-23 15:14:33 CFRunloop[62358:34093079] 3</div><div class=\"line\">2019-07-23 15:14:34 CFRunloop[62358:34093079] 4</div><div class=\"line\">2019-07-23 15:14:35 CFRunloop[62358:34093079] 5</div><div class=\"line\">2019-07-23 15:14:36 CFRunloop[62358:34093079] 6</div><div class=\"line\">2019-07-23 15:14:37 CFRunloop[62358:34093079] 7</div><div class=\"line\">2019-07-23 15:14:38 CFRunloop[62358:34093079] 8</div></pre></td></tr></table></figure>\n<p>当滑动的时候<code>timer</code>的时候，<code>timer</code>还是如此丝滑，没有一点停顿。<br>没有卡顿之后我们<code>VC -&gt; dealloc</code>中<code>timer</code>还是在执行，那么需要在<code>dealloc</code>中去下和删除观察者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tCFRunLoopRemoveObserver(CFRunLoopGetMain(), obs, m);</div><div class=\"line\">\tdispatch_source_cancel(timer);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>退出<code>vc</code>之后<code>dealloc</code>照常执行，日志只有<code>-[ViewController dealloc]</code>，而且数字没有继续输出，说明删除观察者和取消<code>source</code>都成功了。</p>\n<p>那么<code>NSRunLoopCommonModes</code>是另外一种模式吗？</p>\n<p>通过源码查看得知，在<code>runloop.c line:1632  line:2608</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</div><div class=\"line\">    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>还有很多地方均可以看出，当是<code>currentMode</code>需要和<code>_mode</code>相等才去执行，当是<code>kCFRunLoopCommonModes</code>的时候，只需要包含<code>curMode</code>即可执行。可见<code>kCFRunLoopCommonModes</code>其实是一个集合，不是某个特定的<code>mode</code>。</p>\n<h5 id=\"线程保活\"><a href=\"#线程保活\" class=\"headerlink\" title=\"线程保活\"></a>线程保活</h5><p>线程为什么需要保活？性能其实很大的瓶颈是在于空间的申请和释放，当我们执行一个任务的时候创建了一个线程，任务结束就释放掉该线程，如果任务频率比较高，那么一个一直活跃的线程来执行我们的任务就省去申请和释放空间的时间和性能。上边已经讲过了<br><code>runloop</code>需要有任务才能不退出，总不可能直接让他执行<code>while(1)</code>吧，这种方法明显不对的，由源码得知，当有监测端口的时候，也不会退出，也不会影响应能。所以在线程初始化的时候使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[NSRunLoop currentRunLoop] addPort:[NSPort port] </div><div class=\"line\">                            forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>\n<p>来保活。<br>在主线程使用是没有意义的，系统已经在APP启动的时候进行了调用，则已经加入到全局的字典中了。</p>\n<p>验证线程保活</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,strong) FYThread *thread;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class=\"line\">\t_thread.name = @&quot;test thread&quot;;</div><div class=\"line\">\t[_thread start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">//添加端口</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] run];</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">//注释掉添加端口代码</div><div class=\"line\">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">--end--</div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">执行完毕了子线程</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//注释放开的时候点击触发log</div><div class=\"line\">&lt;FYThread: 0x6000013a9540&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\"></div><div class=\"line\">-[ViewController touchesBegan:withEvent:]</div><div class=\"line\">执行完毕了子线程</div><div class=\"line\">我还活着呢-&gt;&lt;FYThread: 0x6000017e5c80&gt;&#123;number = 3, name = test thread&#125;</div></pre></td></tr></table></figure>\n<p><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port]forMode:NSDefaultRunLoopMode]</code>添加端口注释掉，直接执行了<code>--end--</code>，线程虽然<code>strong</code>强引用，但是<code>runloop</code>已经退出了，所以函数<code>alive</code>没有执行，不注释的话，<code>alive</code>还会执行，<code>end</code>一直不会执行，因为进入了<code>runloop</code>，而且没有退出，代码就不会向下执行。</p>\n<p>那我们测试下该线程声明周期多长？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tself.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</div><div class=\"line\">\t_thread.name = @&quot;test thread&quot;;</div><div class=\"line\">\t[_thread start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\t/*</div><div class=\"line\">\t If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</div><div class=\"line\">\t */</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] run];</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//返回上页</div><div class=\"line\">- (IBAction)popVC:(id)sender &#123;</div><div class=\"line\">\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">\tCFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">&lt;FYThread: 0x600003394780&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">-[ViewController stop]</div></pre></td></tr></table></figure>\n<p>拥有该线程的是<code>VC</code>，点击<code>pop</code>的时候，但是<code>VC</code>和<code>thread</code>没释放掉,好像<code>thread</code>和<code>VC</code>建立的循环引用，当<code>self.thread=[[FYThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code>注释了，则<code>VC</code>可以进行正常释放。</p>\n<p>通过测试了解到<br>这个线程达到了<strong>永生</strong>，就是你杀不死他，简直了<strong>死待</strong>。查找了不少资料才发现官方文档才是最稳的。有对这句<code>[[NSRunLoop currentRunLoop] run]</code>的解释</p>\n<blockquote>\n<p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>\n</blockquote>\n<p>就是系统写了以一个死循环但是没有阻止他的参数，相当于一直在循环调用<br><code>runMode:beforeDate:</code>，那么该怎么办呢？<br>官方文档给出了解决方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">BOOL shouldKeepRunning = YES; // global</div><div class=\"line\">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure>\n<p>将代码改成下面的成功将<strong>死待</strong>杀死了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test &#123;</div><div class=\"line\">\t[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">\t//获取obs</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\tNSLog(@&quot;--start--&quot;);</div><div class=\"line\">\tself.shouldKeepRunning = YES;//默认运行</div><div class=\"line\">\tNSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">\twhile (_shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class=\"line\">\tNSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelector:@selector(alive) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">\tNSLog(@&quot;执行完毕了子线程&quot;);//不执行 因为子线程保活了 不会执行完毕</div><div class=\"line\">&#125;</div><div class=\"line\">//返回上页</div><div class=\"line\">- (IBAction)popVC:(id)sender &#123;</div><div class=\"line\">\tself.shouldKeepRunning = NO;</div><div class=\"line\">\t[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">//测试子线程是否还活着</div><div class=\"line\">- (void)alive&#123;</div><div class=\"line\">\tNSLog(@&quot;我还活着呢-&gt;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">\tCFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self performSelectorOnMainThread:@selector(pop) withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)pop&#123;</div><div class=\"line\">\t[self.navigationController popViewControllerAnimated:YES];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">&lt;FYThread: 0x600002699fc0&gt;&#123;number = 3, name = test thread&#125;</div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">--end--</div><div class=\"line\">-[ViewController dealloc]</div><div class=\"line\">-[FYThread dealloc]</div></pre></td></tr></table></figure>\n<p>点击<code>popVC:</code>首先将<code>self.shouldKeepRunning = NO</code>，然后<strong>子线程</strong>执行<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，然后在<strong>主线程</strong>执行<code>pop</code>函数，最终返回上级页面而且成功杀死<code>VC</code>和<strong>死待</strong>。<br>当然这个<strong>死待</strong>其实也是有用处的，当使用单例模式作为下载器的时候使用<strong>死待</strong>也没问题。这样子处理比较复杂，我们可以放在<code>VC</code>的<code>dealloc</code>看看是否能成功。<br>关键函数稍微更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//停止子线程线程</div><div class=\"line\">- (void)stop&#123;</div><div class=\"line\">    if (self.thread == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">        [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)stopThread&#123;</div><div class=\"line\">    self.shouldKeepRunning = NO;</div><div class=\"line\">    CFRunLoopStop(CFRunLoopGetCurrent());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">    [self stop];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当点击返回按钮<code>VC</code>和线程都没死，原来他们形成了强引用无法释放,就是<code>VC</code>始终无法执行<code>dealloc</code>。将函数改成<code>block</code>实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">__weak typeof(self) __weakSelf = self;</div><div class=\"line\">self.thread = [[FYThread alloc]initWithBlock:^&#123;</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    NSLog(@&quot;--start--&quot;);</div><div class=\"line\">    __weakSelf.shouldKeepRunning = YES;//默认运行</div><div class=\"line\">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class=\"line\">    while (__weakSelf &amp;&amp; __weakSelf.shouldKeepRunning  )&#123;</div><div class=\"line\">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class=\"line\">    &#125;;</div><div class=\"line\">    NSLog(@&quot;--end--&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>测试下崩溃了，崩溃到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (__weakSelf.shouldKeepRunning  )&#123;</div><div class=\"line\">        [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//崩溃的地方</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>怎么想感觉不对劲啊，怎么会不行呢？<code>VC</code>销毁的时候调用子线程<code>stop</code>,最后打断点发现到了崩溃的地方<code>self</code>已经不存在了，说明是异步执行的，往前查找使用异步的函数最后出现在了<code>[self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</code>，表示不用等待<code>stopThread</code>函数执行时间，直接向前继续执行，所以<code>VC</code>释放掉了，<code>while (__weakSelf.shouldKeepRunning )</code>是<code>true</code>，还真进去了，访问了<code>exe_bad_access</code>，所以改成<code>while (__weakSelf&amp;&amp;__weakSelf.shouldKeepRunning )</code>再跑一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">--start--</div><div class=\"line\">-[ViewController stop]</div><div class=\"line\">-[ViewController dealloc]</div><div class=\"line\">--end--</div><div class=\"line\">-[FYThread dealloc]</div></pre></td></tr></table></figure>\n<p>如牛奶般丝滑，解决了释放问题，也解决了复杂操作。本文章所有代码均在底部链接可以下载。<br>使用这个思路自己封装了一个简单的功能，大家可以自己封装一下然后对比一下我的思路，说不定有惊喜！</p>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"https://opensource.apple.com/tarballs/CF/\" target=\"_blank\" rel=\"external\">runloop源码</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85%E7%9A%84c%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">thread保活c语言版本</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/OC%E6%9C%AC%E8%B4%A8/day14-CFRunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%B0%81%E8%A3%85\" target=\"_blank\" rel=\"external\">thread 保活</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  KVO和KVC本质与联系 --(3)","date":"2019-12-01T03:13:58.000Z","_content":"我们知道实例实际是存储了成员变量的值和指向类的`isa`指针，`class`对象和`meta-class`对象包含 `isa`、`superclass`和`class_rw_t`这几种结构体，只是数据不一样，`isa`需要`ISA_MASK`&之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。\n \n### KVO本质\n \n 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。\n \n ```\n \n #import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface FYPerson : NSObject\n\n@property (nonatomic,assign) NSInteger age;\n@end\n\nNS_ASSUME_NONNULL_END\n\n#import \"ViewController.h\"\n#import \"FYPerson.h\"\n\n@interface ViewController ()\n@property (nonatomic,strong)FYPerson *person;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.person=[FYPerson new];\n\tself.person.age = 10;\n\t[self.person addObserver:self\n    \t\t\t  forKeyPath:@\"age\"\n    \t\t\t\t options:NSKeyValueObservingOptionNew\n    \t\t\t\t context:nil];\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tself.person.age += 1;\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n\tNSLog(@\"监听到了age变化： %@\",change);\n}\n-(void)dealloc{\n\t[self.person removeObserver:self forKeyPath:@\"age\"];\n}\n\n@end\n\n//下边是输出结果\n监听到了age变化： {\n    kind = 1;\n    new = 12;\n    old = 11;\n}\n ```\n \n \n 从上述代码可以看出，添加监听之后，当值改变时，会触发函数`observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context`。\n#### 触发条件\n \n ```\n - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n//\tself.person.age += 1;\n\t[self.person willChangeValueForKey:@\"age\"];\n\t[self.person didChangeValueForKey:@\"age\"];\n}\n ```\n \n 当把`age`具体值的改变，变成手动调用`willChangeValueForKey`和`didChangeValueForKey`的时候，结果如下：\n \n ```\n  监听到了age变化： {\n    kind = 1;\n    new = 10;\n    old = 10;\n}\n ```\n \n `new`和`old`的值竟然一样，经测试只有同时先后调用`willChangeValueForKey`和`didChangeValueForKey`，会触发回调函数`observeValueForKeyPath`，由此可知触发条件是`willChangeValueForKey`和`didChangeValueForKey`配合使用。\n \n \n \n#### 探寻KVO底层实现原理\n通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。\n我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。\n说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。\nKVO底层实现分析\n首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：\n\n```\n@interface ViewController ()\n@property (nonatomic,strong)FYPerson *person;\n@property (nonatomic,strong)FYPerson *person2;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.person=[FYPerson new];\n\tself.person2 =[FYPerson new];\n\tself.person.age = 10;\n\t[self.person addObserver:self\n\t\t\t\t\t  forKeyPath:@\"age\"\n\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld\n\t\t\t\t\t\t context:nil];\n Class superclass = NSStringFromClass( class_getSuperclass(NSClassFromString(@\"NSKVONotifying_FYPerson\")));\nClass NSKVONotifying_FYPerson = objc_getClass(\"NSKVONotifying_FYPerson\");\n    fy_objc_class* NSKVONotifying_FYPerson_class = (__bridge fy_objc_class *)NSKVONotifying_FYPerson;\n\t\t\t\t\t\t //此处打断点\n\n//p 命令输出isa指针 \n(lldb) p self.person2->isa\n(Class) $0 = FYPerson\n(lldb) p self.person->isa\n(Class) $1 = NSKVONotifying_FYPerson\n\n(lldb) p superclass\n(Class) $0 = FYPerson\n\n(lldb) p NSKVONotifying_FYPerson_class->superclass\n(Class) $4 = FYPerson\n}\n\n```\n\n从输出的isa指针看来，经过`【person addObserver】`之后，`person`的`isa`指针指向了`NSKVONotifying_FYPerson`,而`person2`的`isa`是`FYPerson`，可以看出系统是对`instance`对象的`isa`进行了赋值操作。通过`p NSKVONotifying_FYPerson_class->superclass==FYPerson`可以看出isa是指向了子类，那么子类`NSKVONotifying_FYPerson`到底做了那些事情呢？\n\n看下边代码查看函数isa改变过程：\n\n```\n\tself.person=[FYPerson new];\n\tself.person2 =[FYPerson new];\n\tself.person.age = 10;\n//打断点 输出 po [_person methodForSelector:@selector(setAge:)]\n\t[self.person addObserver:self\n\t\t\t\t\t  forKeyPath:@\"age\"\n\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld\n\t\t\t\t\t\t context:nil];\n//打断点 输出 po [_person methodForSelector:@selector(setAge:)]\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x000000010666b720\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x00000001069c63d2\n\n//查看IMP指针对应地址和内容\n(lldb) p (IMP)0x000000010666b720\n(IMP) $2 = 0x000000010666b720 (day03-KVO本质`::-[FYPerson setAge:](int) at FYPerson.h:14)\n(lldb) p (IMP)0x00000001069c63d2\n(IMP) $3 = 0x00000001069c63d2 (Foundation`_NSSetIntValueAndNotify)\n```\n\n可以看出来两次的函数地址不一致，添加KVO之前是`[FYPerson setAge:]`,添加之后是`(Foundation_NSSetIntValueAndNotify)`。我们将`age`的类型改成`double`，再看一下结果：\n\n```\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x00000001080c4710\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x000000010841f18c\n\n(lldb) p (IMP)0x00000001080c4710\n(IMP) $2 = 0x00000001080c4710 (day03-KVO本质`::-[FYPerson setAge:](double) at FYPerson.h:14)\n(lldb) p (IMP)0x000000010841f18c\n(IMP) $3 = 0x000000010841f18c (Foundation`_NSSetDoubleValueAndNotify)\n```\n\n`age`是`int`的时候添加之后是`Foundation _NSSetIntValueAndNotify`,改成`double`之后，是`Foundation _NSSetDoubleValueAndNotify`。那么我们可以推测`Foundation`框架中还有很多例如`_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify`等等函数。\n运行`nm Foundation | grep ValueAndNotify`结果如下：\n\n```\nnm Foundation  | grep ValueAndNotify\n__NSSetBoolValueAndNotify\n__NSSetCharValueAndNotify\n__NSSetDoubleValueAndNotify\n__NSSetFloatValueAndNotify\n__NSSetIntValueAndNotify\n__NSSetLongLongValueAndNotify\n__NSSetLongValueAndNotify\n__NSSetObjectValueAndNotify\n__NSSetPointValueAndNotify\n__NSSetRangeValueAndNotify\n__NSSetRectValueAndNotify\n__NSSetShortValueAndNotify\n__NSSetSizeValueAndNotify\n```\n#### 另外一种验证方法 \n在macOS中可以使用\n\n```\n//开始记录日志\ninstrumentObjcMessageSends(YES);\n    // Do stuff...\ninstrumentObjcMessageSends(NO);//结束记录日志\n```\n\n如果将`NSObjCMessageLoggingEnabled`环境变量设置为`YES`，则`Objective-C`运行时会将所有已分派的`Objective-C`消息记录到名为`/tmp/msgSends-<pid>`的文件中。每一次运行会生成一个文件，我们进入到该文件内部：\n\n```\n//初始化\n+ FYPerson NSObject initialize\n+ FYPerson NSObject new\n- FYPerson NSObject init\n- FYPerson NSObject addObserver:forKeyPath:options:context:\n- FYPerson NSObject _isKVOA\n\n****\n\n\n//子类设置age [NSKVONotifying_FYPerson setAge:]\n\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:\n- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:\n- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:\n\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:\n\n//will changeValueForKey\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:\n \n//FYPerson 设置age\n- FYPerson FYPerson setAge:\n\n// didChangeValueForKeyOrKeys\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:\n- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath\n\n//找到key 发送 具体的key对应的value 到observe\n\n- NSKVONotifying_FYPerson NSObject valueForKeyPath:\n\n- NSKVONotifying_FYPerson NSObject valueForKey:\n+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:\n-\n+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:\n+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:\n- NSKVONotifying_FYPerson FYPerson age\n+ NSKeyValueMethodGetter NSObject alloc\n- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:\n- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:\n\n\n- NSKVONotifying_FYPerson NSObject respondsToSelector:\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA\n+ FYPerson NSObject class\n+ FYPerson NSObject resolveInstanceMethod:\n+ FYPerson NSObject resolveInstanceMethod:\n\n//数据字典\n+ NSDictionary NSObject self\n+ NSMutableDictionary NSObject self\n- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:\n- NSDictionary NSObject init\n\n// 执行观察者回调函数\n- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:\n\n\n+ Student NSObject alloc\n- Student NSObject init\n- Student NSObject dealloc\n\n\n***//省略一部分代码\n NSKVONotifying_FYPerson NSObject release\n- NSKeyValueChangeDictionary NSObject release\n- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc\n- NSDictionary NSObject dealloc\n- NSKeyValueObservationInfo NSObject release\n- NSKVONotifying_FYPerson NSObject release\n```\n\n经过仔细把重要的函数过滤出来，我们可以了解到`person.age = 12`的执行过程是`NSKVONotifying_FYPerson setAge:`->`NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues`->`FYPerson FYPerson setAge:`->`NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:\n`->`NSKVONotifying_FYPerson NSObject valueForKeyPath:`->`NSMutableDictionary NSObject self`->`- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:\n`，我们来用伪代码实现一遍：\n\n```\n//person.age = 12\n[NSKVONotifying_FYPerson setAge:12];\nwillChangeValueForKey@\"age\";\n[FYPerson setAge:12];\ndidChangeValueForKey@\"age\";\n[[NSMutableDictionary alloc] init];\n[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];\n```\n\nNSKVONotifyin_Person内部结构是怎样的？\n首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。\n我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    Person *p1 = [[Person alloc] init];\n    p1.age = 1.0;\n    Person *p2 = [[Person alloc] init];\n    p1.age = 2.0;\n    // self 监听 p1的 age属性\n    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;\n    [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil];\n\n    [self printMethods: object_getClass(p2)];\n    [self printMethods: object_getClass(p1)];\n\n    [p1 removeObserver:self forKeyPath:@\"age\"];\n}\n\n- (void) printMethods:(Class)cls\n{\n    unsigned int count ;\n    Method *methods = class_copyMethodList(cls, &count);\n    NSMutableString *methodNames = [NSMutableString string];\n    [methodNames appendFormat:@\"%@ - \", cls];\n    \n    for (int i = 0 ; i < count; i++) {\n        Method method = methods[i];\n        NSString *methodName  = NSStringFromSelector(method_getName(method));\n        \n        [methodNames appendString: methodName];\n        [methodNames appendString:@\" \"];\n        \n    }\n    \n    NSLog(@\"%@\",methodNames);\n    free(methods);\n}\n\n\n//结果如下：\nNSKVONotifying_FYPerson - setAge: class dealloc _isKVOA\nFYPerson - setAge: age\n```\n\n 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。\n \n![](../images/3-1.png)\n\n这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。\n\n如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。\n\n那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为\n\n```\n- (Class) class {\n     // 得到类对象，在找到类对象父类\n     return class_getSuperclass(object_getClass(self));\n}\n```\n\n最后自己写代码验证一下：\n\n```\n\n@implementation FYPerson\n-(void)willChangeValueForKey:(NSString *)key{\n\tNSLog(@\"%s 开始\",__func__);\n\t[super didChangeValueForKey:key];\n\tNSLog(@\"%s 结束\",__func__);\n}\n- (void)didChangeValueForKey:(NSString *)key{\n\tNSLog(@\"%s 开始\",__func__);\n\t[super didChangeValueForKey:key];\n\tNSLog(@\"%s 结束\",__func__);\n}\n- (void)setAge:(double)age{\n\t_age = age;\n\tNSLog(@\"%s\",__func__);\n}\n\n@end\n\n```\n\n执行之后结果如下：\n\n```\n-[FYPerson willChangeValueForKey:] 开始\n-[FYPerson willChangeValueForKey:] 结束\n-[FYPerson setAge:]\n-[FYPerson didChangeValueForKey:] 开始\n 监听到了age变化： {\n    kind = 1;\n    new = 11;\n    old = 10;\n}\n-[FYPerson didChangeValueForKey:] 结束\n```\n\n#### 总结：\nKVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。\n\n### KVC的本质\n\nKVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。\n常用的API有\n\n```\n- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- (void)setValue:(id)value forKey:(NSString *)key;\n- (id)valueForKeyPath:(NSString *)keyPath;\n- (id)valueForKey:(NSString *)key; \n```\n\n其实当Obj调用`(void)setValue:(id)value forKey:(NSString *)key`的时候，`obj`会主动寻找方法`setKey`和`_setKey`两个方法，没有找到这两个方法会再去寻找`accessInstanceVariablesDirectly`，返回值为`NO`则抛出异常，返回`YES`则去按照`_key`、`_isKey`、`key`、`isKey`的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。\n我们使用这段代码来验证：\n\n```\n@interface FYPerson(){\n}\n@end\n@implementation FYPerson\n//code1\n- (void)setAge:(NSInteger)age{\n\tNSLog(@\"%s %ld\",__func__,(long)age);\n}\n//code2\n- (void)_setAge:(NSInteger)age{\n\tNSLog(@\"%s %ld\",__func__,(long)age);\n}\n@end\n\n\nFYPerson *p=[[FYPerson alloc]init];\n[p setValue:@(2) forKey:@\"age\"];\n\n```\n\n当执行`code1`和`code2`都有的时候，输出`-[FYPerson setAge:] 2`，当`code1`注释掉，输出`-[FYPerson _setAge:] 2`，可以看出执行顺序是`setAge`，没有`setAge`的时候再去执行`_setAge`。\n\n现在新增`FYPerson`4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。\n```\n\n@interface FYPerson : NSObject\n{\n@public\n\tNSInteger _age;\n\tNSInteger _isAge;\n\tNSInteger age;\n\tNSInteger isAge;\n}\n@end\n\n\n\n\nFYPerson *p=[[FYPerson alloc]init];\n[p setValue:@(2) forKey:@\"age\"];\n\nNSLog(@\"age:%d _age:%d isAge:%d _isAge:%d\",(int)p->age,(int)p->_age,(int)p->isAge,(int)p->_isAge);\n\n```\n\n- 没注释输出 `age:0 _age:2 isAge:0 _isAge:0`\n- 注释`_age`输出 `age:0 isAge:0 _isAge:2`\n- 注释`_isAge`输出 `age:2 isAge:0`\n- 注释`age`输出 `isAge:2`\n\n#### KVC和KVO联系\n我们知道KVC本质也是调用setter方法，那么会出发KVO吗？\n\n```\nFYPerson *p=[[FYPerson alloc]init];\n[p addObserver:p\n\tforKeyPath:@\"age\"\n\t   options:NSKeyValueChangeNewKey\n\t   context:nil];\n[p setValue:@2 forKey:@\"age\"];\n[p removeObserver:p forKeyPath:@\"age\"];\n\n@interface FYPerson(){\n\t@public\n\tNSInteger _age;\n\tNSInteger _isAge;\n\tNSInteger age;\n\tNSInteger isAge;\n}\n@end\n@implementation FYPerson\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n\tNSLog(@\"%@\",change);\n}\n@end\n\n//结果\n{\n    kind = 1;\n    new = 2;\n    old = 0;\n}\n```\n\n经过测试，可以看出KVC能触发KVO的。那么`valueForKey:key`底层是怎么运行的呢？其实底层是按照顺序查找四个方法`_age`->`_isAge`->`age`->`isAge`。我们测试一下：\n\n```\nFYPerson *p=[[FYPerson alloc]init];\np->_age = 1;\np->_isAge = 2;\np->age = 3;\np->isAge = 4;\nNSLog(@\"value:%@\",[p valueForKey:@\"age\"]);\n//依次注释1,2,3，依次输出是1->2->3->4\n```\n\n#### 总结：\nKVC其实本质是执行4个set方法和4个get方法，当使用`setValue:forKey:key`会触发KVO，找不到4个方法的时候会抛出异常。\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n\n\n之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何`hook objc_msgsend`,感觉这个挺好玩的。\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n \n 广告时间\n\n![](../images/0.png)\n \n \n","source":"_posts/iOS底层原理 KVO和KVC本质与联系 --(3).md","raw":"title: iOS底层原理  KVO和KVC本质与联系 --(3)\ndate: 2019-12-1 11:13:58\ntags:\n- iOS\ncategories: iOS\n---\n我们知道实例实际是存储了成员变量的值和指向类的`isa`指针，`class`对象和`meta-class`对象包含 `isa`、`superclass`和`class_rw_t`这几种结构体，只是数据不一样，`isa`需要`ISA_MASK`&之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。\n \n### KVO本质\n \n 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。\n \n ```\n \n #import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface FYPerson : NSObject\n\n@property (nonatomic,assign) NSInteger age;\n@end\n\nNS_ASSUME_NONNULL_END\n\n#import \"ViewController.h\"\n#import \"FYPerson.h\"\n\n@interface ViewController ()\n@property (nonatomic,strong)FYPerson *person;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.person=[FYPerson new];\n\tself.person.age = 10;\n\t[self.person addObserver:self\n    \t\t\t  forKeyPath:@\"age\"\n    \t\t\t\t options:NSKeyValueObservingOptionNew\n    \t\t\t\t context:nil];\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\tself.person.age += 1;\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n\tNSLog(@\"监听到了age变化： %@\",change);\n}\n-(void)dealloc{\n\t[self.person removeObserver:self forKeyPath:@\"age\"];\n}\n\n@end\n\n//下边是输出结果\n监听到了age变化： {\n    kind = 1;\n    new = 12;\n    old = 11;\n}\n ```\n \n \n 从上述代码可以看出，添加监听之后，当值改变时，会触发函数`observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context`。\n#### 触发条件\n \n ```\n - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n//\tself.person.age += 1;\n\t[self.person willChangeValueForKey:@\"age\"];\n\t[self.person didChangeValueForKey:@\"age\"];\n}\n ```\n \n 当把`age`具体值的改变，变成手动调用`willChangeValueForKey`和`didChangeValueForKey`的时候，结果如下：\n \n ```\n  监听到了age变化： {\n    kind = 1;\n    new = 10;\n    old = 10;\n}\n ```\n \n `new`和`old`的值竟然一样，经测试只有同时先后调用`willChangeValueForKey`和`didChangeValueForKey`，会触发回调函数`observeValueForKeyPath`，由此可知触发条件是`willChangeValueForKey`和`didChangeValueForKey`配合使用。\n \n \n \n#### 探寻KVO底层实现原理\n通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。\n我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。\n说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。\nKVO底层实现分析\n首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：\n\n```\n@interface ViewController ()\n@property (nonatomic,strong)FYPerson *person;\n@property (nonatomic,strong)FYPerson *person2;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.person=[FYPerson new];\n\tself.person2 =[FYPerson new];\n\tself.person.age = 10;\n\t[self.person addObserver:self\n\t\t\t\t\t  forKeyPath:@\"age\"\n\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld\n\t\t\t\t\t\t context:nil];\n Class superclass = NSStringFromClass( class_getSuperclass(NSClassFromString(@\"NSKVONotifying_FYPerson\")));\nClass NSKVONotifying_FYPerson = objc_getClass(\"NSKVONotifying_FYPerson\");\n    fy_objc_class* NSKVONotifying_FYPerson_class = (__bridge fy_objc_class *)NSKVONotifying_FYPerson;\n\t\t\t\t\t\t //此处打断点\n\n//p 命令输出isa指针 \n(lldb) p self.person2->isa\n(Class) $0 = FYPerson\n(lldb) p self.person->isa\n(Class) $1 = NSKVONotifying_FYPerson\n\n(lldb) p superclass\n(Class) $0 = FYPerson\n\n(lldb) p NSKVONotifying_FYPerson_class->superclass\n(Class) $4 = FYPerson\n}\n\n```\n\n从输出的isa指针看来，经过`【person addObserver】`之后，`person`的`isa`指针指向了`NSKVONotifying_FYPerson`,而`person2`的`isa`是`FYPerson`，可以看出系统是对`instance`对象的`isa`进行了赋值操作。通过`p NSKVONotifying_FYPerson_class->superclass==FYPerson`可以看出isa是指向了子类，那么子类`NSKVONotifying_FYPerson`到底做了那些事情呢？\n\n看下边代码查看函数isa改变过程：\n\n```\n\tself.person=[FYPerson new];\n\tself.person2 =[FYPerson new];\n\tself.person.age = 10;\n//打断点 输出 po [_person methodForSelector:@selector(setAge:)]\n\t[self.person addObserver:self\n\t\t\t\t\t  forKeyPath:@\"age\"\n\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld\n\t\t\t\t\t\t context:nil];\n//打断点 输出 po [_person methodForSelector:@selector(setAge:)]\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x000000010666b720\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x00000001069c63d2\n\n//查看IMP指针对应地址和内容\n(lldb) p (IMP)0x000000010666b720\n(IMP) $2 = 0x000000010666b720 (day03-KVO本质`::-[FYPerson setAge:](int) at FYPerson.h:14)\n(lldb) p (IMP)0x00000001069c63d2\n(IMP) $3 = 0x00000001069c63d2 (Foundation`_NSSetIntValueAndNotify)\n```\n\n可以看出来两次的函数地址不一致，添加KVO之前是`[FYPerson setAge:]`,添加之后是`(Foundation_NSSetIntValueAndNotify)`。我们将`age`的类型改成`double`，再看一下结果：\n\n```\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x00000001080c4710\n\n(lldb) po [_person methodForSelector:@selector(setAge:)]\n0x000000010841f18c\n\n(lldb) p (IMP)0x00000001080c4710\n(IMP) $2 = 0x00000001080c4710 (day03-KVO本质`::-[FYPerson setAge:](double) at FYPerson.h:14)\n(lldb) p (IMP)0x000000010841f18c\n(IMP) $3 = 0x000000010841f18c (Foundation`_NSSetDoubleValueAndNotify)\n```\n\n`age`是`int`的时候添加之后是`Foundation _NSSetIntValueAndNotify`,改成`double`之后，是`Foundation _NSSetDoubleValueAndNotify`。那么我们可以推测`Foundation`框架中还有很多例如`_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify`等等函数。\n运行`nm Foundation | grep ValueAndNotify`结果如下：\n\n```\nnm Foundation  | grep ValueAndNotify\n__NSSetBoolValueAndNotify\n__NSSetCharValueAndNotify\n__NSSetDoubleValueAndNotify\n__NSSetFloatValueAndNotify\n__NSSetIntValueAndNotify\n__NSSetLongLongValueAndNotify\n__NSSetLongValueAndNotify\n__NSSetObjectValueAndNotify\n__NSSetPointValueAndNotify\n__NSSetRangeValueAndNotify\n__NSSetRectValueAndNotify\n__NSSetShortValueAndNotify\n__NSSetSizeValueAndNotify\n```\n#### 另外一种验证方法 \n在macOS中可以使用\n\n```\n//开始记录日志\ninstrumentObjcMessageSends(YES);\n    // Do stuff...\ninstrumentObjcMessageSends(NO);//结束记录日志\n```\n\n如果将`NSObjCMessageLoggingEnabled`环境变量设置为`YES`，则`Objective-C`运行时会将所有已分派的`Objective-C`消息记录到名为`/tmp/msgSends-<pid>`的文件中。每一次运行会生成一个文件，我们进入到该文件内部：\n\n```\n//初始化\n+ FYPerson NSObject initialize\n+ FYPerson NSObject new\n- FYPerson NSObject init\n- FYPerson NSObject addObserver:forKeyPath:options:context:\n- FYPerson NSObject _isKVOA\n\n****\n\n\n//子类设置age [NSKVONotifying_FYPerson setAge:]\n\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:\n- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:\n- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:\n\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:\n\n//will changeValueForKey\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:\n \n//FYPerson 设置age\n- FYPerson FYPerson setAge:\n\n// didChangeValueForKeyOrKeys\n- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:\n- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath\n\n//找到key 发送 具体的key对应的value 到observe\n\n- NSKVONotifying_FYPerson NSObject valueForKeyPath:\n\n- NSKVONotifying_FYPerson NSObject valueForKey:\n+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:\n-\n+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:\n+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:\n- NSKVONotifying_FYPerson FYPerson age\n+ NSKeyValueMethodGetter NSObject alloc\n- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:\n- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:\n\n\n- NSKVONotifying_FYPerson NSObject respondsToSelector:\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class\n- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA\n+ FYPerson NSObject class\n+ FYPerson NSObject resolveInstanceMethod:\n+ FYPerson NSObject resolveInstanceMethod:\n\n//数据字典\n+ NSDictionary NSObject self\n+ NSMutableDictionary NSObject self\n- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:\n- NSDictionary NSObject init\n\n// 执行观察者回调函数\n- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:\n\n\n+ Student NSObject alloc\n- Student NSObject init\n- Student NSObject dealloc\n\n\n***//省略一部分代码\n NSKVONotifying_FYPerson NSObject release\n- NSKeyValueChangeDictionary NSObject release\n- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc\n- NSDictionary NSObject dealloc\n- NSKeyValueObservationInfo NSObject release\n- NSKVONotifying_FYPerson NSObject release\n```\n\n经过仔细把重要的函数过滤出来，我们可以了解到`person.age = 12`的执行过程是`NSKVONotifying_FYPerson setAge:`->`NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues`->`FYPerson FYPerson setAge:`->`NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:\n`->`NSKVONotifying_FYPerson NSObject valueForKeyPath:`->`NSMutableDictionary NSObject self`->`- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:\n`，我们来用伪代码实现一遍：\n\n```\n//person.age = 12\n[NSKVONotifying_FYPerson setAge:12];\nwillChangeValueForKey@\"age\";\n[FYPerson setAge:12];\ndidChangeValueForKey@\"age\";\n[[NSMutableDictionary alloc] init];\n[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];\n```\n\nNSKVONotifyin_Person内部结构是怎样的？\n首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。\n我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    Person *p1 = [[Person alloc] init];\n    p1.age = 1.0;\n    Person *p2 = [[Person alloc] init];\n    p1.age = 2.0;\n    // self 监听 p1的 age属性\n    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;\n    [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil];\n\n    [self printMethods: object_getClass(p2)];\n    [self printMethods: object_getClass(p1)];\n\n    [p1 removeObserver:self forKeyPath:@\"age\"];\n}\n\n- (void) printMethods:(Class)cls\n{\n    unsigned int count ;\n    Method *methods = class_copyMethodList(cls, &count);\n    NSMutableString *methodNames = [NSMutableString string];\n    [methodNames appendFormat:@\"%@ - \", cls];\n    \n    for (int i = 0 ; i < count; i++) {\n        Method method = methods[i];\n        NSString *methodName  = NSStringFromSelector(method_getName(method));\n        \n        [methodNames appendString: methodName];\n        [methodNames appendString:@\" \"];\n        \n    }\n    \n    NSLog(@\"%@\",methodNames);\n    free(methods);\n}\n\n\n//结果如下：\nNSKVONotifying_FYPerson - setAge: class dealloc _isKVOA\nFYPerson - setAge: age\n```\n\n 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。\n \n![](../images/3-1.png)\n\n这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。\n\n如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。\n\n那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为\n\n```\n- (Class) class {\n     // 得到类对象，在找到类对象父类\n     return class_getSuperclass(object_getClass(self));\n}\n```\n\n最后自己写代码验证一下：\n\n```\n\n@implementation FYPerson\n-(void)willChangeValueForKey:(NSString *)key{\n\tNSLog(@\"%s 开始\",__func__);\n\t[super didChangeValueForKey:key];\n\tNSLog(@\"%s 结束\",__func__);\n}\n- (void)didChangeValueForKey:(NSString *)key{\n\tNSLog(@\"%s 开始\",__func__);\n\t[super didChangeValueForKey:key];\n\tNSLog(@\"%s 结束\",__func__);\n}\n- (void)setAge:(double)age{\n\t_age = age;\n\tNSLog(@\"%s\",__func__);\n}\n\n@end\n\n```\n\n执行之后结果如下：\n\n```\n-[FYPerson willChangeValueForKey:] 开始\n-[FYPerson willChangeValueForKey:] 结束\n-[FYPerson setAge:]\n-[FYPerson didChangeValueForKey:] 开始\n 监听到了age变化： {\n    kind = 1;\n    new = 11;\n    old = 10;\n}\n-[FYPerson didChangeValueForKey:] 结束\n```\n\n#### 总结：\nKVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。\n\n### KVC的本质\n\nKVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。\n常用的API有\n\n```\n- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;\n- (void)setValue:(id)value forKey:(NSString *)key;\n- (id)valueForKeyPath:(NSString *)keyPath;\n- (id)valueForKey:(NSString *)key; \n```\n\n其实当Obj调用`(void)setValue:(id)value forKey:(NSString *)key`的时候，`obj`会主动寻找方法`setKey`和`_setKey`两个方法，没有找到这两个方法会再去寻找`accessInstanceVariablesDirectly`，返回值为`NO`则抛出异常，返回`YES`则去按照`_key`、`_isKey`、`key`、`isKey`的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。\n我们使用这段代码来验证：\n\n```\n@interface FYPerson(){\n}\n@end\n@implementation FYPerson\n//code1\n- (void)setAge:(NSInteger)age{\n\tNSLog(@\"%s %ld\",__func__,(long)age);\n}\n//code2\n- (void)_setAge:(NSInteger)age{\n\tNSLog(@\"%s %ld\",__func__,(long)age);\n}\n@end\n\n\nFYPerson *p=[[FYPerson alloc]init];\n[p setValue:@(2) forKey:@\"age\"];\n\n```\n\n当执行`code1`和`code2`都有的时候，输出`-[FYPerson setAge:] 2`，当`code1`注释掉，输出`-[FYPerson _setAge:] 2`，可以看出执行顺序是`setAge`，没有`setAge`的时候再去执行`_setAge`。\n\n现在新增`FYPerson`4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。\n```\n\n@interface FYPerson : NSObject\n{\n@public\n\tNSInteger _age;\n\tNSInteger _isAge;\n\tNSInteger age;\n\tNSInteger isAge;\n}\n@end\n\n\n\n\nFYPerson *p=[[FYPerson alloc]init];\n[p setValue:@(2) forKey:@\"age\"];\n\nNSLog(@\"age:%d _age:%d isAge:%d _isAge:%d\",(int)p->age,(int)p->_age,(int)p->isAge,(int)p->_isAge);\n\n```\n\n- 没注释输出 `age:0 _age:2 isAge:0 _isAge:0`\n- 注释`_age`输出 `age:0 isAge:0 _isAge:2`\n- 注释`_isAge`输出 `age:2 isAge:0`\n- 注释`age`输出 `isAge:2`\n\n#### KVC和KVO联系\n我们知道KVC本质也是调用setter方法，那么会出发KVO吗？\n\n```\nFYPerson *p=[[FYPerson alloc]init];\n[p addObserver:p\n\tforKeyPath:@\"age\"\n\t   options:NSKeyValueChangeNewKey\n\t   context:nil];\n[p setValue:@2 forKey:@\"age\"];\n[p removeObserver:p forKeyPath:@\"age\"];\n\n@interface FYPerson(){\n\t@public\n\tNSInteger _age;\n\tNSInteger _isAge;\n\tNSInteger age;\n\tNSInteger isAge;\n}\n@end\n@implementation FYPerson\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{\n\tNSLog(@\"%@\",change);\n}\n@end\n\n//结果\n{\n    kind = 1;\n    new = 2;\n    old = 0;\n}\n```\n\n经过测试，可以看出KVC能触发KVO的。那么`valueForKey:key`底层是怎么运行的呢？其实底层是按照顺序查找四个方法`_age`->`_isAge`->`age`->`isAge`。我们测试一下：\n\n```\nFYPerson *p=[[FYPerson alloc]init];\np->_age = 1;\np->_isAge = 2;\np->age = 3;\np->isAge = 4;\nNSLog(@\"value:%@\",[p valueForKey:@\"age\"]);\n//依次注释1,2,3，依次输出是1->2->3->4\n```\n\n#### 总结：\nKVC其实本质是执行4个set方法和4个get方法，当使用`setValue:forKey:key`会触发KVO，找不到4个方法的时候会抛出异常。\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n\n\n之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何`hook objc_msgsend`,感觉这个挺好玩的。\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n \n 广告时间\n\n![](../images/0.png)\n \n \n","slug":"iOS底层原理 KVO和KVC本质与联系 --(3)","published":1,"updated":"2019-12-03T05:01:39.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2i000k9zsksug5xpm7","content":"<p>我们知道实例实际是存储了成员变量的值和指向类的<code>isa</code>指针，<code>class</code>对象和<code>meta-class</code>对象包含 <code>isa</code>、<code>superclass</code>和<code>class_rw_t</code>这几种结构体，只是数据不一样，<code>isa</code>需要<code>ISA_MASK</code>&amp;之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。</p>\n<h3 id=\"KVO本质\"><a href=\"#KVO本质\" class=\"headerlink\" title=\"KVO本质\"></a>KVO本质</h3><p> 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\"> #import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">NS_ASSUME_NONNULL_BEGIN</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,assign) NSInteger age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">NS_ASSUME_NONNULL_END</div><div class=\"line\"></div><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\">#import &quot;FYPerson.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">    \t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">    \t\t\t\t options:NSKeyValueObservingOptionNew</div><div class=\"line\">    \t\t\t\t context:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tself.person.age += 1;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">\tNSLog(@&quot;监听到了age变化： %@&quot;,change);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\t[self.person removeObserver:self forKeyPath:@&quot;age&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//下边是输出结果</div><div class=\"line\">监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 12;</div><div class=\"line\">    old = 11;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 从上述代码可以看出，添加监听之后，当值改变时，会触发函数<code>observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</code>。</p>\n<h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">//\tself.person.age += 1;</div><div class=\"line\">\t[self.person willChangeValueForKey:@&quot;age&quot;];</div><div class=\"line\">\t[self.person didChangeValueForKey:@&quot;age&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 当把<code>age</code>具体值的改变，变成手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>的时候，结果如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 10;</div><div class=\"line\">    old = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <code>new</code>和<code>old</code>的值竟然一样，经测试只有同时先后调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>，会触发回调函数<code>observeValueForKeyPath</code>，由此可知触发条件是<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>配合使用。</p>\n<h4 id=\"探寻KVO底层实现原理\"><a href=\"#探寻KVO底层实现原理\" class=\"headerlink\" title=\"探寻KVO底层实现原理\"></a>探寻KVO底层实现原理</h4><p>通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。<br>我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。<br>说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。<br>KVO底层实现分析<br>首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person;</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person2;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person2 =[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">\t\t\t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</div><div class=\"line\">\t\t\t\t\t\t context:nil];</div><div class=\"line\"> Class superclass = NSStringFromClass( class_getSuperclass(NSClassFromString(@&quot;NSKVONotifying_FYPerson&quot;)));</div><div class=\"line\">Class NSKVONotifying_FYPerson = objc_getClass(&quot;NSKVONotifying_FYPerson&quot;);</div><div class=\"line\">    fy_objc_class* NSKVONotifying_FYPerson_class = (__bridge fy_objc_class *)NSKVONotifying_FYPerson;</div><div class=\"line\">\t\t\t\t\t\t //此处打断点</div><div class=\"line\"></div><div class=\"line\">//p 命令输出isa指针 </div><div class=\"line\">(lldb) p self.person2-&gt;isa</div><div class=\"line\">(Class) $0 = FYPerson</div><div class=\"line\">(lldb) p self.person-&gt;isa</div><div class=\"line\">(Class) $1 = NSKVONotifying_FYPerson</div><div class=\"line\"></div><div class=\"line\">(lldb) p superclass</div><div class=\"line\">(Class) $0 = FYPerson</div><div class=\"line\"></div><div class=\"line\">(lldb) p NSKVONotifying_FYPerson_class-&gt;superclass</div><div class=\"line\">(Class) $4 = FYPerson</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从输出的isa指针看来，经过<code>【person addObserver】</code>之后，<code>person</code>的<code>isa</code>指针指向了<code>NSKVONotifying_FYPerson</code>,而<code>person2</code>的<code>isa</code>是<code>FYPerson</code>，可以看出系统是对<code>instance</code>对象的<code>isa</code>进行了赋值操作。通过<code>p NSKVONotifying_FYPerson_class-&gt;superclass==FYPerson</code>可以看出isa是指向了子类，那么子类<code>NSKVONotifying_FYPerson</code>到底做了那些事情呢？</p>\n<p>看下边代码查看函数isa改变过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person2 =[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">\t\t\t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</div><div class=\"line\">\t\t\t\t\t\t context:nil];</div><div class=\"line\">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x000000010666b720</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x00000001069c63d2</div><div class=\"line\"></div><div class=\"line\">//查看IMP指针对应地址和内容</div><div class=\"line\">(lldb) p (IMP)0x000000010666b720</div><div class=\"line\">(IMP) $2 = 0x000000010666b720 (day03-KVO本质`::-[FYPerson setAge:](int) at FYPerson.h:14)</div><div class=\"line\">(lldb) p (IMP)0x00000001069c63d2</div><div class=\"line\">(IMP) $3 = 0x00000001069c63d2 (Foundation`_NSSetIntValueAndNotify)</div></pre></td></tr></table></figure>\n<p>可以看出来两次的函数地址不一致，添加KVO之前是<code>[FYPerson setAge:]</code>,添加之后是<code>(Foundation_NSSetIntValueAndNotify)</code>。我们将<code>age</code>的类型改成<code>double</code>，再看一下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x00000001080c4710</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x000000010841f18c</div><div class=\"line\"></div><div class=\"line\">(lldb) p (IMP)0x00000001080c4710</div><div class=\"line\">(IMP) $2 = 0x00000001080c4710 (day03-KVO本质`::-[FYPerson setAge:](double) at FYPerson.h:14)</div><div class=\"line\">(lldb) p (IMP)0x000000010841f18c</div><div class=\"line\">(IMP) $3 = 0x000000010841f18c (Foundation`_NSSetDoubleValueAndNotify)</div></pre></td></tr></table></figure>\n<p><code>age</code>是<code>int</code>的时候添加之后是<code>Foundation _NSSetIntValueAndNotify</code>,改成<code>double</code>之后，是<code>Foundation _NSSetDoubleValueAndNotify</code>。那么我们可以推测<code>Foundation</code>框架中还有很多例如<code>_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify</code>等等函数。<br>运行<code>nm Foundation | grep ValueAndNotify</code>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">nm Foundation  | grep ValueAndNotify</div><div class=\"line\">__NSSetBoolValueAndNotify</div><div class=\"line\">__NSSetCharValueAndNotify</div><div class=\"line\">__NSSetDoubleValueAndNotify</div><div class=\"line\">__NSSetFloatValueAndNotify</div><div class=\"line\">__NSSetIntValueAndNotify</div><div class=\"line\">__NSSetLongLongValueAndNotify</div><div class=\"line\">__NSSetLongValueAndNotify</div><div class=\"line\">__NSSetObjectValueAndNotify</div><div class=\"line\">__NSSetPointValueAndNotify</div><div class=\"line\">__NSSetRangeValueAndNotify</div><div class=\"line\">__NSSetRectValueAndNotify</div><div class=\"line\">__NSSetShortValueAndNotify</div><div class=\"line\">__NSSetSizeValueAndNotify</div></pre></td></tr></table></figure>\n<h4 id=\"另外一种验证方法\"><a href=\"#另外一种验证方法\" class=\"headerlink\" title=\"另外一种验证方法\"></a>另外一种验证方法</h4><p>在macOS中可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始记录日志</div><div class=\"line\">instrumentObjcMessageSends(YES);</div><div class=\"line\">    // Do stuff...</div><div class=\"line\">instrumentObjcMessageSends(NO);//结束记录日志</div></pre></td></tr></table></figure>\n<p>如果将<code>NSObjCMessageLoggingEnabled</code>环境变量设置为<code>YES</code>，则<code>Objective-C</code>运行时会将所有已分派的<code>Objective-C</code>消息记录到名为<code>/tmp/msgSends-&lt;pid&gt;</code>的文件中。每一次运行会生成一个文件，我们进入到该文件内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化</div><div class=\"line\">+ FYPerson NSObject initialize</div><div class=\"line\">+ FYPerson NSObject new</div><div class=\"line\">- FYPerson NSObject init</div><div class=\"line\">- FYPerson NSObject addObserver:forKeyPath:options:context:</div><div class=\"line\">- FYPerson NSObject _isKVOA</div><div class=\"line\"></div><div class=\"line\">****</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//子类设置age [NSKVONotifying_FYPerson setAge:]</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:</div><div class=\"line\"></div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:</div><div class=\"line\"></div><div class=\"line\">//will changeValueForKey</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:</div><div class=\"line\"> </div><div class=\"line\">//FYPerson 设置age</div><div class=\"line\">- FYPerson FYPerson setAge:</div><div class=\"line\"></div><div class=\"line\">// didChangeValueForKeyOrKeys</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath</div><div class=\"line\"></div><div class=\"line\">//找到key 发送 具体的key对应的value 到observe</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject valueForKeyPath:</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject valueForKey:</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:</div><div class=\"line\">-</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">- NSKVONotifying_FYPerson FYPerson age</div><div class=\"line\">+ NSKeyValueMethodGetter NSObject alloc</div><div class=\"line\">- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:</div><div class=\"line\">- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject respondsToSelector:</div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class</div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA</div><div class=\"line\">+ FYPerson NSObject class</div><div class=\"line\">+ FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">+ FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\"></div><div class=\"line\">//数据字典</div><div class=\"line\">+ NSDictionary NSObject self</div><div class=\"line\">+ NSMutableDictionary NSObject self</div><div class=\"line\">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:</div><div class=\"line\">- NSDictionary NSObject init</div><div class=\"line\"></div><div class=\"line\">// 执行观察者回调函数</div><div class=\"line\">- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">+ Student NSObject alloc</div><div class=\"line\">- Student NSObject init</div><div class=\"line\">- Student NSObject dealloc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">***//省略一部分代码</div><div class=\"line\"> NSKVONotifying_FYPerson NSObject release</div><div class=\"line\">- NSKeyValueChangeDictionary NSObject release</div><div class=\"line\">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc</div><div class=\"line\">- NSDictionary NSObject dealloc</div><div class=\"line\">- NSKeyValueObservationInfo NSObject release</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject release</div></pre></td></tr></table></figure>\n<p>经过仔细把重要的函数过滤出来，我们可以了解到<code>person.age = 12</code>的执行过程是<code>NSKVONotifying_FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues</code>-&gt;<code>FYPerson FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</code>-&gt;<code>NSKVONotifying_FYPerson NSObject valueForKeyPath:</code>-&gt;<code>NSMutableDictionary NSObject self</code>-&gt;<code>- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</code>，我们来用伪代码实现一遍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//person.age = 12</div><div class=\"line\">[NSKVONotifying_FYPerson setAge:12];</div><div class=\"line\">willChangeValueForKey@&quot;age&quot;;</div><div class=\"line\">[FYPerson setAge:12];</div><div class=\"line\">didChangeValueForKey@&quot;age&quot;;</div><div class=\"line\">[[NSMutableDictionary alloc] init];</div><div class=\"line\">[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];</div></pre></td></tr></table></figure>\n<p>NSKVONotifyin_Person内部结构是怎样的？<br>首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。<br>我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    Person *p1 = [[Person alloc] init];</div><div class=\"line\">    p1.age = 1.0;</div><div class=\"line\">    Person *p2 = [[Person alloc] init];</div><div class=\"line\">    p1.age = 2.0;</div><div class=\"line\">    // self 监听 p1的 age属性</div><div class=\"line\">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</div><div class=\"line\">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</div><div class=\"line\"></div><div class=\"line\">    [self printMethods: object_getClass(p2)];</div><div class=\"line\">    [self printMethods: object_getClass(p1)];</div><div class=\"line\"></div><div class=\"line\">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void) printMethods:(Class)cls</div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count ;</div><div class=\"line\">    Method *methods = class_copyMethodList(cls, &amp;count);</div><div class=\"line\">    NSMutableString *methodNames = [NSMutableString string];</div><div class=\"line\">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0 ; i &lt; count; i++) &#123;</div><div class=\"line\">        Method method = methods[i];</div><div class=\"line\">        NSString *methodName  = NSStringFromSelector(method_getName(method));</div><div class=\"line\">        </div><div class=\"line\">        [methodNames appendString: methodName];</div><div class=\"line\">        [methodNames appendString:@&quot; &quot;];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;%@&quot;,methodNames);</div><div class=\"line\">    free(methods);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//结果如下：</div><div class=\"line\">NSKVONotifying_FYPerson - setAge: class dealloc _isKVOA</div><div class=\"line\">FYPerson - setAge: age</div></pre></td></tr></table></figure>\n<p> 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。</p>\n<p><img src=\"../images/3-1.png\" alt=\"\"></p>\n<p>这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。</p>\n<p>如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。</p>\n<p>那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">     // 得到类对象，在找到类对象父类</div><div class=\"line\">     return class_getSuperclass(object_getClass(self));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后自己写代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(void)willChangeValueForKey:(NSString *)key&#123;</div><div class=\"line\">\tNSLog(@&quot;%s 开始&quot;,__func__);</div><div class=\"line\">\t[super didChangeValueForKey:key];</div><div class=\"line\">\tNSLog(@&quot;%s 结束&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)didChangeValueForKey:(NSString *)key&#123;</div><div class=\"line\">\tNSLog(@&quot;%s 开始&quot;,__func__);</div><div class=\"line\">\t[super didChangeValueForKey:key];</div><div class=\"line\">\tNSLog(@&quot;%s 结束&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setAge:(double)age&#123;</div><div class=\"line\">\t_age = age;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>执行之后结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[FYPerson willChangeValueForKey:] 开始</div><div class=\"line\">-[FYPerson willChangeValueForKey:] 结束</div><div class=\"line\">-[FYPerson setAge:]</div><div class=\"line\">-[FYPerson didChangeValueForKey:] 开始</div><div class=\"line\"> 监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 11;</div><div class=\"line\">    old = 10;</div><div class=\"line\">&#125;</div><div class=\"line\">-[FYPerson didChangeValueForKey:] 结束</div></pre></td></tr></table></figure>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>KVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p>\n<h3 id=\"KVC的本质\"><a href=\"#KVC的本质\" class=\"headerlink\" title=\"KVC的本质\"></a>KVC的本质</h3><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。<br>常用的API有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</div><div class=\"line\">- (void)setValue:(id)value forKey:(NSString *)key;</div><div class=\"line\">- (id)valueForKeyPath:(NSString *)keyPath;</div><div class=\"line\">- (id)valueForKey:(NSString *)key;</div></pre></td></tr></table></figure>\n<p>其实当Obj调用<code>(void)setValue:(id)value forKey:(NSString *)key</code>的时候，<code>obj</code>会主动寻找方法<code>setKey</code>和<code>_setKey</code>两个方法，没有找到这两个方法会再去寻找<code>accessInstanceVariablesDirectly</code>，返回值为<code>NO</code>则抛出异常，返回<code>YES</code>则去按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。<br>我们使用这段代码来验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">//code1</div><div class=\"line\">- (void)setAge:(NSInteger)age&#123;</div><div class=\"line\">\tNSLog(@&quot;%s %ld&quot;,__func__,(long)age);</div><div class=\"line\">&#125;</div><div class=\"line\">//code2</div><div class=\"line\">- (void)_setAge:(NSInteger)age&#123;</div><div class=\"line\">\tNSLog(@&quot;%s %ld&quot;,__func__,(long)age);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p setValue:@(2) forKey:@&quot;age&quot;];</div></pre></td></tr></table></figure>\n<p>当执行<code>code1</code>和<code>code2</code>都有的时候，输出<code>-[FYPerson setAge:] 2</code>，当<code>code1</code>注释掉，输出<code>-[FYPerson _setAge:] 2</code>，可以看出执行顺序是<code>setAge</code>，没有<code>setAge</code>的时候再去执行<code>_setAge</code>。</p>\n<p>现在新增<code>FYPerson</code>4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tNSInteger _age;</div><div class=\"line\">\tNSInteger _isAge;</div><div class=\"line\">\tNSInteger age;</div><div class=\"line\">\tNSInteger isAge;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p setValue:@(2) forKey:@&quot;age&quot;];</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;age:%d _age:%d isAge:%d _isAge:%d&quot;,(int)p-&gt;age,(int)p-&gt;_age,(int)p-&gt;isAge,(int)p-&gt;_isAge);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>没注释输出 <code>age:0 _age:2 isAge:0 _isAge:0</code></li>\n<li>注释<code>_age</code>输出 <code>age:0 isAge:0 _isAge:2</code></li>\n<li>注释<code>_isAge</code>输出 <code>age:2 isAge:0</code></li>\n<li>注释<code>age</code>输出 <code>isAge:2</code></li>\n</ul>\n<h4 id=\"KVC和KVO联系\"><a href=\"#KVC和KVO联系\" class=\"headerlink\" title=\"KVC和KVO联系\"></a>KVC和KVO联系</h4><p>我们知道KVC本质也是调用setter方法，那么会出发KVO吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p addObserver:p</div><div class=\"line\">\tforKeyPath:@&quot;age&quot;</div><div class=\"line\">\t   options:NSKeyValueChangeNewKey</div><div class=\"line\">\t   context:nil];</div><div class=\"line\">[p setValue:@2 forKey:@&quot;age&quot;];</div><div class=\"line\">[p removeObserver:p forKeyPath:@&quot;age&quot;];</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tNSInteger _age;</div><div class=\"line\">\tNSInteger _isAge;</div><div class=\"line\">\tNSInteger age;</div><div class=\"line\">\tNSInteger isAge;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,change);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//结果</div><div class=\"line\">&#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 2;</div><div class=\"line\">    old = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过测试，可以看出KVC能触发KVO的。那么<code>valueForKey:key</code>底层是怎么运行的呢？其实底层是按照顺序查找四个方法<code>_age</code>-&gt;<code>_isAge</code>-&gt;<code>age</code>-&gt;<code>isAge</code>。我们测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">p-&gt;_age = 1;</div><div class=\"line\">p-&gt;_isAge = 2;</div><div class=\"line\">p-&gt;age = 3;</div><div class=\"line\">p-&gt;isAge = 4;</div><div class=\"line\">NSLog(@&quot;value:%@&quot;,[p valueForKey:@&quot;age&quot;]);</div><div class=\"line\">//依次注释1,2,3，依次输出是1-&gt;2-&gt;3-&gt;4</div></pre></td></tr></table></figure>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>KVC其实本质是执行4个set方法和4个get方法，当使用<code>setValue:forKey:key</code>会触发KVO，找不到4个方法的时候会抛出异常。</p>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n</ul>\n<p>之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何<code>hook objc_msgsend</code>,感觉这个挺好玩的。</p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p> 广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道实例实际是存储了成员变量的值和指向类的<code>isa</code>指针，<code>class</code>对象和<code>meta-class</code>对象包含 <code>isa</code>、<code>superclass</code>和<code>class_rw_t</code>这几种结构体，只是数据不一样，<code>isa</code>需要<code>ISA_MASK</code>&amp;之后才是真正的值。那么今天我们在看一下Key-Value Observing的本质。</p>\n<h3 id=\"KVO本质\"><a href=\"#KVO本质\" class=\"headerlink\" title=\"KVO本质\"></a>KVO本质</h3><p> 首先需要了解KVO基本使用，KVO的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。下面我们展示一下KVO的基本使用。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\"> #import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">NS_ASSUME_NONNULL_BEGIN</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic,assign) NSInteger age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">NS_ASSUME_NONNULL_END</div><div class=\"line\"></div><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\">#import &quot;FYPerson.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">    \t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">    \t\t\t\t options:NSKeyValueObservingOptionNew</div><div class=\"line\">    \t\t\t\t context:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tself.person.age += 1;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">\tNSLog(@&quot;监听到了age变化： %@&quot;,change);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\t[self.person removeObserver:self forKeyPath:@&quot;age&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//下边是输出结果</div><div class=\"line\">监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 12;</div><div class=\"line\">    old = 11;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 从上述代码可以看出，添加监听之后，当值改变时，会触发函数<code>observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</code>。</p>\n<h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">//\tself.person.age += 1;</div><div class=\"line\">\t[self.person willChangeValueForKey:@&quot;age&quot;];</div><div class=\"line\">\t[self.person didChangeValueForKey:@&quot;age&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 当把<code>age</code>具体值的改变，变成手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>的时候，结果如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 10;</div><div class=\"line\">    old = 10;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> <code>new</code>和<code>old</code>的值竟然一样，经测试只有同时先后调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>，会触发回调函数<code>observeValueForKeyPath</code>，由此可知触发条件是<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>配合使用。</p>\n<h4 id=\"探寻KVO底层实现原理\"><a href=\"#探寻KVO底层实现原理\" class=\"headerlink\" title=\"探寻KVO底层实现原理\"></a>探寻KVO底层实现原理</h4><p>通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。<br>我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。<br>说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。<br>KVO底层实现分析<br>首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person;</div><div class=\"line\">@property (nonatomic,strong)FYPerson *person2;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person2 =[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">\t\t\t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</div><div class=\"line\">\t\t\t\t\t\t context:nil];</div><div class=\"line\"> Class superclass = NSStringFromClass( class_getSuperclass(NSClassFromString(@&quot;NSKVONotifying_FYPerson&quot;)));</div><div class=\"line\">Class NSKVONotifying_FYPerson = objc_getClass(&quot;NSKVONotifying_FYPerson&quot;);</div><div class=\"line\">    fy_objc_class* NSKVONotifying_FYPerson_class = (__bridge fy_objc_class *)NSKVONotifying_FYPerson;</div><div class=\"line\">\t\t\t\t\t\t //此处打断点</div><div class=\"line\"></div><div class=\"line\">//p 命令输出isa指针 </div><div class=\"line\">(lldb) p self.person2-&gt;isa</div><div class=\"line\">(Class) $0 = FYPerson</div><div class=\"line\">(lldb) p self.person-&gt;isa</div><div class=\"line\">(Class) $1 = NSKVONotifying_FYPerson</div><div class=\"line\"></div><div class=\"line\">(lldb) p superclass</div><div class=\"line\">(Class) $0 = FYPerson</div><div class=\"line\"></div><div class=\"line\">(lldb) p NSKVONotifying_FYPerson_class-&gt;superclass</div><div class=\"line\">(Class) $4 = FYPerson</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从输出的isa指针看来，经过<code>【person addObserver】</code>之后，<code>person</code>的<code>isa</code>指针指向了<code>NSKVONotifying_FYPerson</code>,而<code>person2</code>的<code>isa</code>是<code>FYPerson</code>，可以看出系统是对<code>instance</code>对象的<code>isa</code>进行了赋值操作。通过<code>p NSKVONotifying_FYPerson_class-&gt;superclass==FYPerson</code>可以看出isa是指向了子类，那么子类<code>NSKVONotifying_FYPerson</code>到底做了那些事情呢？</p>\n<p>看下边代码查看函数isa改变过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tself.person=[FYPerson new];</div><div class=\"line\">\tself.person2 =[FYPerson new];</div><div class=\"line\">\tself.person.age = 10;</div><div class=\"line\">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">\t[self.person addObserver:self</div><div class=\"line\">\t\t\t\t\t  forKeyPath:@&quot;age&quot;</div><div class=\"line\">\t\t\t\t\t\t options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</div><div class=\"line\">\t\t\t\t\t\t context:nil];</div><div class=\"line\">//打断点 输出 po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x000000010666b720</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x00000001069c63d2</div><div class=\"line\"></div><div class=\"line\">//查看IMP指针对应地址和内容</div><div class=\"line\">(lldb) p (IMP)0x000000010666b720</div><div class=\"line\">(IMP) $2 = 0x000000010666b720 (day03-KVO本质`::-[FYPerson setAge:](int) at FYPerson.h:14)</div><div class=\"line\">(lldb) p (IMP)0x00000001069c63d2</div><div class=\"line\">(IMP) $3 = 0x00000001069c63d2 (Foundation`_NSSetIntValueAndNotify)</div></pre></td></tr></table></figure>\n<p>可以看出来两次的函数地址不一致，添加KVO之前是<code>[FYPerson setAge:]</code>,添加之后是<code>(Foundation_NSSetIntValueAndNotify)</code>。我们将<code>age</code>的类型改成<code>double</code>，再看一下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x00000001080c4710</div><div class=\"line\"></div><div class=\"line\">(lldb) po [_person methodForSelector:@selector(setAge:)]</div><div class=\"line\">0x000000010841f18c</div><div class=\"line\"></div><div class=\"line\">(lldb) p (IMP)0x00000001080c4710</div><div class=\"line\">(IMP) $2 = 0x00000001080c4710 (day03-KVO本质`::-[FYPerson setAge:](double) at FYPerson.h:14)</div><div class=\"line\">(lldb) p (IMP)0x000000010841f18c</div><div class=\"line\">(IMP) $3 = 0x000000010841f18c (Foundation`_NSSetDoubleValueAndNotify)</div></pre></td></tr></table></figure>\n<p><code>age</code>是<code>int</code>的时候添加之后是<code>Foundation _NSSetIntValueAndNotify</code>,改成<code>double</code>之后，是<code>Foundation _NSSetDoubleValueAndNotify</code>。那么我们可以推测<code>Foundation</code>框架中还有很多例如<code>_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify</code>等等函数。<br>运行<code>nm Foundation | grep ValueAndNotify</code>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">nm Foundation  | grep ValueAndNotify</div><div class=\"line\">__NSSetBoolValueAndNotify</div><div class=\"line\">__NSSetCharValueAndNotify</div><div class=\"line\">__NSSetDoubleValueAndNotify</div><div class=\"line\">__NSSetFloatValueAndNotify</div><div class=\"line\">__NSSetIntValueAndNotify</div><div class=\"line\">__NSSetLongLongValueAndNotify</div><div class=\"line\">__NSSetLongValueAndNotify</div><div class=\"line\">__NSSetObjectValueAndNotify</div><div class=\"line\">__NSSetPointValueAndNotify</div><div class=\"line\">__NSSetRangeValueAndNotify</div><div class=\"line\">__NSSetRectValueAndNotify</div><div class=\"line\">__NSSetShortValueAndNotify</div><div class=\"line\">__NSSetSizeValueAndNotify</div></pre></td></tr></table></figure>\n<h4 id=\"另外一种验证方法\"><a href=\"#另外一种验证方法\" class=\"headerlink\" title=\"另外一种验证方法\"></a>另外一种验证方法</h4><p>在macOS中可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始记录日志</div><div class=\"line\">instrumentObjcMessageSends(YES);</div><div class=\"line\">    // Do stuff...</div><div class=\"line\">instrumentObjcMessageSends(NO);//结束记录日志</div></pre></td></tr></table></figure>\n<p>如果将<code>NSObjCMessageLoggingEnabled</code>环境变量设置为<code>YES</code>，则<code>Objective-C</code>运行时会将所有已分派的<code>Objective-C</code>消息记录到名为<code>/tmp/msgSends-&lt;pid&gt;</code>的文件中。每一次运行会生成一个文件，我们进入到该文件内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化</div><div class=\"line\">+ FYPerson NSObject initialize</div><div class=\"line\">+ FYPerson NSObject new</div><div class=\"line\">- FYPerson NSObject init</div><div class=\"line\">- FYPerson NSObject addObserver:forKeyPath:options:context:</div><div class=\"line\">- FYPerson NSObject _isKVOA</div><div class=\"line\"></div><div class=\"line\">****</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//子类设置age [NSKVONotifying_FYPerson setAge:]</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson setAge:</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject _changeValueForKey:key:key:usingBlock:</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:</div><div class=\"line\"></div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty keyPathIfAffectedByValueForKey:exactMatch:</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty _keyPathIfAffectedByValueForKey:exactMatch:</div><div class=\"line\"></div><div class=\"line\">//will changeValueForKey</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues:</div><div class=\"line\"> </div><div class=\"line\">//FYPerson 设置age</div><div class=\"line\">- FYPerson FYPerson setAge:</div><div class=\"line\"></div><div class=\"line\">// didChangeValueForKeyOrKeys</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</div><div class=\"line\">- NSKeyValueUnnestedProperty NSKeyValueProperty keyPath</div><div class=\"line\"></div><div class=\"line\">//找到key 发送 具体的key对应的value 到observe</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject valueForKeyPath:</div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject valueForKey:</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject _createValueGetterWithContainerClassID:key:</div><div class=\"line\">-</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">+ NSKVONotifying_FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">- NSKVONotifying_FYPerson FYPerson age</div><div class=\"line\">+ NSKeyValueMethodGetter NSObject alloc</div><div class=\"line\">- NSKeyValueMethodGetter NSKeyValueMethodGetter initWithContainerClassID:key:method:</div><div class=\"line\">- NSKeyValueGetter NSKeyValueAccessor initWithContainerClassID:key:implementation:selector:extraArguments:count:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- NSKVONotifying_FYPerson NSObject respondsToSelector:</div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson class</div><div class=\"line\">- NSKVONotifying_FYPerson NSKVONotifying_FYPerson _isKVOA</div><div class=\"line\">+ FYPerson NSObject class</div><div class=\"line\">+ FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\">+ FYPerson NSObject resolveInstanceMethod:</div><div class=\"line\"></div><div class=\"line\">//数据字典</div><div class=\"line\">+ NSDictionary NSObject self</div><div class=\"line\">+ NSMutableDictionary NSObject self</div><div class=\"line\">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary initWithDetailsNoCopy:originalObservable:isPriorNotification:</div><div class=\"line\">- NSDictionary NSObject init</div><div class=\"line\"></div><div class=\"line\">// 执行观察者回调函数</div><div class=\"line\">- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">+ Student NSObject alloc</div><div class=\"line\">- Student NSObject init</div><div class=\"line\">- Student NSObject dealloc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">***//省略一部分代码</div><div class=\"line\"> NSKVONotifying_FYPerson NSObject release</div><div class=\"line\">- NSKeyValueChangeDictionary NSObject release</div><div class=\"line\">- NSKeyValueChangeDictionary NSKeyValueChangeDictionary dealloc</div><div class=\"line\">- NSDictionary NSObject dealloc</div><div class=\"line\">- NSKeyValueObservationInfo NSObject release</div><div class=\"line\">- NSKVONotifying_FYPerson NSObject release</div></pre></td></tr></table></figure>\n<p>经过仔细把重要的函数过滤出来，我们可以了解到<code>person.age = 12</code>的执行过程是<code>NSKVONotifying_FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty object:withObservance:willChangeValueForKeyOrKeys:recurse:forwardingValues</code>-&gt;<code>FYPerson FYPerson setAge:</code>-&gt;<code>NSKeyValueUnnestedProperty NSKeyValueUnnestedProperty object:withObservance:didChangeValueForKeyOrKeys:recurse:forwardingValues:</code>-&gt;<code>NSKVONotifying_FYPerson NSObject valueForKeyPath:</code>-&gt;<code>NSMutableDictionary NSObject self</code>-&gt;<code>- NSKVONotifying_FYPerson FYPerson observeValueForKeyPath:ofObject:change:context:</code>，我们来用伪代码实现一遍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//person.age = 12</div><div class=\"line\">[NSKVONotifying_FYPerson setAge:12];</div><div class=\"line\">willChangeValueForKey@&quot;age&quot;;</div><div class=\"line\">[FYPerson setAge:12];</div><div class=\"line\">didChangeValueForKey@&quot;age&quot;;</div><div class=\"line\">[[NSMutableDictionary alloc] init];</div><div class=\"line\">[NSKVONotifying_FYPerson observeValueForKeyPath:ofObject:change:context];</div></pre></td></tr></table></figure>\n<p>NSKVONotifyin_Person内部结构是怎样的？<br>首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。<br>我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    Person *p1 = [[Person alloc] init];</div><div class=\"line\">    p1.age = 1.0;</div><div class=\"line\">    Person *p2 = [[Person alloc] init];</div><div class=\"line\">    p1.age = 2.0;</div><div class=\"line\">    // self 监听 p1的 age属性</div><div class=\"line\">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</div><div class=\"line\">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</div><div class=\"line\"></div><div class=\"line\">    [self printMethods: object_getClass(p2)];</div><div class=\"line\">    [self printMethods: object_getClass(p1)];</div><div class=\"line\"></div><div class=\"line\">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void) printMethods:(Class)cls</div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count ;</div><div class=\"line\">    Method *methods = class_copyMethodList(cls, &amp;count);</div><div class=\"line\">    NSMutableString *methodNames = [NSMutableString string];</div><div class=\"line\">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0 ; i &lt; count; i++) &#123;</div><div class=\"line\">        Method method = methods[i];</div><div class=\"line\">        NSString *methodName  = NSStringFromSelector(method_getName(method));</div><div class=\"line\">        </div><div class=\"line\">        [methodNames appendString: methodName];</div><div class=\"line\">        [methodNames appendString:@&quot; &quot;];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;%@&quot;,methodNames);</div><div class=\"line\">    free(methods);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//结果如下：</div><div class=\"line\">NSKVONotifying_FYPerson - setAge: class dealloc _isKVOA</div><div class=\"line\">FYPerson - setAge: age</div></pre></td></tr></table></figure>\n<p> 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。</p>\n<p><img src=\"../images/3-1.png\" alt=\"\"></p>\n<p>这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。</p>\n<p>如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。</p>\n<p>那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">     // 得到类对象，在找到类对象父类</div><div class=\"line\">     return class_getSuperclass(object_getClass(self));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后自己写代码验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(void)willChangeValueForKey:(NSString *)key&#123;</div><div class=\"line\">\tNSLog(@&quot;%s 开始&quot;,__func__);</div><div class=\"line\">\t[super didChangeValueForKey:key];</div><div class=\"line\">\tNSLog(@&quot;%s 结束&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)didChangeValueForKey:(NSString *)key&#123;</div><div class=\"line\">\tNSLog(@&quot;%s 开始&quot;,__func__);</div><div class=\"line\">\t[super didChangeValueForKey:key];</div><div class=\"line\">\tNSLog(@&quot;%s 结束&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setAge:(double)age&#123;</div><div class=\"line\">\t_age = age;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>执行之后结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[FYPerson willChangeValueForKey:] 开始</div><div class=\"line\">-[FYPerson willChangeValueForKey:] 结束</div><div class=\"line\">-[FYPerson setAge:]</div><div class=\"line\">-[FYPerson didChangeValueForKey:] 开始</div><div class=\"line\"> 监听到了age变化： &#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 11;</div><div class=\"line\">    old = 10;</div><div class=\"line\">&#125;</div><div class=\"line\">-[FYPerson didChangeValueForKey:] 结束</div></pre></td></tr></table></figure>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>KVO其实是一个通过runtime注册建立子类，通过修改instance的isa指针，指向新的子类，重写instace的class方法来掩盖，子类拥有自己的set方法，调用顺序是willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p>\n<h3 id=\"KVC的本质\"><a href=\"#KVC的本质\" class=\"headerlink\" title=\"KVC的本质\"></a>KVC的本质</h3><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性。<br>常用的API有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</div><div class=\"line\">- (void)setValue:(id)value forKey:(NSString *)key;</div><div class=\"line\">- (id)valueForKeyPath:(NSString *)keyPath;</div><div class=\"line\">- (id)valueForKey:(NSString *)key;</div></pre></td></tr></table></figure>\n<p>其实当Obj调用<code>(void)setValue:(id)value forKey:(NSString *)key</code>的时候，<code>obj</code>会主动寻找方法<code>setKey</code>和<code>_setKey</code>两个方法，没有找到这两个方法会再去寻找<code>accessInstanceVariablesDirectly</code>，返回值为<code>NO</code>则抛出异常，返回<code>YES</code>则去按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的查找优先级查找成员变量，找到之后直接复制，否则抛出异常。<br>我们使用这段代码来验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">//code1</div><div class=\"line\">- (void)setAge:(NSInteger)age&#123;</div><div class=\"line\">\tNSLog(@&quot;%s %ld&quot;,__func__,(long)age);</div><div class=\"line\">&#125;</div><div class=\"line\">//code2</div><div class=\"line\">- (void)_setAge:(NSInteger)age&#123;</div><div class=\"line\">\tNSLog(@&quot;%s %ld&quot;,__func__,(long)age);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p setValue:@(2) forKey:@&quot;age&quot;];</div></pre></td></tr></table></figure>\n<p>当执行<code>code1</code>和<code>code2</code>都有的时候，输出<code>-[FYPerson setAge:] 2</code>，当<code>code1</code>注释掉，输出<code>-[FYPerson _setAge:] 2</code>，可以看出执行顺序是<code>setAge</code>，没有<code>setAge</code>的时候再去执行<code>_setAge</code>。</p>\n<p>现在新增<code>FYPerson</code>4个成员变量，依次注释掉他们来测试寻找成员变量的顺序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">@public</div><div class=\"line\">\tNSInteger _age;</div><div class=\"line\">\tNSInteger _isAge;</div><div class=\"line\">\tNSInteger age;</div><div class=\"line\">\tNSInteger isAge;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p setValue:@(2) forKey:@&quot;age&quot;];</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;age:%d _age:%d isAge:%d _isAge:%d&quot;,(int)p-&gt;age,(int)p-&gt;_age,(int)p-&gt;isAge,(int)p-&gt;_isAge);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>没注释输出 <code>age:0 _age:2 isAge:0 _isAge:0</code></li>\n<li>注释<code>_age</code>输出 <code>age:0 isAge:0 _isAge:2</code></li>\n<li>注释<code>_isAge</code>输出 <code>age:2 isAge:0</code></li>\n<li>注释<code>age</code>输出 <code>isAge:2</code></li>\n</ul>\n<h4 id=\"KVC和KVO联系\"><a href=\"#KVC和KVO联系\" class=\"headerlink\" title=\"KVC和KVO联系\"></a>KVC和KVO联系</h4><p>我们知道KVC本质也是调用setter方法，那么会出发KVO吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">[p addObserver:p</div><div class=\"line\">\tforKeyPath:@&quot;age&quot;</div><div class=\"line\">\t   options:NSKeyValueChangeNewKey</div><div class=\"line\">\t   context:nil];</div><div class=\"line\">[p setValue:@2 forKey:@&quot;age&quot;];</div><div class=\"line\">[p removeObserver:p forKeyPath:@&quot;age&quot;];</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tNSInteger _age;</div><div class=\"line\">\tNSInteger _isAge;</div><div class=\"line\">\tNSInteger age;</div><div class=\"line\">\tNSInteger isAge;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,change);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//结果</div><div class=\"line\">&#123;</div><div class=\"line\">    kind = 1;</div><div class=\"line\">    new = 2;</div><div class=\"line\">    old = 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过测试，可以看出KVC能触发KVO的。那么<code>valueForKey:key</code>底层是怎么运行的呢？其实底层是按照顺序查找四个方法<code>_age</code>-&gt;<code>_isAge</code>-&gt;<code>age</code>-&gt;<code>isAge</code>。我们测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">p-&gt;_age = 1;</div><div class=\"line\">p-&gt;_isAge = 2;</div><div class=\"line\">p-&gt;age = 3;</div><div class=\"line\">p-&gt;isAge = 4;</div><div class=\"line\">NSLog(@&quot;value:%@&quot;,[p valueForKey:@&quot;age&quot;]);</div><div class=\"line\">//依次注释1,2,3，依次输出是1-&gt;2-&gt;3-&gt;4</div></pre></td></tr></table></figure>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>KVC其实本质是执行4个set方法和4个get方法，当使用<code>setValue:forKey:key</code>会触发KVO，找不到4个方法的时候会抛出异常。</p>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n</ul>\n<p>之前看的没有手动去试验一下，然后再写出来，现在总结一下，参考了很多文章，还有macOS中日志记录是无意搜索出来了一个老外的blog，大家可以了解下，以后会有用，后边会讲如何<code>hook objc_msgsend</code>,感觉这个挺好玩的。</p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p> 广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理 runtime - super、hook、以及简单应用--(8)","date":"2019-12-01T03:18:58.000Z","_content":"\n### 关键字 super\n关键字`super`,在调用`[super init]`的时候，`super`会转化成结构体`__rw_objc_super`\n\n```\nstruct __rw_objc_super { \n\tstruct objc_object *object; //消息接受者\n\tstruct objc_object *superClass; //父类\n\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) {} \n};\n```\n\n`[super init]`使用命令`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m`转化成`cpp`\n打开`cpp`大概在底部的位置找到\n\n```\n(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"init\"))\n```\n\n简化之后是\n\n```\n(void *)objc_msgSendSuper((__rw_objc_super){self, class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"init\"))\n```\n\n`void\nobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )`\n    其实是向父类发送消息，参数是`struct objc_super *super, SEL op, ...`，我们源码中找到了该函数的实现在`objc-msg-arm64.s`\n    \n```\nENTRY _objc_msgSendSuper\nUNWIND _objc_msgSendSuper, NoFrame\n//根据结构体struct __rw_objc_super \n{ \n\t//struct objc_object *object; //消息接受者\n\t//struct objc_object *superClass; //父类\n}占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，\n//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16\nldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass\n\nCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\nEND_ENTRY _objc_msgSendSuper\n\n```\n将`self`和`superclass`赋值给 `p0, p16`调用`CacheLookup NORMAL`\n\n```\n.macro CacheLookup //.macro 是一个宏 使用 _cmd&mask 查找缓存中的方法\n\t// p1 = SEL, p16 = isa\n\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask\n#if !__LP64__\n\tand\tw11, w11, 0xffff\t// p11 = mask\n#endif\n\tand\tw12, w1, w11\t\t// x12 = _cmd & mask\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket 没有命中\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)\n\t\t                        // p12 = buckets + (mask << 1+PTRSHIFT)\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// double wrap\n\tJumpMiss $0\n\t\n.endmacro\n```\n\n汇编比较多，只看到第二行`p1 = SEL, p16 = isa`，查找缓存是从`p16`,也就是`superclass`开始查找，后边的都和`objc_msgSend`一样。\n大致上比较清楚了，`super`本质上调用了`objc_msgSendSuper`，`objc_msgSendSuper`是查找从父类开始查找方法。\n\n`[super init]`就是`self`直接调用父类`init`的方法，但是`objc_msgSend`接受者是`self`，假如是`[self init]`则会产生死循环。`[super test]`则是执行父类的`test`。\n使用`Debug Workflow->Always Show Disassemdly`发现`super`其实调用了汇编的`objc_msgSendSuper2`，进入`objc_msgSendSuper2 objc-msg-arm64.s 422 行`发现和`objc_msgSendSuper`其实基本一致的\n\n```\n//_objc_msgSendSuper 开始\n\tENTRY _objc_msgSendSuper\n\tUNWIND _objc_msgSendSuper, NoFrame\n//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16\n\tldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass\n\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\tEND_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束\n\t\n//objc_msgLookupSuper2 开始\n\tENTRY _objc_msgSendSuper2 \n\tUNWIND _objc_msgSendSuper2, NoFrame\n\n\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class\n\t//将存储器地址为x16+8的字数据读入寄存器p16。\n\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class->superclass\n\tCacheLookup NORMAL\n\tEND_ENTRY _objc_msgSendSuper2\n```\n\n也可以使用`LLVM`转化成中间代码来查看，`clang -emit-llvm -S FYCat.m`查看关键函数\n\n```\ndefine internal void @\"\\01-[FYCat forwardInvocation:]\"(%1*, i8*, %2*) #1 {\n    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)\n}\n```\n这是`forwardInvocation`函数的调用代码，简化之后是`objc_msgSendSuper2(self,struct._objc_super i8*,%2*)`，就是`objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)`。\n\n验证\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n- (int)age;\n-(void)test;\n@end\n\n@implementation FYPerson\n- (void)test{\n    ;    NSLog(@\"%s\",__func__);\n}\n- (int)age{\n    NSLog(@\"%s\",__func__);\n    return 10;\n}\n- (NSString *)name{\n    return [_name stringByAppendingString:@\" eat apple\"];\n}\n@end\n\n\n@interface FYStudent : FYPerson\n\n@end\n@implementation FYStudent\n- (void)test{\n    [super test]; //执行父类的test\n    int age = [super age]; //获取父类的方法 返回值\n    NSLog(@\"age is %d\",age);\n    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值\n    NSLog(@\"%@\",name);\n}\n-(int)age{\n    return 12;\n}\n@end\n//输出\n-[FYPerson test]\n-[FYPerson age]\nage is 10\n小李子 eat apple\n\n```\n\n`test`是执行父类的方法，`[super age]`获取父类中固定的`age`,\n`[self name]`从父类开始寻找`name`的值，但返回的是`self.name`的值。\n\n###  isMemberOfClass &  isKindOfClass\n\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return object_getClass((id)self) == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {\n        printf(\"%s %s\\n\",class_getName(tcls),class_getName(cls));\n        if (tcls == cls)\n        {return YES;}else{\n            printf(\"%s\",class_getName(tcls));\n        }\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        \n        printf(\" %s %s\\n\",class_getName(tcls),class_getName(cls));\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n+ (BOOL)isSubclassOfClass:(Class)cls {\n    for (Class tcls = self; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n`- (BOOL)isMemberOfClass`和`- (BOOL)isKindOfClass:(Class)cls`比较简单，都是判断`self.class` 和`cls`，`+ (BOOL)isMemberOfClass:(Class)cls`是判断`self.class->isa`是否和`cls`相等，`+ (BOOL)isKindOfClass:(Class)cls`判断`cls->isa`和`cls->isa->isa`有没有可能和`cls`相等？只有基类是，其他的都不是。\n#### 验证 实例方法\n\n```\nClass cls = NSObject.class;\nClass pcls = FYPerson.class;\nFYPerson *p=[FYPerson new];\nNSObject *obj=[NSObject new];\nBOOL res11 =[p isKindOfClass:pcls];\nBOOL res12 =[p isMemberOfClass:pcls];\nBOOL res13 =[obj isKindOfClass:cls];\nBOOL res14 =[obj isMemberOfClass:cls];\nNSLog(@\"instance:%d %d %d %d\",res11,res12,res13,res14);\n//log\n//instance:1 1 1 1\n```\n\n`p`是`pcls`的子类，`obj` 是`cls`的子类，在明显不过了。\n\n#### 验证 类方法\n\n```\n\n//isKindOfClass cls->isa 和cls/cls->superclass相等吗?\n//元类对象和类对象不相等，但是最后一个元类的isa->superclass是指向NSObject的class 所以res1 = YES;\n//cls->isa:元类对象 cls->isa->superclass: NSObject类对象\n//cls:类对象\nBOOL res1 =[cls isKindOfClass:cls];\n//cls->isa 和cls相等吗？ 不相等 cls->isa是元类对象,cls是类对象，不可能相等。\nBOOL res2 =[cls isMemberOfClass:cls];\n//pcls->isa:person的元类对象 cls->isa->superclass: NSObject元类类对象 ->superclass:NSObject类对象 ->superclass:nil\n//pcls:person类对象\nBOOL res3 =[pcls isKindOfClass:pcls];\n//pcls->isa:person的元类对象\n//pcls:person类对象\nBOOL res4 =[pcls isMemberOfClass:pcls];\nNSLog(@\"%d %d %d %d\",res1,res2,res3,res4);\n结果：\n1 0 0 0\n```\n\n### 堆栈 对象本质 class本质实战\n网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。\n其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文[obj_msgsend基础](https://juejin.im/post/5d2d200be51d4510a7328161)、[类的本质](https://juejin.im/post/5d19c59e6fb9a07f04205f95)、[对象的本质](https://juejin.im/post/5d15887ee51d45108126d28d)。\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n- (void)print;\n@end\n@implementation FYPerson\n- (void)print{\n    NSLog(@\"my name is %@\",self.name);\n}\n@end\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030\n    id cls  = [FYPerson class];针\n    void * obj = &cls; \n    [(__bridge id)obj print];\n}\n```\n\n#### 问题一 能否编译成功？\n当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有`id self `和`SEL sel`，现在`cls`和`obj`都在栈区，`obj` 指针指向`cls`的内存地址，访问`obj`相当于直接访问`cls`内存存储的值，`cls`存储的是`Person.class`,`[obj print]` 相当于`objc_msgSend(cls,@selector(print))`,`cls`是有`print`方法的，所以会编译成功。\n#### 输出什么？\n`fix/cls/obj`这三个对象都是存储在栈上，`fix/cls/obj`地址是连续从高到低的，而且他们地址相差都是`8`字节，一个指针大小是`8`字节。他们三个地址如下所示：\n\n使用图来表示`fix`和`obj`：\n|对象|地址|地址高低|\n|:-:|:-:|:-:|:-:|\n|fix|0x7ffeec3df920| 高 |\n|cls|0x7ffeec3df918|中|\n|obj|0x7ffeec3df910|低|\n\n寻找属性先是寻找`isa`，然后再在`isa`地址上+`8`则是属性的值，所以根据`obj`寻找`cls`地址是`0x7ffeec3df918`,然后`cls`地址+8字节则是`_name`的地址，`cls`地址是`0x7ffeec3df918`，加上`8`字节正好是`fix`的地址`0x7ffeec3df920`，因为都是指针，所以都是`8`字节,所以最后输出是结果是`fix`对象的地址的数据。\n\n情况再复杂一点，`FYPerson`结构改动一下\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,copy) NSString *name2;\n@property (nonatomic,copy) NSString *name3;\n- (void)print;\n@end\n```\n则他们的`_name`、`_name2`、`_name3`则在`cls`的地址基础上再向上寻找`8*1=8/8*2=16/8*3=24`字节，就是向上寻找第1个，第2个，第3个指向对象的指针。\n\n\n测试代码：\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,copy) NSString *name2;\n@property (nonatomic,copy) NSString *name3;\n- (void)print;\n@end\n@implementation FYPerson\n- (void)print{\n    NSLog(@\"name1:%@ name2:%@ name3:%@\",self.name1,self.name2,self.name3);\n}\n@end\n\n//主函数\n\nNSObject *fix =[NSObject new];\nFYPerson *fix2 =[FYPerson new];\n\nid cls  = [FYPerson class];\nvoid * obj = &cls; \n[(__bridge id)obj print];//objc_msgSend(self,sel);\nNSLog(@\"fix:%p fix2:%p cls:%p obj:%p\",&fix,&fix2,&cls,&obj);\n\n//log\nname1:<FYPerson: 0x6000033a38a0> \nname2:<NSObject: 0x6000031f5380> \nname3:<ViewController: 0x7f8307505580>\n\nfix: 0x7ffeec3d f9 28 \nfix2:0x7ffeec3d f9 20 \ncls: 0x7ffeec3d f9 18 \nobj: 0x7ffeec3d f9 10\n```\n\n再变形：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\t/*\n\t objc_msgSuperSend(self,ViewController,sel)\n\t */\nNSLog(@\"self:%p ViewController.class:%p SEL:%p\",self,ViewController.class,@selector(viewDidLoad));\n    id cls  = [FYPerson class];//cls 是类指针\n    void * obj = &cls; //obj \n    [(__bridge id)obj print];//objc_msgSend(self,sel);\n    \n NSLog(@\"cls:%p obj:%p\",&cls,&obj);\n //log\n \n name1:<ViewController: 0x7fad03e04ea0> \n name2:ViewController\n \n self:                  0x7fad03e04ea0 \n ViewController.class:  0x10d0edf00 \n SEL:                   0x1117d5687\n \n cls:0x7ffee2b11908 \n obj:0x7ffee2b11900\n \n}\n```\n\n`_name1`是`cls`地址向上+8字节，`_name2`是向上移动16字节，`[super viewDidLoad]`本质上是`objc_msgSuperSend(self,ViewController.class,sel)`，`self`、`ViewController.class`、`SEL`是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，\n结构体如下图所示：\n\n|对象|地址高低|\n|:-:|:-:|\n|self|低|\n|ViewController.class|中|\n|SEL|高|\n\n\n### 常用的runtimeAPI \n\n|method|desc|\n|:-:|:-:|\n|Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)|动态创建一个类（参数：父类，类名，额外的内存空间|\n|void objc_registerClassPair(Class cls))|注册一个类|\n|void objc_disposeClassPair(Class cls)|销毁一个类|\n|Class objcect_getClass(id obj)|获取isa指向的class|\n|Class object_setClass (id obj,Class cls)|设置isa指向的class|\n|BOOL object_isClass(id class)|判断oc对象是否为Class|\n|BOOL class_isMetaClass(Class cls)|是否是元类|\n|Class class_getSuperclass(Class cls)|获取父类|\n|Ivar class_getInstanceVariable(Class cls ,const char * name|获取一个实例变量信息|\n|Ivar * class_copyIvarList(Class cls,unsigned int * outCount)|拷贝实例变量列表，需要free|\n|void object_setIvar(id obj,Ivar ivar,id value|设置获取实例变量的值|\n|id object_getIvar(id obj,Ivar ivar)|获取实例变量的值|\n|BOOL class_addIvar(Class cls,const cahr * name ,size_t size,uint_t alignment,const char * types)|动态添加成员变量（已注册的类不能动态添加成员变量）|\n|const char * ivar_getName（Ivar v)|获取变量名字|\n|const char * ivar_getTypeEncoding(Ivar v)|变量的encode|\n|objc_property_t class_getProperty(Class cls,const char* name)|获取一个属性|\n|objc_property_t _Nonnull * _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)|拷贝属性列表|\n|objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)|获取属性列表|\n| BOOL class_addProperty(Class _Nullable cls, const char * _Nonnull name,const objc_property_attribute_t * _Nullable attributes,unsigned int attributeCount)|添加属性|\n| void class_replaceProperty(Class _Nullable cls, const char * _Nonnull name,const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)|替换属性|\n|void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)|动态替换属性|\n|const char * _Nonnull property_getName(objc_property_t _Nonnull property) |获取name|\n|const char * _Nullable property_getAttributes(objc_property_t _Nonnull property) |获取属性的属性|\n|IMP imp_implementationWithBlock(id block)|获取block的IMP|\n|id imp_getBlock(IMP anIMP)|通过imp 获取block|\n|BOOL imp_removeBlock(IMP anIMP)|IMP是否被删除|\n|...|...|\n在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们\n获取`class`的所有成员变量,可以获取`Ivar`查看是否有该变量，然后可以通过`KVC`来赋值。\n\n```\n\n@interface FYCat : NSObject\n@property (nonatomic,copy) NSString * name;\n@property (nonatomic,assign) int  age;\n@end\n\nFYCat *cat=[FYCat new];\nunsigned int count = 0;\nIvar *vars= class_copyIvarList(cat.class, &count);\nfor (int i = 0; i < count; i ++) {\n\tIvar item = vars[i];\n\tconst char *name = ivar_getName(item);\n\tNSLog(@\"%s\",name);\n}\nfree(vars);\n\nMethod *m1= class_copyMethodList(cat.class, &count);\nfor (int i = 0; i < count; i ++) {\n\tMethod item = m1[i];\n\tSEL name = method_getName(item);\n\tprintf(\"method:%s \\n\",NSStringFromSelector(name).UTF8String);\n}\nfree(m1);\n\t\t\n//log\n_age\n_name\n\nmethod:.cxx_destruct \nmethod:name \nmethod:setName: \nmethod:methodSignatureForSelector: \nmethod:forwardInvocation: \nmethod:age \nmethod:setAge:\n```\n\n大家常用的一个功能是`JsonToModel`，那么我们已经了解到了`runtime`的基础知识，现在可以自己撸一个`JsonToModel`了。\n\n```\n@interface NSObject (Json)\n+ (instancetype)fy_objectWithJson:(NSDictionary *)json;\n@end\n@implementation NSObject (Json)\n+ (instancetype)fy_objectWithJson:(NSDictionary *)json{\n\tid obj = [[self alloc]init];\n\tunsigned int count = 0;\n\tIvar *vars= class_copyIvarList(self, &count);\n\tfor (int i = 0; i < count; i ++) {\n\t\tIvar item = vars[i];\n\t\tconst char *name = ivar_getName(item);\n\t\tNSString * nameOC= [NSString stringWithUTF8String:name];\n\t\tif (nameOC.length>1) {\n\t\t\tnameOC = [nameOC substringFromIndex:1];\n\t\t\tNSString * value = json[nameOC];\n\t\t\tif ([value isKindOfClass:NSString.class] && value.length) {\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:NSArray.class]){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:NSDictionary.class]){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])\n\t\t\t{\n\t\t\t\tprintf(\"%s value is nil or null \\n\",name);\n\t\t\t}else if ([value integerValue] > 0){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else{\n\t\t\t\tprintf(\"未知错误 \\n\");\n\t\t\t}\n\t\t}\n\t}\n\tfree(vars);\n\treturn obj;\n}\n@end\n```\n\n然后自己定义一个字典，来测试一下这段代码\n\n```\n@interface FYCat : NSObject\n@property (nonatomic,copy) NSString * name;\n@property (nonatomic,assign) int  age;\n\n- (void)run;\n@end\n\nNSDictionary * info = @{@\"age\":@\"10\",@\"value\":@10,@\"name\":@\"小明\"};\n\t\tFYCat *cat=[FYCat fy_objectWithJson:info];\n//log\nage:10 name:小明\n```\n\n#### hook钩子(method_exchangeImplementations)\n由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。\n\n```\n@implementation UIButton (add)\n+ (void)load{\n\tMethod m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));\n\tMethod m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tmethod_exchangeImplementations(m1, m2);\n\t});\n}\n- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event{\n\tNSLog(@\"%@ \",NSStringFromSelector(action));\n\t/*\n\t code here\n\t */\n\t //sel IMP 已经交换过了，所以不会死循环\n\t[self fy_sendAction:action to:target forEvent:event];\n}\n@end\n```\n\n可以在`code here`添加需要处理的代码，一般记录日志和延迟触发都可以处理。`[self fy_sendAction:action to:target forEvent:event];`不会产生死循环，原因是在`+load`中已经将`m1`和`m2`已经交换过了`IMP`。我们进入到`method_exchangeImplementations`内部：\n\n```\nvoid method_exchangeImplementations(Method m1, Method m2)\n{\n    if (!m1  ||  !m2) return;\n\n    mutex_locker_t lock(runtimeLock);\n\n//交换IMP\n    IMP m1_imp = m1->imp;\n    m1->imp = m2->imp;\n    m2->imp = m1_imp;\n\n//刷新缓存\n    flushCaches(nil);\n\n    updateCustomRR_AWZ(nil, m1);\n    updateCustomRR_AWZ(nil, m2);\n}\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n};\nusing MethodListIMP = IMP;\n```\n\n`m1`和`m2`交换了`IMP`，交换的是`method_t->imp`，然后刷新缓存(清空缓存)，等下次调用`IMP`则需要在`cls->rw->data->method`中去寻找。\n\n#### 数组越界和nil处理\n\n```\n@implementation NSMutableArray (add)\n+ (void)load{\n\tClass cls= NSClassFromString(@\"__NSArrayM\");\n\tMethod m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));\n\tSEL sel = @selector(fy_insertObject:atIndex:);\n\tMethod m2= class_getInstanceMethod(cls, sel);\n\t\n\tMethod m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));\n\tMethod m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));\n\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tmethod_exchangeImplementations(m1, m2);\n\t\tmethod_exchangeImplementations(m3, m4);\n\t});\n}\n\n- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index{\n\tif (anObject != nil) {\n\t\t[self fy_insertObject:anObject atIndex:index];\n\t}else{\n\t\tprintf(\" anObject is nil \\n\");\n\t}\n}\n- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx{\n\tif (self.count > idx) {\n\t\treturn [self fy_objectAtIndexedSubscript:idx];\n\t}else{\n\t\tprintf(\" %ld is outof rang \\n\",(long)idx);\n\t\treturn nil;\n\t}\n}\n@end\n\n\n\nNSMutableArray *array=[NSMutableArray array];\nid obj = nil;\n[array addObject:obj];\narray[1];\n\n//log\n anObject is nil \n 1 is outof rang \n```\n\n`NSMutableArray`是类簇，使用工厂模式，`NSMutableArray`不是数组实例，而是生产数组对象的工厂。\n真实的数组对象是`__NSArrayM`,然后给`__NSArrayM`钩子，交换`objectAtIndexedSubscript:(NSUInteger)idx`和`insertObject:(id)anObject atIndex:(NSUInteger)index`方法，实现崩溃避免。\n\n\n#### 字典nil处理\n\n```\n@interface NSMutableDictionary (add)\n\n@end\n\n@implementation NSMutableDictionary (add)\n+ (void)load{\n    Class cls= NSClassFromString(@\"__NSDictionaryM\");\n    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));\n//    __NSDictionaryM\n    SEL sel = @selector(fy_setObject:forKey:);\n    Method m2= class_getInstanceMethod(cls, sel);\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        method_exchangeImplementations(m1, m2);\n    });\n}\n- (void)fy_setObject:(id)anObject forKey:(id<NSCopying>)aKey{\n    if (anObject) {\n        [self fy_setObject:anObject forKey:aKey];\n    }else{\n        NSString * key = (NSString *)aKey;\n        printf(\"key:%s anobj is nil \\n\",key.UTF8String);\n    }\n}\n@end\n```\n\n利用类别`+load`给`__NSDictionaryM`添加方法，然后交换`IMP`，实现给`NSMutableDictionary setObject:Key:`的时候进行`nil`校验,`+load`虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成`IMP`和`SEL`混乱，使用`dispatch_once`进行单次运行。\n\n### 总结\n1. `super`本质上是`self`调用函数，不过查找函数是从`sueprclass`开始查找的\n2. `+isKandOfClass`是判断`self`是否是`cls`的子类，`+isMemberOfClass:`是判断`self`是否和`cls`相同。\n3. 了解`+load`在`Category`是启动的时候使用运行时编译的，而且只会加载一次,然后利用`objc/runtime.h`中`method_exchangeImplementations`实现交换两个函数的`IMP`，可以实现拦截`nil`，降低崩溃率。\n4. `NSMutableDictionary`、`NSMutableArray`是类簇，先找到他们的类然后再交换该类的函数的`IMP`。\n\n### 资料参考\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 runtime - super、hook、以及简单应用--(8).md","raw":"title: iOS底层原理 runtime - super、hook、以及简单应用--(8)\ndate: 2019-12-1 11:18:58\ntags:\n- iOS\ncategories: iOS\n---\n\n### 关键字 super\n关键字`super`,在调用`[super init]`的时候，`super`会转化成结构体`__rw_objc_super`\n\n```\nstruct __rw_objc_super { \n\tstruct objc_object *object; //消息接受者\n\tstruct objc_object *superClass; //父类\n\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) {} \n};\n```\n\n`[super init]`使用命令`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m`转化成`cpp`\n打开`cpp`大概在底部的位置找到\n\n```\n(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"init\"))\n```\n\n简化之后是\n\n```\n(void *)objc_msgSendSuper((__rw_objc_super){self, class_getSuperclass(objc_getClass(\"Student\"))}, sel_registerName(\"init\"))\n```\n\n`void\nobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )`\n    其实是向父类发送消息，参数是`struct objc_super *super, SEL op, ...`，我们源码中找到了该函数的实现在`objc-msg-arm64.s`\n    \n```\nENTRY _objc_msgSendSuper\nUNWIND _objc_msgSendSuper, NoFrame\n//根据结构体struct __rw_objc_super \n{ \n\t//struct objc_object *object; //消息接受者\n\t//struct objc_object *superClass; //父类\n}占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，\n//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16\nldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass\n\nCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\nEND_ENTRY _objc_msgSendSuper\n\n```\n将`self`和`superclass`赋值给 `p0, p16`调用`CacheLookup NORMAL`\n\n```\n.macro CacheLookup //.macro 是一个宏 使用 _cmd&mask 查找缓存中的方法\n\t// p1 = SEL, p16 = isa\n\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask\n#if !__LP64__\n\tand\tw11, w11, 0xffff\t// p11 = mask\n#endif\n\tand\tw12, w1, w11\t\t// x12 = _cmd & mask\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket 没有命中\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)\n\t\t                        // p12 = buckets + (mask << 1+PTRSHIFT)\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// double wrap\n\tJumpMiss $0\n\t\n.endmacro\n```\n\n汇编比较多，只看到第二行`p1 = SEL, p16 = isa`，查找缓存是从`p16`,也就是`superclass`开始查找，后边的都和`objc_msgSend`一样。\n大致上比较清楚了，`super`本质上调用了`objc_msgSendSuper`，`objc_msgSendSuper`是查找从父类开始查找方法。\n\n`[super init]`就是`self`直接调用父类`init`的方法，但是`objc_msgSend`接受者是`self`，假如是`[self init]`则会产生死循环。`[super test]`则是执行父类的`test`。\n使用`Debug Workflow->Always Show Disassemdly`发现`super`其实调用了汇编的`objc_msgSendSuper2`，进入`objc_msgSendSuper2 objc-msg-arm64.s 422 行`发现和`objc_msgSendSuper`其实基本一致的\n\n```\n//_objc_msgSendSuper 开始\n\tENTRY _objc_msgSendSuper\n\tUNWIND _objc_msgSendSuper, NoFrame\n//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16\n\tldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass\n\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\tEND_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束\n\t\n//objc_msgLookupSuper2 开始\n\tENTRY _objc_msgSendSuper2 \n\tUNWIND _objc_msgSendSuper2, NoFrame\n\n\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class\n\t//将存储器地址为x16+8的字数据读入寄存器p16。\n\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class->superclass\n\tCacheLookup NORMAL\n\tEND_ENTRY _objc_msgSendSuper2\n```\n\n也可以使用`LLVM`转化成中间代码来查看，`clang -emit-llvm -S FYCat.m`查看关键函数\n\n```\ndefine internal void @\"\\01-[FYCat forwardInvocation:]\"(%1*, i8*, %2*) #1 {\n    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)\n}\n```\n这是`forwardInvocation`函数的调用代码，简化之后是`objc_msgSendSuper2(self,struct._objc_super i8*,%2*)`，就是`objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)`。\n\n验证\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n- (int)age;\n-(void)test;\n@end\n\n@implementation FYPerson\n- (void)test{\n    ;    NSLog(@\"%s\",__func__);\n}\n- (int)age{\n    NSLog(@\"%s\",__func__);\n    return 10;\n}\n- (NSString *)name{\n    return [_name stringByAppendingString:@\" eat apple\"];\n}\n@end\n\n\n@interface FYStudent : FYPerson\n\n@end\n@implementation FYStudent\n- (void)test{\n    [super test]; //执行父类的test\n    int age = [super age]; //获取父类的方法 返回值\n    NSLog(@\"age is %d\",age);\n    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值\n    NSLog(@\"%@\",name);\n}\n-(int)age{\n    return 12;\n}\n@end\n//输出\n-[FYPerson test]\n-[FYPerson age]\nage is 10\n小李子 eat apple\n\n```\n\n`test`是执行父类的方法，`[super age]`获取父类中固定的`age`,\n`[self name]`从父类开始寻找`name`的值，但返回的是`self.name`的值。\n\n###  isMemberOfClass &  isKindOfClass\n\n```\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return object_getClass((id)self) == cls;\n}\n\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {\n        printf(\"%s %s\\n\",class_getName(tcls),class_getName(cls));\n        if (tcls == cls)\n        {return YES;}else{\n            printf(\"%s\",class_getName(tcls));\n        }\n    }\n    return NO;\n}\n\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        \n        printf(\" %s %s\\n\",class_getName(tcls),class_getName(cls));\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n+ (BOOL)isSubclassOfClass:(Class)cls {\n    for (Class tcls = self; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n\n`- (BOOL)isMemberOfClass`和`- (BOOL)isKindOfClass:(Class)cls`比较简单，都是判断`self.class` 和`cls`，`+ (BOOL)isMemberOfClass:(Class)cls`是判断`self.class->isa`是否和`cls`相等，`+ (BOOL)isKindOfClass:(Class)cls`判断`cls->isa`和`cls->isa->isa`有没有可能和`cls`相等？只有基类是，其他的都不是。\n#### 验证 实例方法\n\n```\nClass cls = NSObject.class;\nClass pcls = FYPerson.class;\nFYPerson *p=[FYPerson new];\nNSObject *obj=[NSObject new];\nBOOL res11 =[p isKindOfClass:pcls];\nBOOL res12 =[p isMemberOfClass:pcls];\nBOOL res13 =[obj isKindOfClass:cls];\nBOOL res14 =[obj isMemberOfClass:cls];\nNSLog(@\"instance:%d %d %d %d\",res11,res12,res13,res14);\n//log\n//instance:1 1 1 1\n```\n\n`p`是`pcls`的子类，`obj` 是`cls`的子类，在明显不过了。\n\n#### 验证 类方法\n\n```\n\n//isKindOfClass cls->isa 和cls/cls->superclass相等吗?\n//元类对象和类对象不相等，但是最后一个元类的isa->superclass是指向NSObject的class 所以res1 = YES;\n//cls->isa:元类对象 cls->isa->superclass: NSObject类对象\n//cls:类对象\nBOOL res1 =[cls isKindOfClass:cls];\n//cls->isa 和cls相等吗？ 不相等 cls->isa是元类对象,cls是类对象，不可能相等。\nBOOL res2 =[cls isMemberOfClass:cls];\n//pcls->isa:person的元类对象 cls->isa->superclass: NSObject元类类对象 ->superclass:NSObject类对象 ->superclass:nil\n//pcls:person类对象\nBOOL res3 =[pcls isKindOfClass:pcls];\n//pcls->isa:person的元类对象\n//pcls:person类对象\nBOOL res4 =[pcls isMemberOfClass:pcls];\nNSLog(@\"%d %d %d %d\",res1,res2,res3,res4);\n结果：\n1 0 0 0\n```\n\n### 堆栈 对象本质 class本质实战\n网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。\n其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文[obj_msgsend基础](https://juejin.im/post/5d2d200be51d4510a7328161)、[类的本质](https://juejin.im/post/5d19c59e6fb9a07f04205f95)、[对象的本质](https://juejin.im/post/5d15887ee51d45108126d28d)。\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n- (void)print;\n@end\n@implementation FYPerson\n- (void)print{\n    NSLog(@\"my name is %@\",self.name);\n}\n@end\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030\n    id cls  = [FYPerson class];针\n    void * obj = &cls; \n    [(__bridge id)obj print];\n}\n```\n\n#### 问题一 能否编译成功？\n当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有`id self `和`SEL sel`，现在`cls`和`obj`都在栈区，`obj` 指针指向`cls`的内存地址，访问`obj`相当于直接访问`cls`内存存储的值，`cls`存储的是`Person.class`,`[obj print]` 相当于`objc_msgSend(cls,@selector(print))`,`cls`是有`print`方法的，所以会编译成功。\n#### 输出什么？\n`fix/cls/obj`这三个对象都是存储在栈上，`fix/cls/obj`地址是连续从高到低的，而且他们地址相差都是`8`字节，一个指针大小是`8`字节。他们三个地址如下所示：\n\n使用图来表示`fix`和`obj`：\n|对象|地址|地址高低|\n|:-:|:-:|:-:|:-:|\n|fix|0x7ffeec3df920| 高 |\n|cls|0x7ffeec3df918|中|\n|obj|0x7ffeec3df910|低|\n\n寻找属性先是寻找`isa`，然后再在`isa`地址上+`8`则是属性的值，所以根据`obj`寻找`cls`地址是`0x7ffeec3df918`,然后`cls`地址+8字节则是`_name`的地址，`cls`地址是`0x7ffeec3df918`，加上`8`字节正好是`fix`的地址`0x7ffeec3df920`，因为都是指针，所以都是`8`字节,所以最后输出是结果是`fix`对象的地址的数据。\n\n情况再复杂一点，`FYPerson`结构改动一下\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,copy) NSString *name2;\n@property (nonatomic,copy) NSString *name3;\n- (void)print;\n@end\n```\n则他们的`_name`、`_name2`、`_name3`则在`cls`的地址基础上再向上寻找`8*1=8/8*2=16/8*3=24`字节，就是向上寻找第1个，第2个，第3个指向对象的指针。\n\n\n测试代码：\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,copy) NSString *name;\n@property (nonatomic,copy) NSString *name2;\n@property (nonatomic,copy) NSString *name3;\n- (void)print;\n@end\n@implementation FYPerson\n- (void)print{\n    NSLog(@\"name1:%@ name2:%@ name3:%@\",self.name1,self.name2,self.name3);\n}\n@end\n\n//主函数\n\nNSObject *fix =[NSObject new];\nFYPerson *fix2 =[FYPerson new];\n\nid cls  = [FYPerson class];\nvoid * obj = &cls; \n[(__bridge id)obj print];//objc_msgSend(self,sel);\nNSLog(@\"fix:%p fix2:%p cls:%p obj:%p\",&fix,&fix2,&cls,&obj);\n\n//log\nname1:<FYPerson: 0x6000033a38a0> \nname2:<NSObject: 0x6000031f5380> \nname3:<ViewController: 0x7f8307505580>\n\nfix: 0x7ffeec3d f9 28 \nfix2:0x7ffeec3d f9 20 \ncls: 0x7ffeec3d f9 18 \nobj: 0x7ffeec3d f9 10\n```\n\n再变形：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\t/*\n\t objc_msgSuperSend(self,ViewController,sel)\n\t */\nNSLog(@\"self:%p ViewController.class:%p SEL:%p\",self,ViewController.class,@selector(viewDidLoad));\n    id cls  = [FYPerson class];//cls 是类指针\n    void * obj = &cls; //obj \n    [(__bridge id)obj print];//objc_msgSend(self,sel);\n    \n NSLog(@\"cls:%p obj:%p\",&cls,&obj);\n //log\n \n name1:<ViewController: 0x7fad03e04ea0> \n name2:ViewController\n \n self:                  0x7fad03e04ea0 \n ViewController.class:  0x10d0edf00 \n SEL:                   0x1117d5687\n \n cls:0x7ffee2b11908 \n obj:0x7ffee2b11900\n \n}\n```\n\n`_name1`是`cls`地址向上+8字节，`_name2`是向上移动16字节，`[super viewDidLoad]`本质上是`objc_msgSuperSend(self,ViewController.class,sel)`，`self`、`ViewController.class`、`SEL`是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，\n结构体如下图所示：\n\n|对象|地址高低|\n|:-:|:-:|\n|self|低|\n|ViewController.class|中|\n|SEL|高|\n\n\n### 常用的runtimeAPI \n\n|method|desc|\n|:-:|:-:|\n|Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)|动态创建一个类（参数：父类，类名，额外的内存空间|\n|void objc_registerClassPair(Class cls))|注册一个类|\n|void objc_disposeClassPair(Class cls)|销毁一个类|\n|Class objcect_getClass(id obj)|获取isa指向的class|\n|Class object_setClass (id obj,Class cls)|设置isa指向的class|\n|BOOL object_isClass(id class)|判断oc对象是否为Class|\n|BOOL class_isMetaClass(Class cls)|是否是元类|\n|Class class_getSuperclass(Class cls)|获取父类|\n|Ivar class_getInstanceVariable(Class cls ,const char * name|获取一个实例变量信息|\n|Ivar * class_copyIvarList(Class cls,unsigned int * outCount)|拷贝实例变量列表，需要free|\n|void object_setIvar(id obj,Ivar ivar,id value|设置获取实例变量的值|\n|id object_getIvar(id obj,Ivar ivar)|获取实例变量的值|\n|BOOL class_addIvar(Class cls,const cahr * name ,size_t size,uint_t alignment,const char * types)|动态添加成员变量（已注册的类不能动态添加成员变量）|\n|const char * ivar_getName（Ivar v)|获取变量名字|\n|const char * ivar_getTypeEncoding(Ivar v)|变量的encode|\n|objc_property_t class_getProperty(Class cls,const char* name)|获取一个属性|\n|objc_property_t _Nonnull * _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)|拷贝属性列表|\n|objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)|获取属性列表|\n| BOOL class_addProperty(Class _Nullable cls, const char * _Nonnull name,const objc_property_attribute_t * _Nullable attributes,unsigned int attributeCount)|添加属性|\n| void class_replaceProperty(Class _Nullable cls, const char * _Nonnull name,const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)|替换属性|\n|void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)|动态替换属性|\n|const char * _Nonnull property_getName(objc_property_t _Nonnull property) |获取name|\n|const char * _Nullable property_getAttributes(objc_property_t _Nonnull property) |获取属性的属性|\n|IMP imp_implementationWithBlock(id block)|获取block的IMP|\n|id imp_getBlock(IMP anIMP)|通过imp 获取block|\n|BOOL imp_removeBlock(IMP anIMP)|IMP是否被删除|\n|...|...|\n在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们\n获取`class`的所有成员变量,可以获取`Ivar`查看是否有该变量，然后可以通过`KVC`来赋值。\n\n```\n\n@interface FYCat : NSObject\n@property (nonatomic,copy) NSString * name;\n@property (nonatomic,assign) int  age;\n@end\n\nFYCat *cat=[FYCat new];\nunsigned int count = 0;\nIvar *vars= class_copyIvarList(cat.class, &count);\nfor (int i = 0; i < count; i ++) {\n\tIvar item = vars[i];\n\tconst char *name = ivar_getName(item);\n\tNSLog(@\"%s\",name);\n}\nfree(vars);\n\nMethod *m1= class_copyMethodList(cat.class, &count);\nfor (int i = 0; i < count; i ++) {\n\tMethod item = m1[i];\n\tSEL name = method_getName(item);\n\tprintf(\"method:%s \\n\",NSStringFromSelector(name).UTF8String);\n}\nfree(m1);\n\t\t\n//log\n_age\n_name\n\nmethod:.cxx_destruct \nmethod:name \nmethod:setName: \nmethod:methodSignatureForSelector: \nmethod:forwardInvocation: \nmethod:age \nmethod:setAge:\n```\n\n大家常用的一个功能是`JsonToModel`，那么我们已经了解到了`runtime`的基础知识，现在可以自己撸一个`JsonToModel`了。\n\n```\n@interface NSObject (Json)\n+ (instancetype)fy_objectWithJson:(NSDictionary *)json;\n@end\n@implementation NSObject (Json)\n+ (instancetype)fy_objectWithJson:(NSDictionary *)json{\n\tid obj = [[self alloc]init];\n\tunsigned int count = 0;\n\tIvar *vars= class_copyIvarList(self, &count);\n\tfor (int i = 0; i < count; i ++) {\n\t\tIvar item = vars[i];\n\t\tconst char *name = ivar_getName(item);\n\t\tNSString * nameOC= [NSString stringWithUTF8String:name];\n\t\tif (nameOC.length>1) {\n\t\t\tnameOC = [nameOC substringFromIndex:1];\n\t\t\tNSString * value = json[nameOC];\n\t\t\tif ([value isKindOfClass:NSString.class] && value.length) {\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:NSArray.class]){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:NSDictionary.class]){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])\n\t\t\t{\n\t\t\t\tprintf(\"%s value is nil or null \\n\",name);\n\t\t\t}else if ([value integerValue] > 0){\n\t\t\t\t[obj setValue:value forKey:nameOC];\n\t\t\t}else{\n\t\t\t\tprintf(\"未知错误 \\n\");\n\t\t\t}\n\t\t}\n\t}\n\tfree(vars);\n\treturn obj;\n}\n@end\n```\n\n然后自己定义一个字典，来测试一下这段代码\n\n```\n@interface FYCat : NSObject\n@property (nonatomic,copy) NSString * name;\n@property (nonatomic,assign) int  age;\n\n- (void)run;\n@end\n\nNSDictionary * info = @{@\"age\":@\"10\",@\"value\":@10,@\"name\":@\"小明\"};\n\t\tFYCat *cat=[FYCat fy_objectWithJson:info];\n//log\nage:10 name:小明\n```\n\n#### hook钩子(method_exchangeImplementations)\n由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。\n\n```\n@implementation UIButton (add)\n+ (void)load{\n\tMethod m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));\n\tMethod m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tmethod_exchangeImplementations(m1, m2);\n\t});\n}\n- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event{\n\tNSLog(@\"%@ \",NSStringFromSelector(action));\n\t/*\n\t code here\n\t */\n\t //sel IMP 已经交换过了，所以不会死循环\n\t[self fy_sendAction:action to:target forEvent:event];\n}\n@end\n```\n\n可以在`code here`添加需要处理的代码，一般记录日志和延迟触发都可以处理。`[self fy_sendAction:action to:target forEvent:event];`不会产生死循环，原因是在`+load`中已经将`m1`和`m2`已经交换过了`IMP`。我们进入到`method_exchangeImplementations`内部：\n\n```\nvoid method_exchangeImplementations(Method m1, Method m2)\n{\n    if (!m1  ||  !m2) return;\n\n    mutex_locker_t lock(runtimeLock);\n\n//交换IMP\n    IMP m1_imp = m1->imp;\n    m1->imp = m2->imp;\n    m2->imp = m1_imp;\n\n//刷新缓存\n    flushCaches(nil);\n\n    updateCustomRR_AWZ(nil, m1);\n    updateCustomRR_AWZ(nil, m2);\n}\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n};\nusing MethodListIMP = IMP;\n```\n\n`m1`和`m2`交换了`IMP`，交换的是`method_t->imp`，然后刷新缓存(清空缓存)，等下次调用`IMP`则需要在`cls->rw->data->method`中去寻找。\n\n#### 数组越界和nil处理\n\n```\n@implementation NSMutableArray (add)\n+ (void)load{\n\tClass cls= NSClassFromString(@\"__NSArrayM\");\n\tMethod m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));\n\tSEL sel = @selector(fy_insertObject:atIndex:);\n\tMethod m2= class_getInstanceMethod(cls, sel);\n\t\n\tMethod m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));\n\tMethod m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));\n\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tmethod_exchangeImplementations(m1, m2);\n\t\tmethod_exchangeImplementations(m3, m4);\n\t});\n}\n\n- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index{\n\tif (anObject != nil) {\n\t\t[self fy_insertObject:anObject atIndex:index];\n\t}else{\n\t\tprintf(\" anObject is nil \\n\");\n\t}\n}\n- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx{\n\tif (self.count > idx) {\n\t\treturn [self fy_objectAtIndexedSubscript:idx];\n\t}else{\n\t\tprintf(\" %ld is outof rang \\n\",(long)idx);\n\t\treturn nil;\n\t}\n}\n@end\n\n\n\nNSMutableArray *array=[NSMutableArray array];\nid obj = nil;\n[array addObject:obj];\narray[1];\n\n//log\n anObject is nil \n 1 is outof rang \n```\n\n`NSMutableArray`是类簇，使用工厂模式，`NSMutableArray`不是数组实例，而是生产数组对象的工厂。\n真实的数组对象是`__NSArrayM`,然后给`__NSArrayM`钩子，交换`objectAtIndexedSubscript:(NSUInteger)idx`和`insertObject:(id)anObject atIndex:(NSUInteger)index`方法，实现崩溃避免。\n\n\n#### 字典nil处理\n\n```\n@interface NSMutableDictionary (add)\n\n@end\n\n@implementation NSMutableDictionary (add)\n+ (void)load{\n    Class cls= NSClassFromString(@\"__NSDictionaryM\");\n    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));\n//    __NSDictionaryM\n    SEL sel = @selector(fy_setObject:forKey:);\n    Method m2= class_getInstanceMethod(cls, sel);\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        method_exchangeImplementations(m1, m2);\n    });\n}\n- (void)fy_setObject:(id)anObject forKey:(id<NSCopying>)aKey{\n    if (anObject) {\n        [self fy_setObject:anObject forKey:aKey];\n    }else{\n        NSString * key = (NSString *)aKey;\n        printf(\"key:%s anobj is nil \\n\",key.UTF8String);\n    }\n}\n@end\n```\n\n利用类别`+load`给`__NSDictionaryM`添加方法，然后交换`IMP`，实现给`NSMutableDictionary setObject:Key:`的时候进行`nil`校验,`+load`虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成`IMP`和`SEL`混乱，使用`dispatch_once`进行单次运行。\n\n### 总结\n1. `super`本质上是`self`调用函数，不过查找函数是从`sueprclass`开始查找的\n2. `+isKandOfClass`是判断`self`是否是`cls`的子类，`+isMemberOfClass:`是判断`self`是否和`cls`相同。\n3. 了解`+load`在`Category`是启动的时候使用运行时编译的，而且只会加载一次,然后利用`objc/runtime.h`中`method_exchangeImplementations`实现交换两个函数的`IMP`，可以实现拦截`nil`，降低崩溃率。\n4. `NSMutableDictionary`、`NSMutableArray`是类簇，先找到他们的类然后再交换该类的函数的`IMP`。\n\n### 资料参考\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 runtime - super、hook、以及简单应用--(8)","published":1,"updated":"2019-12-03T05:03:32.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2j000l9zsktshqec1g","content":"<h3 id=\"关键字-super\"><a href=\"#关键字-super\" class=\"headerlink\" title=\"关键字 super\"></a>关键字 super</h3><p>关键字<code>super</code>,在调用<code>[super init]</code>的时候，<code>super</code>会转化成结构体<code>__rw_objc_super</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __rw_objc_super &#123; </div><div class=\"line\">\tstruct objc_object *object; //消息接受者</div><div class=\"line\">\tstruct objc_object *superClass; //父类</div><div class=\"line\">\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>[super init]</code>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m</code>转化成<code>cpp</code><br>打开<code>cpp</code>大概在底部的位置找到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>\n<p>简化之后是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(void *)objc_msgSendSuper((__rw_objc_super)&#123;self, class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>\n<p><code>void\nobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )</code><br>    其实是向父类发送消息，参数是<code>struct objc_super *super, SEL op, ...</code>，我们源码中找到了该函数的实现在<code>objc-msg-arm64.s</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">ENTRY _objc_msgSendSuper</div><div class=\"line\">UNWIND _objc_msgSendSuper, NoFrame</div><div class=\"line\">//根据结构体struct __rw_objc_super </div><div class=\"line\">&#123; </div><div class=\"line\">\t//struct objc_object *object; //消息接受者</div><div class=\"line\">\t//struct objc_object *superClass; //父类</div><div class=\"line\">&#125;占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，</div><div class=\"line\">//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class=\"line\">ldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass</div><div class=\"line\"></div><div class=\"line\">CacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\"></div><div class=\"line\">END_ENTRY _objc_msgSendSuper</div></pre></td></tr></table></figure>\n<p>将<code>self</code>和<code>superclass</code>赋值给 <code>p0, p16</code>调用<code>CacheLookup NORMAL</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class=\"line\">\t// p1 = SEL, p16 = isa</div><div class=\"line\">\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask</div><div class=\"line\">#if !__LP64__</div><div class=\"line\">\tand\tw11, w11, 0xffff\t// p11 = mask</div><div class=\"line\">#endif</div><div class=\"line\">\tand\tw12, w1, w11\t\t// x12 = _cmd &amp; mask</div><div class=\"line\">\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)</div><div class=\"line\">\t\t             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket 没有命中</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// wrap: p12 = first bucket, w11 = mask</div><div class=\"line\">\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class=\"line\">\t\t                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class=\"line\"></div><div class=\"line\">\t// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class=\"line\">\t// The slow path may detect any corruption and halt later.</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// double wrap</div><div class=\"line\">\tJumpMiss $0</div><div class=\"line\">\t</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>汇编比较多，只看到第二行<code>p1 = SEL, p16 = isa</code>，查找缓存是从<code>p16</code>,也就是<code>superclass</code>开始查找，后边的都和<code>objc_msgSend</code>一样。<br>大致上比较清楚了，<code>super</code>本质上调用了<code>objc_msgSendSuper</code>，<code>objc_msgSendSuper</code>是查找从父类开始查找方法。</p>\n<p><code>[super init]</code>就是<code>self</code>直接调用父类<code>init</code>的方法，但是<code>objc_msgSend</code>接受者是<code>self</code>，假如是<code>[self init]</code>则会产生死循环。<code>[super test]</code>则是执行父类的<code>test</code>。<br>使用<code>Debug Workflow-&gt;Always Show Disassemdly</code>发现<code>super</code>其实调用了汇编的<code>objc_msgSendSuper2</code>，进入<code>objc_msgSendSuper2 objc-msg-arm64.s 422 行</code>发现和<code>objc_msgSendSuper</code>其实基本一致的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//_objc_msgSendSuper 开始</div><div class=\"line\">\tENTRY _objc_msgSendSuper</div><div class=\"line\">\tUNWIND _objc_msgSendSuper, NoFrame</div><div class=\"line\">//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class=\"line\">\tldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass</div><div class=\"line\">\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\">\tEND_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束</div><div class=\"line\">\t</div><div class=\"line\">//objc_msgLookupSuper2 开始</div><div class=\"line\">\tENTRY _objc_msgSendSuper2 </div><div class=\"line\">\tUNWIND _objc_msgSendSuper2, NoFrame</div><div class=\"line\"></div><div class=\"line\">\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class</div><div class=\"line\">\t//将存储器地址为x16+8的字数据读入寄存器p16。</div><div class=\"line\">\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class-&gt;superclass</div><div class=\"line\">\tCacheLookup NORMAL</div><div class=\"line\">\tEND_ENTRY _objc_msgSendSuper2</div></pre></td></tr></table></figure>\n<p>也可以使用<code>LLVM</code>转化成中间代码来查看，<code>clang -emit-llvm -S FYCat.m</code>查看关键函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">define internal void @&quot;\\01-[FYCat forwardInvocation:]&quot;(%1*, i8*, %2*) #1 &#123;</div><div class=\"line\">    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是<code>forwardInvocation</code>函数的调用代码，简化之后是<code>objc_msgSendSuper2(self,struct._objc_super i8*,%2*)</code>，就是<code>objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)</code>。</p>\n<p>验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">- (int)age;</div><div class=\"line\">-(void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    ;    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (int)age&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString *)name&#123;</div><div class=\"line\">    return [_name stringByAppendingString:@&quot; eat apple&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@interface FYStudent : FYPerson</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYStudent</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    [super test]; //执行父类的test</div><div class=\"line\">    int age = [super age]; //获取父类的方法 返回值</div><div class=\"line\">    NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值</div><div class=\"line\">    NSLog(@&quot;%@&quot;,name);</div><div class=\"line\">&#125;</div><div class=\"line\">-(int)age&#123;</div><div class=\"line\">    return 12;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//输出</div><div class=\"line\">-[FYPerson test]</div><div class=\"line\">-[FYPerson age]</div><div class=\"line\">age is 10</div><div class=\"line\">小李子 eat apple</div></pre></td></tr></table></figure>\n<p><code>test</code>是执行父类的方法，<code>[super age]</code>获取父类中固定的<code>age</code>,<br><code>[self name]</code>从父类开始寻找<code>name</code>的值，但返回的是<code>self.name</code>的值。</p>\n<h3 id=\"isMemberOfClass-amp-isKindOfClass\"><a href=\"#isMemberOfClass-amp-isKindOfClass\" class=\"headerlink\" title=\"isMemberOfClass &amp;  isKindOfClass\"></a>isMemberOfClass &amp;  isKindOfClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class=\"line\">    return object_getClass((id)self) == cls;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class=\"line\">    return [self class] == cls;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        printf(&quot;%s %s\\n&quot;,class_getName(tcls),class_getName(cls));</div><div class=\"line\">        if (tcls == cls)</div><div class=\"line\">        &#123;return YES;&#125;else&#123;</div><div class=\"line\">            printf(&quot;%s&quot;,class_getName(tcls));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        </div><div class=\"line\">        printf(&quot; %s %s\\n&quot;,class_getName(tcls),class_getName(cls));</div><div class=\"line\">        if (tcls == cls) return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isSubclassOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        if (tcls == cls) return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>- (BOOL)isMemberOfClass</code>和<code>- (BOOL)isKindOfClass:(Class)cls</code>比较简单，都是判断<code>self.class</code> 和<code>cls</code>，<code>+ (BOOL)isMemberOfClass:(Class)cls</code>是判断<code>self.class-&gt;isa</code>是否和<code>cls</code>相等，<code>+ (BOOL)isKindOfClass:(Class)cls</code>判断<code>cls-&gt;isa</code>和<code>cls-&gt;isa-&gt;isa</code>有没有可能和<code>cls</code>相等？只有基类是，其他的都不是。</p>\n<h4 id=\"验证-实例方法\"><a href=\"#验证-实例方法\" class=\"headerlink\" title=\"验证 实例方法\"></a>验证 实例方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class cls = NSObject.class;</div><div class=\"line\">Class pcls = FYPerson.class;</div><div class=\"line\">FYPerson *p=[FYPerson new];</div><div class=\"line\">NSObject *obj=[NSObject new];</div><div class=\"line\">BOOL res11 =[p isKindOfClass:pcls];</div><div class=\"line\">BOOL res12 =[p isMemberOfClass:pcls];</div><div class=\"line\">BOOL res13 =[obj isKindOfClass:cls];</div><div class=\"line\">BOOL res14 =[obj isMemberOfClass:cls];</div><div class=\"line\">NSLog(@&quot;instance:%d %d %d %d&quot;,res11,res12,res13,res14);</div><div class=\"line\">//log</div><div class=\"line\">//instance:1 1 1 1</div></pre></td></tr></table></figure>\n<p><code>p</code>是<code>pcls</code>的子类，<code>obj</code> 是<code>cls</code>的子类，在明显不过了。</p>\n<h4 id=\"验证-类方法\"><a href=\"#验证-类方法\" class=\"headerlink\" title=\"验证 类方法\"></a>验证 类方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//isKindOfClass cls-&gt;isa 和cls/cls-&gt;superclass相等吗?</div><div class=\"line\">//元类对象和类对象不相等，但是最后一个元类的isa-&gt;superclass是指向NSObject的class 所以res1 = YES;</div><div class=\"line\">//cls-&gt;isa:元类对象 cls-&gt;isa-&gt;superclass: NSObject类对象</div><div class=\"line\">//cls:类对象</div><div class=\"line\">BOOL res1 =[cls isKindOfClass:cls];</div><div class=\"line\">//cls-&gt;isa 和cls相等吗？ 不相等 cls-&gt;isa是元类对象,cls是类对象，不可能相等。</div><div class=\"line\">BOOL res2 =[cls isMemberOfClass:cls];</div><div class=\"line\">//pcls-&gt;isa:person的元类对象 cls-&gt;isa-&gt;superclass: NSObject元类类对象 -&gt;superclass:NSObject类对象 -&gt;superclass:nil</div><div class=\"line\">//pcls:person类对象</div><div class=\"line\">BOOL res3 =[pcls isKindOfClass:pcls];</div><div class=\"line\">//pcls-&gt;isa:person的元类对象</div><div class=\"line\">//pcls:person类对象</div><div class=\"line\">BOOL res4 =[pcls isMemberOfClass:pcls];</div><div class=\"line\">NSLog(@&quot;%d %d %d %d&quot;,res1,res2,res3,res4);</div><div class=\"line\">结果：</div><div class=\"line\">1 0 0 0</div></pre></td></tr></table></figure>\n<h3 id=\"堆栈-对象本质-class本质实战\"><a href=\"#堆栈-对象本质-class本质实战\" class=\"headerlink\" title=\"堆栈 对象本质 class本质实战\"></a>堆栈 对象本质 class本质实战</h3><p>网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。<br>其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文<a href=\"https://juejin.im/post/5d2d200be51d4510a7328161\" target=\"_blank\" rel=\"external\">obj_msgsend基础</a>、<a href=\"https://juejin.im/post/5d19c59e6fb9a07f04205f95\" target=\"_blank\" rel=\"external\">类的本质</a>、<a href=\"https://juejin.im/post/5d15887ee51d45108126d28d\" target=\"_blank\" rel=\"external\">对象的本质</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;my name is %@&quot;,self.name);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030</div><div class=\"line\">    id cls  = [FYPerson class];针</div><div class=\"line\">    void * obj = &amp;cls; </div><div class=\"line\">    [(__bridge id)obj print];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"问题一-能否编译成功？\"><a href=\"#问题一-能否编译成功？\" class=\"headerlink\" title=\"问题一 能否编译成功？\"></a>问题一 能否编译成功？</h4><p>当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有<code>id self</code>和<code>SEL sel</code>，现在<code>cls</code>和<code>obj</code>都在栈区，<code>obj</code> 指针指向<code>cls</code>的内存地址，访问<code>obj</code>相当于直接访问<code>cls</code>内存存储的值，<code>cls</code>存储的是<code>Person.class</code>,<code>[obj print]</code> 相当于<code>objc_msgSend(cls,@selector(print))</code>,<code>cls</code>是有<code>print</code>方法的，所以会编译成功。</p>\n<h4 id=\"输出什么？\"><a href=\"#输出什么？\" class=\"headerlink\" title=\"输出什么？\"></a>输出什么？</h4><p><code>fix/cls/obj</code>这三个对象都是存储在栈上，<code>fix/cls/obj</code>地址是连续从高到低的，而且他们地址相差都是<code>8</code>字节，一个指针大小是<code>8</code>字节。他们三个地址如下所示：</p>\n<p>使用图来表示<code>fix</code>和<code>obj</code>：<br>|对象|地址|地址高低|<br>|:-:|:-:|:-:|:-:|<br>|fix|0x7ffeec3df920| 高 |<br>|cls|0x7ffeec3df918|中|<br>|obj|0x7ffeec3df910|低|</p>\n<p>寻找属性先是寻找<code>isa</code>，然后再在<code>isa</code>地址上+<code>8</code>则是属性的值，所以根据<code>obj</code>寻找<code>cls</code>地址是<code>0x7ffeec3df918</code>,然后<code>cls</code>地址+8字节则是<code>_name</code>的地址，<code>cls</code>地址是<code>0x7ffeec3df918</code>，加上<code>8</code>字节正好是<code>fix</code>的地址<code>0x7ffeec3df920</code>，因为都是指针，所以都是<code>8</code>字节,所以最后输出是结果是<code>fix</code>对象的地址的数据。</p>\n<p>情况再复杂一点，<code>FYPerson</code>结构改动一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,copy) NSString *name2;</div><div class=\"line\">@property (nonatomic,copy) NSString *name3;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>则他们的<code>_name</code>、<code>_name2</code>、<code>_name3</code>则在<code>cls</code>的地址基础上再向上寻找<code>8*1=8/8*2=16/8*3=24</code>字节，就是向上寻找第1个，第2个，第3个指向对象的指针。</p>\n<p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,copy) NSString *name2;</div><div class=\"line\">@property (nonatomic,copy) NSString *name3;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;name1:%@ name2:%@ name3:%@&quot;,self.name1,self.name2,self.name3);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//主函数</div><div class=\"line\"></div><div class=\"line\">NSObject *fix =[NSObject new];</div><div class=\"line\">FYPerson *fix2 =[FYPerson new];</div><div class=\"line\"></div><div class=\"line\">id cls  = [FYPerson class];</div><div class=\"line\">void * obj = &amp;cls; </div><div class=\"line\">[(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class=\"line\">NSLog(@&quot;fix:%p fix2:%p cls:%p obj:%p&quot;,&amp;fix,&amp;fix2,&amp;cls,&amp;obj);</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">name1:&lt;FYPerson: 0x6000033a38a0&gt; </div><div class=\"line\">name2:&lt;NSObject: 0x6000031f5380&gt; </div><div class=\"line\">name3:&lt;ViewController: 0x7f8307505580&gt;</div><div class=\"line\"></div><div class=\"line\">fix: 0x7ffeec3d f9 28 </div><div class=\"line\">fix2:0x7ffeec3d f9 20 </div><div class=\"line\">cls: 0x7ffeec3d f9 18 </div><div class=\"line\">obj: 0x7ffeec3d f9 10</div></pre></td></tr></table></figure>\n<p>再变形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">\t/*</div><div class=\"line\">\t objc_msgSuperSend(self,ViewController,sel)</div><div class=\"line\">\t */</div><div class=\"line\">NSLog(@&quot;self:%p ViewController.class:%p SEL:%p&quot;,self,ViewController.class,@selector(viewDidLoad));</div><div class=\"line\">    id cls  = [FYPerson class];//cls 是类指针</div><div class=\"line\">    void * obj = &amp;cls; //obj </div><div class=\"line\">    [(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class=\"line\">    </div><div class=\"line\"> NSLog(@&quot;cls:%p obj:%p&quot;,&amp;cls,&amp;obj);</div><div class=\"line\"> //log</div><div class=\"line\"> </div><div class=\"line\"> name1:&lt;ViewController: 0x7fad03e04ea0&gt; </div><div class=\"line\"> name2:ViewController</div><div class=\"line\"> </div><div class=\"line\"> self:                  0x7fad03e04ea0 </div><div class=\"line\"> ViewController.class:  0x10d0edf00 </div><div class=\"line\"> SEL:                   0x1117d5687</div><div class=\"line\"> </div><div class=\"line\"> cls:0x7ffee2b11908 </div><div class=\"line\"> obj:0x7ffee2b11900</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>_name1</code>是<code>cls</code>地址向上+8字节，<code>_name2</code>是向上移动16字节，<code>[super viewDidLoad]</code>本质上是<code>objc_msgSuperSend(self,ViewController.class,sel)</code>，<code>self</code>、<code>ViewController.class</code>、<code>SEL</code>是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，<br>结构体如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">地址高低</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">self</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ViewController.class</td>\n<td style=\"text-align:center\">中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SEL</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"常用的runtimeAPI\"><a href=\"#常用的runtimeAPI\" class=\"headerlink\" title=\"常用的runtimeAPI\"></a>常用的runtimeAPI</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">method</th>\n<th style=\"text-align:center\">desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</td>\n<td style=\"text-align:center\">动态创建一个类（参数：父类，类名，额外的内存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void objc_registerClassPair(Class cls))</td>\n<td style=\"text-align:center\">注册一个类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void objc_disposeClassPair(Class cls)</td>\n<td style=\"text-align:center\">销毁一个类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class objcect_getClass(id obj)</td>\n<td style=\"text-align:center\">获取isa指向的class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class object_setClass (id obj,Class cls)</td>\n<td style=\"text-align:center\">设置isa指向的class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL object_isClass(id class)</td>\n<td style=\"text-align:center\">判断oc对象是否为Class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_isMetaClass(Class cls)</td>\n<td style=\"text-align:center\">是否是元类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class class_getSuperclass(Class cls)</td>\n<td style=\"text-align:center\">获取父类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ivar class_getInstanceVariable(Class cls ,const char * name</td>\n<td style=\"text-align:center\">获取一个实例变量信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ivar <em> class_copyIvarList(Class cls,unsigned int </em> outCount)</td>\n<td style=\"text-align:center\">拷贝实例变量列表，需要free</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void object_setIvar(id obj,Ivar ivar,id value</td>\n<td style=\"text-align:center\">设置获取实例变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">id object_getIvar(id obj,Ivar ivar)</td>\n<td style=\"text-align:center\">获取实例变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_addIvar(Class cls,const cahr <em> name ,size_t size,uint_t alignment,const char </em> types)</td>\n<td style=\"text-align:center\">动态添加成员变量（已注册的类不能动态添加成员变量）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * ivar_getName（Ivar v)</td>\n<td style=\"text-align:center\">获取变量名字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * ivar_getTypeEncoding(Ivar v)</td>\n<td style=\"text-align:center\">变量的encode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t class_getProperty(Class cls,const char* name)</td>\n<td style=\"text-align:center\">获取一个属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t _Nonnull <em> _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)</td>\n<td style=\"text-align:center\">拷贝属性列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)</td>\n<td style=\"text-align:center\">获取属性列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_addProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes,unsigned int attributeCount)</td>\n<td style=\"text-align:center\">添加属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void class_replaceProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes, unsigned int attributeCount)</td>\n<td style=\"text-align:center\">替换属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void class_replaceProperty(Class cls, const char <em>name, const objc_property_attribute_t </em>attributes,unsigned int attributeCount)</td>\n<td style=\"text-align:center\">动态替换属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * _Nonnull property_getName(objc_property_t _Nonnull property)</td>\n<td style=\"text-align:center\">获取name</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * _Nullable property_getAttributes(objc_property_t _Nonnull property)</td>\n<td style=\"text-align:center\">获取属性的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IMP imp_implementationWithBlock(id block)</td>\n<td style=\"text-align:center\">获取block的IMP</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">id imp_getBlock(IMP anIMP)</td>\n<td style=\"text-align:center\">通过imp 获取block</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL imp_removeBlock(IMP anIMP)</td>\n<td style=\"text-align:center\">IMP是否被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n</tbody>\n</table>\n<p>在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们<br>获取<code>class</code>的所有成员变量,可以获取<code>Ivar</code>查看是否有该变量，然后可以通过<code>KVC</code>来赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface FYCat : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@property (nonatomic,assign) int  age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">FYCat *cat=[FYCat new];</div><div class=\"line\">unsigned int count = 0;</div><div class=\"line\">Ivar *vars= class_copyIvarList(cat.class, &amp;count);</div><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\tIvar item = vars[i];</div><div class=\"line\">\tconst char *name = ivar_getName(item);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,name);</div><div class=\"line\">&#125;</div><div class=\"line\">free(vars);</div><div class=\"line\"></div><div class=\"line\">Method *m1= class_copyMethodList(cat.class, &amp;count);</div><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\tMethod item = m1[i];</div><div class=\"line\">\tSEL name = method_getName(item);</div><div class=\"line\">\tprintf(&quot;method:%s \\n&quot;,NSStringFromSelector(name).UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\">free(m1);</div><div class=\"line\">\t\t</div><div class=\"line\">//log</div><div class=\"line\">_age</div><div class=\"line\">_name</div><div class=\"line\"></div><div class=\"line\">method:.cxx_destruct </div><div class=\"line\">method:name </div><div class=\"line\">method:setName: </div><div class=\"line\">method:methodSignatureForSelector: </div><div class=\"line\">method:forwardInvocation: </div><div class=\"line\">method:age </div><div class=\"line\">method:setAge:</div></pre></td></tr></table></figure>\n<p>大家常用的一个功能是<code>JsonToModel</code>，那么我们已经了解到了<code>runtime</code>的基础知识，现在可以自己撸一个<code>JsonToModel</code>了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (Json)</div><div class=\"line\">+ (instancetype)fy_objectWithJson:(NSDictionary *)json;</div><div class=\"line\">@end</div><div class=\"line\">@implementation NSObject (Json)</div><div class=\"line\">+ (instancetype)fy_objectWithJson:(NSDictionary *)json&#123;</div><div class=\"line\">\tid obj = [[self alloc]init];</div><div class=\"line\">\tunsigned int count = 0;</div><div class=\"line\">\tIvar *vars= class_copyIvarList(self, &amp;count);</div><div class=\"line\">\tfor (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\t\tIvar item = vars[i];</div><div class=\"line\">\t\tconst char *name = ivar_getName(item);</div><div class=\"line\">\t\tNSString * nameOC= [NSString stringWithUTF8String:name];</div><div class=\"line\">\t\tif (nameOC.length&gt;1) &#123;</div><div class=\"line\">\t\t\tnameOC = [nameOC substringFromIndex:1];</div><div class=\"line\">\t\t\tNSString * value = json[nameOC];</div><div class=\"line\">\t\t\tif ([value isKindOfClass:NSString.class] &amp;&amp; value.length) &#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:NSArray.class])&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:NSDictionary.class])&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tprintf(&quot;%s value is nil or null \\n&quot;,name);</div><div class=\"line\">\t\t\t&#125;else if ([value integerValue] &gt; 0)&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t\tprintf(&quot;未知错误 \\n&quot;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfree(vars);</div><div class=\"line\">\treturn obj;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>然后自己定义一个字典，来测试一下这段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYCat : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@property (nonatomic,assign) int  age;</div><div class=\"line\"></div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">NSDictionary * info = @&#123;@&quot;age&quot;:@&quot;10&quot;,@&quot;value&quot;:@10,@&quot;name&quot;:@&quot;小明&quot;&#125;;</div><div class=\"line\">\t\tFYCat *cat=[FYCat fy_objectWithJson:info];</div><div class=\"line\">//log</div><div class=\"line\">age:10 name:小明</div></pre></td></tr></table></figure>\n<h4 id=\"hook钩子-method-exchangeImplementations\"><a href=\"#hook钩子-method-exchangeImplementations\" class=\"headerlink\" title=\"hook钩子(method_exchangeImplementations)\"></a>hook钩子(method_exchangeImplementations)</h4><p>由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));</div><div class=\"line\">\tMethod m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));</div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tmethod_exchangeImplementations(m1, m2);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%@ &quot;,NSStringFromSelector(action));</div><div class=\"line\">\t/*</div><div class=\"line\">\t code here</div><div class=\"line\">\t */</div><div class=\"line\">\t //sel IMP 已经交换过了，所以不会死循环</div><div class=\"line\">\t[self fy_sendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>可以在<code>code here</code>添加需要处理的代码，一般记录日志和延迟触发都可以处理。<code>[self fy_sendAction:action to:target forEvent:event];</code>不会产生死循环，原因是在<code>+load</code>中已经将<code>m1</code>和<code>m2</code>已经交换过了<code>IMP</code>。我们进入到<code>method_exchangeImplementations</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">void method_exchangeImplementations(Method m1, Method m2)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!m1  ||  !m2) return;</div><div class=\"line\"></div><div class=\"line\">    mutex_locker_t lock(runtimeLock);</div><div class=\"line\"></div><div class=\"line\">//交换IMP</div><div class=\"line\">    IMP m1_imp = m1-&gt;imp;</div><div class=\"line\">    m1-&gt;imp = m2-&gt;imp;</div><div class=\"line\">    m2-&gt;imp = m1_imp;</div><div class=\"line\"></div><div class=\"line\">//刷新缓存</div><div class=\"line\">    flushCaches(nil);</div><div class=\"line\"></div><div class=\"line\">    updateCustomRR_AWZ(nil, m1);</div><div class=\"line\">    updateCustomRR_AWZ(nil, m2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    MethodListIMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\">using MethodListIMP = IMP;</div></pre></td></tr></table></figure>\n<p><code>m1</code>和<code>m2</code>交换了<code>IMP</code>，交换的是<code>method_t-&gt;imp</code>，然后刷新缓存(清空缓存)，等下次调用<code>IMP</code>则需要在<code>cls-&gt;rw-&gt;data-&gt;method</code>中去寻找。</p>\n<h4 id=\"数组越界和nil处理\"><a href=\"#数组越界和nil处理\" class=\"headerlink\" title=\"数组越界和nil处理\"></a>数组越界和nil处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSMutableArray (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">\tClass cls= NSClassFromString(@&quot;__NSArrayM&quot;);</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</div><div class=\"line\">\tSEL sel = @selector(fy_insertObject:atIndex:);</div><div class=\"line\">\tMethod m2= class_getInstanceMethod(cls, sel);</div><div class=\"line\">\t</div><div class=\"line\">\tMethod m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));</div><div class=\"line\">\tMethod m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));</div><div class=\"line\"></div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tmethod_exchangeImplementations(m1, m2);</div><div class=\"line\">\t\tmethod_exchangeImplementations(m3, m4);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index&#123;</div><div class=\"line\">\tif (anObject != nil) &#123;</div><div class=\"line\">\t\t[self fy_insertObject:anObject atIndex:index];</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tprintf(&quot; anObject is nil \\n&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx&#123;</div><div class=\"line\">\tif (self.count &gt; idx) &#123;</div><div class=\"line\">\t\treturn [self fy_objectAtIndexedSubscript:idx];</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tprintf(&quot; %ld is outof rang \\n&quot;,(long)idx);</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSMutableArray *array=[NSMutableArray array];</div><div class=\"line\">id obj = nil;</div><div class=\"line\">[array addObject:obj];</div><div class=\"line\">array[1];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"> anObject is nil </div><div class=\"line\"> 1 is outof rang</div></pre></td></tr></table></figure>\n<p><code>NSMutableArray</code>是类簇，使用工厂模式，<code>NSMutableArray</code>不是数组实例，而是生产数组对象的工厂。<br>真实的数组对象是<code>__NSArrayM</code>,然后给<code>__NSArrayM</code>钩子，交换<code>objectAtIndexedSubscript:(NSUInteger)idx</code>和<code>insertObject:(id)anObject atIndex:(NSUInteger)index</code>方法，实现崩溃避免。</p>\n<h4 id=\"字典nil处理\"><a href=\"#字典nil处理\" class=\"headerlink\" title=\"字典nil处理\"></a>字典nil处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSMutableDictionary (add)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableDictionary (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">    Class cls= NSClassFromString(@&quot;__NSDictionaryM&quot;);</div><div class=\"line\">    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));</div><div class=\"line\">//    __NSDictionaryM</div><div class=\"line\">    SEL sel = @selector(fy_setObject:forKey:);</div><div class=\"line\">    Method m2= class_getInstanceMethod(cls, sel);</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        method_exchangeImplementations(m1, m2);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)fy_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey&#123;</div><div class=\"line\">    if (anObject) &#123;</div><div class=\"line\">        [self fy_setObject:anObject forKey:aKey];</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        NSString * key = (NSString *)aKey;</div><div class=\"line\">        printf(&quot;key:%s anobj is nil \\n&quot;,key.UTF8String);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>利用类别<code>+load</code>给<code>__NSDictionaryM</code>添加方法，然后交换<code>IMP</code>，实现给<code>NSMutableDictionary setObject:Key:</code>的时候进行<code>nil</code>校验,<code>+load</code>虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成<code>IMP</code>和<code>SEL</code>混乱，使用<code>dispatch_once</code>进行单次运行。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>super</code>本质上是<code>self</code>调用函数，不过查找函数是从<code>sueprclass</code>开始查找的</li>\n<li><code>+isKandOfClass</code>是判断<code>self</code>是否是<code>cls</code>的子类，<code>+isMemberOfClass:</code>是判断<code>self</code>是否和<code>cls</code>相同。</li>\n<li>了解<code>+load</code>在<code>Category</code>是启动的时候使用运行时编译的，而且只会加载一次,然后利用<code>objc/runtime.h</code>中<code>method_exchangeImplementations</code>实现交换两个函数的<code>IMP</code>，可以实现拦截<code>nil</code>，降低崩溃率。</li>\n<li><code>NSMutableDictionary</code>、<code>NSMutableArray</code>是类簇，先找到他们的类然后再交换该类的函数的<code>IMP</code>。</li>\n</ol>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关键字-super\"><a href=\"#关键字-super\" class=\"headerlink\" title=\"关键字 super\"></a>关键字 super</h3><p>关键字<code>super</code>,在调用<code>[super init]</code>的时候，<code>super</code>会转化成结构体<code>__rw_objc_super</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __rw_objc_super &#123; </div><div class=\"line\">\tstruct objc_object *object; //消息接受者</div><div class=\"line\">\tstruct objc_object *superClass; //父类</div><div class=\"line\">\t__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>[super init]</code>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 Student.m</code>转化成<code>cpp</code><br>打开<code>cpp</code>大概在底部的位置找到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>\n<p>简化之后是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(void *)objc_msgSendSuper((__rw_objc_super)&#123;self, class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;))</div></pre></td></tr></table></figure>\n<p><code>void\nobjc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )</code><br>    其实是向父类发送消息，参数是<code>struct objc_super *super, SEL op, ...</code>，我们源码中找到了该函数的实现在<code>objc-msg-arm64.s</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">ENTRY _objc_msgSendSuper</div><div class=\"line\">UNWIND _objc_msgSendSuper, NoFrame</div><div class=\"line\">//根据结构体struct __rw_objc_super </div><div class=\"line\">&#123; </div><div class=\"line\">\t//struct objc_object *object; //消息接受者</div><div class=\"line\">\t//struct objc_object *superClass; //父类</div><div class=\"line\">&#125;占用空间16字节，objc_msgSendSuper参数是__rw_objc_super，</div><div class=\"line\">//使x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class=\"line\">ldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass</div><div class=\"line\"></div><div class=\"line\">CacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\"></div><div class=\"line\">END_ENTRY _objc_msgSendSuper</div></pre></td></tr></table></figure>\n<p>将<code>self</code>和<code>superclass</code>赋值给 <code>p0, p16</code>调用<code>CacheLookup NORMAL</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class=\"line\">\t// p1 = SEL, p16 = isa</div><div class=\"line\">\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask</div><div class=\"line\">#if !__LP64__</div><div class=\"line\">\tand\tw11, w11, 0xffff\t// p11 = mask</div><div class=\"line\">#endif</div><div class=\"line\">\tand\tw12, w1, w11\t\t// x12 = _cmd &amp; mask</div><div class=\"line\">\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)</div><div class=\"line\">\t\t             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket 没有命中</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// wrap: p12 = first bucket, w11 = mask</div><div class=\"line\">\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class=\"line\">\t\t                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class=\"line\"></div><div class=\"line\">\t// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class=\"line\">\t// The slow path may detect any corruption and halt later.</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// double wrap</div><div class=\"line\">\tJumpMiss $0</div><div class=\"line\">\t</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>汇编比较多，只看到第二行<code>p1 = SEL, p16 = isa</code>，查找缓存是从<code>p16</code>,也就是<code>superclass</code>开始查找，后边的都和<code>objc_msgSend</code>一样。<br>大致上比较清楚了，<code>super</code>本质上调用了<code>objc_msgSendSuper</code>，<code>objc_msgSendSuper</code>是查找从父类开始查找方法。</p>\n<p><code>[super init]</code>就是<code>self</code>直接调用父类<code>init</code>的方法，但是<code>objc_msgSend</code>接受者是<code>self</code>，假如是<code>[self init]</code>则会产生死循环。<code>[super test]</code>则是执行父类的<code>test</code>。<br>使用<code>Debug Workflow-&gt;Always Show Disassemdly</code>发现<code>super</code>其实调用了汇编的<code>objc_msgSendSuper2</code>，进入<code>objc_msgSendSuper2 objc-msg-arm64.s 422 行</code>发现和<code>objc_msgSendSuper</code>其实基本一致的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//_objc_msgSendSuper 开始</div><div class=\"line\">\tENTRY _objc_msgSendSuper</div><div class=\"line\">\tUNWIND _objc_msgSendSuper, NoFrame</div><div class=\"line\">//x0偏移16字节，就是两个指针的空间，赋值给p0 和p16</div><div class=\"line\">\tldp\tp0, p16, [x0]\t\t// p0 = self , p16 = superclass</div><div class=\"line\">\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\">\tEND_ENTRY _objc_msgSendSuper  //_objc_msgSendSuper 结束</div><div class=\"line\">\t</div><div class=\"line\">//objc_msgLookupSuper2 开始</div><div class=\"line\">\tENTRY _objc_msgSendSuper2 </div><div class=\"line\">\tUNWIND _objc_msgSendSuper2, NoFrame</div><div class=\"line\"></div><div class=\"line\">\tldp\tp0, p16, [x0]\t\t// p0 = real receiver, p16 = class</div><div class=\"line\">\t//将存储器地址为x16+8的字数据读入寄存器p16。</div><div class=\"line\">\tldr\tp16, [x16, #SUPERCLASS]\t// p16 = class-&gt;superclass</div><div class=\"line\">\tCacheLookup NORMAL</div><div class=\"line\">\tEND_ENTRY _objc_msgSendSuper2</div></pre></td></tr></table></figure>\n<p>也可以使用<code>LLVM</code>转化成中间代码来查看，<code>clang -emit-llvm -S FYCat.m</code>查看关键函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">define internal void @&quot;\\01-[FYCat forwardInvocation:]&quot;(%1*, i8*, %2*) #1 &#123;</div><div class=\"line\">    call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %2*)*)(%struct._objc_super* %7, i8* %18, %2* %12)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是<code>forwardInvocation</code>函数的调用代码，简化之后是<code>objc_msgSendSuper2(self,struct._objc_super i8*,%2*)</code>，就是<code>objc_msgSendSuper2(self,superclass,@selector(forwardInvocation),anInvocation)</code>。</p>\n<p>验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">- (int)age;</div><div class=\"line\">-(void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    ;    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">- (int)age&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString *)name&#123;</div><div class=\"line\">    return [_name stringByAppendingString:@&quot; eat apple&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@interface FYStudent : FYPerson</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">@implementation FYStudent</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    [super test]; //执行父类的test</div><div class=\"line\">    int age = [super age]; //获取父类的方法 返回值</div><div class=\"line\">    NSLog(@&quot;age is %d&quot;,age);</div><div class=\"line\">    NSString * name = [self name]; //从父类开始寻找name的值，但返回的是self.name的值</div><div class=\"line\">    NSLog(@&quot;%@&quot;,name);</div><div class=\"line\">&#125;</div><div class=\"line\">-(int)age&#123;</div><div class=\"line\">    return 12;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//输出</div><div class=\"line\">-[FYPerson test]</div><div class=\"line\">-[FYPerson age]</div><div class=\"line\">age is 10</div><div class=\"line\">小李子 eat apple</div></pre></td></tr></table></figure>\n<p><code>test</code>是执行父类的方法，<code>[super age]</code>获取父类中固定的<code>age</code>,<br><code>[self name]</code>从父类开始寻找<code>name</code>的值，但返回的是<code>self.name</code>的值。</p>\n<h3 id=\"isMemberOfClass-amp-isKindOfClass\"><a href=\"#isMemberOfClass-amp-isKindOfClass\" class=\"headerlink\" title=\"isMemberOfClass &amp;  isKindOfClass\"></a>isMemberOfClass &amp;  isKindOfClass</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class=\"line\">    return object_getClass((id)self) == cls;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class=\"line\">    return [self class] == cls;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        printf(&quot;%s %s\\n&quot;,class_getName(tcls),class_getName(cls));</div><div class=\"line\">        if (tcls == cls)</div><div class=\"line\">        &#123;return YES;&#125;else&#123;</div><div class=\"line\">            printf(&quot;%s&quot;,class_getName(tcls));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        </div><div class=\"line\">        printf(&quot; %s %s\\n&quot;,class_getName(tcls),class_getName(cls));</div><div class=\"line\">        if (tcls == cls) return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (BOOL)isSubclassOfClass:(Class)cls &#123;</div><div class=\"line\">    for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class=\"line\">        if (tcls == cls) return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>- (BOOL)isMemberOfClass</code>和<code>- (BOOL)isKindOfClass:(Class)cls</code>比较简单，都是判断<code>self.class</code> 和<code>cls</code>，<code>+ (BOOL)isMemberOfClass:(Class)cls</code>是判断<code>self.class-&gt;isa</code>是否和<code>cls</code>相等，<code>+ (BOOL)isKindOfClass:(Class)cls</code>判断<code>cls-&gt;isa</code>和<code>cls-&gt;isa-&gt;isa</code>有没有可能和<code>cls</code>相等？只有基类是，其他的都不是。</p>\n<h4 id=\"验证-实例方法\"><a href=\"#验证-实例方法\" class=\"headerlink\" title=\"验证 实例方法\"></a>验证 实例方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class cls = NSObject.class;</div><div class=\"line\">Class pcls = FYPerson.class;</div><div class=\"line\">FYPerson *p=[FYPerson new];</div><div class=\"line\">NSObject *obj=[NSObject new];</div><div class=\"line\">BOOL res11 =[p isKindOfClass:pcls];</div><div class=\"line\">BOOL res12 =[p isMemberOfClass:pcls];</div><div class=\"line\">BOOL res13 =[obj isKindOfClass:cls];</div><div class=\"line\">BOOL res14 =[obj isMemberOfClass:cls];</div><div class=\"line\">NSLog(@&quot;instance:%d %d %d %d&quot;,res11,res12,res13,res14);</div><div class=\"line\">//log</div><div class=\"line\">//instance:1 1 1 1</div></pre></td></tr></table></figure>\n<p><code>p</code>是<code>pcls</code>的子类，<code>obj</code> 是<code>cls</code>的子类，在明显不过了。</p>\n<h4 id=\"验证-类方法\"><a href=\"#验证-类方法\" class=\"headerlink\" title=\"验证 类方法\"></a>验证 类方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//isKindOfClass cls-&gt;isa 和cls/cls-&gt;superclass相等吗?</div><div class=\"line\">//元类对象和类对象不相等，但是最后一个元类的isa-&gt;superclass是指向NSObject的class 所以res1 = YES;</div><div class=\"line\">//cls-&gt;isa:元类对象 cls-&gt;isa-&gt;superclass: NSObject类对象</div><div class=\"line\">//cls:类对象</div><div class=\"line\">BOOL res1 =[cls isKindOfClass:cls];</div><div class=\"line\">//cls-&gt;isa 和cls相等吗？ 不相等 cls-&gt;isa是元类对象,cls是类对象，不可能相等。</div><div class=\"line\">BOOL res2 =[cls isMemberOfClass:cls];</div><div class=\"line\">//pcls-&gt;isa:person的元类对象 cls-&gt;isa-&gt;superclass: NSObject元类类对象 -&gt;superclass:NSObject类对象 -&gt;superclass:nil</div><div class=\"line\">//pcls:person类对象</div><div class=\"line\">BOOL res3 =[pcls isKindOfClass:pcls];</div><div class=\"line\">//pcls-&gt;isa:person的元类对象</div><div class=\"line\">//pcls:person类对象</div><div class=\"line\">BOOL res4 =[pcls isMemberOfClass:pcls];</div><div class=\"line\">NSLog(@&quot;%d %d %d %d&quot;,res1,res2,res3,res4);</div><div class=\"line\">结果：</div><div class=\"line\">1 0 0 0</div></pre></td></tr></table></figure>\n<h3 id=\"堆栈-对象本质-class本质实战\"><a href=\"#堆栈-对象本质-class本质实战\" class=\"headerlink\" title=\"堆栈 对象本质 class本质实战\"></a>堆栈 对象本质 class本质实战</h3><p>网上看到了一个比较有意思的面试题，今天我们就借此机会分析一下,虽然网上很多博文已经讲了，但是好像都不很对，或者没有讲到根本的东西，所以今天再来探讨一下究竟。<br>其实这道题考察了对象在内存中的布局，类和对象的关系，和堆上的内存布局。基础知识不很牢固的同学可以看一下我历史的博文<a href=\"https://juejin.im/post/5d2d200be51d4510a7328161\" target=\"_blank\" rel=\"external\">obj_msgsend基础</a>、<a href=\"https://juejin.im/post/5d19c59e6fb9a07f04205f95\" target=\"_blank\" rel=\"external\">类的本质</a>、<a href=\"https://juejin.im/post/5d15887ee51d45108126d28d\" target=\"_blank\" rel=\"external\">对象的本质</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;my name is %@&quot;,self.name);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    NSObject *fix =[NSObject new]; // 16字节 0x60000219b030</div><div class=\"line\">    id cls  = [FYPerson class];针</div><div class=\"line\">    void * obj = &amp;cls; </div><div class=\"line\">    [(__bridge id)obj print];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"问题一-能否编译成功？\"><a href=\"#问题一-能否编译成功？\" class=\"headerlink\" title=\"问题一 能否编译成功？\"></a>问题一 能否编译成功？</h4><p>当大家看到第二个问题的时候，不傻的话都会回答能编译成功，否则还问结果干嘛。我们从之前学的只是来分析一下，调用方法成功需要有<code>id self</code>和<code>SEL sel</code>，现在<code>cls</code>和<code>obj</code>都在栈区，<code>obj</code> 指针指向<code>cls</code>的内存地址，访问<code>obj</code>相当于直接访问<code>cls</code>内存存储的值，<code>cls</code>存储的是<code>Person.class</code>,<code>[obj print]</code> 相当于<code>objc_msgSend(cls,@selector(print))</code>,<code>cls</code>是有<code>print</code>方法的，所以会编译成功。</p>\n<h4 id=\"输出什么？\"><a href=\"#输出什么？\" class=\"headerlink\" title=\"输出什么？\"></a>输出什么？</h4><p><code>fix/cls/obj</code>这三个对象都是存储在栈上，<code>fix/cls/obj</code>地址是连续从高到低的，而且他们地址相差都是<code>8</code>字节，一个指针大小是<code>8</code>字节。他们三个地址如下所示：</p>\n<p>使用图来表示<code>fix</code>和<code>obj</code>：<br>|对象|地址|地址高低|<br>|:-:|:-:|:-:|:-:|<br>|fix|0x7ffeec3df920| 高 |<br>|cls|0x7ffeec3df918|中|<br>|obj|0x7ffeec3df910|低|</p>\n<p>寻找属性先是寻找<code>isa</code>，然后再在<code>isa</code>地址上+<code>8</code>则是属性的值，所以根据<code>obj</code>寻找<code>cls</code>地址是<code>0x7ffeec3df918</code>,然后<code>cls</code>地址+8字节则是<code>_name</code>的地址，<code>cls</code>地址是<code>0x7ffeec3df918</code>，加上<code>8</code>字节正好是<code>fix</code>的地址<code>0x7ffeec3df920</code>，因为都是指针，所以都是<code>8</code>字节,所以最后输出是结果是<code>fix</code>对象的地址的数据。</p>\n<p>情况再复杂一点，<code>FYPerson</code>结构改动一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,copy) NSString *name2;</div><div class=\"line\">@property (nonatomic,copy) NSString *name3;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>则他们的<code>_name</code>、<code>_name2</code>、<code>_name3</code>则在<code>cls</code>的地址基础上再向上寻找<code>8*1=8/8*2=16/8*3=24</code>字节，就是向上寻找第1个，第2个，第3个指向对象的指针。</p>\n<p>测试代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString *name;</div><div class=\"line\">@property (nonatomic,copy) NSString *name2;</div><div class=\"line\">@property (nonatomic,copy) NSString *name3;</div><div class=\"line\">- (void)print;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;name1:%@ name2:%@ name3:%@&quot;,self.name1,self.name2,self.name3);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//主函数</div><div class=\"line\"></div><div class=\"line\">NSObject *fix =[NSObject new];</div><div class=\"line\">FYPerson *fix2 =[FYPerson new];</div><div class=\"line\"></div><div class=\"line\">id cls  = [FYPerson class];</div><div class=\"line\">void * obj = &amp;cls; </div><div class=\"line\">[(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class=\"line\">NSLog(@&quot;fix:%p fix2:%p cls:%p obj:%p&quot;,&amp;fix,&amp;fix2,&amp;cls,&amp;obj);</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">name1:&lt;FYPerson: 0x6000033a38a0&gt; </div><div class=\"line\">name2:&lt;NSObject: 0x6000031f5380&gt; </div><div class=\"line\">name3:&lt;ViewController: 0x7f8307505580&gt;</div><div class=\"line\"></div><div class=\"line\">fix: 0x7ffeec3d f9 28 </div><div class=\"line\">fix2:0x7ffeec3d f9 20 </div><div class=\"line\">cls: 0x7ffeec3d f9 18 </div><div class=\"line\">obj: 0x7ffeec3d f9 10</div></pre></td></tr></table></figure>\n<p>再变形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">\t/*</div><div class=\"line\">\t objc_msgSuperSend(self,ViewController,sel)</div><div class=\"line\">\t */</div><div class=\"line\">NSLog(@&quot;self:%p ViewController.class:%p SEL:%p&quot;,self,ViewController.class,@selector(viewDidLoad));</div><div class=\"line\">    id cls  = [FYPerson class];//cls 是类指针</div><div class=\"line\">    void * obj = &amp;cls; //obj </div><div class=\"line\">    [(__bridge id)obj print];//objc_msgSend(self,sel);</div><div class=\"line\">    </div><div class=\"line\"> NSLog(@&quot;cls:%p obj:%p&quot;,&amp;cls,&amp;obj);</div><div class=\"line\"> //log</div><div class=\"line\"> </div><div class=\"line\"> name1:&lt;ViewController: 0x7fad03e04ea0&gt; </div><div class=\"line\"> name2:ViewController</div><div class=\"line\"> </div><div class=\"line\"> self:                  0x7fad03e04ea0 </div><div class=\"line\"> ViewController.class:  0x10d0edf00 </div><div class=\"line\"> SEL:                   0x1117d5687</div><div class=\"line\"> </div><div class=\"line\"> cls:0x7ffee2b11908 </div><div class=\"line\"> obj:0x7ffee2b11900</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>_name1</code>是<code>cls</code>地址向上+8字节，<code>_name2</code>是向上移动16字节，<code>[super viewDidLoad]</code>本质上是<code>objc_msgSuperSend(self,ViewController.class,sel)</code>，<code>self</code>、<code>ViewController.class</code>、<code>SEL</code>是同一块连续内存，布局由低到高，看了下图的内存布局就会顿悟，<br>结构体如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象</th>\n<th style=\"text-align:center\">地址高低</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">self</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ViewController.class</td>\n<td style=\"text-align:center\">中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SEL</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"常用的runtimeAPI\"><a href=\"#常用的runtimeAPI\" class=\"headerlink\" title=\"常用的runtimeAPI\"></a>常用的runtimeAPI</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">method</th>\n<th style=\"text-align:center\">desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</td>\n<td style=\"text-align:center\">动态创建一个类（参数：父类，类名，额外的内存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void objc_registerClassPair(Class cls))</td>\n<td style=\"text-align:center\">注册一个类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void objc_disposeClassPair(Class cls)</td>\n<td style=\"text-align:center\">销毁一个类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class objcect_getClass(id obj)</td>\n<td style=\"text-align:center\">获取isa指向的class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class object_setClass (id obj,Class cls)</td>\n<td style=\"text-align:center\">设置isa指向的class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL object_isClass(id class)</td>\n<td style=\"text-align:center\">判断oc对象是否为Class</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_isMetaClass(Class cls)</td>\n<td style=\"text-align:center\">是否是元类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class class_getSuperclass(Class cls)</td>\n<td style=\"text-align:center\">获取父类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ivar class_getInstanceVariable(Class cls ,const char * name</td>\n<td style=\"text-align:center\">获取一个实例变量信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Ivar <em> class_copyIvarList(Class cls,unsigned int </em> outCount)</td>\n<td style=\"text-align:center\">拷贝实例变量列表，需要free</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void object_setIvar(id obj,Ivar ivar,id value</td>\n<td style=\"text-align:center\">设置获取实例变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">id object_getIvar(id obj,Ivar ivar)</td>\n<td style=\"text-align:center\">获取实例变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_addIvar(Class cls,const cahr <em> name ,size_t size,uint_t alignment,const char </em> types)</td>\n<td style=\"text-align:center\">动态添加成员变量（已注册的类不能动态添加成员变量）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * ivar_getName（Ivar v)</td>\n<td style=\"text-align:center\">获取变量名字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * ivar_getTypeEncoding(Ivar v)</td>\n<td style=\"text-align:center\">变量的encode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t class_getProperty(Class cls,const char* name)</td>\n<td style=\"text-align:center\">获取一个属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t _Nonnull <em> _Nullable class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)</td>\n<td style=\"text-align:center\">拷贝属性列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">objc_property_t _Nullable class_getProperty(Class _Nullable cls, const char * _Nonnull name)</td>\n<td style=\"text-align:center\">获取属性列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL class_addProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes,unsigned int attributeCount)</td>\n<td style=\"text-align:center\">添加属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void class_replaceProperty(Class _Nullable cls, const char <em> _Nonnull name,const objc_property_attribute_t </em> _Nullable attributes, unsigned int attributeCount)</td>\n<td style=\"text-align:center\">替换属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void class_replaceProperty(Class cls, const char <em>name, const objc_property_attribute_t </em>attributes,unsigned int attributeCount)</td>\n<td style=\"text-align:center\">动态替换属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * _Nonnull property_getName(objc_property_t _Nonnull property)</td>\n<td style=\"text-align:center\">获取name</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">const char * _Nullable property_getAttributes(objc_property_t _Nonnull property)</td>\n<td style=\"text-align:center\">获取属性的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IMP imp_implementationWithBlock(id block)</td>\n<td style=\"text-align:center\">获取block的IMP</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">id imp_getBlock(IMP anIMP)</td>\n<td style=\"text-align:center\">通过imp 获取block</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BOOL imp_removeBlock(IMP anIMP)</td>\n<td style=\"text-align:center\">IMP是否被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n</tr>\n</tbody>\n</table>\n<p>在业务上有些时候需要给系统控件的某个属性赋值，但是系统没有提供方法，只能靠自己了，那么我们<br>获取<code>class</code>的所有成员变量,可以获取<code>Ivar</code>查看是否有该变量，然后可以通过<code>KVC</code>来赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface FYCat : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@property (nonatomic,assign) int  age;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">FYCat *cat=[FYCat new];</div><div class=\"line\">unsigned int count = 0;</div><div class=\"line\">Ivar *vars= class_copyIvarList(cat.class, &amp;count);</div><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\tIvar item = vars[i];</div><div class=\"line\">\tconst char *name = ivar_getName(item);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,name);</div><div class=\"line\">&#125;</div><div class=\"line\">free(vars);</div><div class=\"line\"></div><div class=\"line\">Method *m1= class_copyMethodList(cat.class, &amp;count);</div><div class=\"line\">for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\tMethod item = m1[i];</div><div class=\"line\">\tSEL name = method_getName(item);</div><div class=\"line\">\tprintf(&quot;method:%s \\n&quot;,NSStringFromSelector(name).UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\">free(m1);</div><div class=\"line\">\t\t</div><div class=\"line\">//log</div><div class=\"line\">_age</div><div class=\"line\">_name</div><div class=\"line\"></div><div class=\"line\">method:.cxx_destruct </div><div class=\"line\">method:name </div><div class=\"line\">method:setName: </div><div class=\"line\">method:methodSignatureForSelector: </div><div class=\"line\">method:forwardInvocation: </div><div class=\"line\">method:age </div><div class=\"line\">method:setAge:</div></pre></td></tr></table></figure>\n<p>大家常用的一个功能是<code>JsonToModel</code>，那么我们已经了解到了<code>runtime</code>的基础知识，现在可以自己撸一个<code>JsonToModel</code>了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject (Json)</div><div class=\"line\">+ (instancetype)fy_objectWithJson:(NSDictionary *)json;</div><div class=\"line\">@end</div><div class=\"line\">@implementation NSObject (Json)</div><div class=\"line\">+ (instancetype)fy_objectWithJson:(NSDictionary *)json&#123;</div><div class=\"line\">\tid obj = [[self alloc]init];</div><div class=\"line\">\tunsigned int count = 0;</div><div class=\"line\">\tIvar *vars= class_copyIvarList(self, &amp;count);</div><div class=\"line\">\tfor (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">\t\tIvar item = vars[i];</div><div class=\"line\">\t\tconst char *name = ivar_getName(item);</div><div class=\"line\">\t\tNSString * nameOC= [NSString stringWithUTF8String:name];</div><div class=\"line\">\t\tif (nameOC.length&gt;1) &#123;</div><div class=\"line\">\t\t\tnameOC = [nameOC substringFromIndex:1];</div><div class=\"line\">\t\t\tNSString * value = json[nameOC];</div><div class=\"line\">\t\t\tif ([value isKindOfClass:NSString.class] &amp;&amp; value.length) &#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:NSArray.class])&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:NSDictionary.class])&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else if ([value isKindOfClass:[NSNull class]] || [value isEqual:nil])</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tprintf(&quot;%s value is nil or null \\n&quot;,name);</div><div class=\"line\">\t\t\t&#125;else if ([value integerValue] &gt; 0)&#123;</div><div class=\"line\">\t\t\t\t[obj setValue:value forKey:nameOC];</div><div class=\"line\">\t\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t\tprintf(&quot;未知错误 \\n&quot;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfree(vars);</div><div class=\"line\">\treturn obj;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>然后自己定义一个字典，来测试一下这段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYCat : NSObject</div><div class=\"line\">@property (nonatomic,copy) NSString * name;</div><div class=\"line\">@property (nonatomic,assign) int  age;</div><div class=\"line\"></div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">NSDictionary * info = @&#123;@&quot;age&quot;:@&quot;10&quot;,@&quot;value&quot;:@10,@&quot;name&quot;:@&quot;小明&quot;&#125;;</div><div class=\"line\">\t\tFYCat *cat=[FYCat fy_objectWithJson:info];</div><div class=\"line\">//log</div><div class=\"line\">age:10 name:小明</div></pre></td></tr></table></figure>\n<h4 id=\"hook钩子-method-exchangeImplementations\"><a href=\"#hook钩子-method-exchangeImplementations\" class=\"headerlink\" title=\"hook钩子(method_exchangeImplementations)\"></a>hook钩子(method_exchangeImplementations)</h4><p>由于业务需求需要在某些按钮点击事件进行记录日志，那么我们可以利用钩子来实现拦截所有button的点击事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(self.class, @selector(sendAction:to:forEvent:));</div><div class=\"line\">\tMethod m2= class_getInstanceMethod(self.class, @selector(fy_sendAction:to:forEvent:));</div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tmethod_exchangeImplementations(m1, m2);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)fy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</div><div class=\"line\">\tNSLog(@&quot;%@ &quot;,NSStringFromSelector(action));</div><div class=\"line\">\t/*</div><div class=\"line\">\t code here</div><div class=\"line\">\t */</div><div class=\"line\">\t //sel IMP 已经交换过了，所以不会死循环</div><div class=\"line\">\t[self fy_sendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>可以在<code>code here</code>添加需要处理的代码，一般记录日志和延迟触发都可以处理。<code>[self fy_sendAction:action to:target forEvent:event];</code>不会产生死循环，原因是在<code>+load</code>中已经将<code>m1</code>和<code>m2</code>已经交换过了<code>IMP</code>。我们进入到<code>method_exchangeImplementations</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">void method_exchangeImplementations(Method m1, Method m2)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!m1  ||  !m2) return;</div><div class=\"line\"></div><div class=\"line\">    mutex_locker_t lock(runtimeLock);</div><div class=\"line\"></div><div class=\"line\">//交换IMP</div><div class=\"line\">    IMP m1_imp = m1-&gt;imp;</div><div class=\"line\">    m1-&gt;imp = m2-&gt;imp;</div><div class=\"line\">    m2-&gt;imp = m1_imp;</div><div class=\"line\"></div><div class=\"line\">//刷新缓存</div><div class=\"line\">    flushCaches(nil);</div><div class=\"line\"></div><div class=\"line\">    updateCustomRR_AWZ(nil, m1);</div><div class=\"line\">    updateCustomRR_AWZ(nil, m2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    MethodListIMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\">using MethodListIMP = IMP;</div></pre></td></tr></table></figure>\n<p><code>m1</code>和<code>m2</code>交换了<code>IMP</code>，交换的是<code>method_t-&gt;imp</code>，然后刷新缓存(清空缓存)，等下次调用<code>IMP</code>则需要在<code>cls-&gt;rw-&gt;data-&gt;method</code>中去寻找。</p>\n<h4 id=\"数组越界和nil处理\"><a href=\"#数组越界和nil处理\" class=\"headerlink\" title=\"数组越界和nil处理\"></a>数组越界和nil处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSMutableArray (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">\tClass cls= NSClassFromString(@&quot;__NSArrayM&quot;);</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</div><div class=\"line\">\tSEL sel = @selector(fy_insertObject:atIndex:);</div><div class=\"line\">\tMethod m2= class_getInstanceMethod(cls, sel);</div><div class=\"line\">\t</div><div class=\"line\">\tMethod m3= class_getInstanceMethod(cls, @selector(objectAtIndexedSubscript:));</div><div class=\"line\">\tMethod m4= class_getInstanceMethod(cls, @selector(fy_objectAtIndexedSubscript:));</div><div class=\"line\"></div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tmethod_exchangeImplementations(m1, m2);</div><div class=\"line\">\t\tmethod_exchangeImplementations(m3, m4);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)fy_insertObject:(id)anObject atIndex:(NSUInteger)index&#123;</div><div class=\"line\">\tif (anObject != nil) &#123;</div><div class=\"line\">\t\t[self fy_insertObject:anObject atIndex:index];</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tprintf(&quot; anObject is nil \\n&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (id)fy_objectAtIndexedSubscript:(NSUInteger)idx&#123;</div><div class=\"line\">\tif (self.count &gt; idx) &#123;</div><div class=\"line\">\t\treturn [self fy_objectAtIndexedSubscript:idx];</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\tprintf(&quot; %ld is outof rang \\n&quot;,(long)idx);</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSMutableArray *array=[NSMutableArray array];</div><div class=\"line\">id obj = nil;</div><div class=\"line\">[array addObject:obj];</div><div class=\"line\">array[1];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"> anObject is nil </div><div class=\"line\"> 1 is outof rang</div></pre></td></tr></table></figure>\n<p><code>NSMutableArray</code>是类簇，使用工厂模式，<code>NSMutableArray</code>不是数组实例，而是生产数组对象的工厂。<br>真实的数组对象是<code>__NSArrayM</code>,然后给<code>__NSArrayM</code>钩子，交换<code>objectAtIndexedSubscript:(NSUInteger)idx</code>和<code>insertObject:(id)anObject atIndex:(NSUInteger)index</code>方法，实现崩溃避免。</p>\n<h4 id=\"字典nil处理\"><a href=\"#字典nil处理\" class=\"headerlink\" title=\"字典nil处理\"></a>字典nil处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSMutableDictionary (add)</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableDictionary (add)</div><div class=\"line\">+ (void)load&#123;</div><div class=\"line\">    Class cls= NSClassFromString(@&quot;__NSDictionaryM&quot;);</div><div class=\"line\">    Method m1= class_getInstanceMethod(cls, @selector(setObject:forKey:));</div><div class=\"line\">//    __NSDictionaryM</div><div class=\"line\">    SEL sel = @selector(fy_setObject:forKey:);</div><div class=\"line\">    Method m2= class_getInstanceMethod(cls, sel);</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        method_exchangeImplementations(m1, m2);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)fy_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey&#123;</div><div class=\"line\">    if (anObject) &#123;</div><div class=\"line\">        [self fy_setObject:anObject forKey:aKey];</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        NSString * key = (NSString *)aKey;</div><div class=\"line\">        printf(&quot;key:%s anobj is nil \\n&quot;,key.UTF8String);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>利用类别<code>+load</code>给<code>__NSDictionaryM</code>添加方法，然后交换<code>IMP</code>，实现给<code>NSMutableDictionary setObject:Key:</code>的时候进行<code>nil</code>校验,<code>+load</code>虽然系统启动的自动调用一次的，但是为防止开发者再次调用造成<code>IMP</code>和<code>SEL</code>混乱，使用<code>dispatch_once</code>进行单次运行。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>super</code>本质上是<code>self</code>调用函数，不过查找函数是从<code>sueprclass</code>开始查找的</li>\n<li><code>+isKandOfClass</code>是判断<code>self</code>是否是<code>cls</code>的子类，<code>+isMemberOfClass:</code>是判断<code>self</code>是否和<code>cls</code>相同。</li>\n<li>了解<code>+load</code>在<code>Category</code>是启动的时候使用运行时编译的，而且只会加载一次,然后利用<code>objc/runtime.h</code>中<code>method_exchangeImplementations</code>实现交换两个函数的<code>IMP</code>，可以实现拦截<code>nil</code>，降低崩溃率。</li>\n<li><code>NSMutableDictionary</code>、<code>NSMutableArray</code>是类簇，先找到他们的类然后再交换该类的函数的<code>IMP</code>。</li>\n</ol>\n<h3 id=\"资料参考\"><a href=\"#资料参考\" class=\"headerlink\" title=\"资料参考\"></a>资料参考</h3><ul>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)","date":"2019-12-01T03:17:58.000Z","_content":"\narm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，`objc_class->cache_t cache`是一个是缓存最近调用`class`的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的`method_t`扩容之后之后被清空。今天我们在了解runtime的消息转发机制。\n#### 基础知识\n\nOC中的方法调用，其实都是转换为objc_msgSend函数的调用\n\nobjc_msgSend的执行流程可以分为3大阶段\n\n1. 消息发送\n2. 动态方法解析\n3. 消息转发\n\n那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下\n\n```\nobjc-msg-arm64.s\nENTRY _objc_msgSend\nb.le\tLNilOrTagged //<0则返回\nCacheLookup NORMAL //缓存查找 未命中则继续查找\n.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp\n.macro CheckMiss //miss 则跳转__objc_msgSend_uncached\nSTATIC_ENTRY __objc_msgSend_uncached \n.macro MethodTableLookup//方法中查找\n__class_lookupMethodAndLoadCache3//跳转->__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行\n\n\nobjc-runtime-new.mm\n_class_lookupMethodAndLoadCache3\nlookUpImpOrForward\ngetMethodNoSuper_nolock、search_method_list、log_and_fill_cache\ncache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache\n_class_resolveInstanceMethod\n_objc_msgForward_impcache\n\n\nobjc-msg-arm64.s\nSTATIC_ENTRY __objc_msgForward_impcache\nENTRY __objc_msgForward\n\nCore Foundation\n__forwarding__（不开源）\n```\n\n### 消息发送\n\n`objc_msgSend`是汇编写的，在源码`objc-msg-arm64.s`304行，是`objc_msgSend`的开始，`_objc_msgSend`结束是351行,\n进入到`objc_msgSend`函数内部一探究竟：\n\n```\n\tENTRY _objc_msgSend // _objc_msgSend 开始\n\tUNWIND _objc_msgSend, NoFrame\n\n\tcmp\tp0, #0\t\t\t// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self\n#if SUPPORT_TAGGED_POINTERS\n\tb.le\tLNilOrTagged\t\t// if le < 0 ->  跳转到标签  LNilOrTagged\n#else\n\tb.eq\tLReturnZero // if le == 0 ->  跳转到标签  LReturnZero\n#endif\n\tldr\tp13, [x0]\t\t// p13 = isa\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\nLGetIsaDone:\n\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n\tb.eq\tLReturnZero\t\t// 如果==0 -> LReturnZero\n\n\t// tagged\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret //return 返回结束掉\n\n\tEND_ENTRY _objc_msgSend // _objc_msgSend 结束\n```\n\n当`objc_msgSend(id,SEL,arg)`的`id`为空的时候，跳转标签`LNilOrTagged`,进入标签内，当等于0则跳转`LReturnZero`,进入到`LReturnZero`内，清除数据和return。不等于零，获取isa和class，调用`CacheLookup NORMAL`,进入到`CacheLookup`内部\n\n```\n.macro CacheLookup //.macro 是一个宏 使用 _cmd&mask 查找缓存中的方法\n\t// p1 = SEL, p16 = isa\n\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask\n#if !__LP64__\n\tand\tw11, w11, 0xffff\t// p11 = mask\n#endif\n\tand\tw12, w1, w11\t\t// x12 = _cmd & mask\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket 没有命中\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)\n\t\t                        // p12 = buckets + (mask << 1+PTRSHIFT)\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// double wrap\n\tJumpMiss $0\n\t\n.endmacro\n```\n\n汇编代码左边是代码，右边是注释，大概都可以看懂的。\n当命中则`return imp`,否则则跳转`CheckMiss`,进入到`CheckMiss`内部：\n\n```\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tp9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n```\n\n刚才传的值是`NORMAL`，则跳转`__objc_msgSend_uncached`，进入到`__objc_msgSend_uncached`内部(484行)：\n\n```\n\tSTATIC_ENTRY __objc_msgSend_uncached\n\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\tMethodTableLookup\n\tTailCallFunctionPointer x17\n\tEND_ENTRY __objc_msgSend_uncached\n```\n\n调用`MethodTableLookup`,我们查看`MethodTableLookup`内部：\n\n```\n.macro MethodTableLookup\n\t// push frame\n\tSignLR\n\tstp\tfp, lr, [sp, #-16]!\n\tmov\tfp, sp\n\n\t// save parameter registers: x0..x8, q0..q7\n\tsub\tsp, sp, #(10*8 + 8*16)\n\tstp\tq0, q1, [sp, #(0*16)]\n\tstp\tq2, q3, [sp, #(2*16)]\n\tstp\tq4, q5, [sp, #(4*16)]\n\tstp\tq6, q7, [sp, #(6*16)]\n\tstp\tx0, x1, [sp, #(8*16+0*8)]\n\tstp\tx2, x3, [sp, #(8*16+2*8)]\n\tstp\tx4, x5, [sp, #(8*16+4*8)]\n\tstp\tx6, x7, [sp, #(8*16+6*8)]\n\tstr\tx8,     [sp, #(8*16+8*8)]\n\n\t// receiver and selector already in x0 and x1\n\tmov\tx2, x16\n\tbl\t__class_lookupMethodAndLoadCache3//跳转->__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行\n\n\t// IMP in x0\n\tmov\tx17, x0\n\t\n\t// restore registers and return\n\tldp\tq0, q1, [sp, #(0*16)]\n\tldp\tq2, q3, [sp, #(2*16)]\n\tldp\tq4, q5, [sp, #(4*16)]\n\tldp\tq6, q7, [sp, #(6*16)]\n\tldp\tx0, x1, [sp, #(8*16+0*8)]\n\tldp\tx2, x3, [sp, #(8*16+2*8)]\n\tldp\tx4, x5, [sp, #(8*16+4*8)]\n\tldp\tx6, x7, [sp, #(8*16+6*8)]\n\tldr\tx8,     [sp, #(8*16+8*8)]\n\n\tmov\tsp, fp\n\tldp\tfp, lr, [sp], #16\n\tAuthenticateLR\n.endmacro\n\n```\n\n最终跳转到`__class_lookupMethodAndLoadCache3`,去掉一个下划线就是c函数，在`runtime-class-new.mm 4856行`,\n调用了函数`lookUpImpOrForward(cls, sel, obj, \n                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);`,第一次会初始化`cls`和`resolver`的值，\n中最终跳转到`c/c++`函数`lookUpImpOrForward`，该函数是最终能看到的`c/c++`,现在我们进入到`lookUpImpOrForward`内部查看：\n\n```\n/***********************************************************************\n* lookUpImpOrForward.\n* initialize==NO 尽量避免调用，有时可能也会调用。\n* cache==NO 跳过缓存查找，其他地方可能会不调过\n* 大多数人会传值 initialize==YES and cache==YES\n*   如果cls是非初始化的元类，则非Non-nil会快点\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n* 如果你不想用forwarding，则调用lookUpImpOrNil()代替\n**********************************************************************/\nIMP lookUpImpOrForward(Class cls, SEL sel, id inst, \n                       bool initialize, bool cache, bool resolver)\n{\n    IMP imp = nil;\n    bool triedResolver = NO;\n\n    runtimeLock.assertUnlocked();\n    // Optimistic cache lookup\n    if (cache) { //从汇编过来是NO\n        imp = cache_getImp(cls, sel);\n        if (imp) return imp;\n    }\n\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n\n    if (!cls->isRealized()) {\n        realizeClass(cls);\n    }\n\n    if (initialize  &&  !cls->isInitialized()) {\n\t\t//当cls需要初始化和没有初始化的时候 进行cls初始化，\n\t\t//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类\n\t\t//数据的大小最小是4，扩容规则是：n*2+1;\n        runtimeLock.unlock();\n        _class_initialize (_class_getNonMetaClass(cls, inst));\n        runtimeLock.lock();\n    }\n\n    \n retry:    \n    runtimeLock.assertLocked();\n\n//再次获取imp\n    imp = cache_getImp(cls, sel);\n    if (imp) goto done;\n\n    //尝试在本类中查找method\n    {//从cls->data()->methods查找method\n        Method meth = getMethodNoSuper_nolock(cls, sel);\n        if (meth) {//找到添加到cache中\n            log_and_fill_cache(cls, meth->imp, sel, inst, cls);\n            imp = meth->imp;\n            goto done;\n        }\n    }\n\n    // Try superclass caches and method lists.\n\t//从cls->superclass->data()->methods查找methd，supercls没有查找出来，再查找父类的父类。\n    {\n        unsigned attempts = unreasonableClassCount();\n        for (Class curClass = cls->superclass;\n             curClass != nil;\n             curClass = curClass->superclass)\n        {\n            // Halt if there is a cycle in the superclass chain.\n            if (--attempts == 0) {\n                _objc_fatal(\"Memory corruption in class list.\");\n            }\n            \n            // Superclass cache.\n            imp = cache_getImp(curClass, sel);\n            if (imp) {\n                if (imp != (IMP)_objc_msgForward_impcache) {\n                    // Found the method in a superclass. Cache it in this class.\n\t\t\t\t\t//将父类添加到 子类的缓存中\n                    log_and_fill_cache(cls, imp, sel, inst, curClass);\n                    goto done;\n                }\n                else {\n                    // Found a forward:: entry in a superclass.\n                    // Stop searching, but don't cache yet; call method \n                    // resolver for this class first.\n                    break;\n                }\n            }\n            \n            // Superclass method list.\n            Method meth = getMethodNoSuper_nolock(curClass, sel);\n            if (meth) {\n                log_and_fill_cache(cls, meth->imp, sel, inst, curClass);\n                imp = meth->imp;\n                goto done;\n            }\n        }\n    }\n\n\t//如果还没有找到imp，进入动态方法解析阶段\n    if (resolver  &&  !triedResolver) {\n        runtimeLock.unlock();\n        _class_resolveMethod(cls, sel, inst);\n        runtimeLock.lock();\n        triedResolver = YES;\n        goto retry;\n    }\n\n    //如果没找到resolveInstanceMethod 和resolveClassMethod，\n//\t进行消息转发 阶段\n    imp = (IMP)_objc_msgForward_impcache;\n\t//填充 cache\n    cache_fill(cls, sel, imp, inst);\n done:\n    runtimeLock.unlock();\n    return imp;\n}\n\n\n```\n`SUPPORT_INDEXED_ISA`是在`arm64`和`LP64` 还有`arm_arch_7k>2`为1，`iphone`属于`arm64`、`mac os`属于`LP64`,所以`SUPPORT_INDEXED_ISA = 1`.\n\n```\n// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa \n// field as an index into a class table.\n// Note, keep this in sync with any .s files which also define it.\n// Be sure to edit objc-abi.h as well.\n// __ARM_ARCH_7K__ 处理器架构指令集版本\n//__arm64__ 架构\n//__LP64__ uinx 和uinx  mac os\n#if __ARM_ARCH_7K__ >= 2  ||  (__arm64__ && !__LP64__)\n#   define SUPPORT_INDEXED_ISA 1\n#else\n#   define SUPPORT_INDEXED_ISA 0\n#endif\n\n```\n`lookUpImpOrForward`函数的 大概思路如下：\n\n首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断`cls`是否已经实现，`cls->isRealized()`，没有实现的话进行实现`realizeClass(cls)`，主要是将初始化`read-write data`和其他的一些数据，后续会细讲。然后进行`cls`的初始化`_class_initialize()`，当`cls`需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：`n*2+1`;然后再次获取imp`cache_getImp`,然后在`cls`方法中查找该`method`，然后就是在`superclass`中查找方法，直到父类是nil，找到的话，获取`imp`并将`cls`和`sel`加入到`cache`中，否则进入到消息解析阶段`_class_resolveMethod`，在转发阶段，不是元类的话，进入到`_class_resolveInstanceMethod`是元类的话调用`_class_resolveClassMethod`,这两种分别都会进入到`lookUpImpOrNil`，再次查找`IMP`，当没找到的话就返回，找到的话用`objc_msgSend`发送消息实现调用`SEL_resolveInstanceMethod`并标记`triedResolver`为已动态解析标志。然后进入到消息动态转发阶段`_objc_msgForward_impcache`,至此`runtime`发送消息结束。\n\n借用网上找一个图， 可以更直观的看出流程运转。\n\n\n![](../images/7-1.png)\n\n\n#### realizeClass()解析\n`realizeClass`是初始化了很多数据，包括`cls->ro`赋值给`cls->rw`，添加元类`version`为7,`cls->chooseClassArrayIndex()`设置`cls`的索引，`supercls = realizeClass(remapClass(cls->superclass));\n    metacls = realizeClass(remapClass(cls->ISA()))`初始化`superclass`和`cls->isa`,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置`cls->setInstanceSize`,拷贝`flags`从`ro`到`rw`中，然后添加`subclass`和`rootclass`，最后添加类别的方法，协议，和属性。\n\n```\n/***********************************************************************\n* realizeClass\n cls第一次初始化会执行，包括cls->rw->data(),返回真实的cls 结构体\n runtimelock 必须有调用者把写入锁锁起来\n**********************************************************************/\nstatic Class realizeClass(Class cls)\n{\n    runtimeLock.assertLocked();\n\n    const class_ro_t *ro;\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n    bool isMeta;\n\n    if (!cls) return nil;\n    if (cls->isRealized()) return cls;\n    assert(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n//首先将tw赋值给to，因为数据结构一样可以直接强制转化\n    ro = (const class_ro_t *)cls->data();\n    if (ro->flags & RO_FUTURE) {//是否已经初始化过，初始化过的哈 则 cls->rw 已经初始化过\n        rw = cls->data();\n        ro = cls->data()->ro;\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // 正常情况下 申请class_rw_t空间\n        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\n        rw->ro = ro;//cls->rw->ro 指向现在的ro\n        rw->flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1\n        cls->setData(rw);//赋值\n    }\n\n    isMeta = ro->flags & RO_META;//是否是元类\n\t\n\n    rw->version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0\n\n\n    // Choose an index for this class.\n//设置cls的索引\n\tcls->chooseClassArrayIndex();\n\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: realizing class '%s'%s %p %p #%u\", \n                     cls->nameForLogging(), isMeta ? \" (meta)\" : \"\", \n                     (void*)cls, ro, cls->classArrayIndex());\n    }\n\n    // 如果父类没有初始化则进行初始化\n    // root_class 做完需要设置RW_REALIZED=1，\n    // root metaclasses 需要执行完.\n\t//从NXMapTable 获取cls ，然后进行初始化\n\t//从NXMapTable 获取cls->isa ，然后进行初始化\n    supercls = realizeClass(remapClass(cls->superclass));\n    metacls = realizeClass(remapClass(cls->ISA()));\n//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。\n#if SUPPORT_NONPOINTER_ISA\n    // Disable non-pointer isa for some classes and/or platforms.\n    // Set instancesRequireRawIsa.\n    bool instancesRequireRawIsa = cls->instancesRequireRawIsa();\n    bool rawIsaIsInherited = false;\n    static bool hackedDispatch = false;\n\n    if (DisableNonpointerIsa) {\n        // Non-pointer isa disabled by environment or app SDK version\n        instancesRequireRawIsa = true;\n    }\n    else if (!hackedDispatch  &&  !(ro->flags & RO_META)  &&  \n             0 == strcmp(ro->name, \"OS_object\")) \n    {\n        // hack for libdispatch et al - isa also acts as vtable pointer\n        hackedDispatch = true;\n        instancesRequireRawIsa = true;\n    }\n    else if (supercls  &&  supercls->superclass  &&  \n             supercls->instancesRequireRawIsa()) \n    {\n        // This is also propagated by addSubclass() \n        // but nonpointer isa setup needs it earlier.\n        // Special case: instancesRequireRawIsa does not propagate \n        // from root class to root metaclass\n        instancesRequireRawIsa = true;\n        rawIsaIsInherited = true;\n    }\n    \n    if (instancesRequireRawIsa) {\n        cls->setInstancesRequireRawIsa(rawIsaIsInherited);\n    }\n// SUPPORT_NONPOINTER_ISA\n#endif\n\n    // Update superclass and metaclass in case of remapping\n    cls->superclass = supercls;\n    cls->initClassIsa(metacls);\n\n\t// 协调实例变量偏移/布局\n\t//可能重新申请空间 class_ro_t,更新我们的class_ro_t\n    if (supercls  &&  !isMeta) reconcileInstanceVariables(cls, supercls, ro);\n\n    // 设置setInstanceSize 从ro->instanceSize\n    cls->setInstanceSize(ro->instanceSize);\n\n\t//拷贝flags 从ro到rw中\n    if (ro->flags & RO_HAS_CXX_STRUCTORS) {\n        cls->setHasCxxDtor();\n        if (! (ro->flags & RO_HAS_CXX_DTOR_ONLY)) {\n            cls->setHasCxxCtor();\n        }\n    }\n//添加superclass指针\n    if (supercls) {\n        addSubclass(supercls, cls);\n    } else {\n        addRootClass(cls);\n    }\n\n    // Attach categories\n\t//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的\n    methodizeClass(cls);\n\n    return cls;\n}\n```\n\n这里最后添加类别的数据是调用了`methodizeClass`函数，这个函数首先添加`method_list_t *list = ro->baseMethods()`到`rw->methods.attachLists(&list, 1)`，然后将属性`property_list_t *proplist=ro->baseProperties`添加到`rw->properties.attachLists(&proplist, 1)`,最后将协议列表`protocol_list_t *protolist = ro->baseProtocols`追加到`rw->protocols.attachLists(&protolist, 1)`，如果是`metaclass`则添加`SEL_initialize`,然后从全局`NXMapTable *category_map`删除已经加载的`category_list`,最后调用`attachCategories(cls, cats, false /*don't flush caches*/)`将已经加载的`cats`的方法添加到`cls->rw`上面并且不刷新`caches`。\n\n```\n/***********************************************************************\n* methodizeClass\n 修复cls方法列表想，协议列表和属性列表\n* 加锁\n**********************************************************************/\nstatic void methodizeClass(Class cls)\n{\n    runtimeLock.assertLocked();\n\n    bool isMeta = cls->isMetaClass();\n    auto rw = cls->data();\n    auto ro = rw->ro;\n\n    // Methodizing for the first time\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: methodizing class '%s' %s\", \n                     cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n    }\n\n\t//方法列表\n    method_list_t *list = ro->baseMethods();\n    if (list) {\n        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));\n\t//将对象的方法追加到cls->rw->methods后面\n        rw->methods.attachLists(&list, 1);\n    }\n\n    property_list_t *proplist = ro->baseProperties;\n    if (proplist) {\n\t//将对象的属性追加到rw->properties后面\n        rw->properties.attachLists(&proplist, 1);\n    }\n\n    protocol_list_t *protolist = ro->baseProtocols;\n    if (protolist) {\n\t//将对象的协议追加到rw->protocols后面\n        rw->protocols.attachLists(&protolist, 1);\n    }\n\n    // Root classes get bonus method implementations if they don't have \n    // them already. These apply before category replacements.\n    if (cls->isRootMetaclass()) {\n        // root metaclass\n        addMethod(cls, SEL_initialize, (IMP)&objc_noop_imp, \"\", NO);\n    }\n\n    // Attach categories.\n\t//类别 从全局NXMapTable *category_map 已经加载过了。\n    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);\n\t//收集所有的cats到cls -> rw中\n    attachCategories(cls, cats, false /*don't flush caches*/);\n\n    if (PrintConnecting) {\n        if (cats) {\n            for (uint32_t i = 0; i < cats->count; i++) {\n                _objc_inform(\"CLASS: attached category %c%s(%s)\", \n                             isMeta ? '+' : '-', \n                             cls->nameForLogging(), cats->list[i].cat->name);\n            }\n        }\n    }\n    \n    if (cats) free(cats);//释放cats\n\n#if DEBUG\n    // Debug: sanity-check all SELs; log method list contents\n    for (const auto& meth : rw->methods) {\n        if (PrintConnecting) {\n            _objc_inform(\"METHOD %c[%s %s]\", isMeta ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(meth.name));\n        }\n        assert(sel_registerName(sel_getName(meth.name)) == meth.name); \n    }\n#endif\n}\n```\n\n#### attachCategories()解析\n`methodizeClass`之前`rw`初始化的时候并没有将其他数据都都复制给`rw`,现在`methodizeClass`实现了将本来的`ro`数据拷贝给`rw`,然后`attachCategories`将\n分类的方法，属性，协议追加到`cls->data->rw`，我们进入`attachCategories`内部\n\n```\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n\t//属性数组\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n\t//协议数组\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    while (i--) {\n\t\t//取出某个分类\n        auto& entry = cats->list[i];\n//取出分类 的 instance方法或者class方法\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist; //mlists 接受所有分类方法\n            fromBundle |= entry.hi->isBundle();\n        }\n//proplist 接受所有分类属性\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n//proplist 接受所有协议方法\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n//收集了所有协议 分类方法\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n\t//追加所有分类方法\n    rw->methods.attachLists(mlists, mcount);\n\t//释放数组\n    free(mlists);\n\t//刷新该类的缓存\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n//追加所有分类属性\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);//释放数组\n//追加所有分类协议\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);//释放数组\n}\n```\n\n#### rw->list->attachLists()解析\n添加`attachLists`函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。\n\n```\n void attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count;\n\t\t\t//一共需要的数量\n            uint32_t newCount = oldCount + addedCount;\n\t\t\t//分配内存 内存不够用了，需要扩容\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n\t\t\t//赋值count\n            array()->count = newCount;\n\t\t\t// array()->lists：原来的方法列表向后移动 oldCount * sizeof(array()->lists[0]个长度\n            memmove(array()->lists + addedCount/*数组末尾*/, array()->lists/*数组*/,\n                    oldCount * sizeof(array()->lists[0])/*移动的大小*/);\n\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()->lists[0])\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n\t\t\t/*\n\t\t\t图示讲解：\n\t\t\tarray()->lists:A->B->C->D->E\n\t\taddedCount:3\n\t\taddedLists:P->L->V\n\t\t\tmemmove之后：nil->nil->nil->A->B->C->D->E\n\t\t\t然后再讲addedLists插入到数组前边,最终array()->lists的值是：\n\t\t\tP->L->V->A->B->C->D->E\n\t\t\t */\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n`class`初始化完成了，然后再次尝试获取`imp = cache_getImp`,由于缓存没有中间也没添加进去，所以这里也是空的，然后从`getMethodNoSuper_nolock`获取该`cls`的方法列表中查找，没有的话再从`superclass`查找`cache`和`method`,找到的话，进行`log_and_fill_cache`至此消息发送完成。\n\n### 消息动态解析\n\n动态解析函数`_class_resolveMethod(cls, sel, inst)`，如果不是元类调用`_class_resolveInstanceMethod`,如果是的话调用`_class_resolveClassMethod`\n\n```\n/***********************************************************************\n* _class_resolveMethod\n* 调用 +resolveClassMethod 或者 +resolveInstanceMethod\n* 如果存在了则不检查\n**********************************************************************/\nvoid _class_resolveMethod(Class cls, SEL sel, id inst)\n{\n    if (! cls->isMetaClass()) {//不是元类则调用 实例的\n\t//首先调用\n\t\t_class_resolveInstanceMethod(cls, sel, inst);\n    } \n    else {\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n\t\t//寻找classMethod\n        _class_resolveClassMethod(cls, sel, inst);\n        if (!lookUpImpOrNil(cls, sel, inst, \n                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n        {\n            _class_resolveInstanceMethod(cls, sel, inst);\n        }\n    }\n}\n\n```\n\n在`resolveInstanceMethod`，查找`SEL_resolveInstanceMethod`，传值不用初始化，不用消息解析，但是`cache`要查找。没有找到的直接返回，找到的话使用`objc_msgSend`发送消息调用`SEL_resolveInstanceMethod`。\n\n```\n/***********************************************************************\n* _class_resolveInstanceMethod\n* 调用 class添加的函数 +resolveInstanceMethod\n* 有可能是元类\n* 如果方法存在则不检查\n**********************************************************************/\nstatic void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)\n{\n    if (! lookUpImpOrNil(cls->ISA(), SEL_resolveInstanceMethod, cls, \n                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n    {\n        // Resolver not implemented.\n        return;\n    }\n//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNil(cls, sel, inst, \n                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n在`_class_resolveClassMethod`中，第一步先去`lookUpImpOrNil`查找`+SEL_resolveClassMethod`方法，没找到的就结束，找到则调用`objc_msgsend(id,sel)`\n\n```\nstatic void _class_resolveClassMethod(Class cls, SEL sel, id inst)\n{\n    assert(cls->isMetaClass());\n\n    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, \n                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n    {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(_class_getNonMetaClass(cls, inst), \n                        SEL_resolveClassMethod, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveClassMethod adds to self->ISA() a.k.a. cls\n    IMP imp = lookUpImpOrNil(cls, sel, inst, \n                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n动态解析至此完成。\n\n### 消息转发\n`_objc_msgForward_impcache`是转发的函数地址，在搜索框搜索发现，这个函数除了`.s`文件中有，其他地方均只是调用，说明这个函数是汇编实现，在`objc-msg-arm64.s 531 行`发现一点踪迹\n\n```\nSTATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache\n\t// No stret specialization.\n\tb\t__objc_msgForward//跳转->__objc_msgForward\n\tEND_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache\n\n\t\n\tENTRY __objc_msgForward // 开始 __objc_msgForward\n\n\tadrp\tx17, __objc_forward_handler@PAGE\n\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和\n\tTailCallFunctionPointer x17 //跳转-> TailCallFunctionPointer\n\n\tEND_ENTRY __objc_msgForward//结束 __objc_msgForward\n```\n\n当跳转到`adrp\tx17, __objc_forward_handler@PAGE`这一行，搜搜索函数`_objc_forward_handler`，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。\n\n```\n__attribute__((noreturn)) void \nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n```\n\n网上有大神总结的点我们先参考下\n\n```\n// 伪代码\nint __forwarding__(void *frameStackPointer, int isStret) {\n    id receiver = *(id *)frameStackPointer;\n    SEL sel = *(SEL *)(frameStackPointer + 8);\n    const char *selName = sel_getName(sel);\n    Class receiverClass = object_getClass(receiver);\n\n    // 调用 forwardingTargetForSelector:\n    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {\n        id forwardingTarget = [receiver forwardingTargetForSelector:sel];\n        if (forwardingTarget && forwardingTarget != receiver) {\n            if (isStret == 1) {\n                int ret;\n                objc_msgSend_stret(&ret,forwardingTarget, sel, ...);\n                return ret;\n            }\n            return objc_msgSend(forwardingTarget, sel, ...);\n        }\n    }\n\n    // 僵尸对象\n    const char *className = class_getName(receiverClass);\n    const char *zombiePrefix = \"_NSZombie_\";\n    size_t prefixLen = strlen(zombiePrefix); // 0xa\n    if (strncmp(className, zombiePrefix, prefixLen) == 0) {\n        CFLog(kCFLogLevelError,\n              @\"*** -[%s %s]: message sent to deallocated instance %p\",\n              className + prefixLen,\n              selName,\n              receiver);\n        <breakpoint-interrupt>\n    }\n\n    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation\n    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {\n        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];\n        if (methodSignature) {\n            BOOL signatureIsStret = [methodSignature _frameDescriptor]->returnArgInfo.flags.isStruct;\n            if (signatureIsStret != isStret) {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.\",\n                      selName,\n                      signatureIsStret ? \"\" : not,\n                      isStret ? \"\" : not);\n            }\n            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {\n                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];\n\n                [receiver forwardInvocation:invocation];\n\n                void *returnValue = NULL;\n                [invocation getReturnValue:&value];\n                return returnValue;\n            } else {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\",\n                      receiver,\n                      className);\n                return 0;\n            }\n        }\n    }\n\n    SEL *registeredSel = sel_getUid(selName);\n\n    // selector 是否已经在 Runtime 注册过\n    if (sel != registeredSel) {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\",\n              sel,\n              selName,\n              registeredSel);\n    } // doesNotRecognizeSelector\n    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {\n        [receiver doesNotRecognizeSelector:sel];\n    }\n    else {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\",\n              receiver,\n              className);\n    }\n\n    // The point of no return.\n    kill(getpid(), 9);\n}\n```\n\n\n### 验证动态解析\n我们简单定义一个`test`函数，然后并执行这个函数。\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n@implementation Person\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n\tNSLog(@\"%s\",__func__);\n\tif (sel == @selector(test)) {\n\t\tMethod me = class_getInstanceMethod(self, @selector(test2));\n\t\tclass_addMethod(self, sel,\n\t\t\t\t\t\tmethod_getImplementation(me),\n\t\t\t\t\t\tmethod_getTypeEncoding(me));\n\t\treturn YES;\n\t}\n\treturn [super resolveInstanceMethod:sel];\n}\n-(void)test2{\n\tNSLog(@\"来了，老弟\");\n}\n@end\n\nPerson *p = [[Person alloc]init];\n[p test];\n[p test];\n //输出\n+[FYPerson resolveInstanceMethod:]\n -[FYPerson test3]\n -[FYPerson test3]\n```\n\n`[p test]`在第一次执行的时候会走到消息动态解析的这一步,然后通过`objc_msgsend`调用了`test`，并且把`test`添加到了缓存中，所以输出了`+[FYPerson resolveInstanceMethod:]`，在第二次调用的时候，会从缓存中查到`imp`，所以直接输出了` -[FYPerson test3]`。\n\n在`+resolveInstanceMethod`可以拦截掉实例方法的动态解析，在`+resolveClassMethod`可以拦截类方法。\n\n```\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n+ (void)test3{\n\tNSLog(@\"来了，老弟\");\n}\n+ (BOOL)resolveClassMethod:(SEL)sel{\n\tNSLog(@\"%s\",__func__);\n\tif (sel == @selector(test)) {\n\t\tMethod me = class_getClassMethod(self, @selector(test3));//获取method\n\t\t//给sel 添加方法实现 @selecter(test3)\n\t\tclass_addMethod(object_getClass(self), sel,\n\t\t\t\t\t\tmethod_getImplementation(me),\n\t\t\t\t\t\tmethod_getTypeEncoding(me));\n\t\treturn YES;\n\t}\n\treturn [super resolveInstanceMethod:sel];\n}\n\n[Person test];\n\n//输出\n+[Person resolveClassMethod:]\n来了，老弟\n```\n\n拦截`+resolveClassMethod`,在条件为`sel==@selector(test)`的时候，将函数实现`+test3()`的`IMP`使用`class_addMethod`添加到`Person`上，待下次调用`test`的时候直接通过`imp = cache_getImp(cls, sel);`获取到`imp`函数指针并且执行。\n我们也可以通过添加c函数的imp来实现给class添加函数实现。\n\n```\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    NSLog(@\"%s\",__func__);\n    if (sel == @selector(test)) {\n//        Method me = class_getInstanceMethod(self, @selector(test3));\n//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));\n        class_addMethod(self.class, sel, (IMP)test3, \"v16@0:8\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\nvoid test3(id self,SEL sel){\n    NSLog(@\"test3:%s\",NSStringFromSelector(sel).UTF8String);\n}\n\n//输出\n+[FYPerson resolveInstanceMethod:]\ntest3:test\ntest3:test\n```\n\n`v16@0:8`是返回值为`void`参数占用16字节大小，第一个是从0开始，第二个从8字节开始。\n这段代码和上面的其实本质上是一样的，一个是给`class`添加函数实现，使`sel`和`imp`对应起来，这个是将`c`函数的`imp`和`sel`进行关联，添加缓存之后，使用`objc_msgsend()`效果是一样的。\n\n###  验证消息转发\n消息转发可分为3步，第一步根据`- (id)forwardingTargetForSelector:(SEL)aSelector`返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的`-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`或`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`函数签名，在第三步` (void)forwardInvocation:(NSInvocation *)anInvocation`调用函数`[anInvocation invoke]`进行校验成功之后进行调用函数。\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n#import \"Person.h\"\n#import \"Student.h\"\n\n@implementation Person\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [[Struent alloc]init];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n@end\n//输出\n-[Student test]\n```\n\n我们定义了一个`Person`只声明了`test`没有实现，然后在消息转发第一步`forwardingTargetForSelector`将要处理的对象返回，成功调用了`Student`的`test`方法。\n\n第一步没拦截，可以在第二步拦截。\n```\n//消息转发第二步 没有对象来处理方法，那将函数签名来实现\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n\tif (aSelector == @selector(test)) {\n\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n\t\treturn sign;\n\t}\n\treturn [super methodSignatureForSelector:aSelector];\n}\n// 函数签名已返回，到了函数调用的地方\n//selector 函数的sel\n//target   函数调用者\n//methodSignature 函数签名\n//NSInvocation  封装数据的对象\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    NSLog(@\"%s\",__func__);\n}\n//输出\n-[Person forwardInvocation:]\n```\n\n打印出了`-[Person forwardInvocation:]`而且没有崩溃，在`forwardInvocation:(NSInvocation *)anInvocation`怎么操作看开发者怎么处理了，探究下都可以做什么事情。\n看到`NSInvocation`的属性和函数,`sel`和`target`是读写，函数签名是必须的，所以`(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`必须将函数签名返回。\n\n```\n@property (readonly, retain) NSMethodSignature *methodSignature;//只读\n- (void)retainArguments;\n@property (readonly) BOOL argumentsRetained;\n@property (nullable, assign) id target;//读写\n@property SEL selector;//读写\n```\n\n当拦截方法是类方法的时候，可以用`+ (id)forwardingTargetForSelector:(SEL)aSelecto`拦截，\n\n```\n//class 转发\n// 消息转发第一步 拦截是否有转发的class对象处理方法\n+ (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test3)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [Student class];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n\n+ (void)test3{\n//\tNSLog(@\"+[Student test3]\");\n//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错\n//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。\n//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗\n}\n- (void)test2{\n\tNSLog(@\"%s\",__func__);\n}\n\n// 输出\n-[Student test2]\n```\n\n也可以用返回`return [[Student alloc]init];`将`class`类方法转化成实例方法,最后调用了`Student`的对象方法`test3`。其实本质上都是`objc_msgSend(id,SEL,...)`，我们修改的只是`id`的值，`id`类型在这段代码中本质是对象，所以我们可以`return instance`也可以`reurn class`。\n\n```\n+ (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test3)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [[Student alloc]init];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n\n- (void)test3{\n\tNSLog(@\"%s\",__func__);\n}\n//输出\n-[Student test3]\n```\n\n将刚才写的`methodSignatureForSelector`和`forwardInvocation`改成类方法，也是同样可以拦截类方法的。我们看下\n\n```\n//消息转发第二步 没有class来处理方法，那将函数签名来实现\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n\tif (aSelector == @selector(test3)) {\n\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n\t\treturn sign;\n\t}\n\treturn [super methodSignatureForSelector:aSelector];\n}\n// 函数签名已返回，到了函数调用的地方\n//selector 函数的sel\n//target   函数调用者\n//methodSignature 函数签名\n//NSInvocation  封装数据的对象\n+ (void)forwardInvocation:(NSInvocation *)anInvocation{\n//\tanInvocation.selector = @selector(test2);\n//此处换成[Student class]同样可以\n//\tanInvocation.target = (id)[[Student alloc]init];\n\n//\t[anInvocation invoke];\n\tNSLog(@\"%s\",__func__);\n}\n\n//输出\n+[Person forwardInvocation:]\n\n```\n测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用`-`方法,类方法是用`+`方法。\n\n### 总结\n- objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是`cache->class_rw_t->supclass cache ->superclass class_rw_t ->动态解析`)\n- 第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的\n- 第三步是消息转发，转发第一步可以在`+ (id)forwardingTargetForSelector:(SEL)aSelector`或`- (id)forwardingTargetForSelector:(SEL)aSelector`拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法\n- 第三步消息转发的第二步可以在`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`或`- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`实现拦截类和实例方法并返回函数签名\n- 第三步消息转发的第三步可以`+ (void)forwardInvocation:(NSInvocation *)anInvocation`或`- (void)forwardInvocation:(NSInvocation *)anInvocation`实现类方法和实例方法的调用和获取返回值\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7).md","raw":"title: iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)\ndate: 2019-12-1 11:17:58\ntags:\n- iOS\ncategories: iOS\n---\n\narm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，`objc_class->cache_t cache`是一个是缓存最近调用`class`的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的`method_t`扩容之后之后被清空。今天我们在了解runtime的消息转发机制。\n#### 基础知识\n\nOC中的方法调用，其实都是转换为objc_msgSend函数的调用\n\nobjc_msgSend的执行流程可以分为3大阶段\n\n1. 消息发送\n2. 动态方法解析\n3. 消息转发\n\n那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下\n\n```\nobjc-msg-arm64.s\nENTRY _objc_msgSend\nb.le\tLNilOrTagged //<0则返回\nCacheLookup NORMAL //缓存查找 未命中则继续查找\n.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp\n.macro CheckMiss //miss 则跳转__objc_msgSend_uncached\nSTATIC_ENTRY __objc_msgSend_uncached \n.macro MethodTableLookup//方法中查找\n__class_lookupMethodAndLoadCache3//跳转->__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行\n\n\nobjc-runtime-new.mm\n_class_lookupMethodAndLoadCache3\nlookUpImpOrForward\ngetMethodNoSuper_nolock、search_method_list、log_and_fill_cache\ncache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache\n_class_resolveInstanceMethod\n_objc_msgForward_impcache\n\n\nobjc-msg-arm64.s\nSTATIC_ENTRY __objc_msgForward_impcache\nENTRY __objc_msgForward\n\nCore Foundation\n__forwarding__（不开源）\n```\n\n### 消息发送\n\n`objc_msgSend`是汇编写的，在源码`objc-msg-arm64.s`304行，是`objc_msgSend`的开始，`_objc_msgSend`结束是351行,\n进入到`objc_msgSend`函数内部一探究竟：\n\n```\n\tENTRY _objc_msgSend // _objc_msgSend 开始\n\tUNWIND _objc_msgSend, NoFrame\n\n\tcmp\tp0, #0\t\t\t// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self\n#if SUPPORT_TAGGED_POINTERS\n\tb.le\tLNilOrTagged\t\t// if le < 0 ->  跳转到标签  LNilOrTagged\n#else\n\tb.eq\tLReturnZero // if le == 0 ->  跳转到标签  LReturnZero\n#endif\n\tldr\tp13, [x0]\t\t// p13 = isa\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\nLGetIsaDone:\n\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n\tb.eq\tLReturnZero\t\t// 如果==0 -> LReturnZero\n\n\t// tagged\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret //return 返回结束掉\n\n\tEND_ENTRY _objc_msgSend // _objc_msgSend 结束\n```\n\n当`objc_msgSend(id,SEL,arg)`的`id`为空的时候，跳转标签`LNilOrTagged`,进入标签内，当等于0则跳转`LReturnZero`,进入到`LReturnZero`内，清除数据和return。不等于零，获取isa和class，调用`CacheLookup NORMAL`,进入到`CacheLookup`内部\n\n```\n.macro CacheLookup //.macro 是一个宏 使用 _cmd&mask 查找缓存中的方法\n\t// p1 = SEL, p16 = isa\n\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask\n#if !__LP64__\n\tand\tw11, w11, 0xffff\t// p11 = mask\n#endif\n\tand\tw12, w1, w11\t\t// x12 = _cmd & mask\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket 没有命中\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)\n\t\t                        // p12 = buckets + (mask << 1+PTRSHIFT)\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\n3:\t// double wrap\n\tJumpMiss $0\n\t\n.endmacro\n```\n\n汇编代码左边是代码，右边是注释，大概都可以看懂的。\n当命中则`return imp`,否则则跳转`CheckMiss`,进入到`CheckMiss`内部：\n\n```\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tp9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n```\n\n刚才传的值是`NORMAL`，则跳转`__objc_msgSend_uncached`，进入到`__objc_msgSend_uncached`内部(484行)：\n\n```\n\tSTATIC_ENTRY __objc_msgSend_uncached\n\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\tMethodTableLookup\n\tTailCallFunctionPointer x17\n\tEND_ENTRY __objc_msgSend_uncached\n```\n\n调用`MethodTableLookup`,我们查看`MethodTableLookup`内部：\n\n```\n.macro MethodTableLookup\n\t// push frame\n\tSignLR\n\tstp\tfp, lr, [sp, #-16]!\n\tmov\tfp, sp\n\n\t// save parameter registers: x0..x8, q0..q7\n\tsub\tsp, sp, #(10*8 + 8*16)\n\tstp\tq0, q1, [sp, #(0*16)]\n\tstp\tq2, q3, [sp, #(2*16)]\n\tstp\tq4, q5, [sp, #(4*16)]\n\tstp\tq6, q7, [sp, #(6*16)]\n\tstp\tx0, x1, [sp, #(8*16+0*8)]\n\tstp\tx2, x3, [sp, #(8*16+2*8)]\n\tstp\tx4, x5, [sp, #(8*16+4*8)]\n\tstp\tx6, x7, [sp, #(8*16+6*8)]\n\tstr\tx8,     [sp, #(8*16+8*8)]\n\n\t// receiver and selector already in x0 and x1\n\tmov\tx2, x16\n\tbl\t__class_lookupMethodAndLoadCache3//跳转->__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行\n\n\t// IMP in x0\n\tmov\tx17, x0\n\t\n\t// restore registers and return\n\tldp\tq0, q1, [sp, #(0*16)]\n\tldp\tq2, q3, [sp, #(2*16)]\n\tldp\tq4, q5, [sp, #(4*16)]\n\tldp\tq6, q7, [sp, #(6*16)]\n\tldp\tx0, x1, [sp, #(8*16+0*8)]\n\tldp\tx2, x3, [sp, #(8*16+2*8)]\n\tldp\tx4, x5, [sp, #(8*16+4*8)]\n\tldp\tx6, x7, [sp, #(8*16+6*8)]\n\tldr\tx8,     [sp, #(8*16+8*8)]\n\n\tmov\tsp, fp\n\tldp\tfp, lr, [sp], #16\n\tAuthenticateLR\n.endmacro\n\n```\n\n最终跳转到`__class_lookupMethodAndLoadCache3`,去掉一个下划线就是c函数，在`runtime-class-new.mm 4856行`,\n调用了函数`lookUpImpOrForward(cls, sel, obj, \n                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);`,第一次会初始化`cls`和`resolver`的值，\n中最终跳转到`c/c++`函数`lookUpImpOrForward`，该函数是最终能看到的`c/c++`,现在我们进入到`lookUpImpOrForward`内部查看：\n\n```\n/***********************************************************************\n* lookUpImpOrForward.\n* initialize==NO 尽量避免调用，有时可能也会调用。\n* cache==NO 跳过缓存查找，其他地方可能会不调过\n* 大多数人会传值 initialize==YES and cache==YES\n*   如果cls是非初始化的元类，则非Non-nil会快点\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n* 如果你不想用forwarding，则调用lookUpImpOrNil()代替\n**********************************************************************/\nIMP lookUpImpOrForward(Class cls, SEL sel, id inst, \n                       bool initialize, bool cache, bool resolver)\n{\n    IMP imp = nil;\n    bool triedResolver = NO;\n\n    runtimeLock.assertUnlocked();\n    // Optimistic cache lookup\n    if (cache) { //从汇编过来是NO\n        imp = cache_getImp(cls, sel);\n        if (imp) return imp;\n    }\n\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n\n    if (!cls->isRealized()) {\n        realizeClass(cls);\n    }\n\n    if (initialize  &&  !cls->isInitialized()) {\n\t\t//当cls需要初始化和没有初始化的时候 进行cls初始化，\n\t\t//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类\n\t\t//数据的大小最小是4，扩容规则是：n*2+1;\n        runtimeLock.unlock();\n        _class_initialize (_class_getNonMetaClass(cls, inst));\n        runtimeLock.lock();\n    }\n\n    \n retry:    \n    runtimeLock.assertLocked();\n\n//再次获取imp\n    imp = cache_getImp(cls, sel);\n    if (imp) goto done;\n\n    //尝试在本类中查找method\n    {//从cls->data()->methods查找method\n        Method meth = getMethodNoSuper_nolock(cls, sel);\n        if (meth) {//找到添加到cache中\n            log_and_fill_cache(cls, meth->imp, sel, inst, cls);\n            imp = meth->imp;\n            goto done;\n        }\n    }\n\n    // Try superclass caches and method lists.\n\t//从cls->superclass->data()->methods查找methd，supercls没有查找出来，再查找父类的父类。\n    {\n        unsigned attempts = unreasonableClassCount();\n        for (Class curClass = cls->superclass;\n             curClass != nil;\n             curClass = curClass->superclass)\n        {\n            // Halt if there is a cycle in the superclass chain.\n            if (--attempts == 0) {\n                _objc_fatal(\"Memory corruption in class list.\");\n            }\n            \n            // Superclass cache.\n            imp = cache_getImp(curClass, sel);\n            if (imp) {\n                if (imp != (IMP)_objc_msgForward_impcache) {\n                    // Found the method in a superclass. Cache it in this class.\n\t\t\t\t\t//将父类添加到 子类的缓存中\n                    log_and_fill_cache(cls, imp, sel, inst, curClass);\n                    goto done;\n                }\n                else {\n                    // Found a forward:: entry in a superclass.\n                    // Stop searching, but don't cache yet; call method \n                    // resolver for this class first.\n                    break;\n                }\n            }\n            \n            // Superclass method list.\n            Method meth = getMethodNoSuper_nolock(curClass, sel);\n            if (meth) {\n                log_and_fill_cache(cls, meth->imp, sel, inst, curClass);\n                imp = meth->imp;\n                goto done;\n            }\n        }\n    }\n\n\t//如果还没有找到imp，进入动态方法解析阶段\n    if (resolver  &&  !triedResolver) {\n        runtimeLock.unlock();\n        _class_resolveMethod(cls, sel, inst);\n        runtimeLock.lock();\n        triedResolver = YES;\n        goto retry;\n    }\n\n    //如果没找到resolveInstanceMethod 和resolveClassMethod，\n//\t进行消息转发 阶段\n    imp = (IMP)_objc_msgForward_impcache;\n\t//填充 cache\n    cache_fill(cls, sel, imp, inst);\n done:\n    runtimeLock.unlock();\n    return imp;\n}\n\n\n```\n`SUPPORT_INDEXED_ISA`是在`arm64`和`LP64` 还有`arm_arch_7k>2`为1，`iphone`属于`arm64`、`mac os`属于`LP64`,所以`SUPPORT_INDEXED_ISA = 1`.\n\n```\n// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa \n// field as an index into a class table.\n// Note, keep this in sync with any .s files which also define it.\n// Be sure to edit objc-abi.h as well.\n// __ARM_ARCH_7K__ 处理器架构指令集版本\n//__arm64__ 架构\n//__LP64__ uinx 和uinx  mac os\n#if __ARM_ARCH_7K__ >= 2  ||  (__arm64__ && !__LP64__)\n#   define SUPPORT_INDEXED_ISA 1\n#else\n#   define SUPPORT_INDEXED_ISA 0\n#endif\n\n```\n`lookUpImpOrForward`函数的 大概思路如下：\n\n首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断`cls`是否已经实现，`cls->isRealized()`，没有实现的话进行实现`realizeClass(cls)`，主要是将初始化`read-write data`和其他的一些数据，后续会细讲。然后进行`cls`的初始化`_class_initialize()`，当`cls`需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：`n*2+1`;然后再次获取imp`cache_getImp`,然后在`cls`方法中查找该`method`，然后就是在`superclass`中查找方法，直到父类是nil，找到的话，获取`imp`并将`cls`和`sel`加入到`cache`中，否则进入到消息解析阶段`_class_resolveMethod`，在转发阶段，不是元类的话，进入到`_class_resolveInstanceMethod`是元类的话调用`_class_resolveClassMethod`,这两种分别都会进入到`lookUpImpOrNil`，再次查找`IMP`，当没找到的话就返回，找到的话用`objc_msgSend`发送消息实现调用`SEL_resolveInstanceMethod`并标记`triedResolver`为已动态解析标志。然后进入到消息动态转发阶段`_objc_msgForward_impcache`,至此`runtime`发送消息结束。\n\n借用网上找一个图， 可以更直观的看出流程运转。\n\n\n![](../images/7-1.png)\n\n\n#### realizeClass()解析\n`realizeClass`是初始化了很多数据，包括`cls->ro`赋值给`cls->rw`，添加元类`version`为7,`cls->chooseClassArrayIndex()`设置`cls`的索引，`supercls = realizeClass(remapClass(cls->superclass));\n    metacls = realizeClass(remapClass(cls->ISA()))`初始化`superclass`和`cls->isa`,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置`cls->setInstanceSize`,拷贝`flags`从`ro`到`rw`中，然后添加`subclass`和`rootclass`，最后添加类别的方法，协议，和属性。\n\n```\n/***********************************************************************\n* realizeClass\n cls第一次初始化会执行，包括cls->rw->data(),返回真实的cls 结构体\n runtimelock 必须有调用者把写入锁锁起来\n**********************************************************************/\nstatic Class realizeClass(Class cls)\n{\n    runtimeLock.assertLocked();\n\n    const class_ro_t *ro;\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n    bool isMeta;\n\n    if (!cls) return nil;\n    if (cls->isRealized()) return cls;\n    assert(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n//首先将tw赋值给to，因为数据结构一样可以直接强制转化\n    ro = (const class_ro_t *)cls->data();\n    if (ro->flags & RO_FUTURE) {//是否已经初始化过，初始化过的哈 则 cls->rw 已经初始化过\n        rw = cls->data();\n        ro = cls->data()->ro;\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // 正常情况下 申请class_rw_t空间\n        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\n        rw->ro = ro;//cls->rw->ro 指向现在的ro\n        rw->flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1\n        cls->setData(rw);//赋值\n    }\n\n    isMeta = ro->flags & RO_META;//是否是元类\n\t\n\n    rw->version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0\n\n\n    // Choose an index for this class.\n//设置cls的索引\n\tcls->chooseClassArrayIndex();\n\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: realizing class '%s'%s %p %p #%u\", \n                     cls->nameForLogging(), isMeta ? \" (meta)\" : \"\", \n                     (void*)cls, ro, cls->classArrayIndex());\n    }\n\n    // 如果父类没有初始化则进行初始化\n    // root_class 做完需要设置RW_REALIZED=1，\n    // root metaclasses 需要执行完.\n\t//从NXMapTable 获取cls ，然后进行初始化\n\t//从NXMapTable 获取cls->isa ，然后进行初始化\n    supercls = realizeClass(remapClass(cls->superclass));\n    metacls = realizeClass(remapClass(cls->ISA()));\n//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。\n#if SUPPORT_NONPOINTER_ISA\n    // Disable non-pointer isa for some classes and/or platforms.\n    // Set instancesRequireRawIsa.\n    bool instancesRequireRawIsa = cls->instancesRequireRawIsa();\n    bool rawIsaIsInherited = false;\n    static bool hackedDispatch = false;\n\n    if (DisableNonpointerIsa) {\n        // Non-pointer isa disabled by environment or app SDK version\n        instancesRequireRawIsa = true;\n    }\n    else if (!hackedDispatch  &&  !(ro->flags & RO_META)  &&  \n             0 == strcmp(ro->name, \"OS_object\")) \n    {\n        // hack for libdispatch et al - isa also acts as vtable pointer\n        hackedDispatch = true;\n        instancesRequireRawIsa = true;\n    }\n    else if (supercls  &&  supercls->superclass  &&  \n             supercls->instancesRequireRawIsa()) \n    {\n        // This is also propagated by addSubclass() \n        // but nonpointer isa setup needs it earlier.\n        // Special case: instancesRequireRawIsa does not propagate \n        // from root class to root metaclass\n        instancesRequireRawIsa = true;\n        rawIsaIsInherited = true;\n    }\n    \n    if (instancesRequireRawIsa) {\n        cls->setInstancesRequireRawIsa(rawIsaIsInherited);\n    }\n// SUPPORT_NONPOINTER_ISA\n#endif\n\n    // Update superclass and metaclass in case of remapping\n    cls->superclass = supercls;\n    cls->initClassIsa(metacls);\n\n\t// 协调实例变量偏移/布局\n\t//可能重新申请空间 class_ro_t,更新我们的class_ro_t\n    if (supercls  &&  !isMeta) reconcileInstanceVariables(cls, supercls, ro);\n\n    // 设置setInstanceSize 从ro->instanceSize\n    cls->setInstanceSize(ro->instanceSize);\n\n\t//拷贝flags 从ro到rw中\n    if (ro->flags & RO_HAS_CXX_STRUCTORS) {\n        cls->setHasCxxDtor();\n        if (! (ro->flags & RO_HAS_CXX_DTOR_ONLY)) {\n            cls->setHasCxxCtor();\n        }\n    }\n//添加superclass指针\n    if (supercls) {\n        addSubclass(supercls, cls);\n    } else {\n        addRootClass(cls);\n    }\n\n    // Attach categories\n\t//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的\n    methodizeClass(cls);\n\n    return cls;\n}\n```\n\n这里最后添加类别的数据是调用了`methodizeClass`函数，这个函数首先添加`method_list_t *list = ro->baseMethods()`到`rw->methods.attachLists(&list, 1)`，然后将属性`property_list_t *proplist=ro->baseProperties`添加到`rw->properties.attachLists(&proplist, 1)`,最后将协议列表`protocol_list_t *protolist = ro->baseProtocols`追加到`rw->protocols.attachLists(&protolist, 1)`，如果是`metaclass`则添加`SEL_initialize`,然后从全局`NXMapTable *category_map`删除已经加载的`category_list`,最后调用`attachCategories(cls, cats, false /*don't flush caches*/)`将已经加载的`cats`的方法添加到`cls->rw`上面并且不刷新`caches`。\n\n```\n/***********************************************************************\n* methodizeClass\n 修复cls方法列表想，协议列表和属性列表\n* 加锁\n**********************************************************************/\nstatic void methodizeClass(Class cls)\n{\n    runtimeLock.assertLocked();\n\n    bool isMeta = cls->isMetaClass();\n    auto rw = cls->data();\n    auto ro = rw->ro;\n\n    // Methodizing for the first time\n    if (PrintConnecting) {\n        _objc_inform(\"CLASS: methodizing class '%s' %s\", \n                     cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n    }\n\n\t//方法列表\n    method_list_t *list = ro->baseMethods();\n    if (list) {\n        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));\n\t//将对象的方法追加到cls->rw->methods后面\n        rw->methods.attachLists(&list, 1);\n    }\n\n    property_list_t *proplist = ro->baseProperties;\n    if (proplist) {\n\t//将对象的属性追加到rw->properties后面\n        rw->properties.attachLists(&proplist, 1);\n    }\n\n    protocol_list_t *protolist = ro->baseProtocols;\n    if (protolist) {\n\t//将对象的协议追加到rw->protocols后面\n        rw->protocols.attachLists(&protolist, 1);\n    }\n\n    // Root classes get bonus method implementations if they don't have \n    // them already. These apply before category replacements.\n    if (cls->isRootMetaclass()) {\n        // root metaclass\n        addMethod(cls, SEL_initialize, (IMP)&objc_noop_imp, \"\", NO);\n    }\n\n    // Attach categories.\n\t//类别 从全局NXMapTable *category_map 已经加载过了。\n    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);\n\t//收集所有的cats到cls -> rw中\n    attachCategories(cls, cats, false /*don't flush caches*/);\n\n    if (PrintConnecting) {\n        if (cats) {\n            for (uint32_t i = 0; i < cats->count; i++) {\n                _objc_inform(\"CLASS: attached category %c%s(%s)\", \n                             isMeta ? '+' : '-', \n                             cls->nameForLogging(), cats->list[i].cat->name);\n            }\n        }\n    }\n    \n    if (cats) free(cats);//释放cats\n\n#if DEBUG\n    // Debug: sanity-check all SELs; log method list contents\n    for (const auto& meth : rw->methods) {\n        if (PrintConnecting) {\n            _objc_inform(\"METHOD %c[%s %s]\", isMeta ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(meth.name));\n        }\n        assert(sel_registerName(sel_getName(meth.name)) == meth.name); \n    }\n#endif\n}\n```\n\n#### attachCategories()解析\n`methodizeClass`之前`rw`初始化的时候并没有将其他数据都都复制给`rw`,现在`methodizeClass`实现了将本来的`ro`数据拷贝给`rw`,然后`attachCategories`将\n分类的方法，属性，协议追加到`cls->data->rw`，我们进入`attachCategories`内部\n\n```\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n\t//属性数组\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n\t//协议数组\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    while (i--) {\n\t\t//取出某个分类\n        auto& entry = cats->list[i];\n//取出分类 的 instance方法或者class方法\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist; //mlists 接受所有分类方法\n            fromBundle |= entry.hi->isBundle();\n        }\n//proplist 接受所有分类属性\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n//proplist 接受所有协议方法\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n//收集了所有协议 分类方法\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n\t//追加所有分类方法\n    rw->methods.attachLists(mlists, mcount);\n\t//释放数组\n    free(mlists);\n\t//刷新该类的缓存\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n//追加所有分类属性\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);//释放数组\n//追加所有分类协议\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);//释放数组\n}\n```\n\n#### rw->list->attachLists()解析\n添加`attachLists`函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。\n\n```\n void attachLists(List* const * addedLists, uint32_t addedCount) {\n        if (addedCount == 0) return;\n\n        if (hasArray()) {\n            // many lists -> many lists\n            uint32_t oldCount = array()->count;\n\t\t\t//一共需要的数量\n            uint32_t newCount = oldCount + addedCount;\n\t\t\t//分配内存 内存不够用了，需要扩容\n            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n\t\t\t//赋值count\n            array()->count = newCount;\n\t\t\t// array()->lists：原来的方法列表向后移动 oldCount * sizeof(array()->lists[0]个长度\n            memmove(array()->lists + addedCount/*数组末尾*/, array()->lists/*数组*/,\n                    oldCount * sizeof(array()->lists[0])/*移动的大小*/);\n\t\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()->lists[0])\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n\t\t\t/*\n\t\t\t图示讲解：\n\t\t\tarray()->lists:A->B->C->D->E\n\t\taddedCount:3\n\t\taddedLists:P->L->V\n\t\t\tmemmove之后：nil->nil->nil->A->B->C->D->E\n\t\t\t然后再讲addedLists插入到数组前边,最终array()->lists的值是：\n\t\t\tP->L->V->A->B->C->D->E\n\t\t\t */\n        }\n        else if (!list  &&  addedCount == 1) {\n            // 0 lists -> 1 list\n            list = addedLists[0];\n        } \n        else {\n            // 1 list -> many lists\n            List* oldList = list;\n            uint32_t oldCount = oldList ? 1 : 0;\n            uint32_t newCount = oldCount + addedCount;\n            setArray((array_t *)malloc(array_t::byteSize(newCount)));\n            array()->count = newCount;\n            if (oldList) array()->lists[addedCount] = oldList;\n            memcpy(array()->lists, addedLists, \n                   addedCount * sizeof(array()->lists[0]));\n        }\n    }\n```\n\n`class`初始化完成了，然后再次尝试获取`imp = cache_getImp`,由于缓存没有中间也没添加进去，所以这里也是空的，然后从`getMethodNoSuper_nolock`获取该`cls`的方法列表中查找，没有的话再从`superclass`查找`cache`和`method`,找到的话，进行`log_and_fill_cache`至此消息发送完成。\n\n### 消息动态解析\n\n动态解析函数`_class_resolveMethod(cls, sel, inst)`，如果不是元类调用`_class_resolveInstanceMethod`,如果是的话调用`_class_resolveClassMethod`\n\n```\n/***********************************************************************\n* _class_resolveMethod\n* 调用 +resolveClassMethod 或者 +resolveInstanceMethod\n* 如果存在了则不检查\n**********************************************************************/\nvoid _class_resolveMethod(Class cls, SEL sel, id inst)\n{\n    if (! cls->isMetaClass()) {//不是元类则调用 实例的\n\t//首先调用\n\t\t_class_resolveInstanceMethod(cls, sel, inst);\n    } \n    else {\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n\t\t//寻找classMethod\n        _class_resolveClassMethod(cls, sel, inst);\n        if (!lookUpImpOrNil(cls, sel, inst, \n                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n        {\n            _class_resolveInstanceMethod(cls, sel, inst);\n        }\n    }\n}\n\n```\n\n在`resolveInstanceMethod`，查找`SEL_resolveInstanceMethod`，传值不用初始化，不用消息解析，但是`cache`要查找。没有找到的直接返回，找到的话使用`objc_msgSend`发送消息调用`SEL_resolveInstanceMethod`。\n\n```\n/***********************************************************************\n* _class_resolveInstanceMethod\n* 调用 class添加的函数 +resolveInstanceMethod\n* 有可能是元类\n* 如果方法存在则不检查\n**********************************************************************/\nstatic void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)\n{\n    if (! lookUpImpOrNil(cls->ISA(), SEL_resolveInstanceMethod, cls, \n                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n    {\n        // Resolver not implemented.\n        return;\n    }\n//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNil(cls, sel, inst, \n                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n在`_class_resolveClassMethod`中，第一步先去`lookUpImpOrNil`查找`+SEL_resolveClassMethod`方法，没找到的就结束，找到则调用`objc_msgsend(id,sel)`\n\n```\nstatic void _class_resolveClassMethod(Class cls, SEL sel, id inst)\n{\n    assert(cls->isMetaClass());\n\n    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, \n                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) \n    {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(_class_getNonMetaClass(cls, inst), \n                        SEL_resolveClassMethod, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveClassMethod adds to self->ISA() a.k.a. cls\n    IMP imp = lookUpImpOrNil(cls, sel, inst, \n                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n动态解析至此完成。\n\n### 消息转发\n`_objc_msgForward_impcache`是转发的函数地址，在搜索框搜索发现，这个函数除了`.s`文件中有，其他地方均只是调用，说明这个函数是汇编实现，在`objc-msg-arm64.s 531 行`发现一点踪迹\n\n```\nSTATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache\n\t// No stret specialization.\n\tb\t__objc_msgForward//跳转->__objc_msgForward\n\tEND_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache\n\n\t\n\tENTRY __objc_msgForward // 开始 __objc_msgForward\n\n\tadrp\tx17, __objc_forward_handler@PAGE\n\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和\n\tTailCallFunctionPointer x17 //跳转-> TailCallFunctionPointer\n\n\tEND_ENTRY __objc_msgForward//结束 __objc_msgForward\n```\n\n当跳转到`adrp\tx17, __objc_forward_handler@PAGE`这一行，搜搜索函数`_objc_forward_handler`，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。\n\n```\n__attribute__((noreturn)) void \nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n```\n\n网上有大神总结的点我们先参考下\n\n```\n// 伪代码\nint __forwarding__(void *frameStackPointer, int isStret) {\n    id receiver = *(id *)frameStackPointer;\n    SEL sel = *(SEL *)(frameStackPointer + 8);\n    const char *selName = sel_getName(sel);\n    Class receiverClass = object_getClass(receiver);\n\n    // 调用 forwardingTargetForSelector:\n    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) {\n        id forwardingTarget = [receiver forwardingTargetForSelector:sel];\n        if (forwardingTarget && forwardingTarget != receiver) {\n            if (isStret == 1) {\n                int ret;\n                objc_msgSend_stret(&ret,forwardingTarget, sel, ...);\n                return ret;\n            }\n            return objc_msgSend(forwardingTarget, sel, ...);\n        }\n    }\n\n    // 僵尸对象\n    const char *className = class_getName(receiverClass);\n    const char *zombiePrefix = \"_NSZombie_\";\n    size_t prefixLen = strlen(zombiePrefix); // 0xa\n    if (strncmp(className, zombiePrefix, prefixLen) == 0) {\n        CFLog(kCFLogLevelError,\n              @\"*** -[%s %s]: message sent to deallocated instance %p\",\n              className + prefixLen,\n              selName,\n              receiver);\n        <breakpoint-interrupt>\n    }\n\n    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation\n    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) {\n        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];\n        if (methodSignature) {\n            BOOL signatureIsStret = [methodSignature _frameDescriptor]->returnArgInfo.flags.isStruct;\n            if (signatureIsStret != isStret) {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s.\",\n                      selName,\n                      signatureIsStret ? \"\" : not,\n                      isStret ? \"\" : not);\n            }\n            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) {\n                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];\n\n                [receiver forwardInvocation:invocation];\n\n                void *returnValue = NULL;\n                [invocation getReturnValue:&value];\n                return returnValue;\n            } else {\n                CFLog(kCFLogLevelWarning ,\n                      @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\",\n                      receiver,\n                      className);\n                return 0;\n            }\n        }\n    }\n\n    SEL *registeredSel = sel_getUid(selName);\n\n    // selector 是否已经在 Runtime 注册过\n    if (sel != registeredSel) {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\",\n              sel,\n              selName,\n              registeredSel);\n    } // doesNotRecognizeSelector\n    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) {\n        [receiver doesNotRecognizeSelector:sel];\n    }\n    else {\n        CFLog(kCFLogLevelWarning ,\n              @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\",\n              receiver,\n              className);\n    }\n\n    // The point of no return.\n    kill(getpid(), 9);\n}\n```\n\n\n### 验证动态解析\n我们简单定义一个`test`函数，然后并执行这个函数。\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n@implementation Person\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n\tNSLog(@\"%s\",__func__);\n\tif (sel == @selector(test)) {\n\t\tMethod me = class_getInstanceMethod(self, @selector(test2));\n\t\tclass_addMethod(self, sel,\n\t\t\t\t\t\tmethod_getImplementation(me),\n\t\t\t\t\t\tmethod_getTypeEncoding(me));\n\t\treturn YES;\n\t}\n\treturn [super resolveInstanceMethod:sel];\n}\n-(void)test2{\n\tNSLog(@\"来了，老弟\");\n}\n@end\n\nPerson *p = [[Person alloc]init];\n[p test];\n[p test];\n //输出\n+[FYPerson resolveInstanceMethod:]\n -[FYPerson test3]\n -[FYPerson test3]\n```\n\n`[p test]`在第一次执行的时候会走到消息动态解析的这一步,然后通过`objc_msgsend`调用了`test`，并且把`test`添加到了缓存中，所以输出了`+[FYPerson resolveInstanceMethod:]`，在第二次调用的时候，会从缓存中查到`imp`，所以直接输出了` -[FYPerson test3]`。\n\n在`+resolveInstanceMethod`可以拦截掉实例方法的动态解析，在`+resolveClassMethod`可以拦截类方法。\n\n```\n\n@interface Person : NSObject\n+ (void)test;\n@end\n\n+ (void)test3{\n\tNSLog(@\"来了，老弟\");\n}\n+ (BOOL)resolveClassMethod:(SEL)sel{\n\tNSLog(@\"%s\",__func__);\n\tif (sel == @selector(test)) {\n\t\tMethod me = class_getClassMethod(self, @selector(test3));//获取method\n\t\t//给sel 添加方法实现 @selecter(test3)\n\t\tclass_addMethod(object_getClass(self), sel,\n\t\t\t\t\t\tmethod_getImplementation(me),\n\t\t\t\t\t\tmethod_getTypeEncoding(me));\n\t\treturn YES;\n\t}\n\treturn [super resolveInstanceMethod:sel];\n}\n\n[Person test];\n\n//输出\n+[Person resolveClassMethod:]\n来了，老弟\n```\n\n拦截`+resolveClassMethod`,在条件为`sel==@selector(test)`的时候，将函数实现`+test3()`的`IMP`使用`class_addMethod`添加到`Person`上，待下次调用`test`的时候直接通过`imp = cache_getImp(cls, sel);`获取到`imp`函数指针并且执行。\n我们也可以通过添加c函数的imp来实现给class添加函数实现。\n\n```\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    NSLog(@\"%s\",__func__);\n    if (sel == @selector(test)) {\n//        Method me = class_getInstanceMethod(self, @selector(test3));\n//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));\n        class_addMethod(self.class, sel, (IMP)test3, \"v16@0:8\");\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\nvoid test3(id self,SEL sel){\n    NSLog(@\"test3:%s\",NSStringFromSelector(sel).UTF8String);\n}\n\n//输出\n+[FYPerson resolveInstanceMethod:]\ntest3:test\ntest3:test\n```\n\n`v16@0:8`是返回值为`void`参数占用16字节大小，第一个是从0开始，第二个从8字节开始。\n这段代码和上面的其实本质上是一样的，一个是给`class`添加函数实现，使`sel`和`imp`对应起来，这个是将`c`函数的`imp`和`sel`进行关联，添加缓存之后，使用`objc_msgsend()`效果是一样的。\n\n###  验证消息转发\n消息转发可分为3步，第一步根据`- (id)forwardingTargetForSelector:(SEL)aSelector`返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的`-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`或`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`函数签名，在第三步` (void)forwardInvocation:(NSInvocation *)anInvocation`调用函数`[anInvocation invoke]`进行校验成功之后进行调用函数。\n\n```\n@interface Person : NSObject\n- (void)test;\n@end\n\n#import \"Person.h\"\n#import \"Student.h\"\n\n@implementation Person\n- (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [[Struent alloc]init];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n@end\n//输出\n-[Student test]\n```\n\n我们定义了一个`Person`只声明了`test`没有实现，然后在消息转发第一步`forwardingTargetForSelector`将要处理的对象返回，成功调用了`Student`的`test`方法。\n\n第一步没拦截，可以在第二步拦截。\n```\n//消息转发第二步 没有对象来处理方法，那将函数签名来实现\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n\tif (aSelector == @selector(test)) {\n\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n\t\treturn sign;\n\t}\n\treturn [super methodSignatureForSelector:aSelector];\n}\n// 函数签名已返回，到了函数调用的地方\n//selector 函数的sel\n//target   函数调用者\n//methodSignature 函数签名\n//NSInvocation  封装数据的对象\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    NSLog(@\"%s\",__func__);\n}\n//输出\n-[Person forwardInvocation:]\n```\n\n打印出了`-[Person forwardInvocation:]`而且没有崩溃，在`forwardInvocation:(NSInvocation *)anInvocation`怎么操作看开发者怎么处理了，探究下都可以做什么事情。\n看到`NSInvocation`的属性和函数,`sel`和`target`是读写，函数签名是必须的，所以`(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`必须将函数签名返回。\n\n```\n@property (readonly, retain) NSMethodSignature *methodSignature;//只读\n- (void)retainArguments;\n@property (readonly) BOOL argumentsRetained;\n@property (nullable, assign) id target;//读写\n@property SEL selector;//读写\n```\n\n当拦截方法是类方法的时候，可以用`+ (id)forwardingTargetForSelector:(SEL)aSelecto`拦截，\n\n```\n//class 转发\n// 消息转发第一步 拦截是否有转发的class对象处理方法\n+ (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test3)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [Student class];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n\n+ (void)test3{\n//\tNSLog(@\"+[Student test3]\");\n//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错\n//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。\n//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗\n}\n- (void)test2{\n\tNSLog(@\"%s\",__func__);\n}\n\n// 输出\n-[Student test2]\n```\n\n也可以用返回`return [[Student alloc]init];`将`class`类方法转化成实例方法,最后调用了`Student`的对象方法`test3`。其实本质上都是`objc_msgSend(id,SEL,...)`，我们修改的只是`id`的值，`id`类型在这段代码中本质是对象，所以我们可以`return instance`也可以`reurn class`。\n\n```\n+ (id)forwardingTargetForSelector:(SEL)aSelector{\n\tif (aSelector == @selector(test3)) {\n\t\t//objc_msgSend([[Struent alloc]init],test)\n\t\treturn [[Student alloc]init];\n\t}\n\treturn [super forwardingTargetForSelector:aSelector];\n}\n\n- (void)test3{\n\tNSLog(@\"%s\",__func__);\n}\n//输出\n-[Student test3]\n```\n\n将刚才写的`methodSignatureForSelector`和`forwardInvocation`改成类方法，也是同样可以拦截类方法的。我们看下\n\n```\n//消息转发第二步 没有class来处理方法，那将函数签名来实现\n+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n{\n\tif (aSelector == @selector(test3)) {\n\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n\t\treturn sign;\n\t}\n\treturn [super methodSignatureForSelector:aSelector];\n}\n// 函数签名已返回，到了函数调用的地方\n//selector 函数的sel\n//target   函数调用者\n//methodSignature 函数签名\n//NSInvocation  封装数据的对象\n+ (void)forwardInvocation:(NSInvocation *)anInvocation{\n//\tanInvocation.selector = @selector(test2);\n//此处换成[Student class]同样可以\n//\tanInvocation.target = (id)[[Student alloc]init];\n\n//\t[anInvocation invoke];\n\tNSLog(@\"%s\",__func__);\n}\n\n//输出\n+[Person forwardInvocation:]\n\n```\n测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用`-`方法,类方法是用`+`方法。\n\n### 总结\n- objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是`cache->class_rw_t->supclass cache ->superclass class_rw_t ->动态解析`)\n- 第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的\n- 第三步是消息转发，转发第一步可以在`+ (id)forwardingTargetForSelector:(SEL)aSelector`或`- (id)forwardingTargetForSelector:(SEL)aSelector`拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法\n- 第三步消息转发的第二步可以在`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`或`- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`实现拦截类和实例方法并返回函数签名\n- 第三步消息转发的第三步可以`+ (void)forwardInvocation:(NSInvocation *)anInvocation`或`- (void)forwardInvocation:(NSInvocation *)anInvocation`实现类方法和实例方法的调用和获取返回值\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 runtime- objc_msgSend拾遗基础篇--(7)","published":1,"updated":"2019-12-03T05:03:16.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2j000m9zskskxcfog6","content":"<p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>\n<p>objc_msgSend的执行流程可以分为3大阶段</p>\n<ol>\n<li>消息发送</li>\n<li>动态方法解析</li>\n<li>消息转发</li>\n</ol>\n<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc-msg-arm64.s</div><div class=\"line\">ENTRY _objc_msgSend</div><div class=\"line\">b.le\tLNilOrTagged //&lt;0则返回</div><div class=\"line\">CacheLookup NORMAL //缓存查找 未命中则继续查找</div><div class=\"line\">.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp</div><div class=\"line\">.macro CheckMiss //miss 则跳转__objc_msgSend_uncached</div><div class=\"line\">STATIC_ENTRY __objc_msgSend_uncached </div><div class=\"line\">.macro MethodTableLookup//方法中查找</div><div class=\"line\">__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc-runtime-new.mm</div><div class=\"line\">_class_lookupMethodAndLoadCache3</div><div class=\"line\">lookUpImpOrForward</div><div class=\"line\">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</div><div class=\"line\">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</div><div class=\"line\">_class_resolveInstanceMethod</div><div class=\"line\">_objc_msgForward_impcache</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc-msg-arm64.s</div><div class=\"line\">STATIC_ENTRY __objc_msgForward_impcache</div><div class=\"line\">ENTRY __objc_msgForward</div><div class=\"line\"></div><div class=\"line\">Core Foundation</div><div class=\"line\">__forwarding__（不开源）</div></pre></td></tr></table></figure>\n<h3 id=\"消息发送\"><a href=\"#消息发送\" class=\"headerlink\" title=\"消息发送\"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tENTRY _objc_msgSend // _objc_msgSend 开始</div><div class=\"line\">\tUNWIND _objc_msgSend, NoFrame</div><div class=\"line\"></div><div class=\"line\">\tcmp\tp0, #0\t\t\t// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</div><div class=\"line\">#if SUPPORT_TAGGED_POINTERS</div><div class=\"line\">\tb.le\tLNilOrTagged\t\t// if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</div><div class=\"line\">#else</div><div class=\"line\">\tb.eq\tLReturnZero // if le == 0 -&gt;  跳转到标签  LReturnZero</div><div class=\"line\">#endif</div><div class=\"line\">\tldr\tp13, [x0]\t\t// p13 = isa</div><div class=\"line\">\tGetClassFromIsa_p16 p13\t\t// p16 = class</div><div class=\"line\">LGetIsaDone:</div><div class=\"line\">\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\"></div><div class=\"line\">#if SUPPORT_TAGGED_POINTERS</div><div class=\"line\">LNilOrTagged:</div><div class=\"line\">\tb.eq\tLReturnZero\t\t// 如果==0 -&gt; LReturnZero</div><div class=\"line\"></div><div class=\"line\">\t// tagged</div><div class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE</div><div class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</div><div class=\"line\">\tubfx\tx11, x0, #60, #4</div><div class=\"line\">\tldr\tx16, [x10, x11, LSL #3]</div><div class=\"line\">\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</div><div class=\"line\">\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</div><div class=\"line\">\tcmp\tx10, x16</div><div class=\"line\">\tb.ne\tLGetIsaDone</div><div class=\"line\"></div><div class=\"line\">\t// ext tagged</div><div class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE</div><div class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</div><div class=\"line\">\tubfx\tx11, x0, #52, #8</div><div class=\"line\">\tldr\tx16, [x10, x11, LSL #3]</div><div class=\"line\">\tb\tLGetIsaDone</div><div class=\"line\">// SUPPORT_TAGGED_POINTERS</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">LReturnZero:</div><div class=\"line\">\t// x0 is already zero</div><div class=\"line\">\tmov\tx1, #0</div><div class=\"line\">\tmovi\td0, #0</div><div class=\"line\">\tmovi\td1, #0</div><div class=\"line\">\tmovi\td2, #0</div><div class=\"line\">\tmovi\td3, #0</div><div class=\"line\">\tret //return 返回结束掉</div><div class=\"line\"></div><div class=\"line\">\tEND_ENTRY _objc_msgSend // _objc_msgSend 结束</div></pre></td></tr></table></figure>\n<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class=\"line\">\t// p1 = SEL, p16 = isa</div><div class=\"line\">\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask</div><div class=\"line\">#if !__LP64__</div><div class=\"line\">\tand\tw11, w11, 0xffff\t// p11 = mask</div><div class=\"line\">#endif</div><div class=\"line\">\tand\tw12, w1, w11\t\t// x12 = _cmd &amp; mask</div><div class=\"line\">\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)</div><div class=\"line\">\t\t             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket 没有命中</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// wrap: p12 = first bucket, w11 = mask</div><div class=\"line\">\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class=\"line\">\t\t                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class=\"line\"></div><div class=\"line\">\t// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class=\"line\">\t// The slow path may detect any corruption and halt later.</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// double wrap</div><div class=\"line\">\tJumpMiss $0</div><div class=\"line\">\t</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CheckMiss</div><div class=\"line\">\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">.if $0 == GETIMP</div><div class=\"line\">\tcbz\tp9, LGetImpMiss</div><div class=\"line\">.elseif $0 == NORMAL</div><div class=\"line\">\tcbz\tp9, __objc_msgSend_uncached</div><div class=\"line\">.elseif $0 == LOOKUP</div><div class=\"line\">\tcbz\tp9, __objc_msgLookup_uncached</div><div class=\"line\">.else</div><div class=\"line\">.abort oops</div><div class=\"line\">.endif</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">STATIC_ENTRY __objc_msgSend_uncached</div><div class=\"line\">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class=\"line\">MethodTableLookup</div><div class=\"line\">TailCallFunctionPointer x17</div><div class=\"line\">END_ENTRY __objc_msgSend_uncached</div></pre></td></tr></table></figure>\n<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro MethodTableLookup</div><div class=\"line\">\t// push frame</div><div class=\"line\">\tSignLR</div><div class=\"line\">\tstp\tfp, lr, [sp, #-16]!</div><div class=\"line\">\tmov\tfp, sp</div><div class=\"line\"></div><div class=\"line\">\t// save parameter registers: x0..x8, q0..q7</div><div class=\"line\">\tsub\tsp, sp, #(10*8 + 8*16)</div><div class=\"line\">\tstp\tq0, q1, [sp, #(0*16)]</div><div class=\"line\">\tstp\tq2, q3, [sp, #(2*16)]</div><div class=\"line\">\tstp\tq4, q5, [sp, #(4*16)]</div><div class=\"line\">\tstp\tq6, q7, [sp, #(6*16)]</div><div class=\"line\">\tstp\tx0, x1, [sp, #(8*16+0*8)]</div><div class=\"line\">\tstp\tx2, x3, [sp, #(8*16+2*8)]</div><div class=\"line\">\tstp\tx4, x5, [sp, #(8*16+4*8)]</div><div class=\"line\">\tstp\tx6, x7, [sp, #(8*16+6*8)]</div><div class=\"line\">\tstr\tx8,     [sp, #(8*16+8*8)]</div><div class=\"line\"></div><div class=\"line\">\t// receiver and selector already in x0 and x1</div><div class=\"line\">\tmov\tx2, x16</div><div class=\"line\">\tbl\t__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class=\"line\"></div><div class=\"line\">\t// IMP in x0</div><div class=\"line\">\tmov\tx17, x0</div><div class=\"line\">\t</div><div class=\"line\">\t// restore registers and return</div><div class=\"line\">\tldp\tq0, q1, [sp, #(0*16)]</div><div class=\"line\">\tldp\tq2, q3, [sp, #(2*16)]</div><div class=\"line\">\tldp\tq4, q5, [sp, #(4*16)]</div><div class=\"line\">\tldp\tq6, q7, [sp, #(6*16)]</div><div class=\"line\">\tldp\tx0, x1, [sp, #(8*16+0*8)]</div><div class=\"line\">\tldp\tx2, x3, [sp, #(8*16+2*8)]</div><div class=\"line\">\tldp\tx4, x5, [sp, #(8*16+4*8)]</div><div class=\"line\">\tldp\tx6, x7, [sp, #(8*16+6*8)]</div><div class=\"line\">\tldr\tx8,     [sp, #(8*16+8*8)]</div><div class=\"line\"></div><div class=\"line\">\tmov\tsp, fp</div><div class=\"line\">\tldp\tfp, lr, [sp], #16</div><div class=\"line\">\tAuthenticateLR</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, \n                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* lookUpImpOrForward.</div><div class=\"line\">* initialize==NO 尽量避免调用，有时可能也会调用。</div><div class=\"line\">* cache==NO 跳过缓存查找，其他地方可能会不调过</div><div class=\"line\">* 大多数人会传值 initialize==YES and cache==YES</div><div class=\"line\">*   如果cls是非初始化的元类，则非Non-nil会快点</div><div class=\"line\">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class=\"line\">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class=\"line\">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class=\"line\">                       bool initialize, bool cache, bool resolver)</div><div class=\"line\">&#123;</div><div class=\"line\">    IMP imp = nil;</div><div class=\"line\">    bool triedResolver = NO;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.assertUnlocked();</div><div class=\"line\">    // Optimistic cache lookup</div><div class=\"line\">    if (cache) &#123; //从汇编过来是NO</div><div class=\"line\">        imp = cache_getImp(cls, sel);</div><div class=\"line\">        if (imp) return imp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.lock();</div><div class=\"line\">    checkIsKnownClass(cls);</div><div class=\"line\"></div><div class=\"line\">    if (!cls-&gt;isRealized()) &#123;</div><div class=\"line\">        realizeClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class=\"line\">\t\t//当cls需要初始化和没有初始化的时候 进行cls初始化，</div><div class=\"line\">\t\t//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</div><div class=\"line\">\t\t//数据的大小最小是4，扩容规则是：n*2+1;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    </div><div class=\"line\"> retry:    </div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">//再次获取imp</div><div class=\"line\">    imp = cache_getImp(cls, sel);</div><div class=\"line\">    if (imp) goto done;</div><div class=\"line\"></div><div class=\"line\">    //尝试在本类中查找method</div><div class=\"line\">    &#123;//从cls-&gt;data()-&gt;methods查找method</div><div class=\"line\">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class=\"line\">        if (meth) &#123;//找到添加到cache中</div><div class=\"line\">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class=\"line\">            imp = meth-&gt;imp;</div><div class=\"line\">            goto done;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Try superclass caches and method lists.</div><div class=\"line\">\t//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</div><div class=\"line\">    &#123;</div><div class=\"line\">        unsigned attempts = unreasonableClassCount();</div><div class=\"line\">        for (Class curClass = cls-&gt;superclass;</div><div class=\"line\">             curClass != nil;</div><div class=\"line\">             curClass = curClass-&gt;superclass)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Halt if there is a cycle in the superclass chain.</div><div class=\"line\">            if (--attempts == 0) &#123;</div><div class=\"line\">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass cache.</div><div class=\"line\">            imp = cache_getImp(curClass, sel);</div><div class=\"line\">            if (imp) &#123;</div><div class=\"line\">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class=\"line\">                    // Found the method in a superclass. Cache it in this class.</div><div class=\"line\">\t\t\t\t\t//将父类添加到 子类的缓存中</div><div class=\"line\">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class=\"line\">                    goto done;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    // Found a forward:: entry in a superclass.</div><div class=\"line\">                    // Stop searching, but don&apos;t cache yet; call method </div><div class=\"line\">                    // resolver for this class first.</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass method list.</div><div class=\"line\">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class=\"line\">            if (meth) &#123;</div><div class=\"line\">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class=\"line\">                imp = meth-&gt;imp;</div><div class=\"line\">                goto done;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//如果还没有找到imp，进入动态方法解析阶段</div><div class=\"line\">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_resolveMethod(cls, sel, inst);</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">        triedResolver = YES;</div><div class=\"line\">        goto retry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //如果没找到resolveInstanceMethod 和resolveClassMethod，</div><div class=\"line\">//\t进行消息转发 阶段</div><div class=\"line\">    imp = (IMP)_objc_msgForward_impcache;</div><div class=\"line\">\t//填充 cache</div><div class=\"line\">    cache_fill(cls, sel, imp, inst);</div><div class=\"line\"> done:</div><div class=\"line\">    runtimeLock.unlock();</div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </div><div class=\"line\">// field as an index into a class table.</div><div class=\"line\">// Note, keep this in sync with any .s files which also define it.</div><div class=\"line\">// Be sure to edit objc-abi.h as well.</div><div class=\"line\">// __ARM_ARCH_7K__ 处理器架构指令集版本</div><div class=\"line\">//__arm64__ 架构</div><div class=\"line\">//__LP64__ uinx 和uinx  mac os</div><div class=\"line\">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</div><div class=\"line\">#   define SUPPORT_INDEXED_ISA 1</div><div class=\"line\">#else</div><div class=\"line\">#   define SUPPORT_INDEXED_ISA 0</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>\n<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>\n<p>借用网上找一个图， 可以更直观的看出流程运转。</p>\n<p><img src=\"../images/7-1.png\" alt=\"\"></p>\n<h4 id=\"realizeClass-解析\"><a href=\"#realizeClass-解析\" class=\"headerlink\" title=\"realizeClass()解析\"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));\n    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* realizeClass</div><div class=\"line\"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</div><div class=\"line\"> runtimelock 必须有调用者把写入锁锁起来</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static Class realizeClass(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    class_rw_t *rw;</div><div class=\"line\">    Class supercls;</div><div class=\"line\">    Class metacls;</div><div class=\"line\">    bool isMeta;</div><div class=\"line\"></div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    if (cls-&gt;isRealized()) return cls;</div><div class=\"line\">    assert(cls == remapClass(cls));</div><div class=\"line\"></div><div class=\"line\">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class=\"line\">//首先将tw赋值给to，因为数据结构一样可以直接强制转化</div><div class=\"line\">    ro = (const class_ro_t *)cls-&gt;data();</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</div><div class=\"line\">        rw = cls-&gt;data();</div><div class=\"line\">        ro = cls-&gt;data()-&gt;ro;</div><div class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // 正常情况下 申请class_rw_t空间</div><div class=\"line\">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class=\"line\">        rw-&gt;ro = ro;//cls-&gt;rw-&gt;ro 指向现在的ro</div><div class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1</div><div class=\"line\">        cls-&gt;setData(rw);//赋值</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    isMeta = ro-&gt;flags &amp; RO_META;//是否是元类</div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">    rw-&gt;version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    // Choose an index for this class.</div><div class=\"line\">//设置cls的索引</div><div class=\"line\">\tcls-&gt;chooseClassArrayIndex();</div><div class=\"line\"></div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        _objc_inform(&quot;CLASS: realizing class &apos;%s&apos;%s %p %p #%u&quot;, </div><div class=\"line\">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </div><div class=\"line\">                     (void*)cls, ro, cls-&gt;classArrayIndex());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 如果父类没有初始化则进行初始化</div><div class=\"line\">    // root_class 做完需要设置RW_REALIZED=1，</div><div class=\"line\">    // root metaclasses 需要执行完.</div><div class=\"line\">\t//从NXMapTable 获取cls ，然后进行初始化</div><div class=\"line\">\t//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</div><div class=\"line\">    supercls = realizeClass(remapClass(cls-&gt;superclass));</div><div class=\"line\">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</div><div class=\"line\">//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。</div><div class=\"line\">#if SUPPORT_NONPOINTER_ISA</div><div class=\"line\">    // Disable non-pointer isa for some classes and/or platforms.</div><div class=\"line\">    // Set instancesRequireRawIsa.</div><div class=\"line\">    bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</div><div class=\"line\">    bool rawIsaIsInherited = false;</div><div class=\"line\">    static bool hackedDispatch = false;</div><div class=\"line\"></div><div class=\"line\">    if (DisableNonpointerIsa) &#123;</div><div class=\"line\">        // Non-pointer isa disabled by environment or app SDK version</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </div><div class=\"line\">             0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // hack for libdispatch et al - isa also acts as vtable pointer</div><div class=\"line\">        hackedDispatch = true;</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </div><div class=\"line\">             supercls-&gt;instancesRequireRawIsa()) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // This is also propagated by addSubclass() </div><div class=\"line\">        // but nonpointer isa setup needs it earlier.</div><div class=\"line\">        // Special case: instancesRequireRawIsa does not propagate </div><div class=\"line\">        // from root class to root metaclass</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">        rawIsaIsInherited = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (instancesRequireRawIsa) &#123;</div><div class=\"line\">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</div><div class=\"line\">    &#125;</div><div class=\"line\">// SUPPORT_NONPOINTER_ISA</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    // Update superclass and metaclass in case of remapping</div><div class=\"line\">    cls-&gt;superclass = supercls;</div><div class=\"line\">    cls-&gt;initClassIsa(metacls);</div><div class=\"line\"></div><div class=\"line\">\t// 协调实例变量偏移/布局</div><div class=\"line\">\t//可能重新申请空间 class_ro_t,更新我们的class_ro_t</div><div class=\"line\">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</div><div class=\"line\"></div><div class=\"line\">    // 设置setInstanceSize 从ro-&gt;instanceSize</div><div class=\"line\">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</div><div class=\"line\"></div><div class=\"line\">\t//拷贝flags 从ro到rw中</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</div><div class=\"line\">        cls-&gt;setHasCxxDtor();</div><div class=\"line\">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</div><div class=\"line\">            cls-&gt;setHasCxxCtor();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//添加superclass指针</div><div class=\"line\">    if (supercls) &#123;</div><div class=\"line\">        addSubclass(supercls, cls);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        addRootClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Attach categories</div><div class=\"line\">\t//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</div><div class=\"line\">    methodizeClass(cls);</div><div class=\"line\"></div><div class=\"line\">    return cls;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* methodizeClass</div><div class=\"line\"> 修复cls方法列表想，协议列表和属性列表</div><div class=\"line\">* 加锁</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static void methodizeClass(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\">    auto ro = rw-&gt;ro;</div><div class=\"line\"></div><div class=\"line\">    // Methodizing for the first time</div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        _objc_inform(&quot;CLASS: methodizing class &apos;%s&apos; %s&quot;, </div><div class=\"line\">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//方法列表</div><div class=\"line\">    method_list_t *list = ro-&gt;baseMethods();</div><div class=\"line\">    if (list) &#123;</div><div class=\"line\">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</div><div class=\"line\">\t//将对象的方法追加到cls-&gt;rw-&gt;methods后面</div><div class=\"line\">        rw-&gt;methods.attachLists(&amp;list, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class=\"line\">    if (proplist) &#123;</div><div class=\"line\">\t//将对象的属性追加到rw-&gt;properties后面</div><div class=\"line\">        rw-&gt;properties.attachLists(&amp;proplist, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class=\"line\">    if (protolist) &#123;</div><div class=\"line\">\t//将对象的协议追加到rw-&gt;protocols后面</div><div class=\"line\">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Root classes get bonus method implementations if they don&apos;t have </div><div class=\"line\">    // them already. These apply before category replacements.</div><div class=\"line\">    if (cls-&gt;isRootMetaclass()) &#123;</div><div class=\"line\">        // root metaclass</div><div class=\"line\">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Attach categories.</div><div class=\"line\">\t//类别 从全局NXMapTable *category_map 已经加载过了。</div><div class=\"line\">    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);</div><div class=\"line\">\t//收集所有的cats到cls -&gt; rw中</div><div class=\"line\">    attachCategories(cls, cats, false /*don&apos;t flush caches*/);</div><div class=\"line\"></div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        if (cats) &#123;</div><div class=\"line\">            for (uint32_t i = 0; i &lt; cats-&gt;count; i++) &#123;</div><div class=\"line\">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </div><div class=\"line\">                             isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (cats) free(cats);//释放cats</div><div class=\"line\"></div><div class=\"line\">#if DEBUG</div><div class=\"line\">    // Debug: sanity-check all SELs; log method list contents</div><div class=\"line\">    for (const auto&amp; meth : rw-&gt;methods) &#123;</div><div class=\"line\">        if (PrintConnecting) &#123;</div><div class=\"line\">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</div><div class=\"line\">        &#125;</div><div class=\"line\">        assert(sel_registerName(sel_getName(meth.name)) == meth.name); </div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"attachCategories-解析\"><a href=\"#attachCategories-解析\" class=\"headerlink\" title=\"attachCategories()解析\"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    // fixme rearrange to remove these intermediate allocations</div><div class=\"line\">\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\">\t//属性数组</div><div class=\"line\">    property_list_t **proplists = (property_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class=\"line\">\t//协议数组</div><div class=\"line\">    protocol_list_t **protolists = (protocol_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int propcount = 0;</div><div class=\"line\">    int protocount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    bool fromBundle = NO;</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">\t\t//取出某个分类</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\">//取出分类 的 instance方法或者class方法</div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有分类属性</div><div class=\"line\">        property_list_t *proplist = </div><div class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class=\"line\">        if (proplist) &#123;</div><div class=\"line\">            proplists[propcount++] = proplist;</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有协议方法</div><div class=\"line\">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class=\"line\">        if (protolist) &#123;</div><div class=\"line\">            protolists[protocount++] = protolist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//收集了所有协议 分类方法</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class=\"line\">\t//追加所有分类方法</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">\t//释放数组</div><div class=\"line\">    free(mlists);</div><div class=\"line\">\t//刷新该类的缓存</div><div class=\"line\">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class=\"line\">//追加所有分类属性</div><div class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class=\"line\">    free(proplists);//释放数组</div><div class=\"line\">//追加所有分类协议</div><div class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class=\"line\">    free(protolists);//释放数组</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"rw-gt-list-gt-attachLists-解析\"><a href=\"#rw-gt-list-gt-attachLists-解析\" class=\"headerlink\" title=\"rw-&gt;list-&gt;attachLists()解析\"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">       if (addedCount == 0) return;</div><div class=\"line\"></div><div class=\"line\">       if (hasArray()) &#123;</div><div class=\"line\">           // many lists -&gt; many lists</div><div class=\"line\">           uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">\t\t//一共需要的数量</div><div class=\"line\">           uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">\t\t//分配内存 内存不够用了，需要扩容</div><div class=\"line\">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">\t\t//赋值count</div><div class=\"line\">           array()-&gt;count = newCount;</div><div class=\"line\">\t\t// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class=\"line\">           memmove(array()-&gt;lists + addedCount/*数组末尾*/, array()-&gt;lists/*数组*/,</div><div class=\"line\">                   oldCount * sizeof(array()-&gt;lists[0])/*移动的大小*/);</div><div class=\"line\">\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class=\"line\">           memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">\t\t/*</div><div class=\"line\">\t\t图示讲解：</div><div class=\"line\">\t\tarray()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\taddedCount:3</div><div class=\"line\">\taddedLists:P-&gt;L-&gt;V</div><div class=\"line\">\t\tmemmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class=\"line\">\t\tP-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t */</div><div class=\"line\">       &#125;</div><div class=\"line\">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class=\"line\">           // 0 lists -&gt; 1 list</div><div class=\"line\">           list = addedLists[0];</div><div class=\"line\">       &#125; </div><div class=\"line\">       else &#123;</div><div class=\"line\">           // 1 list -&gt; many lists</div><div class=\"line\">           List* oldList = list;</div><div class=\"line\">           uint32_t oldCount = oldList ? 1 : 0;</div><div class=\"line\">           uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class=\"line\">           array()-&gt;count = newCount;</div><div class=\"line\">           if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class=\"line\">           memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>\n<h3 id=\"消息动态解析\"><a href=\"#消息动态解析\" class=\"headerlink\" title=\"消息动态解析\"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* _class_resolveMethod</div><div class=\"line\">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</div><div class=\"line\">* 如果存在了则不检查</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">void _class_resolveMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (! cls-&gt;isMetaClass()) &#123;//不是元类则调用 实例的</div><div class=\"line\">\t//首先调用</div><div class=\"line\">\t\t_class_resolveInstanceMethod(cls, sel, inst);</div><div class=\"line\">    &#125; </div><div class=\"line\">    else &#123;</div><div class=\"line\">        // try [nonMetaClass resolveClassMethod:sel]</div><div class=\"line\">        // and [cls resolveInstanceMethod:sel]</div><div class=\"line\">\t\t//寻找classMethod</div><div class=\"line\">        _class_resolveClassMethod(cls, sel, inst);</div><div class=\"line\">        if (!lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">        &#123;</div><div class=\"line\">            _class_resolveInstanceMethod(cls, sel, inst);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* _class_resolveInstanceMethod</div><div class=\"line\">* 调用 class添加的函数 +resolveInstanceMethod</div><div class=\"line\">* 有可能是元类</div><div class=\"line\">* 如果方法存在则不检查</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </div><div class=\"line\">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // Resolver not implemented.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</div><div class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class=\"line\">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</div><div class=\"line\"></div><div class=\"line\">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class=\"line\">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class=\"line\">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class=\"line\"></div><div class=\"line\">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class=\"line\">        if (imp) &#123;</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class=\"line\">                         &quot;dynamically resolved to %p&quot;, </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Method resolver didn&apos;t add anything?</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</div><div class=\"line\">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(cls-&gt;isMetaClass());</div><div class=\"line\"></div><div class=\"line\">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </div><div class=\"line\">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // Resolver not implemented.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class=\"line\">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </div><div class=\"line\">                        SEL_resolveClassMethod, sel);</div><div class=\"line\"></div><div class=\"line\">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class=\"line\">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class=\"line\">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class=\"line\"></div><div class=\"line\">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class=\"line\">        if (imp) &#123;</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class=\"line\">                         &quot;dynamically resolved to %p&quot;, </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Method resolver didn&apos;t add anything?</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</div><div class=\"line\">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>动态解析至此完成。</p>\n<h3 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">STATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache</div><div class=\"line\">\t// No stret specialization.</div><div class=\"line\">\tb\t__objc_msgForward//跳转-&gt;__objc_msgForward</div><div class=\"line\">\tEND_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">\tENTRY __objc_msgForward // 开始 __objc_msgForward</div><div class=\"line\"></div><div class=\"line\">\tadrp\tx17, __objc_forward_handler@PAGE</div><div class=\"line\">\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和</div><div class=\"line\">\tTailCallFunctionPointer x17 //跳转-&gt; TailCallFunctionPointer</div><div class=\"line\"></div><div class=\"line\">\tEND_ENTRY __objc_msgForward//结束 __objc_msgForward</div></pre></td></tr></table></figure>\n<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">__attribute__((noreturn)) void </div><div class=\"line\">objc_defaultForwardHandler(id self, SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class=\"line\">                &quot;(no message forward handler is installed)&quot;, </div><div class=\"line\">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                object_getClassName(self), sel_getName(sel), self);</div><div class=\"line\">&#125;</div><div class=\"line\">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>\n<p>网上有大神总结的点我们先参考下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 伪代码</div><div class=\"line\">int __forwarding__(void *frameStackPointer, int isStret) &#123;</div><div class=\"line\">    id receiver = *(id *)frameStackPointer;</div><div class=\"line\">    SEL sel = *(SEL *)(frameStackPointer + 8);</div><div class=\"line\">    const char *selName = sel_getName(sel);</div><div class=\"line\">    Class receiverClass = object_getClass(receiver);</div><div class=\"line\"></div><div class=\"line\">    // 调用 forwardingTargetForSelector:</div><div class=\"line\">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</div><div class=\"line\">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</div><div class=\"line\">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</div><div class=\"line\">            if (isStret == 1) &#123;</div><div class=\"line\">                int ret;</div><div class=\"line\">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</div><div class=\"line\">                return ret;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return objc_msgSend(forwardingTarget, sel, ...);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 僵尸对象</div><div class=\"line\">    const char *className = class_getName(receiverClass);</div><div class=\"line\">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</div><div class=\"line\">    size_t prefixLen = strlen(zombiePrefix); // 0xa</div><div class=\"line\">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</div><div class=\"line\">        CFLog(kCFLogLevelError,</div><div class=\"line\">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</div><div class=\"line\">              className + prefixLen,</div><div class=\"line\">              selName,</div><div class=\"line\">              receiver);</div><div class=\"line\">        &lt;breakpoint-interrupt&gt;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</div><div class=\"line\">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</div><div class=\"line\">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</div><div class=\"line\">        if (methodSignature) &#123;</div><div class=\"line\">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</div><div class=\"line\">            if (signatureIsStret != isStret) &#123;</div><div class=\"line\">                CFLog(kCFLogLevelWarning ,</div><div class=\"line\">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</div><div class=\"line\">                      selName,</div><div class=\"line\">                      signatureIsStret ? &quot;&quot; : not,</div><div class=\"line\">                      isStret ? &quot;&quot; : not);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</div><div class=\"line\">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</div><div class=\"line\"></div><div class=\"line\">                [receiver forwardInvocation:invocation];</div><div class=\"line\"></div><div class=\"line\">                void *returnValue = NULL;</div><div class=\"line\">                [invocation getReturnValue:&amp;value];</div><div class=\"line\">                return returnValue;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                CFLog(kCFLogLevelWarning ,</div><div class=\"line\">                      @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;,</div><div class=\"line\">                      receiver,</div><div class=\"line\">                      className);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SEL *registeredSel = sel_getUid(selName);</div><div class=\"line\"></div><div class=\"line\">    // selector 是否已经在 Runtime 注册过</div><div class=\"line\">    if (sel != registeredSel) &#123;</div><div class=\"line\">        CFLog(kCFLogLevelWarning ,</div><div class=\"line\">              @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;,</div><div class=\"line\">              sel,</div><div class=\"line\">              selName,</div><div class=\"line\">              registeredSel);</div><div class=\"line\">    &#125; // doesNotRecognizeSelector</div><div class=\"line\">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</div><div class=\"line\">        [receiver doesNotRecognizeSelector:sel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        CFLog(kCFLogLevelWarning ,</div><div class=\"line\">              @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement doesNotRecognizeSelector: -- abort&quot;,</div><div class=\"line\">              receiver,</div><div class=\"line\">              className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The point of no return.</div><div class=\"line\">    kill(getpid(), 9);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"验证动态解析\"><a href=\"#验证动态解析\" class=\"headerlink\" title=\"验证动态解析\"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tif (sel == @selector(test)) &#123;</div><div class=\"line\">\t\tMethod me = class_getInstanceMethod(self, @selector(test2));</div><div class=\"line\">\t\tclass_addMethod(self, sel,</div><div class=\"line\">\t\t\t\t\t\tmethod_getImplementation(me),</div><div class=\"line\">\t\t\t\t\t\tmethod_getTypeEncoding(me));</div><div class=\"line\">\t\treturn YES;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)test2&#123;</div><div class=\"line\">\tNSLog(@&quot;来了，老弟&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">Person *p = [[Person alloc]init];</div><div class=\"line\">[p test];</div><div class=\"line\">[p test];</div><div class=\"line\"> //输出</div><div class=\"line\">+[FYPerson resolveInstanceMethod:]</div><div class=\"line\"> -[FYPerson test3]</div><div class=\"line\"> -[FYPerson test3]</div></pre></td></tr></table></figure>\n<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>\n<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">+ (void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">+ (void)test3&#123;</div><div class=\"line\">\tNSLog(@&quot;来了，老弟&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tif (sel == @selector(test)) &#123;</div><div class=\"line\">\t\tMethod me = class_getClassMethod(self, @selector(test3));//获取method</div><div class=\"line\">\t\t//给sel 添加方法实现 @selecter(test3)</div><div class=\"line\">\t\tclass_addMethod(object_getClass(self), sel,</div><div class=\"line\">\t\t\t\t\t\tmethod_getImplementation(me),</div><div class=\"line\">\t\t\t\t\t\tmethod_getTypeEncoding(me));</div><div class=\"line\">\t\treturn YES;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[Person test];</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[Person resolveClassMethod:]</div><div class=\"line\">来了，老弟</div></pre></td></tr></table></figure>\n<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">    if (sel == @selector(test)) &#123;</div><div class=\"line\">//        Method me = class_getInstanceMethod(self, @selector(test3));</div><div class=\"line\">//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</div><div class=\"line\">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">void test3(id self,SEL sel)&#123;</div><div class=\"line\">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[FYPerson resolveInstanceMethod:]</div><div class=\"line\">test3:test</div><div class=\"line\">test3:test</div></pre></td></tr></table></figure>\n<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>\n<h3 id=\"验证消息转发\"><a href=\"#验证消息转发\" class=\"headerlink\" title=\"验证消息转发\"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;Person.h&quot;</div><div class=\"line\">#import &quot;Student.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation Person</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [[Struent alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//输出</div><div class=\"line\">-[Student test]</div></pre></td></tr></table></figure>\n<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>\n<p>第一步没拦截，可以在第二步拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//消息转发第二步 没有对象来处理方法，那将函数签名来实现</div><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (aSelector == @selector(test)) &#123;</div><div class=\"line\">\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class=\"line\">\t\treturn sign;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super methodSignatureForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">// 函数签名已返回，到了函数调用的地方</div><div class=\"line\">//selector 函数的sel</div><div class=\"line\">//target   函数调用者</div><div class=\"line\">//methodSignature 函数签名</div><div class=\"line\">//NSInvocation  封装数据的对象</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">-[Person forwardInvocation:]</div></pre></td></tr></table></figure></p>\n<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (readonly, retain) NSMethodSignature *methodSignature;//只读</div><div class=\"line\">- (void)retainArguments;</div><div class=\"line\">@property (readonly) BOOL argumentsRetained;</div><div class=\"line\">@property (nullable, assign) id target;//读写</div><div class=\"line\">@property SEL selector;//读写</div></pre></td></tr></table></figure>\n<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">//class 转发</div><div class=\"line\">// 消息转发第一步 拦截是否有转发的class对象处理方法</div><div class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [Student class];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (void)test3&#123;</div><div class=\"line\">//\tNSLog(@&quot;+[Student test3]&quot;);</div><div class=\"line\">//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错</div><div class=\"line\">//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</div><div class=\"line\">//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 输出</div><div class=\"line\">-[Student test2]</div></pre></td></tr></table></figure>\n<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [[Student alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)test3&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">-[Student test3]</div></pre></td></tr></table></figure>\n<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">//消息转发第二步 没有class来处理方法，那将函数签名来实现</div><div class=\"line\">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class=\"line\">\t\treturn sign;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super methodSignatureForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">// 函数签名已返回，到了函数调用的地方</div><div class=\"line\">//selector 函数的sel</div><div class=\"line\">//target   函数调用者</div><div class=\"line\">//methodSignature 函数签名</div><div class=\"line\">//NSInvocation  封装数据的对象</div><div class=\"line\">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class=\"line\">//\tanInvocation.selector = @selector(test2);</div><div class=\"line\">//此处换成[Student class]同样可以</div><div class=\"line\">//\tanInvocation.target = (id)[[Student alloc]init];</div><div class=\"line\"></div><div class=\"line\">//\t[anInvocation invoke];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[Person forwardInvocation:]</div></pre></td></tr></table></figure>\n<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>\n<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>\n<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>\n<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>\n<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></li>\n</ul>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>arm64之后isa是使用联合体使用更少的空间存储更多的数据，以及如何自定义和使用联合体，<code>objc_class-&gt;cache_t cache</code>是一个是缓存最近调用<code>class</code>的方法，当缓存剩余空间小余1/4则进行扩容，扩容为原来的两倍，扩容之后，已存储的<code>method_t</code>扩容之后之后被清空。今天我们在了解runtime的消息转发机制。</p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p>\n<p>objc_msgSend的执行流程可以分为3大阶段</p>\n<ol>\n<li>消息发送</li>\n<li>动态方法解析</li>\n<li>消息转发</li>\n</ol>\n<p>那么我们根据这三块内容进行源码解读。源码执行的顺序大概如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc-msg-arm64.s</div><div class=\"line\">ENTRY _objc_msgSend</div><div class=\"line\">b.le\tLNilOrTagged //&lt;0则返回</div><div class=\"line\">CacheLookup NORMAL //缓存查找 未命中则继续查找</div><div class=\"line\">.macro CacheLookup// 通过宏 查找cache，命中直接call or return imp</div><div class=\"line\">.macro CheckMiss //miss 则跳转__objc_msgSend_uncached</div><div class=\"line\">STATIC_ENTRY __objc_msgSend_uncached </div><div class=\"line\">.macro MethodTableLookup//方法中查找</div><div class=\"line\">__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc-runtime-new.mm</div><div class=\"line\">_class_lookupMethodAndLoadCache3</div><div class=\"line\">lookUpImpOrForward</div><div class=\"line\">getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</div><div class=\"line\">cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</div><div class=\"line\">_class_resolveInstanceMethod</div><div class=\"line\">_objc_msgForward_impcache</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc-msg-arm64.s</div><div class=\"line\">STATIC_ENTRY __objc_msgForward_impcache</div><div class=\"line\">ENTRY __objc_msgForward</div><div class=\"line\"></div><div class=\"line\">Core Foundation</div><div class=\"line\">__forwarding__（不开源）</div></pre></td></tr></table></figure>\n<h3 id=\"消息发送\"><a href=\"#消息发送\" class=\"headerlink\" title=\"消息发送\"></a>消息发送</h3><p><code>objc_msgSend</code>是汇编写的，在源码<code>objc-msg-arm64.s</code>304行，是<code>objc_msgSend</code>的开始，<code>_objc_msgSend</code>结束是351行,<br>进入到<code>objc_msgSend</code>函数内部一探究竟：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tENTRY _objc_msgSend // _objc_msgSend 开始</div><div class=\"line\">\tUNWIND _objc_msgSend, NoFrame</div><div class=\"line\"></div><div class=\"line\">\tcmp\tp0, #0\t\t\t// 检查p0寄存器是否是0  _objc_msgSend()第一个参数:self</div><div class=\"line\">#if SUPPORT_TAGGED_POINTERS</div><div class=\"line\">\tb.le\tLNilOrTagged\t\t// if le &lt; 0 -&gt;  跳转到标签  LNilOrTagged</div><div class=\"line\">#else</div><div class=\"line\">\tb.eq\tLReturnZero // if le == 0 -&gt;  跳转到标签  LReturnZero</div><div class=\"line\">#endif</div><div class=\"line\">\tldr\tp13, [x0]\t\t// p13 = isa</div><div class=\"line\">\tGetClassFromIsa_p16 p13\t\t// p16 = class</div><div class=\"line\">LGetIsaDone:</div><div class=\"line\">\tCacheLookup NORMAL\t\t// calls imp or objc_msgSend_uncached</div><div class=\"line\"></div><div class=\"line\">#if SUPPORT_TAGGED_POINTERS</div><div class=\"line\">LNilOrTagged:</div><div class=\"line\">\tb.eq\tLReturnZero\t\t// 如果==0 -&gt; LReturnZero</div><div class=\"line\"></div><div class=\"line\">\t// tagged</div><div class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE</div><div class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</div><div class=\"line\">\tubfx\tx11, x0, #60, #4</div><div class=\"line\">\tldr\tx16, [x10, x11, LSL #3]</div><div class=\"line\">\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</div><div class=\"line\">\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</div><div class=\"line\">\tcmp\tx10, x16</div><div class=\"line\">\tb.ne\tLGetIsaDone</div><div class=\"line\"></div><div class=\"line\">\t// ext tagged</div><div class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE</div><div class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</div><div class=\"line\">\tubfx\tx11, x0, #52, #8</div><div class=\"line\">\tldr\tx16, [x10, x11, LSL #3]</div><div class=\"line\">\tb\tLGetIsaDone</div><div class=\"line\">// SUPPORT_TAGGED_POINTERS</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">LReturnZero:</div><div class=\"line\">\t// x0 is already zero</div><div class=\"line\">\tmov\tx1, #0</div><div class=\"line\">\tmovi\td0, #0</div><div class=\"line\">\tmovi\td1, #0</div><div class=\"line\">\tmovi\td2, #0</div><div class=\"line\">\tmovi\td3, #0</div><div class=\"line\">\tret //return 返回结束掉</div><div class=\"line\"></div><div class=\"line\">\tEND_ENTRY _objc_msgSend // _objc_msgSend 结束</div></pre></td></tr></table></figure>\n<p>当<code>objc_msgSend(id,SEL,arg)</code>的<code>id</code>为空的时候，跳转标签<code>LNilOrTagged</code>,进入标签内，当等于0则跳转<code>LReturnZero</code>,进入到<code>LReturnZero</code>内，清除数据和return。不等于零，获取isa和class，调用<code>CacheLookup NORMAL</code>,进入到<code>CacheLookup</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CacheLookup //.macro 是一个宏 使用 _cmd&amp;mask 查找缓存中的方法</div><div class=\"line\">\t// p1 = SEL, p16 = isa</div><div class=\"line\">\tldp\tp10, p11, [x16, #CACHE]\t// p10 = buckets, p11 = occupied|mask</div><div class=\"line\">#if !__LP64__</div><div class=\"line\">\tand\tw11, w11, 0xffff\t// p11 = mask</div><div class=\"line\">#endif</div><div class=\"line\">\tand\tw12, w1, w11\t\t// x12 = _cmd &amp; mask</div><div class=\"line\">\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)</div><div class=\"line\">\t\t             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp 命中 调用或者返回imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket 没有命中</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// wrap: p12 = first bucket, w11 = mask</div><div class=\"line\">\tadd\tp12, p12, w11, UXTW #(1+PTRSHIFT)</div><div class=\"line\">\t\t                        // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</div><div class=\"line\"></div><div class=\"line\">\t// Clone scanning loop to miss instead of hang when cache is corrupt.</div><div class=\"line\">\t// The slow path may detect any corruption and halt later.</div><div class=\"line\"></div><div class=\"line\">\tldp\tp17, p9, [x12]\t\t// &#123;imp, sel&#125; = *bucket</div><div class=\"line\">1:\tcmp\tp9, p1\t\t\t// if (bucket-&gt;sel != _cmd)</div><div class=\"line\">\tb.ne\t2f\t\t\t//     scan more</div><div class=\"line\">\tCacheHit $0\t\t\t// call or return imp</div><div class=\"line\">\t</div><div class=\"line\">2:\t// not hit: p12 = not-hit bucket</div><div class=\"line\">\tCheckMiss $0\t\t\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">\tcmp\tp12, p10\t\t// wrap if bucket == buckets</div><div class=\"line\">\tb.eq\t3f</div><div class=\"line\">\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</div><div class=\"line\">\tb\t1b\t\t\t// loop</div><div class=\"line\"></div><div class=\"line\">3:\t// double wrap</div><div class=\"line\">\tJumpMiss $0</div><div class=\"line\">\t</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>汇编代码左边是代码，右边是注释，大概都可以看懂的。<br>当命中则<code>return imp</code>,否则则跳转<code>CheckMiss</code>,进入到<code>CheckMiss</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro CheckMiss</div><div class=\"line\">\t// miss if bucket-&gt;sel == 0</div><div class=\"line\">.if $0 == GETIMP</div><div class=\"line\">\tcbz\tp9, LGetImpMiss</div><div class=\"line\">.elseif $0 == NORMAL</div><div class=\"line\">\tcbz\tp9, __objc_msgSend_uncached</div><div class=\"line\">.elseif $0 == LOOKUP</div><div class=\"line\">\tcbz\tp9, __objc_msgLookup_uncached</div><div class=\"line\">.else</div><div class=\"line\">.abort oops</div><div class=\"line\">.endif</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>刚才传的值是<code>NORMAL</code>，则跳转<code>__objc_msgSend_uncached</code>，进入到<code>__objc_msgSend_uncached</code>内部(484行)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">STATIC_ENTRY __objc_msgSend_uncached</div><div class=\"line\">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</div><div class=\"line\">MethodTableLookup</div><div class=\"line\">TailCallFunctionPointer x17</div><div class=\"line\">END_ENTRY __objc_msgSend_uncached</div></pre></td></tr></table></figure>\n<p>调用<code>MethodTableLookup</code>,我们查看<code>MethodTableLookup</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">.macro MethodTableLookup</div><div class=\"line\">\t// push frame</div><div class=\"line\">\tSignLR</div><div class=\"line\">\tstp\tfp, lr, [sp, #-16]!</div><div class=\"line\">\tmov\tfp, sp</div><div class=\"line\"></div><div class=\"line\">\t// save parameter registers: x0..x8, q0..q7</div><div class=\"line\">\tsub\tsp, sp, #(10*8 + 8*16)</div><div class=\"line\">\tstp\tq0, q1, [sp, #(0*16)]</div><div class=\"line\">\tstp\tq2, q3, [sp, #(2*16)]</div><div class=\"line\">\tstp\tq4, q5, [sp, #(4*16)]</div><div class=\"line\">\tstp\tq6, q7, [sp, #(6*16)]</div><div class=\"line\">\tstp\tx0, x1, [sp, #(8*16+0*8)]</div><div class=\"line\">\tstp\tx2, x3, [sp, #(8*16+2*8)]</div><div class=\"line\">\tstp\tx4, x5, [sp, #(8*16+4*8)]</div><div class=\"line\">\tstp\tx6, x7, [sp, #(8*16+6*8)]</div><div class=\"line\">\tstr\tx8,     [sp, #(8*16+8*8)]</div><div class=\"line\"></div><div class=\"line\">\t// receiver and selector already in x0 and x1</div><div class=\"line\">\tmov\tx2, x16</div><div class=\"line\">\tbl\t__class_lookupMethodAndLoadCache3//跳转-&gt;__class_lookupMethodAndLoadCache3 在runtime-class-new.mm 4856行</div><div class=\"line\"></div><div class=\"line\">\t// IMP in x0</div><div class=\"line\">\tmov\tx17, x0</div><div class=\"line\">\t</div><div class=\"line\">\t// restore registers and return</div><div class=\"line\">\tldp\tq0, q1, [sp, #(0*16)]</div><div class=\"line\">\tldp\tq2, q3, [sp, #(2*16)]</div><div class=\"line\">\tldp\tq4, q5, [sp, #(4*16)]</div><div class=\"line\">\tldp\tq6, q7, [sp, #(6*16)]</div><div class=\"line\">\tldp\tx0, x1, [sp, #(8*16+0*8)]</div><div class=\"line\">\tldp\tx2, x3, [sp, #(8*16+2*8)]</div><div class=\"line\">\tldp\tx4, x5, [sp, #(8*16+4*8)]</div><div class=\"line\">\tldp\tx6, x7, [sp, #(8*16+6*8)]</div><div class=\"line\">\tldr\tx8,     [sp, #(8*16+8*8)]</div><div class=\"line\"></div><div class=\"line\">\tmov\tsp, fp</div><div class=\"line\">\tldp\tfp, lr, [sp], #16</div><div class=\"line\">\tAuthenticateLR</div><div class=\"line\">.endmacro</div></pre></td></tr></table></figure>\n<p>最终跳转到<code>__class_lookupMethodAndLoadCache3</code>,去掉一个下划线就是c函数，在<code>runtime-class-new.mm 4856行</code>,<br>调用了函数<code>lookUpImpOrForward(cls, sel, obj, \n                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</code>,第一次会初始化<code>cls</code>和<code>resolver</code>的值，<br>中最终跳转到<code>c/c++</code>函数<code>lookUpImpOrForward</code>，该函数是最终能看到的<code>c/c++</code>,现在我们进入到<code>lookUpImpOrForward</code>内部查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* lookUpImpOrForward.</div><div class=\"line\">* initialize==NO 尽量避免调用，有时可能也会调用。</div><div class=\"line\">* cache==NO 跳过缓存查找，其他地方可能会不调过</div><div class=\"line\">* 大多数人会传值 initialize==YES and cache==YES</div><div class=\"line\">*   如果cls是非初始化的元类，则非Non-nil会快点</div><div class=\"line\">* May return _objc_msgForward_impcache. IMPs destined for external use </div><div class=\"line\">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</div><div class=\"line\">* 如果你不想用forwarding，则调用lookUpImpOrNil()代替</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </div><div class=\"line\">                       bool initialize, bool cache, bool resolver)</div><div class=\"line\">&#123;</div><div class=\"line\">    IMP imp = nil;</div><div class=\"line\">    bool triedResolver = NO;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.assertUnlocked();</div><div class=\"line\">    // Optimistic cache lookup</div><div class=\"line\">    if (cache) &#123; //从汇编过来是NO</div><div class=\"line\">        imp = cache_getImp(cls, sel);</div><div class=\"line\">        if (imp) return imp;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runtimeLock.lock();</div><div class=\"line\">    checkIsKnownClass(cls);</div><div class=\"line\"></div><div class=\"line\">    if (!cls-&gt;isRealized()) &#123;</div><div class=\"line\">        realizeClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class=\"line\">\t\t//当cls需要初始化和没有初始化的时候 进行cls初始化，</div><div class=\"line\">\t\t//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</div><div class=\"line\">\t\t//数据的大小最小是4，扩容规则是：n*2+1;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    </div><div class=\"line\"> retry:    </div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">//再次获取imp</div><div class=\"line\">    imp = cache_getImp(cls, sel);</div><div class=\"line\">    if (imp) goto done;</div><div class=\"line\"></div><div class=\"line\">    //尝试在本类中查找method</div><div class=\"line\">    &#123;//从cls-&gt;data()-&gt;methods查找method</div><div class=\"line\">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class=\"line\">        if (meth) &#123;//找到添加到cache中</div><div class=\"line\">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class=\"line\">            imp = meth-&gt;imp;</div><div class=\"line\">            goto done;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Try superclass caches and method lists.</div><div class=\"line\">\t//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</div><div class=\"line\">    &#123;</div><div class=\"line\">        unsigned attempts = unreasonableClassCount();</div><div class=\"line\">        for (Class curClass = cls-&gt;superclass;</div><div class=\"line\">             curClass != nil;</div><div class=\"line\">             curClass = curClass-&gt;superclass)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // Halt if there is a cycle in the superclass chain.</div><div class=\"line\">            if (--attempts == 0) &#123;</div><div class=\"line\">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass cache.</div><div class=\"line\">            imp = cache_getImp(curClass, sel);</div><div class=\"line\">            if (imp) &#123;</div><div class=\"line\">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class=\"line\">                    // Found the method in a superclass. Cache it in this class.</div><div class=\"line\">\t\t\t\t\t//将父类添加到 子类的缓存中</div><div class=\"line\">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class=\"line\">                    goto done;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    // Found a forward:: entry in a superclass.</div><div class=\"line\">                    // Stop searching, but don&apos;t cache yet; call method </div><div class=\"line\">                    // resolver for this class first.</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            // Superclass method list.</div><div class=\"line\">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class=\"line\">            if (meth) &#123;</div><div class=\"line\">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class=\"line\">                imp = meth-&gt;imp;</div><div class=\"line\">                goto done;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//如果还没有找到imp，进入动态方法解析阶段</div><div class=\"line\">    if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class=\"line\">        runtimeLock.unlock();</div><div class=\"line\">        _class_resolveMethod(cls, sel, inst);</div><div class=\"line\">        runtimeLock.lock();</div><div class=\"line\">        triedResolver = YES;</div><div class=\"line\">        goto retry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //如果没找到resolveInstanceMethod 和resolveClassMethod，</div><div class=\"line\">//\t进行消息转发 阶段</div><div class=\"line\">    imp = (IMP)_objc_msgForward_impcache;</div><div class=\"line\">\t//填充 cache</div><div class=\"line\">    cache_fill(cls, sel, imp, inst);</div><div class=\"line\"> done:</div><div class=\"line\">    runtimeLock.unlock();</div><div class=\"line\">    return imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>SUPPORT_INDEXED_ISA</code>是在<code>arm64</code>和<code>LP64</code> 还有<code>arm_arch_7k&gt;2</code>为1，<code>iphone</code>属于<code>arm64</code>、<code>mac os</code>属于<code>LP64</code>,所以<code>SUPPORT_INDEXED_ISA = 1</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </div><div class=\"line\">// field as an index into a class table.</div><div class=\"line\">// Note, keep this in sync with any .s files which also define it.</div><div class=\"line\">// Be sure to edit objc-abi.h as well.</div><div class=\"line\">// __ARM_ARCH_7K__ 处理器架构指令集版本</div><div class=\"line\">//__arm64__ 架构</div><div class=\"line\">//__LP64__ uinx 和uinx  mac os</div><div class=\"line\">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</div><div class=\"line\">#   define SUPPORT_INDEXED_ISA 1</div><div class=\"line\">#else</div><div class=\"line\">#   define SUPPORT_INDEXED_ISA 0</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p><code>lookUpImpOrForward</code>函数的 大概思路如下：</p>\n<p>首次已经从缓存中查过没有命中所以不再去缓存中查了，然后判断<code>cls</code>是否已经实现，<code>cls-&gt;isRealized()</code>，没有实现的话进行实现<code>realizeClass(cls)</code>，主要是将初始化<code>read-write data</code>和其他的一些数据，后续会细讲。然后进行<code>cls</code>的初始化<code>_class_initialize()</code>，当<code>cls</code>需要初始化和没有初始化的时候进行cls初始化，初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类,数据的大小最小是4，扩容规则是：<code>n*2+1</code>;然后再次获取imp<code>cache_getImp</code>,然后在<code>cls</code>方法中查找该<code>method</code>，然后就是在<code>superclass</code>中查找方法，直到父类是nil，找到的话，获取<code>imp</code>并将<code>cls</code>和<code>sel</code>加入到<code>cache</code>中，否则进入到消息解析阶段<code>_class_resolveMethod</code>，在转发阶段，不是元类的话，进入到<code>_class_resolveInstanceMethod</code>是元类的话调用<code>_class_resolveClassMethod</code>,这两种分别都会进入到<code>lookUpImpOrNil</code>，再次查找<code>IMP</code>，当没找到的话就返回，找到的话用<code>objc_msgSend</code>发送消息实现调用<code>SEL_resolveInstanceMethod</code>并标记<code>triedResolver</code>为已动态解析标志。然后进入到消息动态转发阶段<code>_objc_msgForward_impcache</code>,至此<code>runtime</code>发送消息结束。</p>\n<p>借用网上找一个图， 可以更直观的看出流程运转。</p>\n<p><img src=\"../images/7-1.png\" alt=\"\"></p>\n<h4 id=\"realizeClass-解析\"><a href=\"#realizeClass-解析\" class=\"headerlink\" title=\"realizeClass()解析\"></a>realizeClass()解析</h4><p><code>realizeClass</code>是初始化了很多数据，包括<code>cls-&gt;ro</code>赋值给<code>cls-&gt;rw</code>，添加元类<code>version</code>为7,<code>cls-&gt;chooseClassArrayIndex()</code>设置<code>cls</code>的索引，<code>supercls = realizeClass(remapClass(cls-&gt;superclass));\n    metacls = realizeClass(remapClass(cls-&gt;ISA()))</code>初始化<code>superclass</code>和<code>cls-&gt;isa</code>,后边针对没有优化的结构进行赋值这里不多讲，然后协调实例变量偏移布局，设置<code>cls-&gt;setInstanceSize</code>,拷贝<code>flags</code>从<code>ro</code>到<code>rw</code>中，然后添加<code>subclass</code>和<code>rootclass</code>，最后添加类别的方法，协议，和属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* realizeClass</div><div class=\"line\"> cls第一次初始化会执行，包括cls-&gt;rw-&gt;data(),返回真实的cls 结构体</div><div class=\"line\"> runtimelock 必须有调用者把写入锁锁起来</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static Class realizeClass(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    class_rw_t *rw;</div><div class=\"line\">    Class supercls;</div><div class=\"line\">    Class metacls;</div><div class=\"line\">    bool isMeta;</div><div class=\"line\"></div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    if (cls-&gt;isRealized()) return cls;</div><div class=\"line\">    assert(cls == remapClass(cls));</div><div class=\"line\"></div><div class=\"line\">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class=\"line\">//首先将tw赋值给to，因为数据结构一样可以直接强制转化</div><div class=\"line\">    ro = (const class_ro_t *)cls-&gt;data();</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</div><div class=\"line\">        rw = cls-&gt;data();</div><div class=\"line\">        ro = cls-&gt;data()-&gt;ro;</div><div class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // 正常情况下 申请class_rw_t空间</div><div class=\"line\">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class=\"line\">        rw-&gt;ro = ro;//cls-&gt;rw-&gt;ro 指向现在的ro</div><div class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;//realized = 1 and  realizing = 1</div><div class=\"line\">        cls-&gt;setData(rw);//赋值</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    isMeta = ro-&gt;flags &amp; RO_META;//是否是元类</div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">    rw-&gt;version = isMeta ? 7 : 0;  // 元类版本是7，旧版的6，否就是0</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    // Choose an index for this class.</div><div class=\"line\">//设置cls的索引</div><div class=\"line\">\tcls-&gt;chooseClassArrayIndex();</div><div class=\"line\"></div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        _objc_inform(&quot;CLASS: realizing class &apos;%s&apos;%s %p %p #%u&quot;, </div><div class=\"line\">                     cls-&gt;nameForLogging(), isMeta ? &quot; (meta)&quot; : &quot;&quot;, </div><div class=\"line\">                     (void*)cls, ro, cls-&gt;classArrayIndex());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 如果父类没有初始化则进行初始化</div><div class=\"line\">    // root_class 做完需要设置RW_REALIZED=1，</div><div class=\"line\">    // root metaclasses 需要执行完.</div><div class=\"line\">\t//从NXMapTable 获取cls ，然后进行初始化</div><div class=\"line\">\t//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</div><div class=\"line\">    supercls = realizeClass(remapClass(cls-&gt;superclass));</div><div class=\"line\">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</div><div class=\"line\">//没有经过优化的isa执行的，现在已经是version=7，在arm64上是优化过的，这个先不看了。</div><div class=\"line\">#if SUPPORT_NONPOINTER_ISA</div><div class=\"line\">    // Disable non-pointer isa for some classes and/or platforms.</div><div class=\"line\">    // Set instancesRequireRawIsa.</div><div class=\"line\">    bool instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</div><div class=\"line\">    bool rawIsaIsInherited = false;</div><div class=\"line\">    static bool hackedDispatch = false;</div><div class=\"line\"></div><div class=\"line\">    if (DisableNonpointerIsa) &#123;</div><div class=\"line\">        // Non-pointer isa disabled by environment or app SDK version</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (!hackedDispatch  &amp;&amp;  !(ro-&gt;flags &amp; RO_META)  &amp;&amp;  </div><div class=\"line\">             0 == strcmp(ro-&gt;name, &quot;OS_object&quot;)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // hack for libdispatch et al - isa also acts as vtable pointer</div><div class=\"line\">        hackedDispatch = true;</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (supercls  &amp;&amp;  supercls-&gt;superclass  &amp;&amp;  </div><div class=\"line\">             supercls-&gt;instancesRequireRawIsa()) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // This is also propagated by addSubclass() </div><div class=\"line\">        // but nonpointer isa setup needs it earlier.</div><div class=\"line\">        // Special case: instancesRequireRawIsa does not propagate </div><div class=\"line\">        // from root class to root metaclass</div><div class=\"line\">        instancesRequireRawIsa = true;</div><div class=\"line\">        rawIsaIsInherited = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (instancesRequireRawIsa) &#123;</div><div class=\"line\">        cls-&gt;setInstancesRequireRawIsa(rawIsaIsInherited);</div><div class=\"line\">    &#125;</div><div class=\"line\">// SUPPORT_NONPOINTER_ISA</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    // Update superclass and metaclass in case of remapping</div><div class=\"line\">    cls-&gt;superclass = supercls;</div><div class=\"line\">    cls-&gt;initClassIsa(metacls);</div><div class=\"line\"></div><div class=\"line\">\t// 协调实例变量偏移/布局</div><div class=\"line\">\t//可能重新申请空间 class_ro_t,更新我们的class_ro_t</div><div class=\"line\">    if (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</div><div class=\"line\"></div><div class=\"line\">    // 设置setInstanceSize 从ro-&gt;instanceSize</div><div class=\"line\">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</div><div class=\"line\"></div><div class=\"line\">\t//拷贝flags 从ro到rw中</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</div><div class=\"line\">        cls-&gt;setHasCxxDtor();</div><div class=\"line\">        if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</div><div class=\"line\">            cls-&gt;setHasCxxCtor();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//添加superclass指针</div><div class=\"line\">    if (supercls) &#123;</div><div class=\"line\">        addSubclass(supercls, cls);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        addRootClass(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Attach categories</div><div class=\"line\">\t//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</div><div class=\"line\">    methodizeClass(cls);</div><div class=\"line\"></div><div class=\"line\">    return cls;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里最后添加类别的数据是调用了<code>methodizeClass</code>函数，这个函数首先添加<code>method_list_t *list = ro-&gt;baseMethods()</code>到<code>rw-&gt;methods.attachLists(&amp;list, 1)</code>，然后将属性<code>property_list_t *proplist=ro-&gt;baseProperties</code>添加到<code>rw-&gt;properties.attachLists(&amp;proplist, 1)</code>,最后将协议列表<code>protocol_list_t *protolist = ro-&gt;baseProtocols</code>追加到<code>rw-&gt;protocols.attachLists(&amp;protolist, 1)</code>，如果是<code>metaclass</code>则添加<code>SEL_initialize</code>,然后从全局<code>NXMapTable *category_map</code>删除已经加载的<code>category_list</code>,最后调用<code>attachCategories(cls, cats, false /*don&#39;t flush caches*/)</code>将已经加载的<code>cats</code>的方法添加到<code>cls-&gt;rw</code>上面并且不刷新<code>caches</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* methodizeClass</div><div class=\"line\"> 修复cls方法列表想，协议列表和属性列表</div><div class=\"line\">* 加锁</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static void methodizeClass(Class cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    runtimeLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\">    auto ro = rw-&gt;ro;</div><div class=\"line\"></div><div class=\"line\">    // Methodizing for the first time</div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        _objc_inform(&quot;CLASS: methodizing class &apos;%s&apos; %s&quot;, </div><div class=\"line\">                     cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//方法列表</div><div class=\"line\">    method_list_t *list = ro-&gt;baseMethods();</div><div class=\"line\">    if (list) &#123;</div><div class=\"line\">        prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls));</div><div class=\"line\">\t//将对象的方法追加到cls-&gt;rw-&gt;methods后面</div><div class=\"line\">        rw-&gt;methods.attachLists(&amp;list, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class=\"line\">    if (proplist) &#123;</div><div class=\"line\">\t//将对象的属性追加到rw-&gt;properties后面</div><div class=\"line\">        rw-&gt;properties.attachLists(&amp;proplist, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class=\"line\">    if (protolist) &#123;</div><div class=\"line\">\t//将对象的协议追加到rw-&gt;protocols后面</div><div class=\"line\">        rw-&gt;protocols.attachLists(&amp;protolist, 1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Root classes get bonus method implementations if they don&apos;t have </div><div class=\"line\">    // them already. These apply before category replacements.</div><div class=\"line\">    if (cls-&gt;isRootMetaclass()) &#123;</div><div class=\"line\">        // root metaclass</div><div class=\"line\">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Attach categories.</div><div class=\"line\">\t//类别 从全局NXMapTable *category_map 已经加载过了。</div><div class=\"line\">    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);</div><div class=\"line\">\t//收集所有的cats到cls -&gt; rw中</div><div class=\"line\">    attachCategories(cls, cats, false /*don&apos;t flush caches*/);</div><div class=\"line\"></div><div class=\"line\">    if (PrintConnecting) &#123;</div><div class=\"line\">        if (cats) &#123;</div><div class=\"line\">            for (uint32_t i = 0; i &lt; cats-&gt;count; i++) &#123;</div><div class=\"line\">                _objc_inform(&quot;CLASS: attached category %c%s(%s)&quot;, </div><div class=\"line\">                             isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                             cls-&gt;nameForLogging(), cats-&gt;list[i].cat-&gt;name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (cats) free(cats);//释放cats</div><div class=\"line\"></div><div class=\"line\">#if DEBUG</div><div class=\"line\">    // Debug: sanity-check all SELs; log method list contents</div><div class=\"line\">    for (const auto&amp; meth : rw-&gt;methods) &#123;</div><div class=\"line\">        if (PrintConnecting) &#123;</div><div class=\"line\">            _objc_inform(&quot;METHOD %c[%s %s]&quot;, isMeta ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(meth.name));</div><div class=\"line\">        &#125;</div><div class=\"line\">        assert(sel_registerName(sel_getName(meth.name)) == meth.name); </div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"attachCategories-解析\"><a href=\"#attachCategories-解析\" class=\"headerlink\" title=\"attachCategories()解析\"></a>attachCategories()解析</h4><p><code>methodizeClass</code>之前<code>rw</code>初始化的时候并没有将其他数据都都复制给<code>rw</code>,现在<code>methodizeClass</code>实现了将本来的<code>ro</code>数据拷贝给<code>rw</code>,然后<code>attachCategories</code>将<br>分类的方法，属性，协议追加到<code>cls-&gt;data-&gt;rw</code>，我们进入<code>attachCategories</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    bool isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    // fixme rearrange to remove these intermediate allocations</div><div class=\"line\">\t//方法数组[[1,2,3],[4,5,6],[7,8,9]]</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\">\t//属性数组</div><div class=\"line\">    property_list_t **proplists = (property_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class=\"line\">\t//协议数组</div><div class=\"line\">    protocol_list_t **protolists = (protocol_list_t **)</div><div class=\"line\">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int propcount = 0;</div><div class=\"line\">    int protocount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    bool fromBundle = NO;</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">\t\t//取出某个分类</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\">//取出分类 的 instance方法或者class方法</div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist; //mlists 接受所有分类方法</div><div class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有分类属性</div><div class=\"line\">        property_list_t *proplist = </div><div class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class=\"line\">        if (proplist) &#123;</div><div class=\"line\">            proplists[propcount++] = proplist;</div><div class=\"line\">        &#125;</div><div class=\"line\">//proplist 接受所有协议方法</div><div class=\"line\">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class=\"line\">        if (protolist) &#123;</div><div class=\"line\">            protolists[protocount++] = protolist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">//收集了所有协议 分类方法</div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class=\"line\">\t//追加所有分类方法</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">\t//释放数组</div><div class=\"line\">    free(mlists);</div><div class=\"line\">\t//刷新该类的缓存</div><div class=\"line\">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class=\"line\">//追加所有分类属性</div><div class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class=\"line\">    free(proplists);//释放数组</div><div class=\"line\">//追加所有分类协议</div><div class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class=\"line\">    free(protolists);//释放数组</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"rw-gt-list-gt-attachLists-解析\"><a href=\"#rw-gt-list-gt-attachLists-解析\" class=\"headerlink\" title=\"rw-&gt;list-&gt;attachLists()解析\"></a>rw-&gt;list-&gt;attachLists()解析</h4><p>添加<code>attachLists</code>函数规则是后来的却添加到内存的前部分，这里就清楚为什么后编译类别能后边的类别覆盖前边的类别的相同名字的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">       if (addedCount == 0) return;</div><div class=\"line\"></div><div class=\"line\">       if (hasArray()) &#123;</div><div class=\"line\">           // many lists -&gt; many lists</div><div class=\"line\">           uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">\t\t//一共需要的数量</div><div class=\"line\">           uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">\t\t//分配内存 内存不够用了，需要扩容</div><div class=\"line\">           setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">\t\t//赋值count</div><div class=\"line\">           array()-&gt;count = newCount;</div><div class=\"line\">\t\t// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</div><div class=\"line\">           memmove(array()-&gt;lists + addedCount/*数组末尾*/, array()-&gt;lists/*数组*/,</div><div class=\"line\">                   oldCount * sizeof(array()-&gt;lists[0])/*移动的大小*/);</div><div class=\"line\">\t\t//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</div><div class=\"line\">           memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">\t\t/*</div><div class=\"line\">\t\t图示讲解：</div><div class=\"line\">\t\tarray()-&gt;lists:A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\taddedCount:3</div><div class=\"line\">\taddedLists:P-&gt;L-&gt;V</div><div class=\"line\">\t\tmemmove之后：nil-&gt;nil-&gt;nil-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t然后再讲addedLists插入到数组前边,最终array()-&gt;lists的值是：</div><div class=\"line\">\t\tP-&gt;L-&gt;V-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E</div><div class=\"line\">\t\t */</div><div class=\"line\">       &#125;</div><div class=\"line\">       else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class=\"line\">           // 0 lists -&gt; 1 list</div><div class=\"line\">           list = addedLists[0];</div><div class=\"line\">       &#125; </div><div class=\"line\">       else &#123;</div><div class=\"line\">           // 1 list -&gt; many lists</div><div class=\"line\">           List* oldList = list;</div><div class=\"line\">           uint32_t oldCount = oldList ? 1 : 0;</div><div class=\"line\">           uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">           setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class=\"line\">           array()-&gt;count = newCount;</div><div class=\"line\">           if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class=\"line\">           memcpy(array()-&gt;lists, addedLists, </div><div class=\"line\">                  addedCount * sizeof(array()-&gt;lists[0]));</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><code>class</code>初始化完成了，然后再次尝试获取<code>imp = cache_getImp</code>,由于缓存没有中间也没添加进去，所以这里也是空的，然后从<code>getMethodNoSuper_nolock</code>获取该<code>cls</code>的方法列表中查找，没有的话再从<code>superclass</code>查找<code>cache</code>和<code>method</code>,找到的话，进行<code>log_and_fill_cache</code>至此消息发送完成。</p>\n<h3 id=\"消息动态解析\"><a href=\"#消息动态解析\" class=\"headerlink\" title=\"消息动态解析\"></a>消息动态解析</h3><p>动态解析函数<code>_class_resolveMethod(cls, sel, inst)</code>，如果不是元类调用<code>_class_resolveInstanceMethod</code>,如果是的话调用<code>_class_resolveClassMethod</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* _class_resolveMethod</div><div class=\"line\">* 调用 +resolveClassMethod 或者 +resolveInstanceMethod</div><div class=\"line\">* 如果存在了则不检查</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">void _class_resolveMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (! cls-&gt;isMetaClass()) &#123;//不是元类则调用 实例的</div><div class=\"line\">\t//首先调用</div><div class=\"line\">\t\t_class_resolveInstanceMethod(cls, sel, inst);</div><div class=\"line\">    &#125; </div><div class=\"line\">    else &#123;</div><div class=\"line\">        // try [nonMetaClass resolveClassMethod:sel]</div><div class=\"line\">        // and [cls resolveInstanceMethod:sel]</div><div class=\"line\">\t\t//寻找classMethod</div><div class=\"line\">        _class_resolveClassMethod(cls, sel, inst);</div><div class=\"line\">        if (!lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">        &#123;</div><div class=\"line\">            _class_resolveInstanceMethod(cls, sel, inst);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>resolveInstanceMethod</code>，查找<code>SEL_resolveInstanceMethod</code>，传值不用初始化，不用消息解析，但是<code>cache</code>要查找。没有找到的直接返回，找到的话使用<code>objc_msgSend</code>发送消息调用<code>SEL_resolveInstanceMethod</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* _class_resolveInstanceMethod</div><div class=\"line\">* 调用 class添加的函数 +resolveInstanceMethod</div><div class=\"line\">* 有可能是元类</div><div class=\"line\">* 如果方法存在则不检查</div><div class=\"line\">**********************************************************************/</div><div class=\"line\">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </div><div class=\"line\">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // Resolver not implemented.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</div><div class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class=\"line\">    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);</div><div class=\"line\"></div><div class=\"line\">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class=\"line\">    // +resolveInstanceMethod adds to self a.k.a. cls</div><div class=\"line\">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class=\"line\"></div><div class=\"line\">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class=\"line\">        if (imp) &#123;</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class=\"line\">                         &quot;dynamically resolved to %p&quot;, </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Method resolver didn&apos;t add anything?</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</div><div class=\"line\">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>_class_resolveClassMethod</code>中，第一步先去<code>lookUpImpOrNil</code>查找<code>+SEL_resolveClassMethod</code>方法，没找到的就结束，找到则调用<code>objc_msgsend(id,sel)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(cls-&gt;isMetaClass());</div><div class=\"line\"></div><div class=\"line\">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </div><div class=\"line\">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        // Resolver not implemented.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</div><div class=\"line\">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </div><div class=\"line\">                        SEL_resolveClassMethod, sel);</div><div class=\"line\"></div><div class=\"line\">    // Cache the result (good or bad) so the resolver doesn&apos;t fire next time.</div><div class=\"line\">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</div><div class=\"line\">    IMP imp = lookUpImpOrNil(cls, sel, inst, </div><div class=\"line\">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</div><div class=\"line\"></div><div class=\"line\">    if (resolved  &amp;&amp;  PrintResolving) &#123;</div><div class=\"line\">        if (imp) &#123;</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</div><div class=\"line\">                         &quot;dynamically resolved to %p&quot;, </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Method resolver didn&apos;t add anything?</div><div class=\"line\">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</div><div class=\"line\">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel), </div><div class=\"line\">                         cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                         cls-&gt;nameForLogging(), sel_getName(sel));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>动态解析至此完成。</p>\n<h3 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h3><p><code>_objc_msgForward_impcache</code>是转发的函数地址，在搜索框搜索发现，这个函数除了<code>.s</code>文件中有，其他地方均只是调用，说明这个函数是汇编实现，在<code>objc-msg-arm64.s 531 行</code>发现一点踪迹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">STATIC_ENTRY __objc_msgForward_impcache //开始__objc_msgForward_impcache</div><div class=\"line\">\t// No stret specialization.</div><div class=\"line\">\tb\t__objc_msgForward//跳转-&gt;__objc_msgForward</div><div class=\"line\">\tEND_ENTRY __objc_msgForward_impcache // 结束__objc_msgForward_impcache</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">\tENTRY __objc_msgForward // 开始 __objc_msgForward</div><div class=\"line\"></div><div class=\"line\">\tadrp\tx17, __objc_forward_handler@PAGE</div><div class=\"line\">\tldr\tp17, [x17, __objc_forward_handler@PAGEOFF]//p17= x17 和 __objc_forward_handler@PAGEOFF的和</div><div class=\"line\">\tTailCallFunctionPointer x17 //跳转-&gt; TailCallFunctionPointer</div><div class=\"line\"></div><div class=\"line\">\tEND_ENTRY __objc_msgForward//结束 __objc_msgForward</div></pre></td></tr></table></figure>\n<p>当跳转到<code>adrp    x17, __objc_forward_handler@PAGE</code>这一行，搜搜索函数<code>_objc_forward_handler</code>，看到只是个打印函数，并没有其他函数来替代这个指针，那么我们用其他方法来探究。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">__attribute__((noreturn)) void </div><div class=\"line\">objc_defaultForwardHandler(id self, SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class=\"line\">                &quot;(no message forward handler is installed)&quot;, </div><div class=\"line\">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class=\"line\">                object_getClassName(self), sel_getName(sel), self);</div><div class=\"line\">&#125;</div><div class=\"line\">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div></pre></td></tr></table></figure>\n<p>网上有大神总结的点我们先参考下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 伪代码</div><div class=\"line\">int __forwarding__(void *frameStackPointer, int isStret) &#123;</div><div class=\"line\">    id receiver = *(id *)frameStackPointer;</div><div class=\"line\">    SEL sel = *(SEL *)(frameStackPointer + 8);</div><div class=\"line\">    const char *selName = sel_getName(sel);</div><div class=\"line\">    Class receiverClass = object_getClass(receiver);</div><div class=\"line\"></div><div class=\"line\">    // 调用 forwardingTargetForSelector:</div><div class=\"line\">    if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</div><div class=\"line\">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</div><div class=\"line\">        if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</div><div class=\"line\">            if (isStret == 1) &#123;</div><div class=\"line\">                int ret;</div><div class=\"line\">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</div><div class=\"line\">                return ret;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return objc_msgSend(forwardingTarget, sel, ...);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 僵尸对象</div><div class=\"line\">    const char *className = class_getName(receiverClass);</div><div class=\"line\">    const char *zombiePrefix = &quot;_NSZombie_&quot;;</div><div class=\"line\">    size_t prefixLen = strlen(zombiePrefix); // 0xa</div><div class=\"line\">    if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123;</div><div class=\"line\">        CFLog(kCFLogLevelError,</div><div class=\"line\">              @&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;,</div><div class=\"line\">              className + prefixLen,</div><div class=\"line\">              selName,</div><div class=\"line\">              receiver);</div><div class=\"line\">        &lt;breakpoint-interrupt&gt;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</div><div class=\"line\">    if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</div><div class=\"line\">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</div><div class=\"line\">        if (methodSignature) &#123;</div><div class=\"line\">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</div><div class=\"line\">            if (signatureIsStret != isStret) &#123;</div><div class=\"line\">                CFLog(kCFLogLevelWarning ,</div><div class=\"line\">                      @&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &apos;%s&apos;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;,</div><div class=\"line\">                      selName,</div><div class=\"line\">                      signatureIsStret ? &quot;&quot; : not,</div><div class=\"line\">                      isStret ? &quot;&quot; : not);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</div><div class=\"line\">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</div><div class=\"line\"></div><div class=\"line\">                [receiver forwardInvocation:invocation];</div><div class=\"line\"></div><div class=\"line\">                void *returnValue = NULL;</div><div class=\"line\">                [invocation getReturnValue:&amp;value];</div><div class=\"line\">                return returnValue;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                CFLog(kCFLogLevelWarning ,</div><div class=\"line\">                      @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement forwardInvocation: -- dropping message&quot;,</div><div class=\"line\">                      receiver,</div><div class=\"line\">                      className);</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SEL *registeredSel = sel_getUid(selName);</div><div class=\"line\"></div><div class=\"line\">    // selector 是否已经在 Runtime 注册过</div><div class=\"line\">    if (sel != registeredSel) &#123;</div><div class=\"line\">        CFLog(kCFLogLevelWarning ,</div><div class=\"line\">              @&quot;*** NSForwarding: warning: selector (%p) for message &apos;%s&apos; does not match selector known to Objective C runtime (%p)-- abort&quot;,</div><div class=\"line\">              sel,</div><div class=\"line\">              selName,</div><div class=\"line\">              registeredSel);</div><div class=\"line\">    &#125; // doesNotRecognizeSelector</div><div class=\"line\">    else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</div><div class=\"line\">        [receiver doesNotRecognizeSelector:sel];</div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        CFLog(kCFLogLevelWarning ,</div><div class=\"line\">              @&quot;*** NSForwarding: warning: object %p of class &apos;%s&apos; does not implement doesNotRecognizeSelector: -- abort&quot;,</div><div class=\"line\">              receiver,</div><div class=\"line\">              className);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // The point of no return.</div><div class=\"line\">    kill(getpid(), 9);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"验证动态解析\"><a href=\"#验证动态解析\" class=\"headerlink\" title=\"验证动态解析\"></a>验证动态解析</h3><p>我们简单定义一个<code>test</code>函数，然后并执行这个函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tif (sel == @selector(test)) &#123;</div><div class=\"line\">\t\tMethod me = class_getInstanceMethod(self, @selector(test2));</div><div class=\"line\">\t\tclass_addMethod(self, sel,</div><div class=\"line\">\t\t\t\t\t\tmethod_getImplementation(me),</div><div class=\"line\">\t\t\t\t\t\tmethod_getTypeEncoding(me));</div><div class=\"line\">\t\treturn YES;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)test2&#123;</div><div class=\"line\">\tNSLog(@&quot;来了，老弟&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">Person *p = [[Person alloc]init];</div><div class=\"line\">[p test];</div><div class=\"line\">[p test];</div><div class=\"line\"> //输出</div><div class=\"line\">+[FYPerson resolveInstanceMethod:]</div><div class=\"line\"> -[FYPerson test3]</div><div class=\"line\"> -[FYPerson test3]</div></pre></td></tr></table></figure>\n<p><code>[p test]</code>在第一次执行的时候会走到消息动态解析的这一步,然后通过<code>objc_msgsend</code>调用了<code>test</code>，并且把<code>test</code>添加到了缓存中，所以输出了<code>+[FYPerson resolveInstanceMethod:]</code>，在第二次调用的时候，会从缓存中查到<code>imp</code>，所以直接输出了<code>-[FYPerson test3]</code>。</p>\n<p>在<code>+resolveInstanceMethod</code>可以拦截掉实例方法的动态解析，在<code>+resolveClassMethod</code>可以拦截类方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">+ (void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">+ (void)test3&#123;</div><div class=\"line\">\tNSLog(@&quot;来了，老弟&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tif (sel == @selector(test)) &#123;</div><div class=\"line\">\t\tMethod me = class_getClassMethod(self, @selector(test3));//获取method</div><div class=\"line\">\t\t//给sel 添加方法实现 @selecter(test3)</div><div class=\"line\">\t\tclass_addMethod(object_getClass(self), sel,</div><div class=\"line\">\t\t\t\t\t\tmethod_getImplementation(me),</div><div class=\"line\">\t\t\t\t\t\tmethod_getTypeEncoding(me));</div><div class=\"line\">\t\treturn YES;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[Person test];</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[Person resolveClassMethod:]</div><div class=\"line\">来了，老弟</div></pre></td></tr></table></figure>\n<p>拦截<code>+resolveClassMethod</code>,在条件为<code>sel==@selector(test)</code>的时候，将函数实现<code>+test3()</code>的<code>IMP</code>使用<code>class_addMethod</code>添加到<code>Person</code>上，待下次调用<code>test</code>的时候直接通过<code>imp = cache_getImp(cls, sel);</code>获取到<code>imp</code>函数指针并且执行。<br>我们也可以通过添加c函数的imp来实现给class添加函数实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">    if (sel == @selector(test)) &#123;</div><div class=\"line\">//        Method me = class_getInstanceMethod(self, @selector(test3));</div><div class=\"line\">//        class_addMethod(self.class, sel, method_getImplementation(me), method_getTypeEncoding(me));</div><div class=\"line\">        class_addMethod(self.class, sel, (IMP)test3, &quot;v16@0:8&quot;);</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">void test3(id self,SEL sel)&#123;</div><div class=\"line\">    NSLog(@&quot;test3:%s&quot;,NSStringFromSelector(sel).UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[FYPerson resolveInstanceMethod:]</div><div class=\"line\">test3:test</div><div class=\"line\">test3:test</div></pre></td></tr></table></figure>\n<p><code>v16@0:8</code>是返回值为<code>void</code>参数占用16字节大小，第一个是从0开始，第二个从8字节开始。<br>这段代码和上面的其实本质上是一样的，一个是给<code>class</code>添加函数实现，使<code>sel</code>和<code>imp</code>对应起来，这个是将<code>c</code>函数的<code>imp</code>和<code>sel</code>进行关联，添加缓存之后，使用<code>objc_msgsend()</code>效果是一样的。</p>\n<h3 id=\"验证消息转发\"><a href=\"#验证消息转发\" class=\"headerlink\" title=\"验证消息转发\"></a>验证消息转发</h3><p>消息转发可分为3步，第一步根据<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>返回的类对象或者元类对象，将方法转发给该对象。假如第一步没实现，则第二步根据返回的<code>-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>函数签名，在第三步<code>(void)forwardInvocation:(NSInvocation *)anInvocation</code>调用函数<code>[anInvocation invoke]</code>进行校验成功之后进行调用函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">- (void)test;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#import &quot;Person.h&quot;</div><div class=\"line\">#import &quot;Student.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation Person</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [[Struent alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//输出</div><div class=\"line\">-[Student test]</div></pre></td></tr></table></figure>\n<p>我们定义了一个<code>Person</code>只声明了<code>test</code>没有实现，然后在消息转发第一步<code>forwardingTargetForSelector</code>将要处理的对象返回，成功调用了<code>Student</code>的<code>test</code>方法。</p>\n<p>第一步没拦截，可以在第二步拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//消息转发第二步 没有对象来处理方法，那将函数签名来实现</div><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (aSelector == @selector(test)) &#123;</div><div class=\"line\">\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class=\"line\">\t\treturn sign;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super methodSignatureForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">// 函数签名已返回，到了函数调用的地方</div><div class=\"line\">//selector 函数的sel</div><div class=\"line\">//target   函数调用者</div><div class=\"line\">//methodSignature 函数签名</div><div class=\"line\">//NSInvocation  封装数据的对象</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class=\"line\">    NSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">-[Person forwardInvocation:]</div></pre></td></tr></table></figure></p>\n<p>打印出了<code>-[Person forwardInvocation:]</code>而且没有崩溃，在<code>forwardInvocation:(NSInvocation *)anInvocation</code>怎么操作看开发者怎么处理了，探究下都可以做什么事情。<br>看到<code>NSInvocation</code>的属性和函数,<code>sel</code>和<code>target</code>是读写，函数签名是必须的，所以<code>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>必须将函数签名返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (readonly, retain) NSMethodSignature *methodSignature;//只读</div><div class=\"line\">- (void)retainArguments;</div><div class=\"line\">@property (readonly) BOOL argumentsRetained;</div><div class=\"line\">@property (nullable, assign) id target;//读写</div><div class=\"line\">@property SEL selector;//读写</div></pre></td></tr></table></figure>\n<p>当拦截方法是类方法的时候，可以用<code>+ (id)forwardingTargetForSelector:(SEL)aSelecto</code>拦截，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">//class 转发</div><div class=\"line\">// 消息转发第一步 拦截是否有转发的class对象处理方法</div><div class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [Student class];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (void)test3&#123;</div><div class=\"line\">//\tNSLog(@&quot;+[Student test3]&quot;);</div><div class=\"line\">//当[Person test3]上一行写这么一行，Person *p = [[Person alloc]init] 这句报错</div><div class=\"line\">//暂时不懂为什么不能调用NSLog，但是已经进来了所以调用了test2。</div><div class=\"line\">//注释掉 [[Person alloc]init]，一切正常。 有大佬了解吗</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 输出</div><div class=\"line\">-[Student test2]</div></pre></td></tr></table></figure>\n<p>也可以用返回<code>return [[Student alloc]init];</code>将<code>class</code>类方法转化成实例方法,最后调用了<code>Student</code>的对象方法<code>test3</code>。其实本质上都是<code>objc_msgSend(id,SEL,...)</code>，我们修改的只是<code>id</code>的值，<code>id</code>类型在这段代码中本质是对象，所以我们可以<code>return instance</code>也可以<code>reurn class</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\t//objc_msgSend([[Struent alloc]init],test)</div><div class=\"line\">\t\treturn [[Student alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)test3&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//输出</div><div class=\"line\">-[Student test3]</div></pre></td></tr></table></figure>\n<p>将刚才写的<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>改成类方法，也是同样可以拦截类方法的。我们看下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">//消息转发第二步 没有class来处理方法，那将函数签名来实现</div><div class=\"line\">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (aSelector == @selector(test3)) &#123;</div><div class=\"line\">\t\tNSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</div><div class=\"line\">\t\treturn sign;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn [super methodSignatureForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">// 函数签名已返回，到了函数调用的地方</div><div class=\"line\">//selector 函数的sel</div><div class=\"line\">//target   函数调用者</div><div class=\"line\">//methodSignature 函数签名</div><div class=\"line\">//NSInvocation  封装数据的对象</div><div class=\"line\">+ (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class=\"line\">//\tanInvocation.selector = @selector(test2);</div><div class=\"line\">//此处换成[Student class]同样可以</div><div class=\"line\">//\tanInvocation.target = (id)[[Student alloc]init];</div><div class=\"line\"></div><div class=\"line\">//\t[anInvocation invoke];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//输出</div><div class=\"line\">+[Person forwardInvocation:]</div></pre></td></tr></table></figure>\n<p>测过其实对象方法和类方法都是用同样的流程拦截的，对象方法是用<code>-</code>方法,类方法是用<code>+</code>方法。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>objc_msgSend发送消息，会首先在cache中查找，查找不到则去方法列表(顺序是<code>cache-&gt;class_rw_t-&gt;supclass cache -&gt;superclass class_rw_t -&gt;动态解析</code>)</li>\n<li>第二步是动态解析，能在resolveInstanceMethod或+ (BOOL)resolveClassMethod:(SEL)sel来来拦截，可以给class新增实现函数，达到不崩溃目的</li>\n<li>第三步是消息转发，转发第一步可以在<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>拦截类或实例方法，能将对象方法转发给其他对象，也能将对象方法转发给类方法，也可以将类方法转发给实例方法</li>\n<li>第三步消息转发的第二步可以在<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>或<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>实现拦截类和实例方法并返回函数签名</li>\n<li>第三步消息转发的第三步可以<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code>或<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现类方法和实例方法的调用和获取返回值</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></li>\n</ul>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)","date":"2019-12-01T03:22:58.000Z","_content":"\n看完本文章你将了解到\n> 1. DisplayLink和timer的使用和原理\n> 2. 内存分配和内存管理\n> 3. 自动释放池原理\n> 4. weak指针原理和释放时机\n> 5. 引用计数原理\n\n\n### DisplayLink\n`CADisplayLink`是将任务添加到`runloop`中，`loop`每次循环便会调用`target`的`selector`，使用这个也能监测卡顿问题。首先介绍下`API`\n\n```\n+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;\n//runloop没循环一圈都会调用\n- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;\n//从runloop中删除\n- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;\n//取消\n- (void)invalidate;\n```\n我们在一个需要`push`的`VC`中运行来观察声明周期\n\n```\n@property (nonatomic,strong) CADisplayLink *link;\n\n//初始化\nself.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];\n[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];\ntimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\ndispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);\ndispatch_source_set_event_handler(timer, ^{\n\t@synchronized (self) {\n\t\tNSLog(@\"FPS:%d\",fps);\n\t\tfps = 0;\n\t}\n});\ndispatch_resume(timer);\n//全局变量\ndispatch_source_t timer;\nstatic int fps;\n\n- (void)test{\n\t\n\t@synchronized (self) {\n\t\tfps += 1;\n\t}\n}\n- (void)dealloc{\n\t[self.link invalidate];\n\tNSLog(@\"%s\",__func__);\n}\n//log\n2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89\n2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60\n```\n\n初始化之后，对`fps`使用了简单版本的读写锁，可以看到`fps`基本稳定在60左右，点击按钮返回之后，`link`和`VC`并没有正常销毁。我们分析一下，`VC（self）`->`link`->`target(self)`,导致了死循环，释放的时候，无法释放`self`和`link`,那么我们改动一下`link`->`target(self)`中的强引用，改成弱引用，代码改成下面的\n\n```\n@interface FYTimerTarget : NSObject\n@property (nonatomic,weak) id target;\n@end\n\n@implementation FYTimerTarget\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n\treturn self.target;\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\n\n\nFYProxy *proxy=[FYProxy proxyWithTarget:self];\nself.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];\n[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];\n\n- (void)test{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n2019-07-30 17:59:04.339934 -[ViewController test]\n2019-07-30 17:59:04.356292 -[ViewController test]\n2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]\n2019-07-30 17:59:04.371634 -[ViewController dealloc]\n```\n\n`FYTimerTarget`对`target`进行了弱引用，`self`对`FYTimerTarget`进行强引用，在销毁了的时候，先释放`self`,然后检查`self`的`FYTimerTarget`,`FYTimerTarget`只有一个参数`weak`属性，可以直接释放，释放完`FYTimerTarget`，然后释放`self(VC)`，最终可以正常。\n\n\n### NSTimer\n使用`NSTimer`的时候，`timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo`会对`aTarget`进行强引用，所以我们对这个`aTarget`进行一个简单的封装\n\n```\n@interface FYProxy : NSProxy\n@property (nonatomic,weak) id target;\n\n+(instancetype)proxyWithTarget:(id)target;\n@end\n@implementation FYProxy\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n+ (instancetype)proxyWithTarget:(id)target{\n\tFYProxy *obj=[FYProxy alloc];\n\tobj.target = target;\n\treturn obj;\n}\n//转发\n- (void)forwardInvocation:(NSInvocation *)invocation{\n\t[invocation invokeWithTarget:self.target];\n}\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{\n\treturn [self.target methodSignatureForSelector:sel];\n}\n@end\n```\n`FYProxy`是继承`NSProxy`，而`NSProxy`不是继承`NSObject`的,而是另外一种基类，不会走`objc_msgSend()`的三大步骤，当找不到函数的时候直接执行`- (void)forwardInvocation:(NSInvocation *)invocation`，和`- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel`直接进入消息转发阶段。或者将继承关系改成`FYTimerTarget : NSObject`,这样子`target`找不到的函数还是会走消息转发的三大步骤，我们再`FYTimerTarget`添加消息动态解析\n```\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n\treturn self.target;\n}\n```\n这样子`target`的`aSelector`转发给了`self.target`处理，成功弱引用了`self`和函数的转发处理。\n\n\n```\nFYTimerTarget *obj =[FYTimerTarget new];\nobj.target = self;\n\nself.timer = [NSTimer timerWithTimeInterval:1.0f\n\t\t\t\t\t\t\t\t\ttarget:obj\n\t\t\t\t\t\t\t\t   selector:@selector(test)\n\t\t\t\t\t\t\t\t   userInfo:nil\n\t\t\t\t\t\t\t\t\trepeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n[self.timer setFireDate:[NSDate distantPast]];\n\n//log\n2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]\n2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]\n2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]\n2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]\n```\n\n或者使用`timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block`，然后外部使用`__weak self`调用函数，也不会产生循环引用。\n使用`block`的情况，释放正常。\n\n```\nself.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n\tNSLog(@\"123\");\n}];\n\n//log\n2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123\n2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123\n2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]\n```\n\n由于`link`和`timer`是添加到`runloop`中使用的，每次一个循环则访问`timer`或者`link`，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。\n\n### GCD中timer\n`GCD`中的`dispatch_source_t`的定时器是基于内核的，时间误差相对较少。\n\n```\n//timer 需要强引用 或者设置成全局变量\n    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);\n    //设置\n    dispatch_source_set_event_handler(timer, ^{\n  //code 定时器执行的代码\n \n    });\n    //开始定时器\n    dispatch_resume(timer);\n```\n\n或者使用函数`dispatch_source_set_event_handler_f(timer, function_t);`\n\n```\ndispatch_source_set_event_handler_f(timer, function_t);\nvoid function_t(void * p){\n    //code here    \n}\n```\n\n业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？\n\n首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。\n先定义一个函数\n\n```\n+ (NSString *)exeTask:(dispatch_block_t)block\n    \t  start:(NSTimeInterval)time\n       interval:(NSTimeInterval)interval\n    \t repeat:(BOOL)repeat\n    \t  async:(BOOL)async;\n+ (NSString *)exeTask:(id)target\n\t\t  sel:(SEL)aciton\n\t\tstart:(NSTimeInterval)time\n\t interval:(NSTimeInterval)interval\n\t   repeat:(BOOL)repeat\n\t\tasync:(BOOL)async;\n//取消\n+ (void)exeCancelTask:(NSString *)key;\n```\n\n然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回`nil`，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的`key`,`timer`为`value`存储到全局变量中，在取消的时候直接用`key`取出`timer`取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。\n\n```\n+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async{\n\tif (block == nil) {\n\t\treturn nil;\n\t}\n\tif (repeat && interval <= 0) {\n\t\treturn nil;\n\t}\n\t\n\tNSString *name =[NSString stringWithFormat:@\"%d\",i];\n\t//主队列\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tif (async) {\n\t\tqueue = dispatch_queue_create(\"async.com\", DISPATCH_QUEUE_CONCURRENT);\n\t}\n\t//创建定时器\n\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\t//设置启动时间\n\tdispatch_source_set_timer(_timer,\n\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);\n\t//设定回调\n\tdispatch_source_set_event_handler(_timer, ^{\n\t\tblock();\n\t\tif (repeat == NO) {\n\t\t\tdispatch_source_cancel(_timer);\n\t\t}\n\t});\n\t//启动定时器\n\tdispatch_resume(_timer);\n\t//存放到字典\n\tif (name.length && _timer) {\n\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\t\ttimers[name] = _timer;\n\t\tdispatch_semaphore_signal(samephore);\n\t}\n\treturn name;\n}\n\n\n\n+ (NSString *)exeTask:(id)target\n\t\t\t\t  sel:(SEL)aciton\n\t\t\t\tstart:(NSTimeInterval)time\n\t\t\t interval:(NSTimeInterval)interval\n\t\t\t   repeat:(BOOL)repeat\n\t\t\t\tasync:(BOOL)async{\n\tif (target == nil || aciton == NULL) {\n\t\treturn nil;\n\t}\n\tif (repeat && interval <= 0) {\n\t\treturn nil;\n\t}\n\t\n\tNSString *name =[NSString stringWithFormat:@\"%d\",i];\n\t//主队列\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tif (async) {\n\t\tqueue = dispatch_queue_create(\"async.com\", DISPATCH_QUEUE_CONCURRENT);\n\t}\n\t//创建定时器\n\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\t//设置启动时间\n\tdispatch_source_set_timer(_timer,\n\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);\n\t//设定回调\n\tdispatch_source_set_event_handler(_timer, ^{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored\"-Warc-performSelector-leaks\"\n\t\t//这里是会报警告的代码\n\t\tif ([target respondsToSelector:aciton]) {\n\t\t\t[target performSelector:aciton];\n\t\t}\n#pragma clang diagnostic pop\n\n\t\tif (repeat == NO) {\n\t\t\tdispatch_source_cancel(_timer);\n\t\t}\n\t});\n\t//启动定时器\n\tdispatch_resume(_timer);\n\t//存放到字典\n\tif (name.length && _timer) {\n\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\t\ttimers[name] = _timer;\n\t\tdispatch_semaphore_signal(samephore);\n\t}\n\treturn name;\n}\n+ (void)exeCancelTask:(NSString *)key{\n\tif (key.length == 0) {\n\t\treturn;\n\t}\n\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\tif ([timers.allKeys containsObject:key]) {\n\t\tdispatch_source_cancel(timers[key]);\n\t\t[timers removeObjectForKey:key];\n\t}\n\tdispatch_semaphore_signal(samephore);\n}\n```\n\n用的时候很简单\n\n```\nkey = [FYTimer exeTask:^{\n        NSLog(@\"123\");\n    } start:1\n    interval:1 \n    repeat:YES \n    async:NO];\n```\n\n或者\n\n```\nkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];\n```\n\n取消执行的时候\n\n```\n[FYTimer exeCancelTask:key];\n```\n\n测试封装的定时器\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];\n}\n-(void)test{\n\tNSLog(@\"%@\",[NSThread currentThread]);\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\t[FYTimer exeCancelTask:key];\n}\n//log\n2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]\n```\n\n在点击`VC`的时候进行取消操作，`timer`停止。\n\n### NSProxy实战\n`NSProxy`其实是除了`NSObject`的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。\n\n问题：`ret1`和`ret2`分别是多少？\n\n```\nViewController *vc1 =[[ViewController alloc]init];\nFYProxy *pro1 =[FYProxy proxyWithTarget:vc1];\n\nFYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];\nBOOL ret1 = [pro1 isKindOfClass:ViewController.class];\nBOOL ret2 = [tar isKindOfClass:ViewController.class];\nNSLog(@\"%d %d\",ret1,ret2);\n```\n\n\n我们来分析一下，`-(bool)isKindOfClass:(cls)`对象函数是判断该对象是否的`cls`的子类或者该类的实例，这点不容置疑，那么`ret1`应该是`0`,`ret2`应该也是`0`\n\n\n\n首先看`FYProxy`的实现，`forwardInvocation`和`methodSignatureForSelector`，在没有该函数的时候进行消息转发，转发对象是`self.target`，在该例子中`isKindOfClass`不存在与`FYProxy`，所以讲该函数转发给了`VC`，则`BOOL ret1 = [pro1 isKindOfClass:ViewController.class];`相当于`BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];`，所以答案是1\n\n然后`ret2`是0，`tar`是继承于`NSObject`的，本身有`-(bool)isKindOfClass:(cls)`函数，所以答案是0。\n\n答案是：`ret1`是`1`，`ret2`是`0`。\n\n\n### 内存分配\n内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。\n\n数据段包括\n- 字符串常量：比如NSString * str = @\"11\"\n- 已初始化数据：已初始化的全局变量、静态变量等\n- 未初始化数据：未初始化的全局变量、静态变量等\n\n栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。\n\n堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。\n\n验证：\n\n```\nint a = 10;\nint b ;\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        static int c = 20;\n        static int d;\n        int e = 10;\n        int f;\n        NSString * str = @\"123\";\n        NSObject *obj =[[NSObject alloc]init];\n        NSLog(@\"\\na:%p \\nb:%p \\nc:%p \\nd:%p \\ne:%p \\nf:%p \\nobj:%p\\n str:%p\",&a,&b,&c,&d,&e,&f,obj,str);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n//log\n\na:0x1063e0d98 \nb:0x1063e0e64 \nc:0x1063e0d9c \nd:0x1063e0e60 \ne:0x7ffee9820efc \nf:0x7ffee9820ef8 \nobj:0x6000013541a0\nstr:0x1063e0068\n```\n### Tagged Pointer\n\n从64bit开始，iOS引入`Tagged Pointer`技术，用于优化`NSNumber、NSDate、NSString`等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用`Tagged Pointer`之后，`NSNumber`指针里面的数据变成了`Tag+Data`，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且`objc_msgSend()`能够识别出`Tagged Pointer`，比如`NSNumber`的`intValue`方法，直接从指针提取数据，节省了以前的调用的开销。\n在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。\n在`runtime`源码中`objc-internal.h 370行`判断是否使用了优化技术\n\n```\nstatic inline void * _Nonnull\n_objc_encodeTaggedPointer(uintptr_t ptr)\n{\n    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);\n}\n```\n\n我们拿来这个可以判断对象是否使用了优化技术。\n#### NSNumbe Tagged Pointer\n我们使用几个`NSNumber`的大小数字来验证\n\n```\n#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__ //mac开发\n// 64-bit Mac - tag bit is LSB\n#   define OBJC_MSB_TAGGED_POINTERS 0\n#else\n// Everything else - tag bit is MSB\n#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发\n#endif\n\n#if OBJC_MSB_TAGGED_POINTERS\n#   define _OBJC_TAG_MASK (1UL<<63)\n#else\n#   define _OBJC_TAG_MASK 1UL\n#endif\nbool objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        NSNumber *n1 = @2;\n        NSNumber *n2 = @3;\n        NSNumber *n3 = @(4);\n        NSNumber *n4 = @(0x4fffffffff);\n        NSLog(@\"\\n%p \\n%p \\n%p \\n%p\",n1,n2,n3,n4);\n        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));\n        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));\n        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));\n        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));\n\n        NSLog(@\"\\nn1:%d \\nn2:%d \\nn3:%d \\nn4:%d \",n1_tag,n2_tag,n3_tag,n4_tag);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n//log\n\n0xbf4071e2657ccb95 \n0xbf4071e2657ccb85 \n0xbf4071e2657ccbf5 \n0xbf40751d9a833444\n2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] \nn1:1 \nn2:1 \nn3:1 \nn4:0\n```\n\n可以看到`n1 n2 n3`是经过优化的，而`n4`是大数字，指针容不下该数值，不能优化。\n#### NSString Tagged Pointer\n看下面一道题,运行`test1`和`test2`会出现什么问题？\n\n```\n- (void)test1{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1000; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abc\"];\n\t\t});\n\t}\n}\n- (void)test2{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1000; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abcsefafaefafafaefe\"];\n\t\t});\n\t}\n}\n```\n我们先不运行，先分析一下。\n\n首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致`_name`结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下\n\n```\nThread: EXC_BAD_ACCESS(code = 1)\n```\n直接在子线程崩溃了，崩溃函数是`objc_release`。符合我们的猜想。\n\n验证`NSString Tagged Pointer`\n\n```\n- (void)test{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abc\"];\n\t\t\tNSLog(@\"test1 class:%@\",self.name.class);\n\t\t});\n\t}\n}\n- (void)test2{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abcsefafaefafafaefe\"];\n\t\t\tNSLog(@\"test2 class:%@\",self.name.class);\n\t\t});\n\t}\n}\n//log\ntest1 class:NSTaggedPointerString\ntest2 class:__NSCFString\n```\n可以看到`NSString Tagged Pointer`在小字符串的时候类是`NSTaggedPointerString`，经过优化的类，大字符串的类是`__NSCFString`，\n\n\n### copy\n拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。\n\n拷贝目的：产生一个副本对象，跟源对象互不影响\n 修改源对象，不会影响到副本对象\n 修改副本对象，不会影响源对象\n \n iOS提供了2中拷贝方法\n 1. copy 拷贝出来不可变对象\n 2. mutableCopy 拷贝出来可变对象\n \n \n```\nvoid test1(){\n\tNSString *str = @\"strstrstrstr\";\n\tNSMutableString *mut1 =[str mutableCopy];\n\t[mut1 appendFormat:@\"123\"];\n\tNSString *str2 = [str copy];\n\tNSLog(@\"%p %p %p\",str,mut1,str2);\n}\n//log\nstr:0x100001040 \nmut1:0x1007385f0 \nstr2:0x100001040\n```\n\n可以看到`str`和`str2`地址一样，没有重新复制出来一份，`mut1`地址和`str`不一致，是深拷贝，重新拷贝了一份。\n\n我们把字符串换成其他常用的数组\n\n```\nvoid test2(){\n\tNSArray *array = @[@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\"];\n\tNSMutableArray *mut =[array mutableCopy];\n\tNSString *array2 = [array copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",array,mut,array2);\n}\n//log\n0x102840800 \n0x1028408a0\n0x102840800\n\nvoid test3(){\n\tNSArray *array = [@[@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\"] mutableCopy];\n\tNSMutableArray *mut =[array mutableCopy];\n\tNSString *array2 = [array copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",array,mut,array2);\n}\n//log\n0x102808720 \n0x1028088a0\n0x1028089a0\n```\n\n从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。\n\n我们再换成其他的常用的字典\n\n```\nvoid test4(){\n\tNSDictionary *item = @{@\"key\":@\"value\"};\n\tNSMutableDictionary *mut =[item mutableCopy];\n\tNSDictionary *item2 = [item copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",item,mut,item2);\n}\n\n//log\n0x1007789c0 \n0x100779190\n0x1007789c0\n\nvoid test5(){\n\tNSDictionary *item = [@{@\"key\":@\"value\"}mutableCopy];\n\tNSMutableDictionary *mut =[item mutableCopy];\n\tNSDictionary *item2 = [item copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",item,mut,item2);\n}\n//log\n\n0x1007041d0 \n0x1007042b0\n0x1007043a0\n```\n\n从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。\n\n由这几个看出来，总结出来下表\n\n|类型|copy|mutableCopy|\n|:-:|:-:|:-:|\n|NSString|浅拷贝|深拷贝|\n|NSMutableString|浅拷贝|深拷贝|\n|NSArray|浅拷贝|深拷贝|\n|NSMutableArray|深拷贝|深拷贝|\n|NSDictionary|浅拷贝|深拷贝|\n|NSMutableDictionary|深拷贝|深拷贝|\n\n#### 自定义对象实现协议NSCoping\n自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承`NSCopying`\n\n```\n@protocol NSCopying\n\n- (id)copyWithZone:(nullable NSZone *)zone;\n\n@end\n\n@protocol NSMutableCopying\n\n- (id)mutableCopyWithZone:(nullable NSZone *)zone;\n\n@end\n\n```\n\n看到`NSCopying`和`NSMutableCopying`这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现`NSCopying`协议就好了。\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age;\n@property (nonatomic,assign) int level;\n\n@end\n\n@interface FYPerson()<NSCopying>\n@end\n\n@implementation FYPerson\n-(instancetype)copyWithZone:(NSZone *)zone{\n\tFYPerson *p=[[FYPerson alloc]init];\n\tp.age = self.age;\n\tp.level = self.level;\n\treturn p;\n}\n\n@end\n\n\nFYPerson *p =[[FYPerson alloc]init];\np.age = 10;\np.level = 11;\nFYPerson *p2 =[p copy];\nNSLog(@\"%d %d\",p2.age,p2.level);\n//log\n10 11\n```\n\n自己实现了`NSCoping`协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用`runtime`实现一个一劳永逸的方案。\n\n然后将`copyWithZone`利用`runtime`遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。\n\n```\n@implementation NSObject (add)\n-(instancetype)copyWithZone:(NSZone *)zone{\n    Class cls = [self class];\n    NSObject * p=[cls new];\n    //成员变量个数\n    unsigned int count;\n    //赋值成员变量数组\n    Ivar *ivars = class_copyIvarList(self.class, &count);\n    //遍历数组\n    for (int i = 0; i < count; i ++) {\n        Ivar var = ivars[i];\n        //获取成员变量名字\n        const char * name = ivar_getName(var);\n        if (name != nil) {\n            NSString *v = [NSString stringWithUTF8String:name];\n            id value = [self valueForKey:v];\n            //给新的对象赋值\n            if (value != NULL) {\n                [p setValue:value forKey:v];\n            }\n        }\n    }\n    free(ivars);\n    return p;\n}\n@end\n\nFYPerson *p =[[FYPerson alloc]init];\np.age = 10;\np.level = 11;\np.name = @\"xiaowang\";\nFYPerson *p2 =[p copy];\nNSLog(@\"%d %d %@\",p2.age,p2.level,p2.name);\n\t\t\n//log\n10 \n11 \nxiaowang\n```\n\n根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以\n在基类`NSObject`在类别中重写了`-(instancetype)copyWithZone:(NSZone *)zone`方法，子类就不用重写了。达成了一劳永逸的方案。\n\n\n### 引用计数原理\n摘自[百度百科](https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin)\n\n> 引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法\n\n在iOS中，使用引用计数来管理`OC`对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，`OC`对象就会销毁，释放其他内存空间，调用`retain`会让`OC`对象的引用计数+1，调用`release`会让`OC`对象的引用计数-1。\n当调用`alloc、new、copy、mutableCopy`方法返回一个对象，在不需要这个对象时，要调用`release`或者`autorelease`来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.\n\n在MRC中我们经常都是这样子使用的\n\n```\nFYPerson *p=[[FYPerson alloc]init];\nFYPerson *p2 =[p retain];\n//code here\n[p release];\n[p2 release];\n```\n\n但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。\n\n\n引用计数存储在`isa`指针中的`extra_rc`，存储值大于这个范围的时候，则`bits.has_sidetable_rc=1`然后将剩余的`RetainCount`存储到全局的`table`，`key`是`self`对应的值。\n\n`Retain`的`runtime`源码查找函数路径`objc_object::retain()`->`objc_object::rootRetain()`->`objc_object::rootRetain(bool, bool)`\n\n```\n//大概率x==1 提高读取指令的效率\n#define fastpath(x) (__builtin_expect(bool(x), 1))\n//大概率x==0 提高读取指令的效率\n#define slowpath(x) (__builtin_expect(bool(x), 0))\n\n\n//引用计数+1\n//tryRetain 尝试+1\n//handleOverflow 是否覆盖\nALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)\n{\n\t//优化的指针 返回this\n    if (isTaggedPointer()) return (id)this;\n\n    bool sideTableLocked = false;\n    bool transcribeToSideTable = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n    do {\n        transcribeToSideTable = false;\n\t\t//old bits\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n\t\t//使用联合体技术\n        if (slowpath(!newisa.nonpointer)) {\n            ClearExclusive(&isa.bits);//nothing\n            if (!tryRetain && sideTableLocked) sidetable_unlock();//解锁\n            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;\n\t\t\telse return sidetable_retain();////sidetable 引用计数+1\n        }\n        // don't check newisa.fast_rr; we already called any RR overrides\n\t\t//不尝试retain 和 正在销毁 什么都不做 返回 nil\n        if (slowpath(tryRetain && newisa.deallocating)) {\n            ClearExclusive(&isa.bits);\n            if (!tryRetain && sideTableLocked) sidetable_unlock();\n            return nil;\n        }\n        uintptr_t carry;\n\t\t//引用计数+1 (bits.extra_rc++;)\n        newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++\n\n        if (slowpath(carry)) {\n            // newisa.extra_rc++ 溢出处理\n            if (!handleOverflow) {\n                ClearExclusive(&isa.bits);\n                return rootRetain_overflow(tryRetain);\n            }\n\t\t\t//为拷贝到side table 做准备\n            if (!tryRetain && !sideTableLocked) sidetable_lock();\n            sideTableLocked = true;\n            transcribeToSideTable = true;\n            newisa.extra_rc = RC_HALF;\n            newisa.has_sidetable_rc = true;\n        }\n    } while (slowpath(!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)));\n\n    if (slowpath(transcribeToSideTable)) {\n\t\t//拷贝 平外一半的 引用计数到 side table\n        sidetable_addExtraRC_nolock(RC_HALF);\n    }\n\n    if (slowpath(!tryRetain && sideTableLocked)) sidetable_unlock();\n    return (id)this;\n}\n\n//sidetable 引用计数+1\nid objc_object::sidetable_retain()\n{\n#if SUPPORT_NONPOINTER_ISA\n    assert(!isa.nonpointer);\n#endif\n\t//取出table key=this\n    SideTable& table = SideTables()[this];\n    \n    table.lock();\n    size_t& refcntStorage = table.refcnts[this];\n    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {\n        refcntStorage += SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n\n    return (id)this;\n}\n```\n\n引用计数+1，判断了需要是指针没有优化和`isa`有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将`extra_rc`的值复制到`side table`中，设置参数`isa->has_sidetable_rc=true`。\n\n引用计数-1，在`runtime`源码中查找路径是`objc_object::release()`->`objc_object::rootRelease()`->`objc_object::rootRelease(bool performDealloc, bool handleUnderflow)`,我们进入到函数内部\n\n```\nALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;//指针优化的不存在计数器\n\n    bool sideTableLocked = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n retry:\n    do {//isa\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n        if (slowpath(!newisa.nonpointer)) {\n            ClearExclusive(&isa.bits);\n            if (sideTableLocked) sidetable_unlock();\n\t\t\t//side table -1\n            return sidetable_release(performDealloc);\n        }\n        uintptr_t carry;\n        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--\n        if (slowpath(carry)) {\n            // don't ClearExclusive()\n            goto underflow;\n        }\n    } while (slowpath(!StoreReleaseExclusive(&isa.bits, \n                                             oldisa.bits, newisa.bits)));\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n    return false;\n\n underflow:\n    newisa = oldisa;\n\n    if (slowpath(newisa.has_sidetable_rc)) {\n        if (!handleUnderflow) {\n            ClearExclusive(&isa.bits);\n            return rootRelease_underflow(performDealloc);\n        }\n\n        if (!sideTableLocked) {\n            ClearExclusive(&isa.bits);\n            sidetable_lock();\n            sideTableLocked = true;\n            goto retry;\n        }\n\n\t\t//side table 引用计数-1\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n\n        if (borrowed > 0) {\n            newisa.extra_rc = borrowed - 1;  // redo the original decrement too\n            bool stored = StoreReleaseExclusive(&isa.bits, \n                                                oldisa.bits, newisa.bits);\n            if (!stored) {\n                isa_t oldisa2 = LoadExclusive(&isa.bits);\n                isa_t newisa2 = oldisa2;\n                if (newisa2.nonpointer) {\n                    uintptr_t overflow;\n                    newisa2.bits = \n                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);\n                    if (!overflow) {\n                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, \n                                                       newisa2.bits);\n                    }\n                }\n            }\n\n            if (!stored) {\n                // Inline update failed.\n                // Put the retains back in the side table.\n                sidetable_addExtraRC_nolock(borrowed);\n                goto retry;\n            }\n\n            sidetable_unlock();\n            return false;\n        }\n        else {\n            // Side table is empty after all. Fall-through to the dealloc path.\n        }\n    }\n\n\t//真正的销毁\n\n    if (slowpath(newisa.deallocating)) {\n        ClearExclusive(&isa.bits);\n        if (sideTableLocked) sidetable_unlock();\n        return overrelease_error();\n        // does not actually return\n    }\n\t//设置正在销毁\n    newisa.deallocating = true;\n    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n\n    __sync_synchronize();\n    if (performDealloc) {\n\t\t//销毁\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    return true;\n}\n```\n看了上边了解到引用计数分两部分，`extra_rc`和`side table`，探究一下\n`rootRetainCount()`的实现\n\n```\ninline uintptr_t  objc_object::rootRetainCount()\n{\n\t//优化指针 直接返回\n    if (isTaggedPointer()) return (uintptr_t)this;\n//没优化则 到SideTable 读取\n    sidetable_lock();\n\t//isa指针\n    isa_t bits = LoadExclusive(&isa.bits);\n    ClearExclusive(&isa.bits);//啥都没做\n    if (bits.nonpointer) {//使用联合体存储更多的数据 \n        uintptr_t rc = 1 + bits.extra_rc;//计数数量\n        if (bits.has_sidetable_rc) {//当大过于 联合体存储的值 则另外在SideTable读取数据\n\t//读取table的值 相加\n            rc += sidetable_getExtraRC_nolock();\n        }\n        sidetable_unlock();\n        return rc;\n    }\n\n    sidetable_unlock();\n\t//在sidetable 中存储的count\n    return sidetable_retainCount();\n}\n```\n当是存储小数据的时候，指针优化，则直接返回`self`,大数据的话，则`table`加锁，\n`class`优化的之后[使用联合体存储更多的数据](https://juejin.im/post/5d2bcf3df265da1b67213d69),`class`没有优化则直接去`sizedable`读取数据。\n优化了则在`sidetable_getExtraRC_nolock()`读取数据\n\n```\n//使用联合体\nsize_t  objc_object::sidetable_getExtraRC_nolock()\n{\n\t//不是联合体技术 则报错\n    assert(isa.nonpointer);\n\t//key是 this，存储了每个对象的table\n    SideTable& table = SideTables()[this];\n\t//找到 it 否则返回0\n    RefcountMap::iterator it = table.refcnts.find(this);\n    if (it == table.refcnts.end()) return 0;\n    else return it->second >> SIDE_TABLE_RC_SHIFT;\n}\n```\n没有优化的是直接读取\n\n```\n//未使用联合体的情况，\nuintptr_t objc_object::sidetable_retainCount()\n{//没有联合体存储的计数器则直接在table中取出来\n    SideTable& table = SideTables()[this];\n    size_t refcnt_result = 1;\n    table.lock();\n    RefcountMap::iterator it = table.refcnts.find(this);\n    if (it != table.refcnts.end()) {\n        refcnt_result += it->second >> SIDE_TABLE_RC_SHIFT;\n    }\n    table.unlock();\n    return refcnt_result;\n}\n```\n\n### weak指针原理\n\n当一个对象要销毁的时候会调用`dealloc`,调用轨迹是`dealloc`->`_objc_rootDealloc`->`object_dispose`->`objc_destructInstance`->`free`\n我们进入到`objc_destructInstance`内部\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n\t\t//c++析构函数\n        bool cxx = obj->hasCxxDtor();\n\t\t//关联函数\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        obj->clearDeallocating();\n    }\n    return obj;\n}\n```\n销毁了c++析构函数和关联函数最后进入到`clearDeallocating`，我们进入到函数内部\n\n```\n//正在清除side table 和weakly referenced\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n\t\t//释放weak\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n\t\t//释放weak 和引用计数\n        clearDeallocating_slow();\n    }\n    assert(!sidetable_present());\n}\n```\n最终调用了`sidetable_clearDeallocating`和`clearDeallocating_slow`实现销毁`weak`和引用计数`side table`。\n\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    assert(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n\t//清除weak\n    if (isa.weakly_referenced) {\n\t\t//table.weak_table 弱引用表\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n\t//引用计数\n    if (isa.has_sidetable_rc) {\n\t\t//擦除 this\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n其实`weak`修饰的对象会存储在全局的`SideTable`，当对象销毁的时候会在`SideTable`进行查找，时候有`weak`对象，有的话则进行销毁。\n\n### Autoreleasepool 原理\n`Autoreleasepool`中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，`release`里边的对象(引用计数-1)。\n我们将下边的代码转化成c++\n\n```\n@autoreleasepool {\n\t\tFYPerson *p = [[FYPerson alloc]init];\n\t}\n```\n使用`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m`\n转成c++\n\n```\n /* @autoreleasepool */ {\n  __AtAutoreleasePool __autoreleasepool;\n  FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"FYPerson\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n }\n```\n`__AtAutoreleasePool`是一个结构体\n\n```\nstruct __AtAutoreleasePool {\n\t__AtAutoreleasePool() {//构造函数 生成结构体变量的时候调用\n\t\tatautoreleasepoolobj = objc_autoreleasePoolPush();\n\t}\n\t~__AtAutoreleasePool() {//析构函数 销毁的时候调用\n\t\tobjc_autoreleasePoolPop(atautoreleasepoolobj);\n\t}\n\tvoid * atautoreleasepoolobj;\n};\n```\n\n然后将上边的代码和c++整合到一起就是这样子\n\n```\n{\n    __AtAutoreleasePool pool = objc_autoreleasePoolPush();\n    FYPerson *p = [[FYPerson alloc]init];\n    objc_autoreleasePoolPop(pool)\n}\n```\n\n在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在`runtime`源码中`NSObject.mm 1848 行`\n\n```\nvoid objc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n`pop`实现了`AutoreleasePoolPage`中的对象的释放，想了解怎么释放的可以研究下源码`runtime NSObject.mm 1063行`。\n\n\n其实`AutoreleasePool`是`AutoreleasePoolPage`来管理的，`AutoreleasePoolpage`结构如下\n\n```\nclass AutoreleasePoolPage {\n    magic_t const magic;\n    id *next;//下一个存放aotoreleass对象的地址\n    pthread_t const thread;//线程\n    AutoreleasePoolPage * const parent; //父节点\n    AutoreleasePoolPage *child;//子节点\n    uint32_t const depth;//深度\n    uint32_t hiwat;\n}\n```\n\n`AutoreleasePoolPage`在初始化在`autoreleaseNewPage`申请了`4096`字节除了自己变量的空间，`AutoreleasePoolPage`是一个`C++`实现的类\n- 内部使用`id *next`指向了栈顶最新`add`进来的`autorelease`对象的下一个位置\n- 一个`AutoreleasePoolPage`的空间被占满时，会新建一个`AutoreleasePoolPage`对象，连接链表，后来的`autorelease`对象在新的`page`加入\n- `AutoreleasePoolPage`每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存`autorelease`对象的地址\n- `AutoreleasePool`是按线程一一对应的（结构中的`thread`指针指向当前线程）\n- `AutoreleasePool`并没有单独的结构，而是由若干个`AutoreleasePoolPage`以双向链表的形式组合而成（分别对应结构中的`parent`指针和`child`指针）\n\n\n其他的都是自动释放池的其他对象的指针，我们使用`_objc_autoreleasePoolPrint()`可以查看释放池的存储内容\n\n```\nextern void _objc_autoreleasePoolPrint(void);\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {//r1 = push()\n\n\t\tFYPerson *p = [[FYPerson alloc]init];\n\t\t_objc_autoreleasePoolPrint();\n\t\tprintf(\"\\n--------------\\n\");\n\t}//pop(r1)\n\treturn 0;\n}\n//log\n\nobjc[23958]: ##############\nobjc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0\nobjc[23958]: 3 releases pending.\nobjc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)\nobjc[23958]: [0x101000038]  ################  POOL 0x101000038\nobjc[23958]: [0x101000040]       0x10050cfa0  FYPerson\nobjc[23958]: [0x101000048]       0x10050cdb0  FYPerson\nobjc[23958]: ##############\n\n--------------\n```\n\n可以看到存储了`3 releases pending`一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {//r1 = push()\n\n\t\tFYPerson *p = [[[FYPerson alloc]init] autorelease];\n\t\tFYPerson *p2 = [[[FYPerson alloc]init] autorelease];\n\t\t@autoreleasepool {//r1 = push()\n\t\t\t\n\t\t\tFYPerson *p3 = [[[FYPerson alloc]init] autorelease];\n\t\t\tFYPerson *p4 = [[[FYPerson alloc]init] autorelease];\n\t\t\t\n\t\t\t_objc_autoreleasePoolPrint();\n\t\t\tprintf(\"\\n--------------\\n\");\n\t\t}//pop(r1)\n\t}//pop(r1)\n\treturn 0;\n}\n//log\nobjc[24025]: ##############\nobjc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0\nobjc[24025]: 6 releases pending.\nobjc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)\nobjc[24025]: [0x100803038]  ################  POOL 0x100803038\nobjc[24025]: [0x100803040]       0x100721580  FYPerson\nobjc[24025]: [0x100803048]       0x100721b10  FYPerson\nobjc[24025]: [0x100803050]  ################  POOL 0x100803050\nobjc[24025]: [0x100803058]       0x100721390  FYPerson\nobjc[24025]: [0x100803060]       0x100717620  FYPerson\nobjc[24025]: ##############\n```\n看到了2个`POOL`和四个`FYPerson`对象，一共是6个对象，当出了释放池会执行`release`。\n\n当无优化的指针调用`autorelease`其实是调用了`AutoreleasePoolPage::autorelease((id)this)`->`autoreleaseFast(obj)`\n\n```\n   static inline id *autoreleaseFast(id obj)\n    {\n        AutoreleasePoolPage *page = hotPage();\n        //当有分页而且分页没有满就添加\n        if (page && !page->full()) {\n            return page->add(obj);\n        } else if (page) {\n            //满则新建一个page进行添加obj和设置hotpage\n            return autoreleaseFullPage(obj, page);\n        } else {\n            //没有page则新建page进行添加\n            return autoreleaseNoPage(obj);\n        }\n    }\n```\n\n在`MRC`中\n`autorealease`修饰的是的对象在没有外部添加到自动释放池的时候，在`runloop`循环的时候会销毁\n\n```\n\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n\n//activities = 0xa0转化成二进制 0b101 0000\n系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据\n//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler\n\n\"<CFRunLoopObserver 0x600002538320 [0x10ce45ae8]>{valid = Yes, activities = 0xa0, \nrepeats = Yes, order = 2147483647, \ncallout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), \ncontext = <CFArray 0x600001a373f0 [0x10ce45ae8]>{type = mutable-small, count = 1, \nvalues = (\\n\\t0 : <0x7fb6dc004058>\\n)}}\"\n```\n\n`activities = 0xa0`转化成二进制 `0b101 0000`\n系统监听了`mainRunloop` 的 `kCFRunLoopBeforeWaiting` 和`kCFRunLoopExit`两种状态来更新`autorelease`的数据\n回调函数是 `_wrapRunLoopWithAutoreleasePoolHandler`。\n\n```\nvoid test(){\n    FYPerson *p =[[FYPerson alloc]init];\n}\n```\n\n`p`对象在某次循环中`push`，在循环到`kCFRunLoopBeforeWaiting`进行一次`pop`，则上次循环的`autolease`对象没有其他对象`retain`的进行释放。并不是出了`test()`立马释放。\n\n在ARC中则执行完毕`test()`会马上释放。\n### 总结\n- 当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。\n- 存在在全局的`SideTable`中weak修饰的对象会在`dealloc`函数执行过程中检测或销毁该对象。\n- 可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。\n- 优化的指向对象的指针，不用走`objc_msgSend()`的消息流程从而提高性能。\n- `CADisplayLink`和`Timer`本质是加到`loop`循环当中，依附于循环，没有`runloop`，则不能正确执行，使用`runloop`需要注意循环引用和`runloop`所在的线程的释放问题。\n\n### 参考资料\n- [黑幕背后的Autorelease\n](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n- 小码哥视频\n- iOS和OS多线程与内存管理\n- iOS和macOS性能优化\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 内存管理 那些你不知道的原理汇总 — (12).md","raw":"title: iOS底层原理  内存管理 那些你不知道的原理汇总 --(12)\ndate: 2019-12-1 11:22:58\ntags:\n- iOS\ncategories: iOS\n---\n\n看完本文章你将了解到\n> 1. DisplayLink和timer的使用和原理\n> 2. 内存分配和内存管理\n> 3. 自动释放池原理\n> 4. weak指针原理和释放时机\n> 5. 引用计数原理\n\n\n### DisplayLink\n`CADisplayLink`是将任务添加到`runloop`中，`loop`每次循环便会调用`target`的`selector`，使用这个也能监测卡顿问题。首先介绍下`API`\n\n```\n+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;\n//runloop没循环一圈都会调用\n- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;\n//从runloop中删除\n- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;\n//取消\n- (void)invalidate;\n```\n我们在一个需要`push`的`VC`中运行来观察声明周期\n\n```\n@property (nonatomic,strong) CADisplayLink *link;\n\n//初始化\nself.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];\n[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];\ntimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\ndispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);\ndispatch_source_set_event_handler(timer, ^{\n\t@synchronized (self) {\n\t\tNSLog(@\"FPS:%d\",fps);\n\t\tfps = 0;\n\t}\n});\ndispatch_resume(timer);\n//全局变量\ndispatch_source_t timer;\nstatic int fps;\n\n- (void)test{\n\t\n\t@synchronized (self) {\n\t\tfps += 1;\n\t}\n}\n- (void)dealloc{\n\t[self.link invalidate];\n\tNSLog(@\"%s\",__func__);\n}\n//log\n2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89\n2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60\n2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60\n```\n\n初始化之后，对`fps`使用了简单版本的读写锁，可以看到`fps`基本稳定在60左右，点击按钮返回之后，`link`和`VC`并没有正常销毁。我们分析一下，`VC（self）`->`link`->`target(self)`,导致了死循环，释放的时候，无法释放`self`和`link`,那么我们改动一下`link`->`target(self)`中的强引用，改成弱引用，代码改成下面的\n\n```\n@interface FYTimerTarget : NSObject\n@property (nonatomic,weak) id target;\n@end\n\n@implementation FYTimerTarget\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n\treturn self.target;\n}\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n@end\n\n\nFYProxy *proxy=[FYProxy proxyWithTarget:self];\nself.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];\n[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];\n\n- (void)test{\n\tNSLog(@\"%s\",__func__);\n}\n\n//log\n2019-07-30 17:59:04.339934 -[ViewController test]\n2019-07-30 17:59:04.356292 -[ViewController test]\n2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]\n2019-07-30 17:59:04.371634 -[ViewController dealloc]\n```\n\n`FYTimerTarget`对`target`进行了弱引用，`self`对`FYTimerTarget`进行强引用，在销毁了的时候，先释放`self`,然后检查`self`的`FYTimerTarget`,`FYTimerTarget`只有一个参数`weak`属性，可以直接释放，释放完`FYTimerTarget`，然后释放`self(VC)`，最终可以正常。\n\n\n### NSTimer\n使用`NSTimer`的时候，`timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo`会对`aTarget`进行强引用，所以我们对这个`aTarget`进行一个简单的封装\n\n```\n@interface FYProxy : NSProxy\n@property (nonatomic,weak) id target;\n\n+(instancetype)proxyWithTarget:(id)target;\n@end\n@implementation FYProxy\n- (void)dealloc{\n\tNSLog(@\"%s\",__func__);\n}\n+ (instancetype)proxyWithTarget:(id)target{\n\tFYProxy *obj=[FYProxy alloc];\n\tobj.target = target;\n\treturn obj;\n}\n//转发\n- (void)forwardInvocation:(NSInvocation *)invocation{\n\t[invocation invokeWithTarget:self.target];\n}\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{\n\treturn [self.target methodSignatureForSelector:sel];\n}\n@end\n```\n`FYProxy`是继承`NSProxy`，而`NSProxy`不是继承`NSObject`的,而是另外一种基类，不会走`objc_msgSend()`的三大步骤，当找不到函数的时候直接执行`- (void)forwardInvocation:(NSInvocation *)invocation`，和`- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel`直接进入消息转发阶段。或者将继承关系改成`FYTimerTarget : NSObject`,这样子`target`找不到的函数还是会走消息转发的三大步骤，我们再`FYTimerTarget`添加消息动态解析\n```\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n\treturn self.target;\n}\n```\n这样子`target`的`aSelector`转发给了`self.target`处理，成功弱引用了`self`和函数的转发处理。\n\n\n```\nFYTimerTarget *obj =[FYTimerTarget new];\nobj.target = self;\n\nself.timer = [NSTimer timerWithTimeInterval:1.0f\n\t\t\t\t\t\t\t\t\ttarget:obj\n\t\t\t\t\t\t\t\t   selector:@selector(test)\n\t\t\t\t\t\t\t\t   userInfo:nil\n\t\t\t\t\t\t\t\t\trepeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n[self.timer setFireDate:[NSDate distantPast]];\n\n//log\n2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]\n2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]\n2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]\n2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]\n```\n\n或者使用`timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block`，然后外部使用`__weak self`调用函数，也不会产生循环引用。\n使用`block`的情况，释放正常。\n\n```\nself.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n\tNSLog(@\"123\");\n}];\n\n//log\n2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123\n2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123\n2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]\n```\n\n由于`link`和`timer`是添加到`runloop`中使用的，每次一个循环则访问`timer`或者`link`，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。\n\n### GCD中timer\n`GCD`中的`dispatch_source_t`的定时器是基于内核的，时间误差相对较少。\n\n```\n//timer 需要强引用 或者设置成全局变量\n    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());\n    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);\n    //设置\n    dispatch_source_set_event_handler(timer, ^{\n  //code 定时器执行的代码\n \n    });\n    //开始定时器\n    dispatch_resume(timer);\n```\n\n或者使用函数`dispatch_source_set_event_handler_f(timer, function_t);`\n\n```\ndispatch_source_set_event_handler_f(timer, function_t);\nvoid function_t(void * p){\n    //code here    \n}\n```\n\n业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？\n\n首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。\n先定义一个函数\n\n```\n+ (NSString *)exeTask:(dispatch_block_t)block\n    \t  start:(NSTimeInterval)time\n       interval:(NSTimeInterval)interval\n    \t repeat:(BOOL)repeat\n    \t  async:(BOOL)async;\n+ (NSString *)exeTask:(id)target\n\t\t  sel:(SEL)aciton\n\t\tstart:(NSTimeInterval)time\n\t interval:(NSTimeInterval)interval\n\t   repeat:(BOOL)repeat\n\t\tasync:(BOOL)async;\n//取消\n+ (void)exeCancelTask:(NSString *)key;\n```\n\n然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回`nil`，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的`key`,`timer`为`value`存储到全局变量中，在取消的时候直接用`key`取出`timer`取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。\n\n```\n+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async{\n\tif (block == nil) {\n\t\treturn nil;\n\t}\n\tif (repeat && interval <= 0) {\n\t\treturn nil;\n\t}\n\t\n\tNSString *name =[NSString stringWithFormat:@\"%d\",i];\n\t//主队列\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tif (async) {\n\t\tqueue = dispatch_queue_create(\"async.com\", DISPATCH_QUEUE_CONCURRENT);\n\t}\n\t//创建定时器\n\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\t//设置启动时间\n\tdispatch_source_set_timer(_timer,\n\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);\n\t//设定回调\n\tdispatch_source_set_event_handler(_timer, ^{\n\t\tblock();\n\t\tif (repeat == NO) {\n\t\t\tdispatch_source_cancel(_timer);\n\t\t}\n\t});\n\t//启动定时器\n\tdispatch_resume(_timer);\n\t//存放到字典\n\tif (name.length && _timer) {\n\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\t\ttimers[name] = _timer;\n\t\tdispatch_semaphore_signal(samephore);\n\t}\n\treturn name;\n}\n\n\n\n+ (NSString *)exeTask:(id)target\n\t\t\t\t  sel:(SEL)aciton\n\t\t\t\tstart:(NSTimeInterval)time\n\t\t\t interval:(NSTimeInterval)interval\n\t\t\t   repeat:(BOOL)repeat\n\t\t\t\tasync:(BOOL)async{\n\tif (target == nil || aciton == NULL) {\n\t\treturn nil;\n\t}\n\tif (repeat && interval <= 0) {\n\t\treturn nil;\n\t}\n\t\n\tNSString *name =[NSString stringWithFormat:@\"%d\",i];\n\t//主队列\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tif (async) {\n\t\tqueue = dispatch_queue_create(\"async.com\", DISPATCH_QUEUE_CONCURRENT);\n\t}\n\t//创建定时器\n\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\t//设置启动时间\n\tdispatch_source_set_timer(_timer,\n\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);\n\t//设定回调\n\tdispatch_source_set_event_handler(_timer, ^{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored\"-Warc-performSelector-leaks\"\n\t\t//这里是会报警告的代码\n\t\tif ([target respondsToSelector:aciton]) {\n\t\t\t[target performSelector:aciton];\n\t\t}\n#pragma clang diagnostic pop\n\n\t\tif (repeat == NO) {\n\t\t\tdispatch_source_cancel(_timer);\n\t\t}\n\t});\n\t//启动定时器\n\tdispatch_resume(_timer);\n\t//存放到字典\n\tif (name.length && _timer) {\n\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\t\ttimers[name] = _timer;\n\t\tdispatch_semaphore_signal(samephore);\n\t}\n\treturn name;\n}\n+ (void)exeCancelTask:(NSString *)key{\n\tif (key.length == 0) {\n\t\treturn;\n\t}\n\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);\n\tif ([timers.allKeys containsObject:key]) {\n\t\tdispatch_source_cancel(timers[key]);\n\t\t[timers removeObjectForKey:key];\n\t}\n\tdispatch_semaphore_signal(samephore);\n}\n```\n\n用的时候很简单\n\n```\nkey = [FYTimer exeTask:^{\n        NSLog(@\"123\");\n    } start:1\n    interval:1 \n    repeat:YES \n    async:NO];\n```\n\n或者\n\n```\nkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];\n```\n\n取消执行的时候\n\n```\n[FYTimer exeCancelTask:key];\n```\n\n测试封装的定时器\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];\n}\n-(void)test{\n\tNSLog(@\"%@\",[NSThread currentThread]);\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\t[FYTimer exeCancelTask:key];\n}\n//log\n2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] <NSThread: 0x6000010ec000>{number = 4, name = (null)}\n2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]\n```\n\n在点击`VC`的时候进行取消操作，`timer`停止。\n\n### NSProxy实战\n`NSProxy`其实是除了`NSObject`的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。\n\n问题：`ret1`和`ret2`分别是多少？\n\n```\nViewController *vc1 =[[ViewController alloc]init];\nFYProxy *pro1 =[FYProxy proxyWithTarget:vc1];\n\nFYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];\nBOOL ret1 = [pro1 isKindOfClass:ViewController.class];\nBOOL ret2 = [tar isKindOfClass:ViewController.class];\nNSLog(@\"%d %d\",ret1,ret2);\n```\n\n\n我们来分析一下，`-(bool)isKindOfClass:(cls)`对象函数是判断该对象是否的`cls`的子类或者该类的实例，这点不容置疑，那么`ret1`应该是`0`,`ret2`应该也是`0`\n\n\n\n首先看`FYProxy`的实现，`forwardInvocation`和`methodSignatureForSelector`，在没有该函数的时候进行消息转发，转发对象是`self.target`，在该例子中`isKindOfClass`不存在与`FYProxy`，所以讲该函数转发给了`VC`，则`BOOL ret1 = [pro1 isKindOfClass:ViewController.class];`相当于`BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];`，所以答案是1\n\n然后`ret2`是0，`tar`是继承于`NSObject`的，本身有`-(bool)isKindOfClass:(cls)`函数，所以答案是0。\n\n答案是：`ret1`是`1`，`ret2`是`0`。\n\n\n### 内存分配\n内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。\n\n数据段包括\n- 字符串常量：比如NSString * str = @\"11\"\n- 已初始化数据：已初始化的全局变量、静态变量等\n- 未初始化数据：未初始化的全局变量、静态变量等\n\n栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。\n\n堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。\n\n验证：\n\n```\nint a = 10;\nint b ;\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        static int c = 20;\n        static int d;\n        int e = 10;\n        int f;\n        NSString * str = @\"123\";\n        NSObject *obj =[[NSObject alloc]init];\n        NSLog(@\"\\na:%p \\nb:%p \\nc:%p \\nd:%p \\ne:%p \\nf:%p \\nobj:%p\\n str:%p\",&a,&b,&c,&d,&e,&f,obj,str);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n//log\n\na:0x1063e0d98 \nb:0x1063e0e64 \nc:0x1063e0d9c \nd:0x1063e0e60 \ne:0x7ffee9820efc \nf:0x7ffee9820ef8 \nobj:0x6000013541a0\nstr:0x1063e0068\n```\n### Tagged Pointer\n\n从64bit开始，iOS引入`Tagged Pointer`技术，用于优化`NSNumber、NSDate、NSString`等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用`Tagged Pointer`之后，`NSNumber`指针里面的数据变成了`Tag+Data`，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且`objc_msgSend()`能够识别出`Tagged Pointer`，比如`NSNumber`的`intValue`方法，直接从指针提取数据，节省了以前的调用的开销。\n在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。\n在`runtime`源码中`objc-internal.h 370行`判断是否使用了优化技术\n\n```\nstatic inline void * _Nonnull\n_objc_encodeTaggedPointer(uintptr_t ptr)\n{\n    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);\n}\n```\n\n我们拿来这个可以判断对象是否使用了优化技术。\n#### NSNumbe Tagged Pointer\n我们使用几个`NSNumber`的大小数字来验证\n\n```\n#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__ //mac开发\n// 64-bit Mac - tag bit is LSB\n#   define OBJC_MSB_TAGGED_POINTERS 0\n#else\n// Everything else - tag bit is MSB\n#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发\n#endif\n\n#if OBJC_MSB_TAGGED_POINTERS\n#   define _OBJC_TAG_MASK (1UL<<63)\n#else\n#   define _OBJC_TAG_MASK 1UL\n#endif\nbool objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        NSNumber *n1 = @2;\n        NSNumber *n2 = @3;\n        NSNumber *n3 = @(4);\n        NSNumber *n4 = @(0x4fffffffff);\n        NSLog(@\"\\n%p \\n%p \\n%p \\n%p\",n1,n2,n3,n4);\n        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));\n        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));\n        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));\n        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));\n\n        NSLog(@\"\\nn1:%d \\nn2:%d \\nn3:%d \\nn4:%d \",n1_tag,n2_tag,n3_tag,n4_tag);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n//log\n\n0xbf4071e2657ccb95 \n0xbf4071e2657ccb85 \n0xbf4071e2657ccbf5 \n0xbf40751d9a833444\n2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] \nn1:1 \nn2:1 \nn3:1 \nn4:0\n```\n\n可以看到`n1 n2 n3`是经过优化的，而`n4`是大数字，指针容不下该数值，不能优化。\n#### NSString Tagged Pointer\n看下面一道题,运行`test1`和`test2`会出现什么问题？\n\n```\n- (void)test1{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1000; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abc\"];\n\t\t});\n\t}\n}\n- (void)test2{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1000; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abcsefafaefafafaefe\"];\n\t\t});\n\t}\n}\n```\n我们先不运行，先分析一下。\n\n首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致`_name`结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下\n\n```\nThread: EXC_BAD_ACCESS(code = 1)\n```\n直接在子线程崩溃了，崩溃函数是`objc_release`。符合我们的猜想。\n\n验证`NSString Tagged Pointer`\n\n```\n- (void)test{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abc\"];\n\t\t\tNSLog(@\"test1 class:%@\",self.name.class);\n\t\t});\n\t}\n}\n- (void)test2{\n\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 1; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\tself.name = [NSString stringWithFormat:@\"abcsefafaefafafaefe\"];\n\t\t\tNSLog(@\"test2 class:%@\",self.name.class);\n\t\t});\n\t}\n}\n//log\ntest1 class:NSTaggedPointerString\ntest2 class:__NSCFString\n```\n可以看到`NSString Tagged Pointer`在小字符串的时候类是`NSTaggedPointerString`，经过优化的类，大字符串的类是`__NSCFString`，\n\n\n### copy\n拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。\n\n拷贝目的：产生一个副本对象，跟源对象互不影响\n 修改源对象，不会影响到副本对象\n 修改副本对象，不会影响源对象\n \n iOS提供了2中拷贝方法\n 1. copy 拷贝出来不可变对象\n 2. mutableCopy 拷贝出来可变对象\n \n \n```\nvoid test1(){\n\tNSString *str = @\"strstrstrstr\";\n\tNSMutableString *mut1 =[str mutableCopy];\n\t[mut1 appendFormat:@\"123\"];\n\tNSString *str2 = [str copy];\n\tNSLog(@\"%p %p %p\",str,mut1,str2);\n}\n//log\nstr:0x100001040 \nmut1:0x1007385f0 \nstr2:0x100001040\n```\n\n可以看到`str`和`str2`地址一样，没有重新复制出来一份，`mut1`地址和`str`不一致，是深拷贝，重新拷贝了一份。\n\n我们把字符串换成其他常用的数组\n\n```\nvoid test2(){\n\tNSArray *array = @[@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\"];\n\tNSMutableArray *mut =[array mutableCopy];\n\tNSString *array2 = [array copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",array,mut,array2);\n}\n//log\n0x102840800 \n0x1028408a0\n0x102840800\n\nvoid test3(){\n\tNSArray *array = [@[@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\",@\"123\"] mutableCopy];\n\tNSMutableArray *mut =[array mutableCopy];\n\tNSString *array2 = [array copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",array,mut,array2);\n}\n//log\n0x102808720 \n0x1028088a0\n0x1028089a0\n```\n\n从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。\n\n我们再换成其他的常用的字典\n\n```\nvoid test4(){\n\tNSDictionary *item = @{@\"key\":@\"value\"};\n\tNSMutableDictionary *mut =[item mutableCopy];\n\tNSDictionary *item2 = [item copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",item,mut,item2);\n}\n\n//log\n0x1007789c0 \n0x100779190\n0x1007789c0\n\nvoid test5(){\n\tNSDictionary *item = [@{@\"key\":@\"value\"}mutableCopy];\n\tNSMutableDictionary *mut =[item mutableCopy];\n\tNSDictionary *item2 = [item copy];\n\tNSLog(@\"\\n%p \\n%p\\n%p\",item,mut,item2);\n}\n//log\n\n0x1007041d0 \n0x1007042b0\n0x1007043a0\n```\n\n从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。\n\n由这几个看出来，总结出来下表\n\n|类型|copy|mutableCopy|\n|:-:|:-:|:-:|\n|NSString|浅拷贝|深拷贝|\n|NSMutableString|浅拷贝|深拷贝|\n|NSArray|浅拷贝|深拷贝|\n|NSMutableArray|深拷贝|深拷贝|\n|NSDictionary|浅拷贝|深拷贝|\n|NSMutableDictionary|深拷贝|深拷贝|\n\n#### 自定义对象实现协议NSCoping\n自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承`NSCopying`\n\n```\n@protocol NSCopying\n\n- (id)copyWithZone:(nullable NSZone *)zone;\n\n@end\n\n@protocol NSMutableCopying\n\n- (id)mutableCopyWithZone:(nullable NSZone *)zone;\n\n@end\n\n```\n\n看到`NSCopying`和`NSMutableCopying`这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现`NSCopying`协议就好了。\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,assign) int age;\n@property (nonatomic,assign) int level;\n\n@end\n\n@interface FYPerson()<NSCopying>\n@end\n\n@implementation FYPerson\n-(instancetype)copyWithZone:(NSZone *)zone{\n\tFYPerson *p=[[FYPerson alloc]init];\n\tp.age = self.age;\n\tp.level = self.level;\n\treturn p;\n}\n\n@end\n\n\nFYPerson *p =[[FYPerson alloc]init];\np.age = 10;\np.level = 11;\nFYPerson *p2 =[p copy];\nNSLog(@\"%d %d\",p2.age,p2.level);\n//log\n10 11\n```\n\n自己实现了`NSCoping`协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用`runtime`实现一个一劳永逸的方案。\n\n然后将`copyWithZone`利用`runtime`遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。\n\n```\n@implementation NSObject (add)\n-(instancetype)copyWithZone:(NSZone *)zone{\n    Class cls = [self class];\n    NSObject * p=[cls new];\n    //成员变量个数\n    unsigned int count;\n    //赋值成员变量数组\n    Ivar *ivars = class_copyIvarList(self.class, &count);\n    //遍历数组\n    for (int i = 0; i < count; i ++) {\n        Ivar var = ivars[i];\n        //获取成员变量名字\n        const char * name = ivar_getName(var);\n        if (name != nil) {\n            NSString *v = [NSString stringWithUTF8String:name];\n            id value = [self valueForKey:v];\n            //给新的对象赋值\n            if (value != NULL) {\n                [p setValue:value forKey:v];\n            }\n        }\n    }\n    free(ivars);\n    return p;\n}\n@end\n\nFYPerson *p =[[FYPerson alloc]init];\np.age = 10;\np.level = 11;\np.name = @\"xiaowang\";\nFYPerson *p2 =[p copy];\nNSLog(@\"%d %d %@\",p2.age,p2.level,p2.name);\n\t\t\n//log\n10 \n11 \nxiaowang\n```\n\n根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以\n在基类`NSObject`在类别中重写了`-(instancetype)copyWithZone:(NSZone *)zone`方法，子类就不用重写了。达成了一劳永逸的方案。\n\n\n### 引用计数原理\n摘自[百度百科](https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin)\n\n> 引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法\n\n在iOS中，使用引用计数来管理`OC`对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，`OC`对象就会销毁，释放其他内存空间，调用`retain`会让`OC`对象的引用计数+1，调用`release`会让`OC`对象的引用计数-1。\n当调用`alloc、new、copy、mutableCopy`方法返回一个对象，在不需要这个对象时，要调用`release`或者`autorelease`来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.\n\n在MRC中我们经常都是这样子使用的\n\n```\nFYPerson *p=[[FYPerson alloc]init];\nFYPerson *p2 =[p retain];\n//code here\n[p release];\n[p2 release];\n```\n\n但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。\n\n\n引用计数存储在`isa`指针中的`extra_rc`，存储值大于这个范围的时候，则`bits.has_sidetable_rc=1`然后将剩余的`RetainCount`存储到全局的`table`，`key`是`self`对应的值。\n\n`Retain`的`runtime`源码查找函数路径`objc_object::retain()`->`objc_object::rootRetain()`->`objc_object::rootRetain(bool, bool)`\n\n```\n//大概率x==1 提高读取指令的效率\n#define fastpath(x) (__builtin_expect(bool(x), 1))\n//大概率x==0 提高读取指令的效率\n#define slowpath(x) (__builtin_expect(bool(x), 0))\n\n\n//引用计数+1\n//tryRetain 尝试+1\n//handleOverflow 是否覆盖\nALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)\n{\n\t//优化的指针 返回this\n    if (isTaggedPointer()) return (id)this;\n\n    bool sideTableLocked = false;\n    bool transcribeToSideTable = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n    do {\n        transcribeToSideTable = false;\n\t\t//old bits\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n\t\t//使用联合体技术\n        if (slowpath(!newisa.nonpointer)) {\n            ClearExclusive(&isa.bits);//nothing\n            if (!tryRetain && sideTableLocked) sidetable_unlock();//解锁\n            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;\n\t\t\telse return sidetable_retain();////sidetable 引用计数+1\n        }\n        // don't check newisa.fast_rr; we already called any RR overrides\n\t\t//不尝试retain 和 正在销毁 什么都不做 返回 nil\n        if (slowpath(tryRetain && newisa.deallocating)) {\n            ClearExclusive(&isa.bits);\n            if (!tryRetain && sideTableLocked) sidetable_unlock();\n            return nil;\n        }\n        uintptr_t carry;\n\t\t//引用计数+1 (bits.extra_rc++;)\n        newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++\n\n        if (slowpath(carry)) {\n            // newisa.extra_rc++ 溢出处理\n            if (!handleOverflow) {\n                ClearExclusive(&isa.bits);\n                return rootRetain_overflow(tryRetain);\n            }\n\t\t\t//为拷贝到side table 做准备\n            if (!tryRetain && !sideTableLocked) sidetable_lock();\n            sideTableLocked = true;\n            transcribeToSideTable = true;\n            newisa.extra_rc = RC_HALF;\n            newisa.has_sidetable_rc = true;\n        }\n    } while (slowpath(!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)));\n\n    if (slowpath(transcribeToSideTable)) {\n\t\t//拷贝 平外一半的 引用计数到 side table\n        sidetable_addExtraRC_nolock(RC_HALF);\n    }\n\n    if (slowpath(!tryRetain && sideTableLocked)) sidetable_unlock();\n    return (id)this;\n}\n\n//sidetable 引用计数+1\nid objc_object::sidetable_retain()\n{\n#if SUPPORT_NONPOINTER_ISA\n    assert(!isa.nonpointer);\n#endif\n\t//取出table key=this\n    SideTable& table = SideTables()[this];\n    \n    table.lock();\n    size_t& refcntStorage = table.refcnts[this];\n    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {\n        refcntStorage += SIDE_TABLE_RC_ONE;\n    }\n    table.unlock();\n\n    return (id)this;\n}\n```\n\n引用计数+1，判断了需要是指针没有优化和`isa`有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将`extra_rc`的值复制到`side table`中，设置参数`isa->has_sidetable_rc=true`。\n\n引用计数-1，在`runtime`源码中查找路径是`objc_object::release()`->`objc_object::rootRelease()`->`objc_object::rootRelease(bool performDealloc, bool handleUnderflow)`,我们进入到函数内部\n\n```\nALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;//指针优化的不存在计数器\n\n    bool sideTableLocked = false;\n\n    isa_t oldisa;\n    isa_t newisa;\n\n retry:\n    do {//isa\n        oldisa = LoadExclusive(&isa.bits);\n        newisa = oldisa;\n        if (slowpath(!newisa.nonpointer)) {\n            ClearExclusive(&isa.bits);\n            if (sideTableLocked) sidetable_unlock();\n\t\t\t//side table -1\n            return sidetable_release(performDealloc);\n        }\n        uintptr_t carry;\n        newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc--\n        if (slowpath(carry)) {\n            // don't ClearExclusive()\n            goto underflow;\n        }\n    } while (slowpath(!StoreReleaseExclusive(&isa.bits, \n                                             oldisa.bits, newisa.bits)));\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n    return false;\n\n underflow:\n    newisa = oldisa;\n\n    if (slowpath(newisa.has_sidetable_rc)) {\n        if (!handleUnderflow) {\n            ClearExclusive(&isa.bits);\n            return rootRelease_underflow(performDealloc);\n        }\n\n        if (!sideTableLocked) {\n            ClearExclusive(&isa.bits);\n            sidetable_lock();\n            sideTableLocked = true;\n            goto retry;\n        }\n\n\t\t//side table 引用计数-1\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n\n        if (borrowed > 0) {\n            newisa.extra_rc = borrowed - 1;  // redo the original decrement too\n            bool stored = StoreReleaseExclusive(&isa.bits, \n                                                oldisa.bits, newisa.bits);\n            if (!stored) {\n                isa_t oldisa2 = LoadExclusive(&isa.bits);\n                isa_t newisa2 = oldisa2;\n                if (newisa2.nonpointer) {\n                    uintptr_t overflow;\n                    newisa2.bits = \n                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &overflow);\n                    if (!overflow) {\n                        stored = StoreReleaseExclusive(&isa.bits, oldisa2.bits, \n                                                       newisa2.bits);\n                    }\n                }\n            }\n\n            if (!stored) {\n                // Inline update failed.\n                // Put the retains back in the side table.\n                sidetable_addExtraRC_nolock(borrowed);\n                goto retry;\n            }\n\n            sidetable_unlock();\n            return false;\n        }\n        else {\n            // Side table is empty after all. Fall-through to the dealloc path.\n        }\n    }\n\n\t//真正的销毁\n\n    if (slowpath(newisa.deallocating)) {\n        ClearExclusive(&isa.bits);\n        if (sideTableLocked) sidetable_unlock();\n        return overrelease_error();\n        // does not actually return\n    }\n\t//设置正在销毁\n    newisa.deallocating = true;\n    if (!StoreExclusive(&isa.bits, oldisa.bits, newisa.bits)) goto retry;\n\n    if (slowpath(sideTableLocked)) sidetable_unlock();\n\n    __sync_synchronize();\n    if (performDealloc) {\n\t\t//销毁\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    return true;\n}\n```\n看了上边了解到引用计数分两部分，`extra_rc`和`side table`，探究一下\n`rootRetainCount()`的实现\n\n```\ninline uintptr_t  objc_object::rootRetainCount()\n{\n\t//优化指针 直接返回\n    if (isTaggedPointer()) return (uintptr_t)this;\n//没优化则 到SideTable 读取\n    sidetable_lock();\n\t//isa指针\n    isa_t bits = LoadExclusive(&isa.bits);\n    ClearExclusive(&isa.bits);//啥都没做\n    if (bits.nonpointer) {//使用联合体存储更多的数据 \n        uintptr_t rc = 1 + bits.extra_rc;//计数数量\n        if (bits.has_sidetable_rc) {//当大过于 联合体存储的值 则另外在SideTable读取数据\n\t//读取table的值 相加\n            rc += sidetable_getExtraRC_nolock();\n        }\n        sidetable_unlock();\n        return rc;\n    }\n\n    sidetable_unlock();\n\t//在sidetable 中存储的count\n    return sidetable_retainCount();\n}\n```\n当是存储小数据的时候，指针优化，则直接返回`self`,大数据的话，则`table`加锁，\n`class`优化的之后[使用联合体存储更多的数据](https://juejin.im/post/5d2bcf3df265da1b67213d69),`class`没有优化则直接去`sizedable`读取数据。\n优化了则在`sidetable_getExtraRC_nolock()`读取数据\n\n```\n//使用联合体\nsize_t  objc_object::sidetable_getExtraRC_nolock()\n{\n\t//不是联合体技术 则报错\n    assert(isa.nonpointer);\n\t//key是 this，存储了每个对象的table\n    SideTable& table = SideTables()[this];\n\t//找到 it 否则返回0\n    RefcountMap::iterator it = table.refcnts.find(this);\n    if (it == table.refcnts.end()) return 0;\n    else return it->second >> SIDE_TABLE_RC_SHIFT;\n}\n```\n没有优化的是直接读取\n\n```\n//未使用联合体的情况，\nuintptr_t objc_object::sidetable_retainCount()\n{//没有联合体存储的计数器则直接在table中取出来\n    SideTable& table = SideTables()[this];\n    size_t refcnt_result = 1;\n    table.lock();\n    RefcountMap::iterator it = table.refcnts.find(this);\n    if (it != table.refcnts.end()) {\n        refcnt_result += it->second >> SIDE_TABLE_RC_SHIFT;\n    }\n    table.unlock();\n    return refcnt_result;\n}\n```\n\n### weak指针原理\n\n当一个对象要销毁的时候会调用`dealloc`,调用轨迹是`dealloc`->`_objc_rootDealloc`->`object_dispose`->`objc_destructInstance`->`free`\n我们进入到`objc_destructInstance`内部\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n\t\t//c++析构函数\n        bool cxx = obj->hasCxxDtor();\n\t\t//关联函数\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        obj->clearDeallocating();\n    }\n    return obj;\n}\n```\n销毁了c++析构函数和关联函数最后进入到`clearDeallocating`，我们进入到函数内部\n\n```\n//正在清除side table 和weakly referenced\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n\t\t//释放weak\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n\t\t//释放weak 和引用计数\n        clearDeallocating_slow();\n    }\n    assert(!sidetable_present());\n}\n```\n最终调用了`sidetable_clearDeallocating`和`clearDeallocating_slow`实现销毁`weak`和引用计数`side table`。\n\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    assert(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n\t//清除weak\n    if (isa.weakly_referenced) {\n\t\t//table.weak_table 弱引用表\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n\t//引用计数\n    if (isa.has_sidetable_rc) {\n\t\t//擦除 this\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n其实`weak`修饰的对象会存储在全局的`SideTable`，当对象销毁的时候会在`SideTable`进行查找，时候有`weak`对象，有的话则进行销毁。\n\n### Autoreleasepool 原理\n`Autoreleasepool`中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，`release`里边的对象(引用计数-1)。\n我们将下边的代码转化成c++\n\n```\n@autoreleasepool {\n\t\tFYPerson *p = [[FYPerson alloc]init];\n\t}\n```\n使用`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m`\n转成c++\n\n```\n /* @autoreleasepool */ {\n  __AtAutoreleasePool __autoreleasepool;\n  FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"FYPerson\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));\n\n }\n```\n`__AtAutoreleasePool`是一个结构体\n\n```\nstruct __AtAutoreleasePool {\n\t__AtAutoreleasePool() {//构造函数 生成结构体变量的时候调用\n\t\tatautoreleasepoolobj = objc_autoreleasePoolPush();\n\t}\n\t~__AtAutoreleasePool() {//析构函数 销毁的时候调用\n\t\tobjc_autoreleasePoolPop(atautoreleasepoolobj);\n\t}\n\tvoid * atautoreleasepoolobj;\n};\n```\n\n然后将上边的代码和c++整合到一起就是这样子\n\n```\n{\n    __AtAutoreleasePool pool = objc_autoreleasePoolPush();\n    FYPerson *p = [[FYPerson alloc]init];\n    objc_autoreleasePoolPop(pool)\n}\n```\n\n在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在`runtime`源码中`NSObject.mm 1848 行`\n\n```\nvoid objc_autoreleasePoolPop(void *ctxt)\n{\n    AutoreleasePoolPage::pop(ctxt);\n}\n```\n\n`pop`实现了`AutoreleasePoolPage`中的对象的释放，想了解怎么释放的可以研究下源码`runtime NSObject.mm 1063行`。\n\n\n其实`AutoreleasePool`是`AutoreleasePoolPage`来管理的，`AutoreleasePoolpage`结构如下\n\n```\nclass AutoreleasePoolPage {\n    magic_t const magic;\n    id *next;//下一个存放aotoreleass对象的地址\n    pthread_t const thread;//线程\n    AutoreleasePoolPage * const parent; //父节点\n    AutoreleasePoolPage *child;//子节点\n    uint32_t const depth;//深度\n    uint32_t hiwat;\n}\n```\n\n`AutoreleasePoolPage`在初始化在`autoreleaseNewPage`申请了`4096`字节除了自己变量的空间，`AutoreleasePoolPage`是一个`C++`实现的类\n- 内部使用`id *next`指向了栈顶最新`add`进来的`autorelease`对象的下一个位置\n- 一个`AutoreleasePoolPage`的空间被占满时，会新建一个`AutoreleasePoolPage`对象，连接链表，后来的`autorelease`对象在新的`page`加入\n- `AutoreleasePoolPage`每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存`autorelease`对象的地址\n- `AutoreleasePool`是按线程一一对应的（结构中的`thread`指针指向当前线程）\n- `AutoreleasePool`并没有单独的结构，而是由若干个`AutoreleasePoolPage`以双向链表的形式组合而成（分别对应结构中的`parent`指针和`child`指针）\n\n\n其他的都是自动释放池的其他对象的指针，我们使用`_objc_autoreleasePoolPrint()`可以查看释放池的存储内容\n\n```\nextern void _objc_autoreleasePoolPrint(void);\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {//r1 = push()\n\n\t\tFYPerson *p = [[FYPerson alloc]init];\n\t\t_objc_autoreleasePoolPrint();\n\t\tprintf(\"\\n--------------\\n\");\n\t}//pop(r1)\n\treturn 0;\n}\n//log\n\nobjc[23958]: ##############\nobjc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0\nobjc[23958]: 3 releases pending.\nobjc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)\nobjc[23958]: [0x101000038]  ################  POOL 0x101000038\nobjc[23958]: [0x101000040]       0x10050cfa0  FYPerson\nobjc[23958]: [0x101000048]       0x10050cdb0  FYPerson\nobjc[23958]: ##############\n\n--------------\n```\n\n可以看到存储了`3 releases pending`一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池\n\n```\nint main(int argc, const char * argv[]) {\n\t@autoreleasepool {//r1 = push()\n\n\t\tFYPerson *p = [[[FYPerson alloc]init] autorelease];\n\t\tFYPerson *p2 = [[[FYPerson alloc]init] autorelease];\n\t\t@autoreleasepool {//r1 = push()\n\t\t\t\n\t\t\tFYPerson *p3 = [[[FYPerson alloc]init] autorelease];\n\t\t\tFYPerson *p4 = [[[FYPerson alloc]init] autorelease];\n\t\t\t\n\t\t\t_objc_autoreleasePoolPrint();\n\t\t\tprintf(\"\\n--------------\\n\");\n\t\t}//pop(r1)\n\t}//pop(r1)\n\treturn 0;\n}\n//log\nobjc[24025]: ##############\nobjc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0\nobjc[24025]: 6 releases pending.\nobjc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)\nobjc[24025]: [0x100803038]  ################  POOL 0x100803038\nobjc[24025]: [0x100803040]       0x100721580  FYPerson\nobjc[24025]: [0x100803048]       0x100721b10  FYPerson\nobjc[24025]: [0x100803050]  ################  POOL 0x100803050\nobjc[24025]: [0x100803058]       0x100721390  FYPerson\nobjc[24025]: [0x100803060]       0x100717620  FYPerson\nobjc[24025]: ##############\n```\n看到了2个`POOL`和四个`FYPerson`对象，一共是6个对象，当出了释放池会执行`release`。\n\n当无优化的指针调用`autorelease`其实是调用了`AutoreleasePoolPage::autorelease((id)this)`->`autoreleaseFast(obj)`\n\n```\n   static inline id *autoreleaseFast(id obj)\n    {\n        AutoreleasePoolPage *page = hotPage();\n        //当有分页而且分页没有满就添加\n        if (page && !page->full()) {\n            return page->add(obj);\n        } else if (page) {\n            //满则新建一个page进行添加obj和设置hotpage\n            return autoreleaseFullPage(obj, page);\n        } else {\n            //没有page则新建page进行添加\n            return autoreleaseNoPage(obj);\n        }\n    }\n```\n\n在`MRC`中\n`autorealease`修饰的是的对象在没有外部添加到自动释放池的时候，在`runloop`循环的时候会销毁\n\n```\n\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n\n//activities = 0xa0转化成二进制 0b101 0000\n系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据\n//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler\n\n\"<CFRunLoopObserver 0x600002538320 [0x10ce45ae8]>{valid = Yes, activities = 0xa0, \nrepeats = Yes, order = 2147483647, \ncallout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), \ncontext = <CFArray 0x600001a373f0 [0x10ce45ae8]>{type = mutable-small, count = 1, \nvalues = (\\n\\t0 : <0x7fb6dc004058>\\n)}}\"\n```\n\n`activities = 0xa0`转化成二进制 `0b101 0000`\n系统监听了`mainRunloop` 的 `kCFRunLoopBeforeWaiting` 和`kCFRunLoopExit`两种状态来更新`autorelease`的数据\n回调函数是 `_wrapRunLoopWithAutoreleasePoolHandler`。\n\n```\nvoid test(){\n    FYPerson *p =[[FYPerson alloc]init];\n}\n```\n\n`p`对象在某次循环中`push`，在循环到`kCFRunLoopBeforeWaiting`进行一次`pop`，则上次循环的`autolease`对象没有其他对象`retain`的进行释放。并不是出了`test()`立马释放。\n\n在ARC中则执行完毕`test()`会马上释放。\n### 总结\n- 当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。\n- 存在在全局的`SideTable`中weak修饰的对象会在`dealloc`函数执行过程中检测或销毁该对象。\n- 可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。\n- 优化的指向对象的指针，不用走`objc_msgSend()`的消息流程从而提高性能。\n- `CADisplayLink`和`Timer`本质是加到`loop`循环当中，依附于循环，没有`runloop`，则不能正确执行，使用`runloop`需要注意循环引用和`runloop`所在的线程的释放问题。\n\n### 参考资料\n- [黑幕背后的Autorelease\n](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n- 小码哥视频\n- iOS和OS多线程与内存管理\n- iOS和macOS性能优化\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 内存管理 那些你不知道的原理汇总 — (12)","published":1,"updated":"2019-12-03T08:24:31.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2k000n9zsk1swy0kdy","content":"<p>看完本文章你将了解到</p>\n<blockquote>\n<ol>\n<li>DisplayLink和timer的使用和原理</li>\n<li>内存分配和内存管理</li>\n<li>自动释放池原理</li>\n<li>weak指针原理和释放时机</li>\n<li>引用计数原理</li>\n</ol>\n</blockquote>\n<h3 id=\"DisplayLink\"><a href=\"#DisplayLink\" class=\"headerlink\" title=\"DisplayLink\"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div><div class=\"line\">//runloop没循环一圈都会调用</div><div class=\"line\">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class=\"line\">//从runloop中删除</div><div class=\"line\">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class=\"line\">//取消</div><div class=\"line\">- (void)invalidate;</div></pre></td></tr></table></figure>\n<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,strong) CADisplayLink *link;</div><div class=\"line\"></div><div class=\"line\">//初始化</div><div class=\"line\">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class=\"line\">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FPS:%d&quot;,fps);</div><div class=\"line\">\t\tfps = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_resume(timer);</div><div class=\"line\">//全局变量</div><div class=\"line\">dispatch_source_t timer;</div><div class=\"line\">static int fps;</div><div class=\"line\"></div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\tfps += 1;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\t[self.link invalidate];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</div><div class=\"line\">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</div></pre></td></tr></table></figure>\n<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYTimerTarget : NSObject</div><div class=\"line\">@property (nonatomic,weak) id target;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYTimerTarget</div><div class=\"line\">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\treturn self.target;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYProxy *proxy=[FYProxy proxyWithTarget:self];</div><div class=\"line\">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class=\"line\">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class=\"line\"></div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 17:59:04.339934 -[ViewController test]</div><div class=\"line\">2019-07-30 17:59:04.356292 -[ViewController test]</div><div class=\"line\">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</div><div class=\"line\">2019-07-30 17:59:04.371634 -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>\n<h3 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYProxy : NSProxy</div><div class=\"line\">@property (nonatomic,weak) id target;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)proxyWithTarget:(id)target;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYProxy</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (instancetype)proxyWithTarget:(id)target&#123;</div><div class=\"line\">\tFYProxy *obj=[FYProxy alloc];</div><div class=\"line\">\tobj.target = target;</div><div class=\"line\">\treturn obj;</div><div class=\"line\">&#125;</div><div class=\"line\">//转发</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</div><div class=\"line\">\t[invocation invokeWithTarget:self.target];</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</div><div class=\"line\">\treturn [self.target methodSignatureForSelector:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\treturn self.target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYTimerTarget *obj =[FYTimerTarget new];</div><div class=\"line\">obj.target = self;</div><div class=\"line\"></div><div class=\"line\">self.timer = [NSTimer timerWithTimeInterval:1.0f</div><div class=\"line\">\t\t\t\t\t\t\t\t\ttarget:obj</div><div class=\"line\">\t\t\t\t\t\t\t\t   selector:@selector(test)</div><div class=\"line\">\t\t\t\t\t\t\t\t   userInfo:nil</div><div class=\"line\">\t\t\t\t\t\t\t\t\trepeats:YES];</div><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class=\"line\">[self.timer setFireDate:[NSDate distantPast]];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class=\"line\">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class=\"line\">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</div><div class=\"line\">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class=\"line\">\tNSLog(@&quot;123&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</div><div class=\"line\">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</div><div class=\"line\">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>\n<h3 id=\"GCD中timer\"><a href=\"#GCD中timer\" class=\"headerlink\" title=\"GCD中timer\"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//timer 需要强引用 或者设置成全局变量</div><div class=\"line\">    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class=\"line\">    //设置</div><div class=\"line\">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">  //code 定时器执行的代码</div><div class=\"line\"> </div><div class=\"line\">    &#125;);</div><div class=\"line\">    //开始定时器</div><div class=\"line\">    dispatch_resume(timer);</div></pre></td></tr></table></figure>\n<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_source_set_event_handler_f(timer, function_t);</div><div class=\"line\">void function_t(void * p)&#123;</div><div class=\"line\">    //code here    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>\n<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)exeTask:(dispatch_block_t)block</div><div class=\"line\">    \t  start:(NSTimeInterval)time</div><div class=\"line\">       interval:(NSTimeInterval)interval</div><div class=\"line\">    \t repeat:(BOOL)repeat</div><div class=\"line\">    \t  async:(BOOL)async;</div><div class=\"line\">+ (NSString *)exeTask:(id)target</div><div class=\"line\">\t\t  sel:(SEL)aciton</div><div class=\"line\">\t\tstart:(NSTimeInterval)time</div><div class=\"line\">\t interval:(NSTimeInterval)interval</div><div class=\"line\">\t   repeat:(BOOL)repeat</div><div class=\"line\">\t\tasync:(BOOL)async;</div><div class=\"line\">//取消</div><div class=\"line\">+ (void)exeCancelTask:(NSString *)key;</div></pre></td></tr></table></figure>\n<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</div><div class=\"line\">\tif (block == nil) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tNSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class=\"line\">\t//主队列</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\">\tif (async) &#123;</div><div class=\"line\">\t\tqueue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//创建定时器</div><div class=\"line\">\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">\t//设置启动时间</div><div class=\"line\">\tdispatch_source_set_timer(_timer,</div><div class=\"line\">\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class=\"line\">\t//设定回调</div><div class=\"line\">\tdispatch_source_set_event_handler(_timer, ^&#123;</div><div class=\"line\">\t\tblock();</div><div class=\"line\">\t\tif (repeat == NO) &#123;</div><div class=\"line\">\t\t\tdispatch_source_cancel(_timer);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t//启动定时器</div><div class=\"line\">\tdispatch_resume(_timer);</div><div class=\"line\">\t//存放到字典</div><div class=\"line\">\tif (name.length &amp;&amp; _timer) &#123;</div><div class=\"line\">\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t\ttimers[name] = _timer;</div><div class=\"line\">\t\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">+ (NSString *)exeTask:(id)target</div><div class=\"line\">\t\t\t\t  sel:(SEL)aciton</div><div class=\"line\">\t\t\t\tstart:(NSTimeInterval)time</div><div class=\"line\">\t\t\t interval:(NSTimeInterval)interval</div><div class=\"line\">\t\t\t   repeat:(BOOL)repeat</div><div class=\"line\">\t\t\t\tasync:(BOOL)async&#123;</div><div class=\"line\">\tif (target == nil || aciton == NULL) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tNSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class=\"line\">\t//主队列</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\">\tif (async) &#123;</div><div class=\"line\">\t\tqueue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//创建定时器</div><div class=\"line\">\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">\t//设置启动时间</div><div class=\"line\">\tdispatch_source_set_timer(_timer,</div><div class=\"line\">\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class=\"line\">\t//设定回调</div><div class=\"line\">\tdispatch_source_set_event_handler(_timer, ^&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">\t\t//这里是会报警告的代码</div><div class=\"line\">\t\tif ([target respondsToSelector:aciton]) &#123;</div><div class=\"line\">\t\t\t[target performSelector:aciton];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\"></div><div class=\"line\">\t\tif (repeat == NO) &#123;</div><div class=\"line\">\t\t\tdispatch_source_cancel(_timer);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t//启动定时器</div><div class=\"line\">\tdispatch_resume(_timer);</div><div class=\"line\">\t//存放到字典</div><div class=\"line\">\tif (name.length &amp;&amp; _timer) &#123;</div><div class=\"line\">\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t\ttimers[name] = _timer;</div><div class=\"line\">\t\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn name;</div><div class=\"line\">&#125;</div><div class=\"line\">+ (void)exeCancelTask:(NSString *)key&#123;</div><div class=\"line\">\tif (key.length == 0) &#123;</div><div class=\"line\">\t\treturn;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tif ([timers.allKeys containsObject:key]) &#123;</div><div class=\"line\">\t\tdispatch_source_cancel(timers[key]);</div><div class=\"line\">\t\t[timers removeObjectForKey:key];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用的时候很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">key = [FYTimer exeTask:^&#123;</div><div class=\"line\">        NSLog(@&quot;123&quot;);</div><div class=\"line\">    &#125; start:1</div><div class=\"line\">    interval:1 </div><div class=\"line\">    repeat:YES </div><div class=\"line\">    async:NO];</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div></pre></td></tr></table></figure>\n<p>取消执行的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[FYTimer exeCancelTask:key];</div></pre></td></tr></table></figure>\n<p>测试封装的定时器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\t[FYTimer exeCancelTask:key];</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</div></pre></td></tr></table></figure>\n<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>\n<h3 id=\"NSProxy实战\"><a href=\"#NSProxy实战\" class=\"headerlink\" title=\"NSProxy实战\"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>\n<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewController *vc1 =[[ViewController alloc]init];</div><div class=\"line\">FYProxy *pro1 =[FYProxy proxyWithTarget:vc1];</div><div class=\"line\"></div><div class=\"line\">FYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];</div><div class=\"line\">BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</div><div class=\"line\">BOOL ret2 = [tar isKindOfClass:ViewController.class];</div><div class=\"line\">NSLog(@&quot;%d %d&quot;,ret1,ret2);</div></pre></td></tr></table></figure>\n<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>\n<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>\n<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>\n<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>\n<p>数据段包括</p>\n<ul>\n<li>字符串常量：比如NSString * str = @”11”</li>\n<li>已初始化数据：已初始化的全局变量、静态变量等</li>\n<li>未初始化数据：未初始化的全局变量、静态变量等</li>\n</ul>\n<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>\n<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>\n<p>验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a = 10;</div><div class=\"line\">int b ;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        static int c = 20;</div><div class=\"line\">        static int d;</div><div class=\"line\">        int e = 10;</div><div class=\"line\">        int f;</div><div class=\"line\">        NSString * str = @&quot;123&quot;;</div><div class=\"line\">        NSObject *obj =[[NSObject alloc]init];</div><div class=\"line\">        NSLog(@&quot;\\na:%p \\nb:%p \\nc:%p \\nd:%p \\ne:%p \\nf:%p \\nobj:%p\\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">a:0x1063e0d98 </div><div class=\"line\">b:0x1063e0e64 </div><div class=\"line\">c:0x1063e0d9c </div><div class=\"line\">d:0x1063e0e60 </div><div class=\"line\">e:0x7ffee9820efc </div><div class=\"line\">f:0x7ffee9820ef8 </div><div class=\"line\">obj:0x6000013541a0</div><div class=\"line\">str:0x1063e0068</div></pre></td></tr></table></figure>\n<h3 id=\"Tagged-Pointer\"><a href=\"#Tagged-Pointer\" class=\"headerlink\" title=\"Tagged Pointer\"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static inline void * _Nonnull</div><div class=\"line\">_objc_encodeTaggedPointer(uintptr_t ptr)</div><div class=\"line\">&#123;</div><div class=\"line\">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们拿来这个可以判断对象是否使用了优化技术。</p>\n<h4 id=\"NSNumbe-Tagged-Pointer\"><a href=\"#NSNumbe-Tagged-Pointer\" class=\"headerlink\" title=\"NSNumbe Tagged Pointer\"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ //mac开发</div><div class=\"line\">// 64-bit Mac - tag bit is LSB</div><div class=\"line\">#   define OBJC_MSB_TAGGED_POINTERS 0</div><div class=\"line\">#else</div><div class=\"line\">// Everything else - tag bit is MSB</div><div class=\"line\">#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if OBJC_MSB_TAGGED_POINTERS</div><div class=\"line\">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</div><div class=\"line\">#else</div><div class=\"line\">#   define _OBJC_TAG_MASK 1UL</div><div class=\"line\">#endif</div><div class=\"line\">bool objc_isTaggedPointer(const void * _Nullable ptr)</div><div class=\"line\">&#123;</div><div class=\"line\">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</div><div class=\"line\">&#125;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        NSNumber *n1 = @2;</div><div class=\"line\">        NSNumber *n2 = @3;</div><div class=\"line\">        NSNumber *n3 = @(4);</div><div class=\"line\">        NSNumber *n4 = @(0x4fffffffff);</div><div class=\"line\">        NSLog(@&quot;\\n%p \\n%p \\n%p \\n%p&quot;,n1,n2,n3,n4);</div><div class=\"line\">        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</div><div class=\"line\">        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</div><div class=\"line\">        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</div><div class=\"line\">        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</div><div class=\"line\"></div><div class=\"line\">        NSLog(@&quot;\\nn1:%d \\nn2:%d \\nn3:%d \\nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">0xbf4071e2657ccb95 </div><div class=\"line\">0xbf4071e2657ccb85 </div><div class=\"line\">0xbf4071e2657ccbf5 </div><div class=\"line\">0xbf40751d9a833444</div><div class=\"line\">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </div><div class=\"line\">n1:1 </div><div class=\"line\">n2:1 </div><div class=\"line\">n3:1 </div><div class=\"line\">n4:0</div></pre></td></tr></table></figure>\n<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>\n<h4 id=\"NSString-Tagged-Pointer\"><a href=\"#NSString-Tagged-Pointer\" class=\"headerlink\" title=\"NSString Tagged Pointer\"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test1&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先不运行，先分析一下。</p>\n<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread: EXC_BAD_ACCESS(code = 1)</div></pre></td></tr></table></figure>\n<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>\n<p>验证<code>NSString Tagged Pointer</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class=\"line\">\t\t\tNSLog(@&quot;test1 class:%@&quot;,self.name.class);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class=\"line\">\t\t\tNSLog(@&quot;test2 class:%@&quot;,self.name.class);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">test1 class:NSTaggedPointerString</div><div class=\"line\">test2 class:__NSCFString</div></pre></td></tr></table></figure>\n<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>\n<h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>\n<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>\n<p> iOS提供了2中拷贝方法</p>\n<ol>\n<li>copy 拷贝出来不可变对象</li>\n<li>mutableCopy 拷贝出来可变对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test1()&#123;</div><div class=\"line\">\tNSString *str = @&quot;strstrstrstr&quot;;</div><div class=\"line\">\tNSMutableString *mut1 =[str mutableCopy];</div><div class=\"line\">\t[mut1 appendFormat:@&quot;123&quot;];</div><div class=\"line\">\tNSString *str2 = [str copy];</div><div class=\"line\">\tNSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">str:0x100001040 </div><div class=\"line\">mut1:0x1007385f0 </div><div class=\"line\">str2:0x100001040</div></pre></td></tr></table></figure>\n<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>\n<p>我们把字符串换成其他常用的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test2()&#123;</div><div class=\"line\">\tNSArray *array = @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</div><div class=\"line\">\tNSMutableArray *mut =[array mutableCopy];</div><div class=\"line\">\tNSString *array2 = [array copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,array,mut,array2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">0x102840800 </div><div class=\"line\">0x1028408a0</div><div class=\"line\">0x102840800</div><div class=\"line\"></div><div class=\"line\">void test3()&#123;</div><div class=\"line\">\tNSArray *array = [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</div><div class=\"line\">\tNSMutableArray *mut =[array mutableCopy];</div><div class=\"line\">\tNSString *array2 = [array copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,array,mut,array2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">0x102808720 </div><div class=\"line\">0x1028088a0</div><div class=\"line\">0x1028089a0</div></pre></td></tr></table></figure>\n<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>\n<p>我们再换成其他的常用的字典</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test4()&#123;</div><div class=\"line\">\tNSDictionary *item = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</div><div class=\"line\">\tNSMutableDictionary *mut =[item mutableCopy];</div><div class=\"line\">\tNSDictionary *item2 = [item copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,item,mut,item2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">0x1007789c0 </div><div class=\"line\">0x100779190</div><div class=\"line\">0x1007789c0</div><div class=\"line\"></div><div class=\"line\">void test5()&#123;</div><div class=\"line\">\tNSDictionary *item = [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</div><div class=\"line\">\tNSMutableDictionary *mut =[item mutableCopy];</div><div class=\"line\">\tNSDictionary *item2 = [item copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,item,mut,item2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">0x1007041d0 </div><div class=\"line\">0x1007042b0</div><div class=\"line\">0x1007043a0</div></pre></td></tr></table></figure>\n<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>\n<p>由这几个看出来，总结出来下表</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">copy</th>\n<th style=\"text-align:center\">mutableCopy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">深拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSDictionary</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableDictionary</td>\n<td style=\"text-align:center\">深拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"自定义对象实现协议NSCoping\"><a href=\"#自定义对象实现协议NSCoping\" class=\"headerlink\" title=\"自定义对象实现协议NSCoping\"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol NSCopying</div><div class=\"line\"></div><div class=\"line\">- (id)copyWithZone:(nullable NSZone *)zone;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@protocol NSMutableCopying</div><div class=\"line\"></div><div class=\"line\">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) int age;</div><div class=\"line\">@property (nonatomic,assign) int level;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()&lt;NSCopying&gt;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class=\"line\">\tFYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\tp.age = self.age;</div><div class=\"line\">\tp.level = self.level;</div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">p.age = 10;</div><div class=\"line\">p.level = 11;</div><div class=\"line\">FYPerson *p2 =[p copy];</div><div class=\"line\">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</div><div class=\"line\">//log</div><div class=\"line\">10 11</div></pre></td></tr></table></figure>\n<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>\n<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSObject (add)</div><div class=\"line\">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class=\"line\">    Class cls = [self class];</div><div class=\"line\">    NSObject * p=[cls new];</div><div class=\"line\">    //成员变量个数</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">    //赋值成员变量数组</div><div class=\"line\">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);</div><div class=\"line\">    //遍历数组</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        Ivar var = ivars[i];</div><div class=\"line\">        //获取成员变量名字</div><div class=\"line\">        const char * name = ivar_getName(var);</div><div class=\"line\">        if (name != nil) &#123;</div><div class=\"line\">            NSString *v = [NSString stringWithUTF8String:name];</div><div class=\"line\">            id value = [self valueForKey:v];</div><div class=\"line\">            //给新的对象赋值</div><div class=\"line\">            if (value != NULL) &#123;</div><div class=\"line\">                [p setValue:value forKey:v];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">    return p;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">p.age = 10;</div><div class=\"line\">p.level = 11;</div><div class=\"line\">p.name = @&quot;xiaowang&quot;;</div><div class=\"line\">FYPerson *p2 =[p copy];</div><div class=\"line\">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</div><div class=\"line\">\t\t</div><div class=\"line\">//log</div><div class=\"line\">10 </div><div class=\"line\">11 </div><div class=\"line\">xiaowang</div></pre></td></tr></table></figure>\n<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>\n<h3 id=\"引用计数原理\"><a href=\"#引用计数原理\" class=\"headerlink\" title=\"引用计数原理\"></a>引用计数原理</h3><p>摘自<a href=\"https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<blockquote>\n<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>\n</blockquote>\n<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>\n<p>在MRC中我们经常都是这样子使用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">FYPerson *p2 =[p retain];</div><div class=\"line\">//code here</div><div class=\"line\">[p release];</div><div class=\"line\">[p2 release];</div></pre></td></tr></table></figure>\n<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>\n<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>\n<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">//大概率x==1 提高读取指令的效率</div><div class=\"line\">#define fastpath(x) (__builtin_expect(bool(x), 1))</div><div class=\"line\">//大概率x==0 提高读取指令的效率</div><div class=\"line\">#define slowpath(x) (__builtin_expect(bool(x), 0))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//引用计数+1</div><div class=\"line\">//tryRetain 尝试+1</div><div class=\"line\">//handleOverflow 是否覆盖</div><div class=\"line\">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</div><div class=\"line\">&#123;</div><div class=\"line\">\t//优化的指针 返回this</div><div class=\"line\">    if (isTaggedPointer()) return (id)this;</div><div class=\"line\"></div><div class=\"line\">    bool sideTableLocked = false;</div><div class=\"line\">    bool transcribeToSideTable = false;</div><div class=\"line\"></div><div class=\"line\">    isa_t oldisa;</div><div class=\"line\">    isa_t newisa;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">        transcribeToSideTable = false;</div><div class=\"line\">\t\t//old bits</div><div class=\"line\">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">        newisa = oldisa;</div><div class=\"line\">\t\t//使用联合体技术</div><div class=\"line\">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);//nothing</div><div class=\"line\">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();//解锁</div><div class=\"line\">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</div><div class=\"line\">\t\t\telse return sidetable_retain();////sidetable 引用计数+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        // don&apos;t check newisa.fast_rr; we already called any RR overrides</div><div class=\"line\">\t\t//不尝试retain 和 正在销毁 什么都不做 返回 nil</div><div class=\"line\">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class=\"line\">            return nil;</div><div class=\"line\">        &#125;</div><div class=\"line\">        uintptr_t carry;</div><div class=\"line\">\t\t//引用计数+1 (bits.extra_rc++;)</div><div class=\"line\">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</div><div class=\"line\"></div><div class=\"line\">        if (slowpath(carry)) &#123;</div><div class=\"line\">            // newisa.extra_rc++ 溢出处理</div><div class=\"line\">            if (!handleOverflow) &#123;</div><div class=\"line\">                ClearExclusive(&amp;isa.bits);</div><div class=\"line\">                return rootRetain_overflow(tryRetain);</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t//为拷贝到side table 做准备</div><div class=\"line\">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class=\"line\">            sideTableLocked = true;</div><div class=\"line\">            transcribeToSideTable = true;</div><div class=\"line\">            newisa.extra_rc = RC_HALF;</div><div class=\"line\">            newisa.has_sidetable_rc = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(transcribeToSideTable)) &#123;</div><div class=\"line\">\t\t//拷贝 平外一半的 引用计数到 side table</div><div class=\"line\">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class=\"line\">    return (id)this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//sidetable 引用计数+1</div><div class=\"line\">id objc_object::sidetable_retain()</div><div class=\"line\">&#123;</div><div class=\"line\">#if SUPPORT_NONPOINTER_ISA</div><div class=\"line\">    assert(!isa.nonpointer);</div><div class=\"line\">#endif</div><div class=\"line\">\t//取出table key=this</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    </div><div class=\"line\">    table.lock();</div><div class=\"line\">    size_t&amp; refcntStorage = table.refcnts[this];</div><div class=\"line\">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class=\"line\">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\"></div><div class=\"line\">    return (id)this;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>\n<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isTaggedPointer()) return false;//指针优化的不存在计数器</div><div class=\"line\"></div><div class=\"line\">    bool sideTableLocked = false;</div><div class=\"line\"></div><div class=\"line\">    isa_t oldisa;</div><div class=\"line\">    isa_t newisa;</div><div class=\"line\"></div><div class=\"line\"> retry:</div><div class=\"line\">    do &#123;//isa</div><div class=\"line\">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">        newisa = oldisa;</div><div class=\"line\">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            if (sideTableLocked) sidetable_unlock();</div><div class=\"line\">\t\t\t//side table -1</div><div class=\"line\">            return sidetable_release(performDealloc);</div><div class=\"line\">        &#125;</div><div class=\"line\">        uintptr_t carry;</div><div class=\"line\">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</div><div class=\"line\">        if (slowpath(carry)) &#123;</div><div class=\"line\">            // don&apos;t ClearExclusive()</div><div class=\"line\">            goto underflow;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class=\"line\">                                             oldisa.bits, newisa.bits)));</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class=\"line\">    return false;</div><div class=\"line\"></div><div class=\"line\"> underflow:</div><div class=\"line\">    newisa = oldisa;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class=\"line\">        if (!handleUnderflow) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            return rootRelease_underflow(performDealloc);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!sideTableLocked) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            sidetable_lock();</div><div class=\"line\">            sideTableLocked = true;</div><div class=\"line\">            goto retry;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t//side table 引用计数-1</div><div class=\"line\">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class=\"line\"></div><div class=\"line\">        if (borrowed &gt; 0) &#123;</div><div class=\"line\">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</div><div class=\"line\">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class=\"line\">                                                oldisa.bits, newisa.bits);</div><div class=\"line\">            if (!stored) &#123;</div><div class=\"line\">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">                isa_t newisa2 = oldisa2;</div><div class=\"line\">                if (newisa2.nonpointer) &#123;</div><div class=\"line\">                    uintptr_t overflow;</div><div class=\"line\">                    newisa2.bits = </div><div class=\"line\">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</div><div class=\"line\">                    if (!overflow) &#123;</div><div class=\"line\">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class=\"line\">                                                       newisa2.bits);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!stored) &#123;</div><div class=\"line\">                // Inline update failed.</div><div class=\"line\">                // Put the retains back in the side table.</div><div class=\"line\">                sidetable_addExtraRC_nolock(borrowed);</div><div class=\"line\">                goto retry;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            sidetable_unlock();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Side table is empty after all. Fall-through to the dealloc path.</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//真正的销毁</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(newisa.deallocating)) &#123;</div><div class=\"line\">        ClearExclusive(&amp;isa.bits);</div><div class=\"line\">        if (sideTableLocked) sidetable_unlock();</div><div class=\"line\">        return overrelease_error();</div><div class=\"line\">        // does not actually return</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//设置正在销毁</div><div class=\"line\">    newisa.deallocating = true;</div><div class=\"line\">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class=\"line\"></div><div class=\"line\">    __sync_synchronize();</div><div class=\"line\">    if (performDealloc) &#123;</div><div class=\"line\">\t\t//销毁</div><div class=\"line\">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">inline uintptr_t  objc_object::rootRetainCount()</div><div class=\"line\">&#123;</div><div class=\"line\">\t//优化指针 直接返回</div><div class=\"line\">    if (isTaggedPointer()) return (uintptr_t)this;</div><div class=\"line\">//没优化则 到SideTable 读取</div><div class=\"line\">    sidetable_lock();</div><div class=\"line\">\t//isa指针</div><div class=\"line\">    isa_t bits = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">    ClearExclusive(&amp;isa.bits);//啥都没做</div><div class=\"line\">    if (bits.nonpointer) &#123;//使用联合体存储更多的数据 </div><div class=\"line\">        uintptr_t rc = 1 + bits.extra_rc;//计数数量</div><div class=\"line\">        if (bits.has_sidetable_rc) &#123;//当大过于 联合体存储的值 则另外在SideTable读取数据</div><div class=\"line\">\t//读取table的值 相加</div><div class=\"line\">            rc += sidetable_getExtraRC_nolock();</div><div class=\"line\">        &#125;</div><div class=\"line\">        sidetable_unlock();</div><div class=\"line\">        return rc;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sidetable_unlock();</div><div class=\"line\">\t//在sidetable 中存储的count</div><div class=\"line\">    return sidetable_retainCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<a href=\"https://juejin.im/post/5d2bcf3df265da1b67213d69\" target=\"_blank\" rel=\"external\">使用联合体存储更多的数据</a>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用联合体</div><div class=\"line\">size_t  objc_object::sidetable_getExtraRC_nolock()</div><div class=\"line\">&#123;</div><div class=\"line\">\t//不是联合体技术 则报错</div><div class=\"line\">    assert(isa.nonpointer);</div><div class=\"line\">\t//key是 this，存储了每个对象的table</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">\t//找到 it 否则返回0</div><div class=\"line\">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class=\"line\">    if (it == table.refcnts.end()) return 0;</div><div class=\"line\">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没有优化的是直接读取</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//未使用联合体的情况，</div><div class=\"line\">uintptr_t objc_object::sidetable_retainCount()</div><div class=\"line\">&#123;//没有联合体存储的计数器则直接在table中取出来</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    size_t refcnt_result = 1;</div><div class=\"line\">    table.lock();</div><div class=\"line\">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class=\"line\">    if (it != table.refcnts.end()) &#123;</div><div class=\"line\">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\">    return refcnt_result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"weak指针原理\"><a href=\"#weak指针原理\" class=\"headerlink\" title=\"weak指针原理\"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *objc_destructInstance(id obj) </div><div class=\"line\">&#123;</div><div class=\"line\">    if (obj) &#123;</div><div class=\"line\">        // Read all of the flags at once for performance.</div><div class=\"line\">\t\t//c++析构函数</div><div class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</div><div class=\"line\">\t\t//关联函数</div><div class=\"line\">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class=\"line\"></div><div class=\"line\">        // This order is important.</div><div class=\"line\">        if (cxx) object_cxxDestruct(obj);</div><div class=\"line\">        if (assoc) _object_remove_assocations(obj);</div><div class=\"line\">        obj-&gt;clearDeallocating();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//正在清除side table 和weakly referenced</div><div class=\"line\">inline void </div><div class=\"line\">objc_object::clearDeallocating()</div><div class=\"line\">&#123;</div><div class=\"line\">    if (slowpath(!isa.nonpointer)) &#123;</div><div class=\"line\">        // Slow path for raw pointer isa.</div><div class=\"line\">\t\t//释放weak</div><div class=\"line\">        sidetable_clearDeallocating();</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</div><div class=\"line\">        // Slow path for non-pointer isa with weak refs and/or side table data.</div><div class=\"line\">\t\t//释放weak 和引用计数</div><div class=\"line\">        clearDeallocating_slow();</div><div class=\"line\">    &#125;</div><div class=\"line\">    assert(!sidetable_present());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">NEVER_INLINE void</div><div class=\"line\">objc_object::clearDeallocating_slow()</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</div><div class=\"line\"></div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    table.lock();</div><div class=\"line\">\t//清除weak</div><div class=\"line\">    if (isa.weakly_referenced) &#123;</div><div class=\"line\">\t\t//table.weak_table 弱引用表</div><div class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//引用计数</div><div class=\"line\">    if (isa.has_sidetable_rc) &#123;</div><div class=\"line\">\t\t//擦除 this</div><div class=\"line\">        table.refcnts.erase(this);</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>\n<h3 id=\"Autoreleasepool-原理\"><a href=\"#Autoreleasepool-原理\" class=\"headerlink\" title=\"Autoreleasepool 原理\"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@autoreleasepool &#123;</div><div class=\"line\">\t\tFYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* @autoreleasepool */ &#123;</div><div class=\"line\"> __AtAutoreleasePool __autoreleasepool;</div><div class=\"line\"> FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>__AtAutoreleasePool</code>是一个结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __AtAutoreleasePool &#123;</div><div class=\"line\">\t__AtAutoreleasePool() &#123;//构造函数 生成结构体变量的时候调用</div><div class=\"line\">\t\tatautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t~__AtAutoreleasePool() &#123;//析构函数 销毁的时候调用</div><div class=\"line\">\t\tobjc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvoid * atautoreleasepoolobj;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后将上边的代码和c++整合到一起就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    __AtAutoreleasePool pool = objc_autoreleasePoolPush();</div><div class=\"line\">    FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">    objc_autoreleasePoolPop(pool)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void objc_autoreleasePoolPop(void *ctxt)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoreleasePoolPage::pop(ctxt);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>\n<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class AutoreleasePoolPage &#123;</div><div class=\"line\">    magic_t const magic;</div><div class=\"line\">    id *next;//下一个存放aotoreleass对象的地址</div><div class=\"line\">    pthread_t const thread;//线程</div><div class=\"line\">    AutoreleasePoolPage * const parent; //父节点</div><div class=\"line\">    AutoreleasePoolPage *child;//子节点</div><div class=\"line\">    uint32_t const depth;//深度</div><div class=\"line\">    uint32_t hiwat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>\n<ul>\n<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>\n<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>\n<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>\n<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>\n<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>\n</ul>\n<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern void _objc_autoreleasePoolPrint(void);</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\"></div><div class=\"line\">\t\tFYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t\t_objc_autoreleasePoolPrint();</div><div class=\"line\">\t\tprintf(&quot;\\n--------------\\n&quot;);</div><div class=\"line\">\t&#125;//pop(r1)</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">objc[23958]: ##############</div><div class=\"line\">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class=\"line\">objc[23958]: 3 releases pending.</div><div class=\"line\">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</div><div class=\"line\">objc[23958]: [0x101000038]  ################  POOL 0x101000038</div><div class=\"line\">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</div><div class=\"line\">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</div><div class=\"line\">objc[23958]: ##############</div><div class=\"line\"></div><div class=\"line\">--------------</div></pre></td></tr></table></figure>\n<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\"></div><div class=\"line\">\t\tFYPerson *p = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\tFYPerson *p2 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tFYPerson *p3 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t\tFYPerson *p4 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t_objc_autoreleasePoolPrint();</div><div class=\"line\">\t\t\tprintf(&quot;\\n--------------\\n&quot;);</div><div class=\"line\">\t\t&#125;//pop(r1)</div><div class=\"line\">\t&#125;//pop(r1)</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">objc[24025]: ##############</div><div class=\"line\">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class=\"line\">objc[24025]: 6 releases pending.</div><div class=\"line\">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</div><div class=\"line\">objc[24025]: [0x100803038]  ################  POOL 0x100803038</div><div class=\"line\">objc[24025]: [0x100803040]       0x100721580  FYPerson</div><div class=\"line\">objc[24025]: [0x100803048]       0x100721b10  FYPerson</div><div class=\"line\">objc[24025]: [0x100803050]  ################  POOL 0x100803050</div><div class=\"line\">objc[24025]: [0x100803058]       0x100721390  FYPerson</div><div class=\"line\">objc[24025]: [0x100803060]       0x100717620  FYPerson</div><div class=\"line\">objc[24025]: ##############</div></pre></td></tr></table></figure>\n<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>\n<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static inline id *autoreleaseFast(id obj)</div><div class=\"line\"> &#123;</div><div class=\"line\">     AutoreleasePoolPage *page = hotPage();</div><div class=\"line\">     //当有分页而且分页没有满就添加</div><div class=\"line\">     if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class=\"line\">         return page-&gt;add(obj);</div><div class=\"line\">     &#125; else if (page) &#123;</div><div class=\"line\">         //满则新建一个page进行添加obj和设置hotpage</div><div class=\"line\">         return autoreleaseFullPage(obj, page);</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         //没有page则新建page进行添加</div><div class=\"line\">         return autoreleaseNoPage(obj);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</div><div class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</div><div class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</div><div class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//activities = 0xa0转化成二进制 0b101 0000</div><div class=\"line\">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</div><div class=\"line\">//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</div><div class=\"line\"></div><div class=\"line\">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid = Yes, activities = 0xa0, </div><div class=\"line\">repeats = Yes, order = 2147483647, </div><div class=\"line\">callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </div><div class=\"line\">context = &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type = mutable-small, count = 1, </div><div class=\"line\">values = (\\n\\t0 : &lt;0x7fb6dc004058&gt;\\n)&#125;&#125;&quot;</div></pre></td></tr></table></figure>\n<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test()&#123;</div><div class=\"line\">    FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>\n<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>\n<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>\n<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>\n<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>\n<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"external\">黑幕背后的Autorelease\n</a></li>\n<li>小码哥视频</li>\n<li>iOS和OS多线程与内存管理</li>\n<li>iOS和macOS性能优化<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>看完本文章你将了解到</p>\n<blockquote>\n<ol>\n<li>DisplayLink和timer的使用和原理</li>\n<li>内存分配和内存管理</li>\n<li>自动释放池原理</li>\n<li>weak指针原理和释放时机</li>\n<li>引用计数原理</li>\n</ol>\n</blockquote>\n<h3 id=\"DisplayLink\"><a href=\"#DisplayLink\" class=\"headerlink\" title=\"DisplayLink\"></a>DisplayLink</h3><p><code>CADisplayLink</code>是将任务添加到<code>runloop</code>中，<code>loop</code>每次循环便会调用<code>target</code>的<code>selector</code>，使用这个也能监测卡顿问题。首先介绍下<code>API</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div><div class=\"line\">//runloop没循环一圈都会调用</div><div class=\"line\">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class=\"line\">//从runloop中删除</div><div class=\"line\">- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;</div><div class=\"line\">//取消</div><div class=\"line\">- (void)invalidate;</div></pre></td></tr></table></figure>\n<p>我们在一个需要<code>push</code>的<code>VC</code>中运行来观察声明周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,strong) CADisplayLink *link;</div><div class=\"line\"></div><div class=\"line\">//初始化</div><div class=\"line\">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class=\"line\">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FPS:%d&quot;,fps);</div><div class=\"line\">\t\tfps = 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_resume(timer);</div><div class=\"line\">//全局变量</div><div class=\"line\">dispatch_source_t timer;</div><div class=\"line\">static int fps;</div><div class=\"line\"></div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\tfps += 1;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\t[self.link invalidate];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 17:44:37.217781+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:38.212477+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:39.706000+0800 day17-定时器[29637:6504821] FPS:89</div><div class=\"line\">2019-07-30 17:44:40.706064+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:41.705589+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:42.706268+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:43.705942+0800 day17-定时器[29637:6504821] FPS:60</div><div class=\"line\">2019-07-30 17:44:44.705792+0800 day17-定时器[29637:6504821] FPS:60</div></pre></td></tr></table></figure>\n<p>初始化之后，对<code>fps</code>使用了简单版本的读写锁，可以看到<code>fps</code>基本稳定在60左右，点击按钮返回之后，<code>link</code>和<code>VC</code>并没有正常销毁。我们分析一下，<code>VC（self）</code>-&gt;<code>link</code>-&gt;<code>target(self)</code>,导致了死循环，释放的时候，无法释放<code>self</code>和<code>link</code>,那么我们改动一下<code>link</code>-&gt;<code>target(self)</code>中的强引用，改成弱引用，代码改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYTimerTarget : NSObject</div><div class=\"line\">@property (nonatomic,weak) id target;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYTimerTarget</div><div class=\"line\">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\treturn self.target;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYProxy *proxy=[FYProxy proxyWithTarget:self];</div><div class=\"line\">self.link = [FYDisplayLink displayLinkWithTarget:self selector:@selector(test)];</div><div class=\"line\">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class=\"line\"></div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 17:59:04.339934 -[ViewController test]</div><div class=\"line\">2019-07-30 17:59:04.356292 -[ViewController test]</div><div class=\"line\">2019-07-30 17:59:04.371428 -[FYTimerTarget dealloc]</div><div class=\"line\">2019-07-30 17:59:04.371634 -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p><code>FYTimerTarget</code>对<code>target</code>进行了弱引用，<code>self</code>对<code>FYTimerTarget</code>进行强引用，在销毁了的时候，先释放<code>self</code>,然后检查<code>self</code>的<code>FYTimerTarget</code>,<code>FYTimerTarget</code>只有一个参数<code>weak</code>属性，可以直接释放，释放完<code>FYTimerTarget</code>，然后释放<code>self(VC)</code>，最终可以正常。</p>\n<h3 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h3><p>使用<code>NSTimer</code>的时候，<code>timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo</code>会对<code>aTarget</code>进行强引用，所以我们对这个<code>aTarget</code>进行一个简单的封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYProxy : NSProxy</div><div class=\"line\">@property (nonatomic,weak) id target;</div><div class=\"line\"></div><div class=\"line\">+(instancetype)proxyWithTarget:(id)target;</div><div class=\"line\">@end</div><div class=\"line\">@implementation FYProxy</div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (instancetype)proxyWithTarget:(id)target&#123;</div><div class=\"line\">\tFYProxy *obj=[FYProxy alloc];</div><div class=\"line\">\tobj.target = target;</div><div class=\"line\">\treturn obj;</div><div class=\"line\">&#125;</div><div class=\"line\">//转发</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</div><div class=\"line\">\t[invocation invokeWithTarget:self.target];</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</div><div class=\"line\">\treturn [self.target methodSignatureForSelector:sel];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>FYProxy</code>是继承<code>NSProxy</code>，而<code>NSProxy</code>不是继承<code>NSObject</code>的,而是另外一种基类，不会走<code>objc_msgSend()</code>的三大步骤，当找不到函数的时候直接执行<code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，和<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code>直接进入消息转发阶段。或者将继承关系改成<code>FYTimerTarget : NSObject</code>,这样子<code>target</code>找不到的函数还是会走消息转发的三大步骤，我们再<code>FYTimerTarget</code>添加消息动态解析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">\treturn self.target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样子<code>target</code>的<code>aSelector</code>转发给了<code>self.target</code>处理，成功弱引用了<code>self</code>和函数的转发处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYTimerTarget *obj =[FYTimerTarget new];</div><div class=\"line\">obj.target = self;</div><div class=\"line\"></div><div class=\"line\">self.timer = [NSTimer timerWithTimeInterval:1.0f</div><div class=\"line\">\t\t\t\t\t\t\t\t\ttarget:obj</div><div class=\"line\">\t\t\t\t\t\t\t\t   selector:@selector(test)</div><div class=\"line\">\t\t\t\t\t\t\t\t   userInfo:nil</div><div class=\"line\">\t\t\t\t\t\t\t\t\trepeats:YES];</div><div class=\"line\">[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div class=\"line\">[self.timer setFireDate:[NSDate distantPast]];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 18:03:08.723433+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class=\"line\">2019-07-30 18:03:09.722611+0800 day17-定时器[30877:6556631] -[ViewController test]</div><div class=\"line\">2019-07-30 18:03:09.847540+0800 day17-定时器[30877:6556631] -[FYTimerTarget dealloc]</div><div class=\"line\">2019-07-30 18:03:09.847677+0800 day17-定时器[30877:6556631] -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p>或者使用<code>timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</code>，然后外部使用<code>__weak self</code>调用函数，也不会产生循环引用。<br>使用<code>block</code>的情况，释放正常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.timer=[NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class=\"line\">\tNSLog(@&quot;123&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 18:08:24.678789+0800 day17-定时器[31126:6566530] 123</div><div class=\"line\">2019-07-30 18:08:25.659127+0800 day17-定时器[31126:6566530] 123</div><div class=\"line\">2019-07-30 18:08:26.107643+0800 day17-定时器[31126:6566530] -[ViewController dealloc]</div></pre></td></tr></table></figure>\n<p>由于<code>link</code>和<code>timer</code>是添加到<code>runloop</code>中使用的，每次一个循环则访问<code>timer</code>或者<code>link</code>，然后执行对应的函数，在时间上有相对少许误差的，每此循环，要刷新UI(在主线程)，要执行其他函数，要处理系统端口事件，要处理其他的计算。。。总的来说，误差还是有的。</p>\n<h3 id=\"GCD中timer\"><a href=\"#GCD中timer\" class=\"headerlink\" title=\"GCD中timer\"></a>GCD中timer</h3><p><code>GCD</code>中的<code>dispatch_source_t</code>的定时器是基于内核的，时间误差相对较少。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//timer 需要强引用 或者设置成全局变量</div><div class=\"line\">    timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</div><div class=\"line\">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class=\"line\">    //设置</div><div class=\"line\">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class=\"line\">  //code 定时器执行的代码</div><div class=\"line\"> </div><div class=\"line\">    &#125;);</div><div class=\"line\">    //开始定时器</div><div class=\"line\">    dispatch_resume(timer);</div></pre></td></tr></table></figure>\n<p>或者使用函数<code>dispatch_source_set_event_handler_f(timer, function_t);</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_source_set_event_handler_f(timer, function_t);</div><div class=\"line\">void function_t(void * p)&#123;</div><div class=\"line\">    //code here    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>业务经常使用定时器的话，还是封装一个简单的功能比较好，封装首先从需求开始分析，我们使用定时器常用的参数都哪些？需要哪些功能？</p>\n<p>首先需要开始的时间，然后执行的频率，执行的任务(函数或block)，是否重复执行，这些都是需要的。<br>先定义一个函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)exeTask:(dispatch_block_t)block</div><div class=\"line\">    \t  start:(NSTimeInterval)time</div><div class=\"line\">       interval:(NSTimeInterval)interval</div><div class=\"line\">    \t repeat:(BOOL)repeat</div><div class=\"line\">    \t  async:(BOOL)async;</div><div class=\"line\">+ (NSString *)exeTask:(id)target</div><div class=\"line\">\t\t  sel:(SEL)aciton</div><div class=\"line\">\t\tstart:(NSTimeInterval)time</div><div class=\"line\">\t interval:(NSTimeInterval)interval</div><div class=\"line\">\t   repeat:(BOOL)repeat</div><div class=\"line\">\t\tasync:(BOOL)async;</div><div class=\"line\">//取消</div><div class=\"line\">+ (void)exeCancelTask:(NSString *)key;</div></pre></td></tr></table></figure>\n<p>然后将刚才写的拿过来，增加了一些判断。有任务的时候才会执行，否则直接返回<code>nil</code>，当循环的时候，需要间隔大于0，否则返回，同步或异步，就或者主队列或者异步队列，然后用生成的<code>key</code>,<code>timer</code>为<code>value</code>存储到全局变量中，在取消的时候直接用<code>key</code>取出<code>timer</code>取消，这里使用了信号量，限制单线程操作。在存储和取出（取消timer）的时候进行限制，提高其他代码执行的效率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)exeTask:(dispatch_block_t)block start:(NSTimeInterval)time interval:(NSTimeInterval)interval repeat:(BOOL)repeat async:(BOOL)async&#123;</div><div class=\"line\">\tif (block == nil) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tNSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class=\"line\">\t//主队列</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\">\tif (async) &#123;</div><div class=\"line\">\t\tqueue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//创建定时器</div><div class=\"line\">\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">\t//设置启动时间</div><div class=\"line\">\tdispatch_source_set_timer(_timer,</div><div class=\"line\">\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class=\"line\">\t//设定回调</div><div class=\"line\">\tdispatch_source_set_event_handler(_timer, ^&#123;</div><div class=\"line\">\t\tblock();</div><div class=\"line\">\t\tif (repeat == NO) &#123;</div><div class=\"line\">\t\t\tdispatch_source_cancel(_timer);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t//启动定时器</div><div class=\"line\">\tdispatch_resume(_timer);</div><div class=\"line\">\t//存放到字典</div><div class=\"line\">\tif (name.length &amp;&amp; _timer) &#123;</div><div class=\"line\">\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t\ttimers[name] = _timer;</div><div class=\"line\">\t\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">+ (NSString *)exeTask:(id)target</div><div class=\"line\">\t\t\t\t  sel:(SEL)aciton</div><div class=\"line\">\t\t\t\tstart:(NSTimeInterval)time</div><div class=\"line\">\t\t\t interval:(NSTimeInterval)interval</div><div class=\"line\">\t\t\t   repeat:(BOOL)repeat</div><div class=\"line\">\t\t\t\tasync:(BOOL)async&#123;</div><div class=\"line\">\tif (target == nil || aciton == NULL) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (repeat &amp;&amp; interval &lt;= 0) &#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tNSString *name =[NSString stringWithFormat:@&quot;%d&quot;,i];</div><div class=\"line\">\t//主队列</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_main_queue();</div><div class=\"line\">\tif (async) &#123;</div><div class=\"line\">\t\tqueue = dispatch_queue_create(&quot;async.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//创建定时器</div><div class=\"line\">\tdispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">\t//设置启动时间</div><div class=\"line\">\tdispatch_source_set_timer(_timer,</div><div class=\"line\">\t\t\t\t\t\t\t  dispatch_time(DISPATCH_TIME_NOW, time*NSEC_PER_SEC), interval*NSEC_PER_SEC, 0);</div><div class=\"line\">\t//设定回调</div><div class=\"line\">\tdispatch_source_set_event_handler(_timer, ^&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">\t\t//这里是会报警告的代码</div><div class=\"line\">\t\tif ([target respondsToSelector:aciton]) &#123;</div><div class=\"line\">\t\t\t[target performSelector:aciton];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\"></div><div class=\"line\">\t\tif (repeat == NO) &#123;</div><div class=\"line\">\t\t\tdispatch_source_cancel(_timer);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t//启动定时器</div><div class=\"line\">\tdispatch_resume(_timer);</div><div class=\"line\">\t//存放到字典</div><div class=\"line\">\tif (name.length &amp;&amp; _timer) &#123;</div><div class=\"line\">\t\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t\ttimers[name] = _timer;</div><div class=\"line\">\t\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn name;</div><div class=\"line\">&#125;</div><div class=\"line\">+ (void)exeCancelTask:(NSString *)key&#123;</div><div class=\"line\">\tif (key.length == 0) &#123;</div><div class=\"line\">\t\treturn;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_wait(samephore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tif ([timers.allKeys containsObject:key]) &#123;</div><div class=\"line\">\t\tdispatch_source_cancel(timers[key]);</div><div class=\"line\">\t\t[timers removeObjectForKey:key];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_signal(samephore);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用的时候很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">key = [FYTimer exeTask:^&#123;</div><div class=\"line\">        NSLog(@&quot;123&quot;);</div><div class=\"line\">    &#125; start:1</div><div class=\"line\">    interval:1 </div><div class=\"line\">    repeat:YES </div><div class=\"line\">    async:NO];</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">key = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div></pre></td></tr></table></figure>\n<p>取消执行的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[FYTimer exeCancelTask:key];</div></pre></td></tr></table></figure>\n<p>测试封装的定时器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\tkey = [FYTimer exeTask:self sel:@selector(test) start:0 interval:1 repeat:YES async:YES];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)test&#123;</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">\t[FYTimer exeCancelTask:key];</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 21:16:48.639486+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:49.640177+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:50.639668+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:51.639590+0800 day17-定时器2[48817:1300897] &lt;NSThread: 0x6000010ec000&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-30 21:16:52.156004+0800 day17-定时器2[48817:1300845] -[ViewController touchesBegan:withEvent:]</div></pre></td></tr></table></figure>\n<p>在点击<code>VC</code>的时候进行取消操作，<code>timer</code>停止。</p>\n<h3 id=\"NSProxy实战\"><a href=\"#NSProxy实战\" class=\"headerlink\" title=\"NSProxy实战\"></a>NSProxy实战</h3><p><code>NSProxy</code>其实是除了<code>NSObject</code>的另外一个基类，方法比较少，当找不到方法的时候执行消息转发阶段(因为没有父类)，调用函数的流程更短，性能则更好。</p>\n<p>问题：<code>ret1</code>和<code>ret2</code>分别是多少？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ViewController *vc1 =[[ViewController alloc]init];</div><div class=\"line\">FYProxy *pro1 =[FYProxy proxyWithTarget:vc1];</div><div class=\"line\"></div><div class=\"line\">FYTimerTarget *tar =[FYTimerTarget proxyWithTarget:vc1];</div><div class=\"line\">BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</div><div class=\"line\">BOOL ret2 = [tar isKindOfClass:ViewController.class];</div><div class=\"line\">NSLog(@&quot;%d %d&quot;,ret1,ret2);</div></pre></td></tr></table></figure>\n<p>我们来分析一下，<code>-(bool)isKindOfClass:(cls)</code>对象函数是判断该对象是否的<code>cls</code>的子类或者该类的实例，这点不容置疑，那么<code>ret1</code>应该是<code>0</code>,<code>ret2</code>应该也是<code>0</code></p>\n<p>首先看<code>FYProxy</code>的实现，<code>forwardInvocation</code>和<code>methodSignatureForSelector</code>，在没有该函数的时候进行消息转发，转发对象是<code>self.target</code>，在该例子中<code>isKindOfClass</code>不存在与<code>FYProxy</code>，所以讲该函数转发给了<code>VC</code>，则<code>BOOL ret1 = [pro1 isKindOfClass:ViewController.class];</code>相当于<code>BOOL ret1 = [ViewController.class isKindOfClass:ViewController.class];</code>，所以答案是1</p>\n<p>然后<code>ret2</code>是0，<code>tar</code>是继承于<code>NSObject</code>的，本身有<code>-(bool)isKindOfClass:(cls)</code>函数，所以答案是0。</p>\n<p>答案是：<code>ret1</code>是<code>1</code>，<code>ret2</code>是<code>0</code>。</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>内存分为保留段、数据段、堆(↓)、栈(↑)、内核区。</p>\n<p>数据段包括</p>\n<ul>\n<li>字符串常量：比如NSString * str = @”11”</li>\n<li>已初始化数据：已初始化的全局变量、静态变量等</li>\n<li>未初始化数据：未初始化的全局变量、静态变量等</li>\n</ul>\n<p>栈：函数调用开销、比如局部变量，分配的内存空间地址越来越小。</p>\n<p>堆：通过alloc、malloc、calloc等动态分配的空间，分配的空间地址越来越大。</p>\n<p>验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a = 10;</div><div class=\"line\">int b ;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        static int c = 20;</div><div class=\"line\">        static int d;</div><div class=\"line\">        int e = 10;</div><div class=\"line\">        int f;</div><div class=\"line\">        NSString * str = @&quot;123&quot;;</div><div class=\"line\">        NSObject *obj =[[NSObject alloc]init];</div><div class=\"line\">        NSLog(@&quot;\\na:%p \\nb:%p \\nc:%p \\nd:%p \\ne:%p \\nf:%p \\nobj:%p\\n str:%p&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,obj,str);</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">a:0x1063e0d98 </div><div class=\"line\">b:0x1063e0e64 </div><div class=\"line\">c:0x1063e0d9c </div><div class=\"line\">d:0x1063e0e60 </div><div class=\"line\">e:0x7ffee9820efc </div><div class=\"line\">f:0x7ffee9820ef8 </div><div class=\"line\">obj:0x6000013541a0</div><div class=\"line\">str:0x1063e0068</div></pre></td></tr></table></figure>\n<h3 id=\"Tagged-Pointer\"><a href=\"#Tagged-Pointer\" class=\"headerlink\" title=\"Tagged Pointer\"></a>Tagged Pointer</h3><p>从64bit开始，iOS引入<code>Tagged Pointer</code>技术，用于优化<code>NSNumber、NSDate、NSString</code>等小对象的存储，在没有使用之前，他们需要动态分配内存，维护计数，使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面的数据变成了<code>Tag+Data</code>，也就是将数值直接存储在了指针中，只有当指针不够存储数据时，才会动态分配内存的方式来存储数据，而且<code>objc_msgSend()</code>能够识别出<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用的开销。<br>在iOS中，最高位是1(第64bit)，在Mac中，最低有效位是1。<br>在<code>runtime</code>源码中<code>objc-internal.h 370行</code>判断是否使用了优化技术</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static inline void * _Nonnull</div><div class=\"line\">_objc_encodeTaggedPointer(uintptr_t ptr)</div><div class=\"line\">&#123;</div><div class=\"line\">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们拿来这个可以判断对象是否使用了优化技术。</p>\n<h4 id=\"NSNumbe-Tagged-Pointer\"><a href=\"#NSNumbe-Tagged-Pointer\" class=\"headerlink\" title=\"NSNumbe Tagged Pointer\"></a>NSNumbe Tagged Pointer</h4><p>我们使用几个<code>NSNumber</code>的大小数字来验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ //mac开发</div><div class=\"line\">// 64-bit Mac - tag bit is LSB</div><div class=\"line\">#   define OBJC_MSB_TAGGED_POINTERS 0</div><div class=\"line\">#else</div><div class=\"line\">// Everything else - tag bit is MSB</div><div class=\"line\">#   define OBJC_MSB_TAGGED_POINTERS 1//iOS开发</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if OBJC_MSB_TAGGED_POINTERS</div><div class=\"line\">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</div><div class=\"line\">#else</div><div class=\"line\">#   define _OBJC_TAG_MASK 1UL</div><div class=\"line\">#endif</div><div class=\"line\">bool objc_isTaggedPointer(const void * _Nullable ptr)</div><div class=\"line\">&#123;</div><div class=\"line\">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</div><div class=\"line\">&#125;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        NSNumber *n1 = @2;</div><div class=\"line\">        NSNumber *n2 = @3;</div><div class=\"line\">        NSNumber *n3 = @(4);</div><div class=\"line\">        NSNumber *n4 = @(0x4fffffffff);</div><div class=\"line\">        NSLog(@&quot;\\n%p \\n%p \\n%p \\n%p&quot;,n1,n2,n3,n4);</div><div class=\"line\">        BOOL n1_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n1));</div><div class=\"line\">        BOOL n2_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n2));</div><div class=\"line\">        BOOL n3_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n3));</div><div class=\"line\">        BOOL n4_tag = objc_isTaggedPointer((__bridge const void * _Nullable)(n4));</div><div class=\"line\"></div><div class=\"line\">        NSLog(@&quot;\\nn1:%d \\nn2:%d \\nn3:%d \\nn4:%d &quot;,n1_tag,n2_tag,n3_tag,n4_tag);</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">0xbf4071e2657ccb95 </div><div class=\"line\">0xbf4071e2657ccb85 </div><div class=\"line\">0xbf4071e2657ccbf5 </div><div class=\"line\">0xbf40751d9a833444</div><div class=\"line\">2019-07-30 21:55:52.626317+0800 day17-TaggedPointer[49770:1328036] </div><div class=\"line\">n1:1 </div><div class=\"line\">n2:1 </div><div class=\"line\">n3:1 </div><div class=\"line\">n4:0</div></pre></td></tr></table></figure>\n<p>可以看到<code>n1 n2 n3</code>是经过优化的，而<code>n4</code>是大数字，指针容不下该数值，不能优化。</p>\n<h4 id=\"NSString-Tagged-Pointer\"><a href=\"#NSString-Tagged-Pointer\" class=\"headerlink\" title=\"NSString Tagged Pointer\"></a>NSString Tagged Pointer</h4><p>看下面一道题,运行<code>test1</code>和<code>test2</code>会出现什么问题？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test1&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1000; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们先不运行，先分析一下。</p>\n<p>首先全局队列异步添加任务会出现多线程并发问题，在并发的时候进行写操作会出现资源竞争问题，另外一个小字符串会出现指针优化问题，小字符串和大字符串切换导致<code>_name</code>结构变化，多线程同时写入和读会导致访问坏内存问题，我们来运行一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread: EXC_BAD_ACCESS(code = 1)</div></pre></td></tr></table></figure>\n<p>直接在子线程崩溃了，崩溃函数是<code>objc_release</code>。符合我们的猜想。</p>\n<p>验证<code>NSString Tagged Pointer</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class=\"line\">\t\t\tNSLog(@&quot;test1 class:%@&quot;,self.name.class);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test2&#123;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 1; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\tself.name = [NSString stringWithFormat:@&quot;abcsefafaefafafaefe&quot;];</div><div class=\"line\">\t\t\tNSLog(@&quot;test2 class:%@&quot;,self.name.class);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">test1 class:NSTaggedPointerString</div><div class=\"line\">test2 class:__NSCFString</div></pre></td></tr></table></figure>\n<p>可以看到<code>NSString Tagged Pointer</code>在小字符串的时候类是<code>NSTaggedPointerString</code>，经过优化的类，大字符串的类是<code>__NSCFString</code>，</p>\n<h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>拷贝分为浅拷贝和深拷贝，浅拷贝只是引用计数+1，深拷贝是拷贝了一个对象，和之前的 互不影响， 引用计数互不影响。</p>\n<p>拷贝目的：产生一个副本对象，跟源对象互不影响<br> 修改源对象，不会影响到副本对象<br> 修改副本对象，不会影响源对象</p>\n<p> iOS提供了2中拷贝方法</p>\n<ol>\n<li>copy 拷贝出来不可变对象</li>\n<li>mutableCopy 拷贝出来可变对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test1()&#123;</div><div class=\"line\">\tNSString *str = @&quot;strstrstrstr&quot;;</div><div class=\"line\">\tNSMutableString *mut1 =[str mutableCopy];</div><div class=\"line\">\t[mut1 appendFormat:@&quot;123&quot;];</div><div class=\"line\">\tNSString *str2 = [str copy];</div><div class=\"line\">\tNSLog(@&quot;%p %p %p&quot;,str,mut1,str2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">str:0x100001040 </div><div class=\"line\">mut1:0x1007385f0 </div><div class=\"line\">str2:0x100001040</div></pre></td></tr></table></figure>\n<p>可以看到<code>str</code>和<code>str2</code>地址一样，没有重新复制出来一份，<code>mut1</code>地址和<code>str</code>不一致，是深拷贝，重新拷贝了一份。</p>\n<p>我们把字符串换成其他常用的数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test2()&#123;</div><div class=\"line\">\tNSArray *array = @[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;];</div><div class=\"line\">\tNSMutableArray *mut =[array mutableCopy];</div><div class=\"line\">\tNSString *array2 = [array copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,array,mut,array2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">0x102840800 </div><div class=\"line\">0x1028408a0</div><div class=\"line\">0x102840800</div><div class=\"line\"></div><div class=\"line\">void test3()&#123;</div><div class=\"line\">\tNSArray *array = [@[@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;,@&quot;123&quot;] mutableCopy];</div><div class=\"line\">\tNSMutableArray *mut =[array mutableCopy];</div><div class=\"line\">\tNSString *array2 = [array copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,array,mut,array2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">0x102808720 </div><div class=\"line\">0x1028088a0</div><div class=\"line\">0x1028089a0</div></pre></td></tr></table></figure>\n<p>从上面可以总结看出来，不变数组拷贝出来不变数组，地址不改变，拷贝出来可变数组地址改变，可变数组拷贝出来不可变数组和可变数组，地址会改变。</p>\n<p>我们再换成其他的常用的字典</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test4()&#123;</div><div class=\"line\">\tNSDictionary *item = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</div><div class=\"line\">\tNSMutableDictionary *mut =[item mutableCopy];</div><div class=\"line\">\tNSDictionary *item2 = [item copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,item,mut,item2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">0x1007789c0 </div><div class=\"line\">0x100779190</div><div class=\"line\">0x1007789c0</div><div class=\"line\"></div><div class=\"line\">void test5()&#123;</div><div class=\"line\">\tNSDictionary *item = [@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;mutableCopy];</div><div class=\"line\">\tNSMutableDictionary *mut =[item mutableCopy];</div><div class=\"line\">\tNSDictionary *item2 = [item copy];</div><div class=\"line\">\tNSLog(@&quot;\\n%p \\n%p\\n%p&quot;,item,mut,item2);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">0x1007041d0 </div><div class=\"line\">0x1007042b0</div><div class=\"line\">0x1007043a0</div></pre></td></tr></table></figure>\n<p>从上面可以总结看出来，不变字典拷贝出来不变字典，地址不改变，拷贝出来可变字典地址改变，可变字典拷贝出来不可变字典和可变字典，地址会改变。</p>\n<p>由这几个看出来，总结出来下表</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">copy</th>\n<th style=\"text-align:center\">mutableCopy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">NSString</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableString</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSArray</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableArray</td>\n<td style=\"text-align:center\">深拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSDictionary</td>\n<td style=\"text-align:center\">浅拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSMutableDictionary</td>\n<td style=\"text-align:center\">深拷贝</td>\n<td style=\"text-align:center\">深拷贝</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"自定义对象实现协议NSCoping\"><a href=\"#自定义对象实现协议NSCoping\" class=\"headerlink\" title=\"自定义对象实现协议NSCoping\"></a>自定义对象实现协议NSCoping</h4><p>自定义的对象使用copy呢？系统的已经实现了，我们自定义的需要自己去实现，自定义的类继承<code>NSCopying</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol NSCopying</div><div class=\"line\"></div><div class=\"line\">- (id)copyWithZone:(nullable NSZone *)zone;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@protocol NSMutableCopying</div><div class=\"line\"></div><div class=\"line\">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>看到<code>NSCopying</code>和<code>NSMutableCopying</code>这两个协议，对于自定义的可变对象，其实没什么意义，本来自定义的对象的属性，基本都是可变的，所以只需要实现<code>NSCopying</code>协议就好了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) int age;</div><div class=\"line\">@property (nonatomic,assign) int level;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()&lt;NSCopying&gt;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class=\"line\">\tFYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\tp.age = self.age;</div><div class=\"line\">\tp.level = self.level;</div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">p.age = 10;</div><div class=\"line\">p.level = 11;</div><div class=\"line\">FYPerson *p2 =[p copy];</div><div class=\"line\">NSLog(@&quot;%d %d&quot;,p2.age,p2.level);</div><div class=\"line\">//log</div><div class=\"line\">10 11</div></pre></td></tr></table></figure>\n<p>自己实现了<code>NSCoping</code>协议完成了对对象的深拷贝，成功将对象的属性复制过去了，当属性多了怎么办？我们可以利用<code>runtime</code>实现一个一劳永逸的方案。</p>\n<p>然后将<code>copyWithZone</code>利用<code>runtime</code>遍历所有的成员变量，将所有的变量都赋值，当变量多的时候，这里也不用修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation NSObject (add)</div><div class=\"line\">-(instancetype)copyWithZone:(NSZone *)zone&#123;</div><div class=\"line\">    Class cls = [self class];</div><div class=\"line\">    NSObject * p=[cls new];</div><div class=\"line\">    //成员变量个数</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">    //赋值成员变量数组</div><div class=\"line\">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);</div><div class=\"line\">    //遍历数组</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        Ivar var = ivars[i];</div><div class=\"line\">        //获取成员变量名字</div><div class=\"line\">        const char * name = ivar_getName(var);</div><div class=\"line\">        if (name != nil) &#123;</div><div class=\"line\">            NSString *v = [NSString stringWithUTF8String:name];</div><div class=\"line\">            id value = [self valueForKey:v];</div><div class=\"line\">            //给新的对象赋值</div><div class=\"line\">            if (value != NULL) &#123;</div><div class=\"line\">                [p setValue:value forKey:v];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">    return p;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">p.age = 10;</div><div class=\"line\">p.level = 11;</div><div class=\"line\">p.name = @&quot;xiaowang&quot;;</div><div class=\"line\">FYPerson *p2 =[p copy];</div><div class=\"line\">NSLog(@&quot;%d %d %@&quot;,p2.age,p2.level,p2.name);</div><div class=\"line\">\t\t</div><div class=\"line\">//log</div><div class=\"line\">10 </div><div class=\"line\">11 </div><div class=\"line\">xiaowang</div></pre></td></tr></table></figure>\n<p>根据启动顺序，类别的方法在类的方法加载后边，类别中的方法会覆盖类的方法，所以<br>在基类<code>NSObject</code>在类别中重写了<code>-(instancetype)copyWithZone:(NSZone *)zone</code>方法，子类就不用重写了。达成了一劳永逸的方案。</p>\n<h3 id=\"引用计数原理\"><a href=\"#引用计数原理\" class=\"headerlink\" title=\"引用计数原理\"></a>引用计数原理</h3><p>摘自<a href=\"https://baike.baidu.com/item/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/10205507?fr=aladdin\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<blockquote>\n<p>引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法</p>\n</blockquote>\n<p>在iOS中，使用引用计数来管理<code>OC</code>对象内存，一个新创建的OC对象的引用计数默认是1，当引用计数减为0，<code>OC</code>对象就会销毁，释放其他内存空间，调用<code>retain</code>会让<code>OC</code>对象的引用计数+1，调用<code>release</code>会让<code>OC</code>对象的引用计数-1。<br>当调用<code>alloc、new、copy、mutableCopy</code>方法返回一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>来释放它，想拥有某个对象，就让他的引用计数+1，不再拥有某个对象，就让他引用计数-1.</p>\n<p>在MRC中我们经常都是这样子使用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">FYPerson *p2 =[p retain];</div><div class=\"line\">//code here</div><div class=\"line\">[p release];</div><div class=\"line\">[p2 release];</div></pre></td></tr></table></figure>\n<p>但是在ARC中是系统帮我们做了自动引用计数，不用开发者做很多繁琐的事情了，我们就探究下引用计数是怎么实现的。</p>\n<p>引用计数存储在<code>isa</code>指针中的<code>extra_rc</code>，存储值大于这个范围的时候，则<code>bits.has_sidetable_rc=1</code>然后将剩余的<code>RetainCount</code>存储到全局的<code>table</code>，<code>key</code>是<code>self</code>对应的值。</p>\n<p><code>Retain</code>的<code>runtime</code>源码查找函数路径<code>objc_object::retain()</code>-&gt;<code>objc_object::rootRetain()</code>-&gt;<code>objc_object::rootRetain(bool, bool)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">//大概率x==1 提高读取指令的效率</div><div class=\"line\">#define fastpath(x) (__builtin_expect(bool(x), 1))</div><div class=\"line\">//大概率x==0 提高读取指令的效率</div><div class=\"line\">#define slowpath(x) (__builtin_expect(bool(x), 0))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//引用计数+1</div><div class=\"line\">//tryRetain 尝试+1</div><div class=\"line\">//handleOverflow 是否覆盖</div><div class=\"line\">ALWAYS_INLINE id  objc_object::rootRetain(bool tryRetain, bool handleOverflow)</div><div class=\"line\">&#123;</div><div class=\"line\">\t//优化的指针 返回this</div><div class=\"line\">    if (isTaggedPointer()) return (id)this;</div><div class=\"line\"></div><div class=\"line\">    bool sideTableLocked = false;</div><div class=\"line\">    bool transcribeToSideTable = false;</div><div class=\"line\"></div><div class=\"line\">    isa_t oldisa;</div><div class=\"line\">    isa_t newisa;</div><div class=\"line\"></div><div class=\"line\">    do &#123;</div><div class=\"line\">        transcribeToSideTable = false;</div><div class=\"line\">\t\t//old bits</div><div class=\"line\">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">        newisa = oldisa;</div><div class=\"line\">\t\t//使用联合体技术</div><div class=\"line\">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);//nothing</div><div class=\"line\">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();//解锁</div><div class=\"line\">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</div><div class=\"line\">\t\t\telse return sidetable_retain();////sidetable 引用计数+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        // don&apos;t check newisa.fast_rr; we already called any RR overrides</div><div class=\"line\">\t\t//不尝试retain 和 正在销毁 什么都不做 返回 nil</div><div class=\"line\">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class=\"line\">            return nil;</div><div class=\"line\">        &#125;</div><div class=\"line\">        uintptr_t carry;</div><div class=\"line\">\t\t//引用计数+1 (bits.extra_rc++;)</div><div class=\"line\">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</div><div class=\"line\"></div><div class=\"line\">        if (slowpath(carry)) &#123;</div><div class=\"line\">            // newisa.extra_rc++ 溢出处理</div><div class=\"line\">            if (!handleOverflow) &#123;</div><div class=\"line\">                ClearExclusive(&amp;isa.bits);</div><div class=\"line\">                return rootRetain_overflow(tryRetain);</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t//为拷贝到side table 做准备</div><div class=\"line\">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class=\"line\">            sideTableLocked = true;</div><div class=\"line\">            transcribeToSideTable = true;</div><div class=\"line\">            newisa.extra_rc = RC_HALF;</div><div class=\"line\">            newisa.has_sidetable_rc = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(transcribeToSideTable)) &#123;</div><div class=\"line\">\t\t//拷贝 平外一半的 引用计数到 side table</div><div class=\"line\">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class=\"line\">    return (id)this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//sidetable 引用计数+1</div><div class=\"line\">id objc_object::sidetable_retain()</div><div class=\"line\">&#123;</div><div class=\"line\">#if SUPPORT_NONPOINTER_ISA</div><div class=\"line\">    assert(!isa.nonpointer);</div><div class=\"line\">#endif</div><div class=\"line\">\t//取出table key=this</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    </div><div class=\"line\">    table.lock();</div><div class=\"line\">    size_t&amp; refcntStorage = table.refcnts[this];</div><div class=\"line\">    if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class=\"line\">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\"></div><div class=\"line\">    return (id)this;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>引用计数+1，判断了需要是指针没有优化和<code>isa</code>有没有使用的联合体技术，然后将判断是否溢出，溢出的话，将<code>extra_rc</code>的值复制到<code>side table</code>中，设置参数<code>isa-&gt;has_sidetable_rc=true</code>。</p>\n<p>引用计数-1，在<code>runtime</code>源码中查找路径是<code>objc_object::release()</code>-&gt;<code>objc_object::rootRelease()</code>-&gt;<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>,我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALWAYS_INLINE bool  objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (isTaggedPointer()) return false;//指针优化的不存在计数器</div><div class=\"line\"></div><div class=\"line\">    bool sideTableLocked = false;</div><div class=\"line\"></div><div class=\"line\">    isa_t oldisa;</div><div class=\"line\">    isa_t newisa;</div><div class=\"line\"></div><div class=\"line\"> retry:</div><div class=\"line\">    do &#123;//isa</div><div class=\"line\">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">        newisa = oldisa;</div><div class=\"line\">        if (slowpath(!newisa.nonpointer)) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            if (sideTableLocked) sidetable_unlock();</div><div class=\"line\">\t\t\t//side table -1</div><div class=\"line\">            return sidetable_release(performDealloc);</div><div class=\"line\">        &#125;</div><div class=\"line\">        uintptr_t carry;</div><div class=\"line\">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</div><div class=\"line\">        if (slowpath(carry)) &#123;</div><div class=\"line\">            // don&apos;t ClearExclusive()</div><div class=\"line\">            goto underflow;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class=\"line\">                                             oldisa.bits, newisa.bits)));</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class=\"line\">    return false;</div><div class=\"line\"></div><div class=\"line\"> underflow:</div><div class=\"line\">    newisa = oldisa;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class=\"line\">        if (!handleUnderflow) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            return rootRelease_underflow(performDealloc);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!sideTableLocked) &#123;</div><div class=\"line\">            ClearExclusive(&amp;isa.bits);</div><div class=\"line\">            sidetable_lock();</div><div class=\"line\">            sideTableLocked = true;</div><div class=\"line\">            goto retry;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t//side table 引用计数-1</div><div class=\"line\">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class=\"line\"></div><div class=\"line\">        if (borrowed &gt; 0) &#123;</div><div class=\"line\">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</div><div class=\"line\">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class=\"line\">                                                oldisa.bits, newisa.bits);</div><div class=\"line\">            if (!stored) &#123;</div><div class=\"line\">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">                isa_t newisa2 = oldisa2;</div><div class=\"line\">                if (newisa2.nonpointer) &#123;</div><div class=\"line\">                    uintptr_t overflow;</div><div class=\"line\">                    newisa2.bits = </div><div class=\"line\">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</div><div class=\"line\">                    if (!overflow) &#123;</div><div class=\"line\">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class=\"line\">                                                       newisa2.bits);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!stored) &#123;</div><div class=\"line\">                // Inline update failed.</div><div class=\"line\">                // Put the retains back in the side table.</div><div class=\"line\">                sidetable_addExtraRC_nolock(borrowed);</div><div class=\"line\">                goto retry;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            sidetable_unlock();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            // Side table is empty after all. Fall-through to the dealloc path.</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t//真正的销毁</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(newisa.deallocating)) &#123;</div><div class=\"line\">        ClearExclusive(&amp;isa.bits);</div><div class=\"line\">        if (sideTableLocked) sidetable_unlock();</div><div class=\"line\">        return overrelease_error();</div><div class=\"line\">        // does not actually return</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//设置正在销毁</div><div class=\"line\">    newisa.deallocating = true;</div><div class=\"line\">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</div><div class=\"line\"></div><div class=\"line\">    if (slowpath(sideTableLocked)) sidetable_unlock();</div><div class=\"line\"></div><div class=\"line\">    __sync_synchronize();</div><div class=\"line\">    if (performDealloc) &#123;</div><div class=\"line\">\t\t//销毁</div><div class=\"line\">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看了上边了解到引用计数分两部分，<code>extra_rc</code>和<code>side table</code>，探究一下<br><code>rootRetainCount()</code>的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">inline uintptr_t  objc_object::rootRetainCount()</div><div class=\"line\">&#123;</div><div class=\"line\">\t//优化指针 直接返回</div><div class=\"line\">    if (isTaggedPointer()) return (uintptr_t)this;</div><div class=\"line\">//没优化则 到SideTable 读取</div><div class=\"line\">    sidetable_lock();</div><div class=\"line\">\t//isa指针</div><div class=\"line\">    isa_t bits = LoadExclusive(&amp;isa.bits);</div><div class=\"line\">    ClearExclusive(&amp;isa.bits);//啥都没做</div><div class=\"line\">    if (bits.nonpointer) &#123;//使用联合体存储更多的数据 </div><div class=\"line\">        uintptr_t rc = 1 + bits.extra_rc;//计数数量</div><div class=\"line\">        if (bits.has_sidetable_rc) &#123;//当大过于 联合体存储的值 则另外在SideTable读取数据</div><div class=\"line\">\t//读取table的值 相加</div><div class=\"line\">            rc += sidetable_getExtraRC_nolock();</div><div class=\"line\">        &#125;</div><div class=\"line\">        sidetable_unlock();</div><div class=\"line\">        return rc;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sidetable_unlock();</div><div class=\"line\">\t//在sidetable 中存储的count</div><div class=\"line\">    return sidetable_retainCount();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当是存储小数据的时候，指针优化，则直接返回<code>self</code>,大数据的话，则<code>table</code>加锁，<br><code>class</code>优化的之后<a href=\"https://juejin.im/post/5d2bcf3df265da1b67213d69\" target=\"_blank\" rel=\"external\">使用联合体存储更多的数据</a>,<code>class</code>没有优化则直接去<code>sizedable</code>读取数据。<br>优化了则在<code>sidetable_getExtraRC_nolock()</code>读取数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用联合体</div><div class=\"line\">size_t  objc_object::sidetable_getExtraRC_nolock()</div><div class=\"line\">&#123;</div><div class=\"line\">\t//不是联合体技术 则报错</div><div class=\"line\">    assert(isa.nonpointer);</div><div class=\"line\">\t//key是 this，存储了每个对象的table</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">\t//找到 it 否则返回0</div><div class=\"line\">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class=\"line\">    if (it == table.refcnts.end()) return 0;</div><div class=\"line\">    else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没有优化的是直接读取</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//未使用联合体的情况，</div><div class=\"line\">uintptr_t objc_object::sidetable_retainCount()</div><div class=\"line\">&#123;//没有联合体存储的计数器则直接在table中取出来</div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    size_t refcnt_result = 1;</div><div class=\"line\">    table.lock();</div><div class=\"line\">    RefcountMap::iterator it = table.refcnts.find(this);</div><div class=\"line\">    if (it != table.refcnts.end()) &#123;</div><div class=\"line\">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\">    return refcnt_result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"weak指针原理\"><a href=\"#weak指针原理\" class=\"headerlink\" title=\"weak指针原理\"></a>weak指针原理</h3><p>当一个对象要销毁的时候会调用<code>dealloc</code>,调用轨迹是<code>dealloc</code>-&gt;<code>_objc_rootDealloc</code>-&gt;<code>object_dispose</code>-&gt;<code>objc_destructInstance</code>-&gt;<code>free</code><br>我们进入到<code>objc_destructInstance</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *objc_destructInstance(id obj) </div><div class=\"line\">&#123;</div><div class=\"line\">    if (obj) &#123;</div><div class=\"line\">        // Read all of the flags at once for performance.</div><div class=\"line\">\t\t//c++析构函数</div><div class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</div><div class=\"line\">\t\t//关联函数</div><div class=\"line\">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class=\"line\"></div><div class=\"line\">        // This order is important.</div><div class=\"line\">        if (cxx) object_cxxDestruct(obj);</div><div class=\"line\">        if (assoc) _object_remove_assocations(obj);</div><div class=\"line\">        obj-&gt;clearDeallocating();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>销毁了c++析构函数和关联函数最后进入到<code>clearDeallocating</code>，我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//正在清除side table 和weakly referenced</div><div class=\"line\">inline void </div><div class=\"line\">objc_object::clearDeallocating()</div><div class=\"line\">&#123;</div><div class=\"line\">    if (slowpath(!isa.nonpointer)) &#123;</div><div class=\"line\">        // Slow path for raw pointer isa.</div><div class=\"line\">\t\t//释放weak</div><div class=\"line\">        sidetable_clearDeallocating();</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</div><div class=\"line\">        // Slow path for non-pointer isa with weak refs and/or side table data.</div><div class=\"line\">\t\t//释放weak 和引用计数</div><div class=\"line\">        clearDeallocating_slow();</div><div class=\"line\">    &#125;</div><div class=\"line\">    assert(!sidetable_present());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终调用了<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>实现销毁<code>weak</code>和引用计数<code>side table</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">NEVER_INLINE void</div><div class=\"line\">objc_object::clearDeallocating_slow()</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</div><div class=\"line\"></div><div class=\"line\">    SideTable&amp; table = SideTables()[this];</div><div class=\"line\">    table.lock();</div><div class=\"line\">\t//清除weak</div><div class=\"line\">    if (isa.weakly_referenced) &#123;</div><div class=\"line\">\t\t//table.weak_table 弱引用表</div><div class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//引用计数</div><div class=\"line\">    if (isa.has_sidetable_rc) &#123;</div><div class=\"line\">\t\t//擦除 this</div><div class=\"line\">        table.refcnts.erase(this);</div><div class=\"line\">    &#125;</div><div class=\"line\">    table.unlock();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实<code>weak</code>修饰的对象会存储在全局的<code>SideTable</code>，当对象销毁的时候会在<code>SideTable</code>进行查找，时候有<code>weak</code>对象，有的话则进行销毁。</p>\n<h3 id=\"Autoreleasepool-原理\"><a href=\"#Autoreleasepool-原理\" class=\"headerlink\" title=\"Autoreleasepool 原理\"></a>Autoreleasepool 原理</h3><p><code>Autoreleasepool</code>中文名自动释放池，里边装着一些变量，当池子不需要（销毁）的时候，<code>release</code>里边的对象(引用计数-1)。<br>我们将下边的代码转化成c++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@autoreleasepool &#123;</div><div class=\"line\">\t\tFYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -f  main.m</code><br>转成c++</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* @autoreleasepool */ &#123;</div><div class=\"line\"> __AtAutoreleasePool __autoreleasepool;</div><div class=\"line\"> FYPerson *p = ((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((FYPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FYPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>__AtAutoreleasePool</code>是一个结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __AtAutoreleasePool &#123;</div><div class=\"line\">\t__AtAutoreleasePool() &#123;//构造函数 生成结构体变量的时候调用</div><div class=\"line\">\t\tatautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t~__AtAutoreleasePool() &#123;//析构函数 销毁的时候调用</div><div class=\"line\">\t\tobjc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvoid * atautoreleasepoolobj;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后将上边的代码和c++整合到一起就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    __AtAutoreleasePool pool = objc_autoreleasePoolPush();</div><div class=\"line\">    FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">    objc_autoreleasePoolPop(pool)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在进入大括号生成一个释放池，离开大括号则释放释放池，我们再看一下释放函数是怎么工作的,在<code>runtime</code>源码中<code>NSObject.mm 1848 行</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void objc_autoreleasePoolPop(void *ctxt)</div><div class=\"line\">&#123;</div><div class=\"line\">    AutoreleasePoolPage::pop(ctxt);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>pop</code>实现了<code>AutoreleasePoolPage</code>中的对象的释放，想了解怎么释放的可以研究下源码<code>runtime NSObject.mm 1063行</code>。</p>\n<p>其实<code>AutoreleasePool</code>是<code>AutoreleasePoolPage</code>来管理的，<code>AutoreleasePoolpage</code>结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class AutoreleasePoolPage &#123;</div><div class=\"line\">    magic_t const magic;</div><div class=\"line\">    id *next;//下一个存放aotoreleass对象的地址</div><div class=\"line\">    pthread_t const thread;//线程</div><div class=\"line\">    AutoreleasePoolPage * const parent; //父节点</div><div class=\"line\">    AutoreleasePoolPage *child;//子节点</div><div class=\"line\">    uint32_t const depth;//深度</div><div class=\"line\">    uint32_t hiwat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>AutoreleasePoolPage</code>在初始化在<code>autoreleaseNewPage</code>申请了<code>4096</code>字节除了自己变量的空间，<code>AutoreleasePoolPage</code>是一个<code>C++</code>实现的类</p>\n<ul>\n<li>内部使用<code>id *next</code>指向了栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>\n<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>page</code>加入</li>\n<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>\n<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的<code>thread</code>指针指向当前线程）</li>\n<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>\n</ul>\n<p>其他的都是自动释放池的其他对象的指针，我们使用<code>_objc_autoreleasePoolPrint()</code>可以查看释放池的存储内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern void _objc_autoreleasePoolPrint(void);</div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\"></div><div class=\"line\">\t\tFYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t\t_objc_autoreleasePoolPrint();</div><div class=\"line\">\t\tprintf(&quot;\\n--------------\\n&quot;);</div><div class=\"line\">\t&#125;//pop(r1)</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">objc[23958]: ##############</div><div class=\"line\">objc[23958]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class=\"line\">objc[23958]: 3 releases pending.</div><div class=\"line\">objc[23958]: [0x101000000]  ................  PAGE  (hot) (cold)</div><div class=\"line\">objc[23958]: [0x101000038]  ################  POOL 0x101000038</div><div class=\"line\">objc[23958]: [0x101000040]       0x10050cfa0  FYPerson</div><div class=\"line\">objc[23958]: [0x101000048]       0x10050cdb0  FYPerson</div><div class=\"line\">objc[23958]: ##############</div><div class=\"line\"></div><div class=\"line\">--------------</div></pre></td></tr></table></figure>\n<p>可以看到存储了<code>3 releases pending</code>一个对象，而且大小都8字节。再看一个复杂的,自动释放池嵌套自动释放池</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\"></div><div class=\"line\">\t\tFYPerson *p = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\tFYPerson *p2 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t@autoreleasepool &#123;//r1 = push()</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tFYPerson *p3 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t\tFYPerson *p4 = [[[FYPerson alloc]init] autorelease];</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\t_objc_autoreleasePoolPrint();</div><div class=\"line\">\t\t\tprintf(&quot;\\n--------------\\n&quot;);</div><div class=\"line\">\t\t&#125;//pop(r1)</div><div class=\"line\">\t&#125;//pop(r1)</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">objc[24025]: ##############</div><div class=\"line\">objc[24025]: AUTORELEASE POOLS for thread 0x1000aa5c0</div><div class=\"line\">objc[24025]: 6 releases pending.</div><div class=\"line\">objc[24025]: [0x100803000]  ................  PAGE  (hot) (cold)</div><div class=\"line\">objc[24025]: [0x100803038]  ################  POOL 0x100803038</div><div class=\"line\">objc[24025]: [0x100803040]       0x100721580  FYPerson</div><div class=\"line\">objc[24025]: [0x100803048]       0x100721b10  FYPerson</div><div class=\"line\">objc[24025]: [0x100803050]  ################  POOL 0x100803050</div><div class=\"line\">objc[24025]: [0x100803058]       0x100721390  FYPerson</div><div class=\"line\">objc[24025]: [0x100803060]       0x100717620  FYPerson</div><div class=\"line\">objc[24025]: ##############</div></pre></td></tr></table></figure>\n<p>看到了2个<code>POOL</code>和四个<code>FYPerson</code>对象，一共是6个对象，当出了释放池会执行<code>release</code>。</p>\n<p>当无优化的指针调用<code>autorelease</code>其实是调用了<code>AutoreleasePoolPage::autorelease((id)this)</code>-&gt;<code>autoreleaseFast(obj)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static inline id *autoreleaseFast(id obj)</div><div class=\"line\"> &#123;</div><div class=\"line\">     AutoreleasePoolPage *page = hotPage();</div><div class=\"line\">     //当有分页而且分页没有满就添加</div><div class=\"line\">     if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class=\"line\">         return page-&gt;add(obj);</div><div class=\"line\">     &#125; else if (page) &#123;</div><div class=\"line\">         //满则新建一个page进行添加obj和设置hotpage</div><div class=\"line\">         return autoreleaseFullPage(obj, page);</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         //没有page则新建page进行添加</div><div class=\"line\">         return autoreleaseNoPage(obj);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在<code>MRC</code>中<br><code>autorealease</code>修饰的是的对象在没有外部添加到自动释放池的时候，在<code>runloop</code>循环的时候会销毁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</div><div class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</div><div class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</div><div class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</div><div class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</div><div class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),</div><div class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//activities = 0xa0转化成二进制 0b101 0000</div><div class=\"line\">系统监听了mainRunloop 的 kCFRunLoopBeforeWaiting 和kCFRunLoopExit两种状态来更新autorelease的数据</div><div class=\"line\">//回调函数是 _wrapRunLoopWithAutoreleasePoolHandler</div><div class=\"line\"></div><div class=\"line\">&quot;&lt;CFRunLoopObserver 0x600002538320 [0x10ce45ae8]&gt;&#123;valid = Yes, activities = 0xa0, </div><div class=\"line\">repeats = Yes, order = 2147483647, </div><div class=\"line\">callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10f94087d), </div><div class=\"line\">context = &lt;CFArray 0x600001a373f0 [0x10ce45ae8]&gt;&#123;type = mutable-small, count = 1, </div><div class=\"line\">values = (\\n\\t0 : &lt;0x7fb6dc004058&gt;\\n)&#125;&#125;&quot;</div></pre></td></tr></table></figure>\n<p><code>activities = 0xa0</code>转化成二进制 <code>0b101 0000</code><br>系统监听了<code>mainRunloop</code> 的 <code>kCFRunLoopBeforeWaiting</code> 和<code>kCFRunLoopExit</code>两种状态来更新<code>autorelease</code>的数据<br>回调函数是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void test()&#123;</div><div class=\"line\">    FYPerson *p =[[FYPerson alloc]init];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>p</code>对象在某次循环中<code>push</code>，在循环到<code>kCFRunLoopBeforeWaiting</code>进行一次<code>pop</code>，则上次循环的<code>autolease</code>对象没有其他对象<code>retain</code>的进行释放。并不是出了<code>test()</code>立马释放。</p>\n<p>在ARC中则执行完毕<code>test()</code>会马上释放。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>当重复创建对象或者代码段不容易管理生命周期使用自动释放池是不错的选择。</li>\n<li>存在在全局的<code>SideTable</code>中weak修饰的对象会在<code>dealloc</code>函数执行过程中检测或销毁该对象。</li>\n<li>可变对象拷贝一定会生成已新对象，不可变对象拷贝成不可变对象则是引用计数+1。</li>\n<li>优化的指向对象的指针，不用走<code>objc_msgSend()</code>的消息流程从而提高性能。</li>\n<li><code>CADisplayLink</code>和<code>Timer</code>本质是加到<code>loop</code>循环当中，依附于循环，没有<code>runloop</code>，则不能正确执行，使用<code>runloop</code>需要注意循环引用和<code>runloop</code>所在的线程的释放问题。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"external\">黑幕背后的Autorelease\n</a></li>\n<li>小码哥视频</li>\n<li>iOS和OS多线程与内存管理</li>\n<li>iOS和macOS性能优化<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  多线程之GCD看我就够了 --(10)","date":"2019-12-01T03:20:58.000Z","_content":"\n`RunLoop`和线程的关系，以及`Thread`如何保活和控制生命周期，今天我们再探究下另外的一个线程`GCD`，揭开蒙娜丽莎的面纱。\n### GCD 基础知识\nGCD是什么呢？我们引用[百度百科](https://baike.baidu.com/item/GCD)的一段话。\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。\n\nGCD有哪些优点\n- GCD自动管理线程\n- 开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可\n- GCD 自动管理线程，线程创建，挂起，销毁。\n\n那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发\n#### 串行队列\n串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。\n#### 并行队列\n并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。\n#### 并发\n并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活\n\n**串行队列**相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。\n\n**并行队列**是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。\n\n**并发**是多个流水线在同时加工产品。\n\n\n#### GCD中的串行队列()\n##### 串行队列（Serial Dispatch Queue）：\n按照**FIFO**(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。\n\n\n![](../images/10-1.png)\n#####  并发队列（Concurrent Dispatch Queue）：\n按照**FIFO**(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。\n\n\n\n![](../images/10-2.png)\n\n### GCD使用步骤\nGCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。\n\n下边来看看 **队列的创建方法/获取方法**，以及 **任务的创建方法**。\n#### 获取主队列\n主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过`dispatch_get_main_queue()`，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。\n\n```\n//获取主队列\ndispatch_queue_t main_queue= dispatch_get_main_queue();\n```\n\n#### 获取全局队列\n全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)`,第一个参数是`identifier`，表示队列的优先级，一般传入`DISPATCH_QUEUE_PRIORITY_DEFAULT`，第二个参数`flags`，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自[libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n> Use the\n.Fn dispatch_get_global_queue\nfunction to obtain the global queue of given priority. The\n.Fa flags\nargument is reserved for future use and must be zero. Passing any value other\nthan zero may result in a NULL return value.\n\n```\n//获取全局队列\ndispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n```\n\n#### 任务的创建\nGCD 提供了同步执行任务的创建方法`dispatch_sync`和异步执行任务创建方法的`spatch_async`。\n\n```\n// 同步执行任务创建方法\ndispatch_sync(queue, ^{\n    // 这里放同步执行任务代码\n});\n// 异步执行任务创建方法\ndispatch_async(queue, ^{\n    // 这里放异步执行任务代码\n});\n```\n\n虽然是只有同步异步但是他们组合的多变的\n\n||并发队列|创建的串行队列|主队列|\n|:-:|:-:|:-:|:-:|\n|同步(sync)|没开启新线程，串行执行|没开启新线程，串行执行任务|没开启新线程，串行执行任务|\n|异步(async)|能开启新线程，并发执行|能开启新线程，串行执行任务|没开启新线程，串行执行任务|\n\n### GCD的使用\n#### 主队列+同步\n在主队列中执行任务，并同步添加任务\n\n```\n//主队列+同步\n-(void)syn_main{\n\tNSLog(@\"1\");\n\tdispatch_queue_t main_queue = dispatch_get_main_queue();\n\tdispatch_sync(main_queue, ^{\n\t\tNSLog(@\"2\");\n\t});\n\tNSLog(@\"3\");\n}\n//log\n1\n```\n\n看到日志只输出了1就崩溃了提示`exc_bad_instuction`,为什么出问题呢？\n主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。\n**what**???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句`exc_bad_instuction`，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。\n那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦\n\n```\n//主队列+同步\n-(void)syn_main2{\n\tNSLog(@\"1任务执行\");\n\tsleep(1);\n\tNSLog(@\"2任务执行\");\n\tsleep(1);\n\tNSLog(@\"3任务执行\");\n}\n//log\n1任务执行\n2任务执行\n3任务执行\n```\n\n没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。\n\n#### 主队列+异步\n在主队列中异步添加任务并执行任务\n\n```\n//主队列+异步\n\tNSLog(@\"start\");\n\tdispatch_queue_t main_queue = dispatch_get_main_queue();\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tNSLog(@\"end\");\n//log\n2019-07-24 15:12:24.73 start\n2019-07-24 15:12:24.73 end\n\n<NSThread: 0x600002f9a940>{number = 1, name = main} 0\n2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 1\n2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 2\n2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 3\n2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 4\n2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 5\n2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 7\n2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 8\n2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 9\n```\n\n在主队列异步执行任务，从日志看出来`end`早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到\n- 主线程多个任务异步不能创建新线程\n- 主线程异步也是串行执行\n\n\n#### 全局队列+同步\n全局队列是并行队列，和同步配合就是串行执行了。\n\n```\n//全局队列+同步\n-(void)sync_global{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_sync(global_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(global_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(global_queue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\nstart\n 2019-07-24 15:35:36 <NSThread: 0x600000592900>{number = 1, name = main} 0\n 2019-07-24 15:35:37 <NSThread: 0x600000592900>{number = 1, name = main} 1\n 2019-07-24 15:35:38 <NSThread: 0x600000592900>{number = 1, name = main} 2\n 2019-07-24 15:35:39 <NSThread: 0x600000592900>{number = 1, name = main} 3\n 2019-07-24 15:35:40 <NSThread: 0x600000592900>{number = 1, name = main} 4\n 2019-07-24 15:35:41 <NSThread: 0x600000592900>{number = 1, name = main} 5\n 2019-07-24 15:35:42 <NSThread: 0x600000592900>{number = 1, name = main} 7\n 2019-07-24 15:35:43 <NSThread: 0x600000592900>{number = 1, name = main} 8\n 2019-07-24 15:35:44 <NSThread: 0x600000592900>{number = 1, name = main} 9\n end\n```\n\n在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。\n#### 全局队列+异步\n全局队列有创建子线程的能力，但是需要异步`async`去执行。\n\n```\n//全局队列+异步\n-(void)async_global{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_async(global_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(global_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(global_queue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n-(NSString *)currentDateString{\n\tNSDate *date=[NSDate new];\n\tNSDateFormatter *format = [[NSDateFormatter alloc]init];\n\t[format setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\n\treturn [format stringFromDate:date];\n}\n//log\n\n start\n end\n 2019-07-24 15:40:21 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 3\n 2019-07-24 15:40:21 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 0\n 2019-07-24 15:40:21 <NSThread: 0x600003b45880>{number = 3, name = (null)} 7\n 2019-07-24 15:40:22 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 1\n 2019-07-24 15:40:22 <NSThread: 0x600003b45880>{number = 3, name = (null)} 8\n 2019-07-24 15:40:22 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 4\n 2019-07-24 15:40:23 <NSThread: 0x600003b45880>{number = 3, name = (null)} 9\n 2019-07-24 15:40:23 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 2\n 2019-07-24 15:40:23 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 5\n```\n\n全局队列当搭配`async`的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。\n#### 创建串行队列+同步\n开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。\n\n```\n//创建串行队列+同步\n-(void)sync_cust_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_SERIAL);\n\tdispatch_sync(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n\n//log\n\nstart\n 2019-07-24 15:53:15 <NSThread: 0x6000017ea940>{number = 1, name = main} 0\n 2019-07-24 15:53:16 <NSThread: 0x6000017ea940>{number = 1, name = main} 1\n 2019-07-24 15:53:17 <NSThread: 0x6000017ea940>{number = 1, name = main} 2\n 2019-07-24 15:53:18 <NSThread: 0x6000017ea940>{number = 1, name = main} 3\n 2019-07-24 15:53:19 <NSThread: 0x6000017ea940>{number = 1, name = main} 4\n 2019-07-24 15:53:20 <NSThread: 0x6000017ea940>{number = 1, name = main} 5\n 2019-07-24 15:53:21 <NSThread: 0x6000017ea940>{number = 1, name = main} 7\n 2019-07-24 15:53:22 <NSThread: 0x6000017ea940>{number = 1, name = main} 8\n 2019-07-24 15:53:23 <NSThread: 0x6000017ea940>{number = 1, name = main} 9\n end\n```\n\n同步向串行队列添加任务并没有死锁！原因是添加任务是在`main_queue`执行的，添加的任务是在`cust-queue`中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在`main`线程中。\n\n#### 创建串行队列+异步\n会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务\n\n```\n//创建串行队列+异步\n-(void)async_cust_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_SERIAL);\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\n\n start\n end\n 2019-07-24 16:12:57 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 0\n 2019-07-24 16:12:58 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 1\n 2019-07-24 16:12:59 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 2\n 2019-07-24 16:13:00 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 3\n 2019-07-24 16:13:01 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 4\n 2019-07-24 16:13:02 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 5\n 2019-07-24 16:13:03 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 7\n 2019-07-24 16:13:04 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 8\n 2019-07-24 16:13:05 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 9\n```\n\n在`异步 + 串行队列`可以看到：\n\n开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。\n所有任务是在打印的`end`之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。\n任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。\n#### 创建并行队列+同步\n在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务\n\n```\n start\n 2019-07-24 16:21:24 <NSThread: 0x6000031d1380>{number = 1, name = main} 0\n 2019-07-24 16:21:25 <NSThread: 0x6000031d1380>{number = 1, name = main} 1\n 2019-07-24 16:21:26 <NSThread: 0x6000031d1380>{number = 1, name = main} 2\n 2019-07-24 16:21:27 <NSThread: 0x6000031d1380>{number = 1, name = main} 3\n 2019-07-24 16:21:28 <NSThread: 0x6000031d1380>{number = 1, name = main} 4\n 2019-07-24 16:21:29 <NSThread: 0x6000031d1380>{number = 1, name = main} 5\n 2019-07-24 16:21:30 <NSThread: 0x6000031d1380>{number = 1, name = main} 7\n 2019-07-24 16:21:31 <NSThread: 0x6000031d1380>{number = 1, name = main} 8\n 2019-07-24 16:21:32 <NSThread: 0x6000031d1380>{number = 1, name = main} 9\n end\n```\n\n全局队列其实就是特殊的并行队列，这里结果和`全局队列+同步`一致。\n\n#### 创建并行队列+异步\n在当前线程中执行任务，会开启新线程，可以同时执行多个任务。\n\n```\n//创建并行队列+异步\n-(void)async_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\nstart\n end\n 2019-07-24 16:22:09 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 7\n 2019-07-24 16:22:09 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 0\n 2019-07-24 16:22:09 <NSThread: 0x600000422300>{number = 4, name = (null)} 3\n 2019-07-24 16:22:10 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 1\n 2019-07-24 16:22:10 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 8\n 2019-07-24 16:22:10 <NSThread: 0x600000422300>{number = 4, name = (null)} 4\n 2019-07-24 16:22:11 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 9\n 2019-07-24 16:22:11 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 2\n 2019-07-24 16:22:11 <NSThread: 0x600000422300>{number = 4, name = (null)} 5\n```\n\n`并行队列+异步`和`全局队列+异步`一致，也会新建线程执行任务，且是并发执行。\n### GCD其他高级用法\n#### 子线程执行任务 主线程刷新UI\n\n```\n- (void)backToMain{\n\tdispatch_queue_t main = dispatch_get_main_queue();\n\tdispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_async(glo, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t\tdispatch_sync(main, ^{\n\t\t\tprintf(\"\\n %s %s 我在刷新UI\",[self dateUTF8],[self threadInfo]);\n\t\t});\n\t});\t\n}\n//log\n 2019-07-24 16:45:07 <NSThread: 0x600001e84380>{number = 3, name = (null)} 0\n 2019-07-24 16:45:08 <NSThread: 0x600001e84380>{number = 3, name = (null)} 1\n 2019-07-24 16:45:09 <NSThread: 0x600001e84380>{number = 3, name = (null)} 2\n 2019-07-24 16:45:09 <NSThread: 0x600001ef2940>{number = 1, name = main} 我在刷新UI\n```\n\n#### 队列分组 dispatch_group_t\n##### dispatch_group_notify \nGCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过`dispatch_group_notify`完成回调，第一个参数`group`是某个分组的回调。\n\n```\n-(void)group{\n\tdispatch_group_t group = dispatch_group_create();\n\tdispatch_queue_t queue= dispatch_queue_create(\"cust.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_queue_t queue2= dispatch_queue_create(\"cust2.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_group_async(group, queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_async(group, queue2, ^{\n\t\tfor (int i = 4; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_notify(group, dispatch_get_main_queue(), ^{\n\t\tprintf(\"\\n %s %s ---end1----\",[self dateUTF8],[self threadInfo]);\n\t});\n\tdispatch_group_async(group, queue, ^{\n\t\tfor (int i = 6; i < 8; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_async(group, queue2, ^{\n\t\tfor (int i = 8; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n}\n```\n\n##### dispatch_group_wait && dispatch_group_enter && dispatch_group_leave\n`dispatch_group_enter`和`dispatch_group_leave`需要成对使用，否则`dispatch_group_wait`在缺少`leave`的情况下会等待到死，造成线程阻塞。\n\n```\nstatic\tdispatch_group_t group ;\nif (group == nil) {\n\tgroup = dispatch_group_create();\n}\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n//\tdispatch_group_enter(group);\ndispatch_group_async(group, queue, ^{\n\t[self print];\n\t[NSThread sleepForTimeInterval:2];\n//\t\tdispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行\n});\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n\ndispatch_group_enter(group);\ndispatch_group_async(group, queue, ^{\n\t[self print];\n\t[NSThread sleepForTimeInterval:2];\n\tdispatch_group_leave(group);\n});\n//log\n2019-07-25 10:58:50 <NSThread: 0x600002d84180>{number = 3, name = (null)} \n2019-07-25 10:58:52 <NSThread: 0x600002d84180>{number = 3, name = (null)} \n\n```\n\n#### 栅栏函数 dispatch_barrier_sync\n栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。\n\n\n```\n- (void)barry{\n\tdispatch_queue_t queue= dispatch_queue_create(\"cust.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_barrier_sync(queue, ^{\n\t\tprintf(\"\\n %s %s ---中间暂停一下----\",[self dateUTF8],[self threadInfo]);\n\t});\n\tdispatch_async(queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_barrier_async(queue, ^{\n\t\tprintf(\"\\n %s %s ---中间第二次暂停一下----\",[self dateUTF8],[self threadInfo]);\n\t});\n}\n//log\n 2019-07-24 16:52:33 <NSThread: 0x600003158440>{number = 3, name = (null)} 0\n 2019-07-24 16:52:34 <NSThread: 0x600003158440>{number = 3, name = (null)} 1\n 2019-07-24 16:52:35 <NSThread: 0x600003158440>{number = 3, name = (null)} 2\n 2019-07-24 16:52:35 <NSThread: 0x6000031293c0>{number = 1, name = main} ---中间暂停一下----\n 2019-07-24 16:52:36 <NSThread: 0x600003158440>{number = 3, name = (null)} 3\n 2019-07-24 16:52:37 <NSThread: 0x600003158440>{number = 3, name = (null)} 4\n 2019-07-24 16:52:38 <NSThread: 0x600003158440>{number = 3, name = (null)} 5\n 2019-07-24 16:52:38 <NSThread: 0x600003158440>{number = 3, name = (null)} ---中间第二次暂停一下----\n```\n\n#### 单例-执行一次的函数 dispatch_once_t\n单例可以通过这个函数实现，只执行一次的函数。\n\n```\n//只执行一次的dispatch_once\n-(void)exc_once{\n\tstatic dispatch_once_t onceToken;\n\tstatic NSObject *obj;\n\tdispatch_once(&onceToken, ^{\n\t\tobj=[NSObject new];\n\t\tprintf(\"\\n just once %s %s\",[self dateUTF8],obj.description.UTF8String);\n\t});\n\tprintf(\"\\n %s %s\",[self dateUTF8],obj.description.UTF8String);\n}\n调用4次\ndispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\t[self exc_once];\n\t});\n\t\n//log\njust once 2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n```\n\n当调用4次的时候，日志打印的四次`obj`均为同一个地址，证明`block`回调四次但是只执行了一次。\n#### 延迟执行 dispatch_after\n当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟\n\n```\n//延迟执行\n-(void)delayTimeExc{\n\tprintf(\"\\n %s %s begin\",[self dateUTF8],[self threadInfo]);\n\t\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\n\t\tprintf(\"\\n %s %s\",[self dateUTF8],[self threadInfo]);\n\t\t\n\t});\n\tprintf(\"\\n %s %s end\",[self dateUTF8],[self threadInfo]);\n}\n//log\n2019-07-24 17:07:48 <NSThread: 0x600003cc6940>{number = 1, name = main} begin\n2019-07-24 17:07:48 <NSThread: 0x600003cc6940>{number = 1, name = main} end\n2019-07-24 17:07:50 <NSThread: 0x600003cc6940>{number = 1, name = main}\n```\n\n#### 信号量  dispatch_semaphore_t\n信号量为1可以作为线程锁来用，当N>1的时候，同时执行的有N个任务。\n`dispatch_apply`可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。\n\n```\n//信号量 当信号量为1 可以未做锁来用，当N>1，t通知执行的数量则是数字N。\n- (void)semaphore{\n\tstatic dispatch_semaphore_t sem;\n\tif (sem == NULL) {\n\t\tsem = dispatch_semaphore_create(1);\n\t}\n\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);\n\tstatic int i = 0;\n\tint currentI = i +2;\n\tfor (; i < currentI; i ++) {\n\t\t[NSThread sleepForTimeInterval:1];\n\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t}\n\tdispatch_semaphore_signal(sem);\n}\n-(void)asyn_semaphore{\n\tdispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\t[self semaphore];\n\t});\n}\n//log\n\n2019-07-24 17:25:04 <NSThread: 0x6000002a2940>{number = 1, name = main} 0\n2019-07-24 17:25:05 <NSThread: 0x6000002a2940>{number = 1, name = main} 1\n2019-07-24 17:25:06 <NSThread: 0x6000002e2b40>{number = 3, name = (null)} 2\n2019-07-24 17:25:07 <NSThread: 0x6000002e2b40>{number = 3, name = (null)} 3\n2019-07-24 17:25:08 <NSThread: 0x6000002d4740>{number = 4, name = (null)} 4\n2019-07-24 17:25:09 <NSThread: 0x6000002d4740>{number = 4, name = (null)} 5\n```\n\n设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。\n\n```\n-(void)muchQueueBuyTick{\n\tdispatch_queue_t queue= dispatch_queue_create(\"com.buy.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:4];\n\t\t}\n\t});\n\tdispatch_queue_t queue2= dispatch_queue_create(\"com.buy2.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue2, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:2];\n\t\t}\n\t});\n}\n- (void)semaphore_buy_ticks:(NSInteger)windowsCount{\n\tstatic dispatch_semaphore_t sem;\n\tif (sem == NULL) {\n\t\tsem = dispatch_semaphore_create(windowsCount);\n\t}\n\t//信号量-1\n\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);\n\tself.count--;\n\tif (self.count > 0) {\n\t\tprintf(\"\\n %s %s 第%ld个人买到票了\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);\n\t\t[NSThread sleepForTimeInterval:0.2];\n\t}\n\t//信号量+1\n\tdispatch_semaphore_signal(sem);\n}\n//log\n\n2019-07-24 18:01:44 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第8个人买到票了\n 2019-07-24 18:01:44 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第8个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第6个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第6个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第4个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第4个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第2个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第2个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第0个人买到票了\n```\n\n两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。\n当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。\n\n```\n-(void)muchQueueBuyTick{\n\tdispatch_queue_t queue= dispatch_queue_create(\"com.buy.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:1];\n\t\t}\n\t});\n\tdispatch_queue_t queue2= dispatch_queue_create(\"com.buy2.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue2, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:1];\n\t\t}\n\t});\n}\n//log\n2019-07-24 18:03:56 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第9个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第8个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第7个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第6个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第5个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第4个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第3个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第2个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第1个人买到票了\n```\n\n顺序是对了，数量也对了。\n\n再换一种思路实现锁住窗口，我们使用串行队列也是可以的。\n\n```\n//使用同步队列卖票\n- (void)sync_buy_tick{\n\tdispatch_async(dispatch_get_main_queue(), ^{\n\t\tself.count--;\n\t\tif (self.count > 0) {\n\t\t\tprintf(\"\\n %s %s 第%ld个人买到票了\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);\n\t\t\t[NSThread sleepForTimeInterval:0.2];\n\t\t}\n\t});\n}\n//log\n2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第9个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第8个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第7个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第6个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第5个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第4个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第3个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第2个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第1个人买到票了\n```\n\n串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。\n\n#### 快速迭代方法：dispatch_apply\n快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。\n\n```\n/*\n同时新建了多条线程来做任务\n*/\n\tdispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\tprintf(\"\\n %s %s \",[self dateUTF8],[self threadInfo]);\n\t});\n\t\n\t//log\n2019-07-25 09:38:38 <NSThread: 0x600000966180>{number = 4, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x60000094a3c0>{number = 3, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x600000979dc0>{number = 5, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x60000090d3c0>{number = 1, name = main} \n2019-07-25 09:38:38 <NSThread: 0x60000095cfc0>{number = 6, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x600000950140>{number = 8, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000095d0c0>{number = 9, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000094a400>{number = 7, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x600000966180>{number = 4, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000094a3c0>{number = 3, name = (null)} \n```\n\n可以看到新建了`3`、`4`、`5`、`6`、`7`、`8`、`9`、`main`来执行任务。\n### 多线程RunLoop实战\n问题一：请问下边代码输出什么？\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n- (void)test{\n    NSLog(@\"2\");\n}\n```\n\n- 猜想1：结果是`123`\n- 猜想2：结果是`132`\n\n有没有第三种结果呢？\n\n猜想1分析：\n因为是延迟`0`s执行，当然是先执行`2`，再执行`3`了。\n\n猜想2分析：\n\n我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出`1`，然后输出`3`，最后输出`2`.\n\n最后验证一下：\n\n```\n1\n3\n```\n\n为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在`runloop.h`文件中，我们猜测延迟执行是`timer`添加到`runloop`中了，添加进去也应该输出`132`的。因为在子线程中，没有主动调用不会有`runloop`的，及时调用了也需要保活技术，那么代码改进一下\n\n```\n    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        // 相当于[self test];\n//       [self performSelector:@selector(test) withObject:nil];\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        \n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];\n        [[NSRunLoop currentRunLoop] run];\n        NSLog(@\"3\");\n    });\n```\n\n经测试输出了`12`，这和我们猜想的还是不对，原来输出`3`放在了最后，导致的问题，`RunLoop`运行起来，进入了循环，则后面的就不会执行了，除非停止当前`RunLoop`，我们再改进一下\n\n```\n    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        // 相当于[self test];\n//       [self performSelector:@selector(test) withObject:nil];\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n         NSLog(@\"3\");\n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];\n        [[NSRunLoop currentRunLoop] run];\n    });\n```\n\n最后终于输出了`132`。缺点是子线程成了**死待**，不死之身，关于怎么杀死**死待**请看[上篇优雅控制RunLoop生命周期](https://juejin.im/post/5d35b347f265da1b8608c49b)。\n关于`performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay`中有延迟的，都是添加到当前你线程的`RunLoop`，如果没有启动`RunLoop`和保活恐怕也不能一直执行。`[self performSelector:@selector(test) withObject:nil]`是在`Foudation`中，源码是直接`objc_msgSend()`，相当于直接`[self test]`，不会有延迟。\n\n问题2：请问输出什么？\n\n```\nNSThread *thread=[[NSThread alloc]initWithBlock:^{\n    NSLog(@\"1\");\n}];\n[thread start];\n[self performSelector:@selector(test)\n             onThread:thread\n           withObject:nil\n        waitUntilDone:YES];\n```\n\n这个和上面的类似，结果是打印了`1`就崩溃了，原因是`thread start`之后执行完`block`就结束了，没有`runloop`的支撑。当执行`performSelector`的时候，线程已经死掉。解决这个问题只需要向子线程中添加`RunLoop`，而且保证`RunLoop`不停止就行了。\n\n\n\n### 总结\n- GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI\n- 队列多任务异步执行最后全局执行完毕可以使用`group_notify`来监听执行完毕时间\n- 队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用`dispatch_barrier_sync`\n- 当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量\n\n### 参考资料\n- [iOS多线程：『GCD』详尽总结](https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n- iOS和OS多线程与内存管理\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 多线程之GCD 看我就够了 --(10).md","raw":"title: iOS底层原理  多线程之GCD看我就够了 --(10)\ndate: 2019-12-1 11:20:58\ntags:\n- iOS\ncategories: iOS\n---\n\n`RunLoop`和线程的关系，以及`Thread`如何保活和控制生命周期，今天我们再探究下另外的一个线程`GCD`，揭开蒙娜丽莎的面纱。\n### GCD 基础知识\nGCD是什么呢？我们引用[百度百科](https://baike.baidu.com/item/GCD)的一段话。\n> Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。\n\nGCD有哪些优点\n- GCD自动管理线程\n- 开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可\n- GCD 自动管理线程，线程创建，挂起，销毁。\n\n那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发\n#### 串行队列\n串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。\n#### 并行队列\n并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。\n#### 并发\n并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活\n\n**串行队列**相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。\n\n**并行队列**是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。\n\n**并发**是多个流水线在同时加工产品。\n\n\n#### GCD中的串行队列()\n##### 串行队列（Serial Dispatch Queue）：\n按照**FIFO**(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。\n\n\n![](../images/10-1.png)\n#####  并发队列（Concurrent Dispatch Queue）：\n按照**FIFO**(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。\n\n\n\n![](../images/10-2.png)\n\n### GCD使用步骤\nGCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。\n\n下边来看看 **队列的创建方法/获取方法**，以及 **任务的创建方法**。\n#### 获取主队列\n主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过`dispatch_get_main_queue()`，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。\n\n```\n//获取主队列\ndispatch_queue_t main_queue= dispatch_get_main_queue();\n```\n\n#### 获取全局队列\n全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)`,第一个参数是`identifier`，表示队列的优先级，一般传入`DISPATCH_QUEUE_PRIORITY_DEFAULT`，第二个参数`flags`，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自[libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n> Use the\n.Fn dispatch_get_global_queue\nfunction to obtain the global queue of given priority. The\n.Fa flags\nargument is reserved for future use and must be zero. Passing any value other\nthan zero may result in a NULL return value.\n\n```\n//获取全局队列\ndispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n```\n\n#### 任务的创建\nGCD 提供了同步执行任务的创建方法`dispatch_sync`和异步执行任务创建方法的`spatch_async`。\n\n```\n// 同步执行任务创建方法\ndispatch_sync(queue, ^{\n    // 这里放同步执行任务代码\n});\n// 异步执行任务创建方法\ndispatch_async(queue, ^{\n    // 这里放异步执行任务代码\n});\n```\n\n虽然是只有同步异步但是他们组合的多变的\n\n||并发队列|创建的串行队列|主队列|\n|:-:|:-:|:-:|:-:|\n|同步(sync)|没开启新线程，串行执行|没开启新线程，串行执行任务|没开启新线程，串行执行任务|\n|异步(async)|能开启新线程，并发执行|能开启新线程，串行执行任务|没开启新线程，串行执行任务|\n\n### GCD的使用\n#### 主队列+同步\n在主队列中执行任务，并同步添加任务\n\n```\n//主队列+同步\n-(void)syn_main{\n\tNSLog(@\"1\");\n\tdispatch_queue_t main_queue = dispatch_get_main_queue();\n\tdispatch_sync(main_queue, ^{\n\t\tNSLog(@\"2\");\n\t});\n\tNSLog(@\"3\");\n}\n//log\n1\n```\n\n看到日志只输出了1就崩溃了提示`exc_bad_instuction`,为什么出问题呢？\n主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。\n**what**???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句`exc_bad_instuction`，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。\n那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦\n\n```\n//主队列+同步\n-(void)syn_main2{\n\tNSLog(@\"1任务执行\");\n\tsleep(1);\n\tNSLog(@\"2任务执行\");\n\tsleep(1);\n\tNSLog(@\"3任务执行\");\n}\n//log\n1任务执行\n2任务执行\n3任务执行\n```\n\n没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。\n\n#### 主队列+异步\n在主队列中异步添加任务并执行任务\n\n```\n//主队列+异步\n\tNSLog(@\"start\");\n\tdispatch_queue_t main_queue = dispatch_get_main_queue();\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tdispatch_async(main_queue, ^{\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tNSLog(@\"%@ %d\",[NSThread currentThread],i);\n\t\t}\n\t});\n\tNSLog(@\"end\");\n//log\n2019-07-24 15:12:24.73 start\n2019-07-24 15:12:24.73 end\n\n<NSThread: 0x600002f9a940>{number = 1, name = main} 0\n2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 1\n2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 2\n2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 3\n2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 4\n2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 5\n2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 7\n2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 8\n2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] <NSThread: 0x600002f9a940>{number = 1, name = main} 9\n```\n\n在主队列异步执行任务，从日志看出来`end`早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到\n- 主线程多个任务异步不能创建新线程\n- 主线程异步也是串行执行\n\n\n#### 全局队列+同步\n全局队列是并行队列，和同步配合就是串行执行了。\n\n```\n//全局队列+同步\n-(void)sync_global{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_sync(global_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(global_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(global_queue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\nstart\n 2019-07-24 15:35:36 <NSThread: 0x600000592900>{number = 1, name = main} 0\n 2019-07-24 15:35:37 <NSThread: 0x600000592900>{number = 1, name = main} 1\n 2019-07-24 15:35:38 <NSThread: 0x600000592900>{number = 1, name = main} 2\n 2019-07-24 15:35:39 <NSThread: 0x600000592900>{number = 1, name = main} 3\n 2019-07-24 15:35:40 <NSThread: 0x600000592900>{number = 1, name = main} 4\n 2019-07-24 15:35:41 <NSThread: 0x600000592900>{number = 1, name = main} 5\n 2019-07-24 15:35:42 <NSThread: 0x600000592900>{number = 1, name = main} 7\n 2019-07-24 15:35:43 <NSThread: 0x600000592900>{number = 1, name = main} 8\n 2019-07-24 15:35:44 <NSThread: 0x600000592900>{number = 1, name = main} 9\n end\n```\n\n在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。\n#### 全局队列+异步\n全局队列有创建子线程的能力，但是需要异步`async`去执行。\n\n```\n//全局队列+异步\n-(void)async_global{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_async(global_queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(global_queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(global_queue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n-(NSString *)currentDateString{\n\tNSDate *date=[NSDate new];\n\tNSDateFormatter *format = [[NSDateFormatter alloc]init];\n\t[format setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];\n\treturn [format stringFromDate:date];\n}\n//log\n\n start\n end\n 2019-07-24 15:40:21 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 3\n 2019-07-24 15:40:21 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 0\n 2019-07-24 15:40:21 <NSThread: 0x600003b45880>{number = 3, name = (null)} 7\n 2019-07-24 15:40:22 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 1\n 2019-07-24 15:40:22 <NSThread: 0x600003b45880>{number = 3, name = (null)} 8\n 2019-07-24 15:40:22 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 4\n 2019-07-24 15:40:23 <NSThread: 0x600003b45880>{number = 3, name = (null)} 9\n 2019-07-24 15:40:23 <NSThread: 0x600003b44e80>{number = 4, name = (null)} 2\n 2019-07-24 15:40:23 <NSThread: 0x600003b43dc0>{number = 5, name = (null)} 5\n```\n\n全局队列当搭配`async`的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。\n#### 创建串行队列+同步\n开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。\n\n```\n//创建串行队列+同步\n-(void)sync_cust_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_SERIAL);\n\tdispatch_sync(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_sync(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n\n//log\n\nstart\n 2019-07-24 15:53:15 <NSThread: 0x6000017ea940>{number = 1, name = main} 0\n 2019-07-24 15:53:16 <NSThread: 0x6000017ea940>{number = 1, name = main} 1\n 2019-07-24 15:53:17 <NSThread: 0x6000017ea940>{number = 1, name = main} 2\n 2019-07-24 15:53:18 <NSThread: 0x6000017ea940>{number = 1, name = main} 3\n 2019-07-24 15:53:19 <NSThread: 0x6000017ea940>{number = 1, name = main} 4\n 2019-07-24 15:53:20 <NSThread: 0x6000017ea940>{number = 1, name = main} 5\n 2019-07-24 15:53:21 <NSThread: 0x6000017ea940>{number = 1, name = main} 7\n 2019-07-24 15:53:22 <NSThread: 0x6000017ea940>{number = 1, name = main} 8\n 2019-07-24 15:53:23 <NSThread: 0x6000017ea940>{number = 1, name = main} 9\n end\n```\n\n同步向串行队列添加任务并没有死锁！原因是添加任务是在`main_queue`执行的，添加的任务是在`cust-queue`中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在`main`线程中。\n\n#### 创建串行队列+异步\n会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务\n\n```\n//创建串行队列+异步\n-(void)async_cust_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_SERIAL);\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\n\n start\n end\n 2019-07-24 16:12:57 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 0\n 2019-07-24 16:12:58 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 1\n 2019-07-24 16:12:59 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 2\n 2019-07-24 16:13:00 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 3\n 2019-07-24 16:13:01 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 4\n 2019-07-24 16:13:02 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 5\n 2019-07-24 16:13:03 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 7\n 2019-07-24 16:13:04 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 8\n 2019-07-24 16:13:05 <NSThread: 0x600002b346c0>{number = 3, name = (null)} 9\n```\n\n在`异步 + 串行队列`可以看到：\n\n开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。\n所有任务是在打印的`end`之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。\n任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。\n#### 创建并行队列+同步\n在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务\n\n```\n start\n 2019-07-24 16:21:24 <NSThread: 0x6000031d1380>{number = 1, name = main} 0\n 2019-07-24 16:21:25 <NSThread: 0x6000031d1380>{number = 1, name = main} 1\n 2019-07-24 16:21:26 <NSThread: 0x6000031d1380>{number = 1, name = main} 2\n 2019-07-24 16:21:27 <NSThread: 0x6000031d1380>{number = 1, name = main} 3\n 2019-07-24 16:21:28 <NSThread: 0x6000031d1380>{number = 1, name = main} 4\n 2019-07-24 16:21:29 <NSThread: 0x6000031d1380>{number = 1, name = main} 5\n 2019-07-24 16:21:30 <NSThread: 0x6000031d1380>{number = 1, name = main} 7\n 2019-07-24 16:21:31 <NSThread: 0x6000031d1380>{number = 1, name = main} 8\n 2019-07-24 16:21:32 <NSThread: 0x6000031d1380>{number = 1, name = main} 9\n end\n```\n\n全局队列其实就是特殊的并行队列，这里结果和`全局队列+同步`一致。\n\n#### 创建并行队列+异步\n在当前线程中执行任务，会开启新线程，可以同时执行多个任务。\n\n```\n//创建并行队列+异步\n-(void)async_queue{\n\tprintf(\"\\n start\");\n\tdispatch_queue_t custQueue = dispatch_queue_create(\"cust-queue\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t\t}\n\t});\n\tdispatch_async(custQueue, ^{\n\t\tNSThread *thread = [NSThread currentThread];\n\t\tfor (int i = 7; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,thread.description.UTF8String,i);\n\t\t}\n\t});\n\tprintf(\"\\n end\");\n}\n//log\nstart\n end\n 2019-07-24 16:22:09 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 7\n 2019-07-24 16:22:09 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 0\n 2019-07-24 16:22:09 <NSThread: 0x600000422300>{number = 4, name = (null)} 3\n 2019-07-24 16:22:10 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 1\n 2019-07-24 16:22:10 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 8\n 2019-07-24 16:22:10 <NSThread: 0x600000422300>{number = 4, name = (null)} 4\n 2019-07-24 16:22:11 <NSThread: 0x6000004280c0>{number = 3, name = (null)} 9\n 2019-07-24 16:22:11 <NSThread: 0x6000004104c0>{number = 5, name = (null)} 2\n 2019-07-24 16:22:11 <NSThread: 0x600000422300>{number = 4, name = (null)} 5\n```\n\n`并行队列+异步`和`全局队列+异步`一致，也会新建线程执行任务，且是并发执行。\n### GCD其他高级用法\n#### 子线程执行任务 主线程刷新UI\n\n```\n- (void)backToMain{\n\tdispatch_queue_t main = dispatch_get_main_queue();\n\tdispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\tdispatch_async(glo, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t\tdispatch_sync(main, ^{\n\t\t\tprintf(\"\\n %s %s 我在刷新UI\",[self dateUTF8],[self threadInfo]);\n\t\t});\n\t});\t\n}\n//log\n 2019-07-24 16:45:07 <NSThread: 0x600001e84380>{number = 3, name = (null)} 0\n 2019-07-24 16:45:08 <NSThread: 0x600001e84380>{number = 3, name = (null)} 1\n 2019-07-24 16:45:09 <NSThread: 0x600001e84380>{number = 3, name = (null)} 2\n 2019-07-24 16:45:09 <NSThread: 0x600001ef2940>{number = 1, name = main} 我在刷新UI\n```\n\n#### 队列分组 dispatch_group_t\n##### dispatch_group_notify \nGCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过`dispatch_group_notify`完成回调，第一个参数`group`是某个分组的回调。\n\n```\n-(void)group{\n\tdispatch_group_t group = dispatch_group_create();\n\tdispatch_queue_t queue= dispatch_queue_create(\"cust.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_queue_t queue2= dispatch_queue_create(\"cust2.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_group_async(group, queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_async(group, queue2, ^{\n\t\tfor (int i = 4; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_notify(group, dispatch_get_main_queue(), ^{\n\t\tprintf(\"\\n %s %s ---end1----\",[self dateUTF8],[self threadInfo]);\n\t});\n\tdispatch_group_async(group, queue, ^{\n\t\tfor (int i = 6; i < 8; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_group_async(group, queue2, ^{\n\t\tfor (int i = 8; i < 10; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n}\n```\n\n##### dispatch_group_wait && dispatch_group_enter && dispatch_group_leave\n`dispatch_group_enter`和`dispatch_group_leave`需要成对使用，否则`dispatch_group_wait`在缺少`leave`的情况下会等待到死，造成线程阻塞。\n\n```\nstatic\tdispatch_group_t group ;\nif (group == nil) {\n\tgroup = dispatch_group_create();\n}\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n//\tdispatch_group_enter(group);\ndispatch_group_async(group, queue, ^{\n\t[self print];\n\t[NSThread sleepForTimeInterval:2];\n//\t\tdispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行\n});\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n\ndispatch_group_enter(group);\ndispatch_group_async(group, queue, ^{\n\t[self print];\n\t[NSThread sleepForTimeInterval:2];\n\tdispatch_group_leave(group);\n});\n//log\n2019-07-25 10:58:50 <NSThread: 0x600002d84180>{number = 3, name = (null)} \n2019-07-25 10:58:52 <NSThread: 0x600002d84180>{number = 3, name = (null)} \n\n```\n\n#### 栅栏函数 dispatch_barrier_sync\n栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。\n\n\n```\n- (void)barry{\n\tdispatch_queue_t queue= dispatch_queue_create(\"cust.queue.com\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (int i = 0; i < 3; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_barrier_sync(queue, ^{\n\t\tprintf(\"\\n %s %s ---中间暂停一下----\",[self dateUTF8],[self threadInfo]);\n\t});\n\tdispatch_async(queue, ^{\n\t\tfor (int i = 3; i < 6; i ++) {\n\t\t\t[NSThread sleepForTimeInterval:1];\n\t\t\tprintf(\"\\n %s %s %d\",[self dateUTF8],[self threadInfo],i);\n\t\t}\n\t});\n\tdispatch_barrier_async(queue, ^{\n\t\tprintf(\"\\n %s %s ---中间第二次暂停一下----\",[self dateUTF8],[self threadInfo]);\n\t});\n}\n//log\n 2019-07-24 16:52:33 <NSThread: 0x600003158440>{number = 3, name = (null)} 0\n 2019-07-24 16:52:34 <NSThread: 0x600003158440>{number = 3, name = (null)} 1\n 2019-07-24 16:52:35 <NSThread: 0x600003158440>{number = 3, name = (null)} 2\n 2019-07-24 16:52:35 <NSThread: 0x6000031293c0>{number = 1, name = main} ---中间暂停一下----\n 2019-07-24 16:52:36 <NSThread: 0x600003158440>{number = 3, name = (null)} 3\n 2019-07-24 16:52:37 <NSThread: 0x600003158440>{number = 3, name = (null)} 4\n 2019-07-24 16:52:38 <NSThread: 0x600003158440>{number = 3, name = (null)} 5\n 2019-07-24 16:52:38 <NSThread: 0x600003158440>{number = 3, name = (null)} ---中间第二次暂停一下----\n```\n\n#### 单例-执行一次的函数 dispatch_once_t\n单例可以通过这个函数实现，只执行一次的函数。\n\n```\n//只执行一次的dispatch_once\n-(void)exc_once{\n\tstatic dispatch_once_t onceToken;\n\tstatic NSObject *obj;\n\tdispatch_once(&onceToken, ^{\n\t\tobj=[NSObject new];\n\t\tprintf(\"\\n just once %s %s\",[self dateUTF8],obj.description.UTF8String);\n\t});\n\tprintf(\"\\n %s %s\",[self dateUTF8],obj.description.UTF8String);\n}\n调用4次\ndispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\t[self exc_once];\n\t});\n\t\n//log\njust once 2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n2019-07-25 14:46:00 <NSObject: 0x60000378b100>\n```\n\n当调用4次的时候，日志打印的四次`obj`均为同一个地址，证明`block`回调四次但是只执行了一次。\n#### 延迟执行 dispatch_after\n当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟\n\n```\n//延迟执行\n-(void)delayTimeExc{\n\tprintf(\"\\n %s %s begin\",[self dateUTF8],[self threadInfo]);\n\t\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\t\n\t\tprintf(\"\\n %s %s\",[self dateUTF8],[self threadInfo]);\n\t\t\n\t});\n\tprintf(\"\\n %s %s end\",[self dateUTF8],[self threadInfo]);\n}\n//log\n2019-07-24 17:07:48 <NSThread: 0x600003cc6940>{number = 1, name = main} begin\n2019-07-24 17:07:48 <NSThread: 0x600003cc6940>{number = 1, name = main} end\n2019-07-24 17:07:50 <NSThread: 0x600003cc6940>{number = 1, name = main}\n```\n\n#### 信号量  dispatch_semaphore_t\n信号量为1可以作为线程锁来用，当N>1的时候，同时执行的有N个任务。\n`dispatch_apply`可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。\n\n```\n//信号量 当信号量为1 可以未做锁来用，当N>1，t通知执行的数量则是数字N。\n- (void)semaphore{\n\tstatic dispatch_semaphore_t sem;\n\tif (sem == NULL) {\n\t\tsem = dispatch_semaphore_create(1);\n\t}\n\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);\n\tstatic int i = 0;\n\tint currentI = i +2;\n\tfor (; i < currentI; i ++) {\n\t\t[NSThread sleepForTimeInterval:1];\n\t\tprintf(\"\\n %s %s %d\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);\n\t}\n\tdispatch_semaphore_signal(sem);\n}\n-(void)asyn_semaphore{\n\tdispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\t[self semaphore];\n\t});\n}\n//log\n\n2019-07-24 17:25:04 <NSThread: 0x6000002a2940>{number = 1, name = main} 0\n2019-07-24 17:25:05 <NSThread: 0x6000002a2940>{number = 1, name = main} 1\n2019-07-24 17:25:06 <NSThread: 0x6000002e2b40>{number = 3, name = (null)} 2\n2019-07-24 17:25:07 <NSThread: 0x6000002e2b40>{number = 3, name = (null)} 3\n2019-07-24 17:25:08 <NSThread: 0x6000002d4740>{number = 4, name = (null)} 4\n2019-07-24 17:25:09 <NSThread: 0x6000002d4740>{number = 4, name = (null)} 5\n```\n\n设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。\n\n```\n-(void)muchQueueBuyTick{\n\tdispatch_queue_t queue= dispatch_queue_create(\"com.buy.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:4];\n\t\t}\n\t});\n\tdispatch_queue_t queue2= dispatch_queue_create(\"com.buy2.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue2, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:2];\n\t\t}\n\t});\n}\n- (void)semaphore_buy_ticks:(NSInteger)windowsCount{\n\tstatic dispatch_semaphore_t sem;\n\tif (sem == NULL) {\n\t\tsem = dispatch_semaphore_create(windowsCount);\n\t}\n\t//信号量-1\n\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);\n\tself.count--;\n\tif (self.count > 0) {\n\t\tprintf(\"\\n %s %s 第%ld个人买到票了\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);\n\t\t[NSThread sleepForTimeInterval:0.2];\n\t}\n\t//信号量+1\n\tdispatch_semaphore_signal(sem);\n}\n//log\n\n2019-07-24 18:01:44 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第8个人买到票了\n 2019-07-24 18:01:44 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第8个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第6个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第6个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第4个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第4个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第2个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003904c40>{number = 3, name = (null)} 第2个人买到票了\n 2019-07-24 18:01:45 <NSThread: 0x600003935e00>{number = 4, name = (null)} 第0个人买到票了\n```\n\n两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。\n当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。\n\n```\n-(void)muchQueueBuyTick{\n\tdispatch_queue_t queue= dispatch_queue_create(\"com.buy.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:1];\n\t\t}\n\t});\n\tdispatch_queue_t queue2= dispatch_queue_create(\"com.buy2.tick\", DISPATCH_QUEUE_CONCURRENT);\n\tdispatch_async(queue2, ^{\n\t\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\t\t[self semaphore_buy_ticks:1];\n\t\t}\n\t});\n}\n//log\n2019-07-24 18:03:56 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第9个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第8个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第7个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第6个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第5个人买到票了\n 2019-07-24 18:03:57 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第4个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第3个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1e0c0>{number = 4, name = (null)} 第2个人买到票了\n 2019-07-24 18:03:58 <NSThread: 0x600000e1cac0>{number = 3, name = (null)} 第1个人买到票了\n```\n\n顺序是对了，数量也对了。\n\n再换一种思路实现锁住窗口，我们使用串行队列也是可以的。\n\n```\n//使用同步队列卖票\n- (void)sync_buy_tick{\n\tdispatch_async(dispatch_get_main_queue(), ^{\n\t\tself.count--;\n\t\tif (self.count > 0) {\n\t\t\tprintf(\"\\n %s %s 第%ld个人买到票了\",[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);\n\t\t\t[NSThread sleepForTimeInterval:0.2];\n\t\t}\n\t});\n}\n//log\n2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第9个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第8个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第7个人买到票了\n 2019-07-25 09:31:56 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第6个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第5个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第4个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第3个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第2个人买到票了\n 2019-07-25 09:31:57 <NSThread: 0x6000034d2e40>{number = 1, name = main} 第1个人买到票了\n```\n\n串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。\n\n#### 快速迭代方法：dispatch_apply\n快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。\n\n```\n/*\n同时新建了多条线程来做任务\n*/\n\tdispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) {\n\t\tprintf(\"\\n %s %s \",[self dateUTF8],[self threadInfo]);\n\t});\n\t\n\t//log\n2019-07-25 09:38:38 <NSThread: 0x600000966180>{number = 4, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x60000094a3c0>{number = 3, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x600000979dc0>{number = 5, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x60000090d3c0>{number = 1, name = main} \n2019-07-25 09:38:38 <NSThread: 0x60000095cfc0>{number = 6, name = (null)} \n2019-07-25 09:38:38 <NSThread: 0x600000950140>{number = 8, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000095d0c0>{number = 9, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000094a400>{number = 7, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x600000966180>{number = 4, name = (null)} \n 2019-07-25 09:38:38 <NSThread: 0x60000094a3c0>{number = 3, name = (null)} \n```\n\n可以看到新建了`3`、`4`、`5`、`6`、`7`、`8`、`9`、`main`来执行任务。\n### 多线程RunLoop实战\n问题一：请问下边代码输出什么？\n\n```\n-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n}\n- (void)test{\n    NSLog(@\"2\");\n}\n```\n\n- 猜想1：结果是`123`\n- 猜想2：结果是`132`\n\n有没有第三种结果呢？\n\n猜想1分析：\n因为是延迟`0`s执行，当然是先执行`2`，再执行`3`了。\n\n猜想2分析：\n\n我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出`1`，然后输出`3`，最后输出`2`.\n\n最后验证一下：\n\n```\n1\n3\n```\n\n为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在`runloop.h`文件中，我们猜测延迟执行是`timer`添加到`runloop`中了，添加进去也应该输出`132`的。因为在子线程中，没有主动调用不会有`runloop`的，及时调用了也需要保活技术，那么代码改进一下\n\n```\n    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        // 相当于[self test];\n//       [self performSelector:@selector(test) withObject:nil];\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        \n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];\n        [[NSRunLoop currentRunLoop] run];\n        NSLog(@\"3\");\n    });\n```\n\n经测试输出了`12`，这和我们猜想的还是不对，原来输出`3`放在了最后，导致的问题，`RunLoop`运行起来，进入了循环，则后面的就不会执行了，除非停止当前`RunLoop`，我们再改进一下\n\n```\n    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_async(que, ^{\n        NSLog(@\"1\");\n        // 相当于[self test];\n//       [self performSelector:@selector(test) withObject:nil];\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n         NSLog(@\"3\");\n        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];\n        [[NSRunLoop currentRunLoop] run];\n    });\n```\n\n最后终于输出了`132`。缺点是子线程成了**死待**，不死之身，关于怎么杀死**死待**请看[上篇优雅控制RunLoop生命周期](https://juejin.im/post/5d35b347f265da1b8608c49b)。\n关于`performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay`中有延迟的，都是添加到当前你线程的`RunLoop`，如果没有启动`RunLoop`和保活恐怕也不能一直执行。`[self performSelector:@selector(test) withObject:nil]`是在`Foudation`中，源码是直接`objc_msgSend()`，相当于直接`[self test]`，不会有延迟。\n\n问题2：请问输出什么？\n\n```\nNSThread *thread=[[NSThread alloc]initWithBlock:^{\n    NSLog(@\"1\");\n}];\n[thread start];\n[self performSelector:@selector(test)\n             onThread:thread\n           withObject:nil\n        waitUntilDone:YES];\n```\n\n这个和上面的类似，结果是打印了`1`就崩溃了，原因是`thread start`之后执行完`block`就结束了，没有`runloop`的支撑。当执行`performSelector`的时候，线程已经死掉。解决这个问题只需要向子线程中添加`RunLoop`，而且保证`RunLoop`不停止就行了。\n\n\n\n### 总结\n- GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI\n- 队列多任务异步执行最后全局执行完毕可以使用`group_notify`来监听执行完毕时间\n- 队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用`dispatch_barrier_sync`\n- 当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量\n\n### 参考资料\n- [iOS多线程：『GCD』详尽总结](https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n- iOS和OS多线程与内存管理\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 多线程之GCD 看我就够了 --(10)","published":1,"updated":"2019-12-03T05:06:41.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2k000o9zsklew7nap1","content":"<p><code>RunLoop</code>和线程的关系，以及<code>Thread</code>如何保活和控制生命周期，今天我们再探究下另外的一个线程<code>GCD</code>，揭开蒙娜丽莎的面纱。</p>\n<h3 id=\"GCD-基础知识\"><a href=\"#GCD-基础知识\" class=\"headerlink\" title=\"GCD 基础知识\"></a>GCD 基础知识</h3><p>GCD是什么呢？我们引用<a href=\"https://baike.baidu.com/item/GCD\" target=\"_blank\" rel=\"external\">百度百科</a>的一段话。</p>\n<blockquote>\n<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>\n</blockquote>\n<p>GCD有哪些优点</p>\n<ul>\n<li>GCD自动管理线程</li>\n<li>开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可</li>\n<li>GCD 自动管理线程，线程创建，挂起，销毁。</li>\n</ul>\n<p>那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发</p>\n<h4 id=\"串行队列\"><a href=\"#串行队列\" class=\"headerlink\" title=\"串行队列\"></a>串行队列</h4><p>串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。</p>\n<h4 id=\"并行队列\"><a href=\"#并行队列\" class=\"headerlink\" title=\"并行队列\"></a>并行队列</h4><p>并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。</p>\n<h4 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h4><p>并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活</p>\n<p><strong>串行队列</strong>相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。</p>\n<p><strong>并行队列</strong>是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。</p>\n<p><strong>并发</strong>是多个流水线在同时加工产品。</p>\n<h4 id=\"GCD中的串行队列\"><a href=\"#GCD中的串行队列\" class=\"headerlink\" title=\"GCD中的串行队列()\"></a>GCD中的串行队列()</h4><h5 id=\"串行队列（Serial-Dispatch-Queue）：\"><a href=\"#串行队列（Serial-Dispatch-Queue）：\" class=\"headerlink\" title=\"串行队列（Serial Dispatch Queue）：\"></a>串行队列（Serial Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。</p>\n<p><img src=\"../images/10-1.png\" alt=\"\"></p>\n<h5 id=\"并发队列（Concurrent-Dispatch-Queue）：\"><a href=\"#并发队列（Concurrent-Dispatch-Queue）：\" class=\"headerlink\" title=\"并发队列（Concurrent Dispatch Queue）：\"></a>并发队列（Concurrent Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。</p>\n<p><img src=\"../images/10-2.png\" alt=\"\"></p>\n<h3 id=\"GCD使用步骤\"><a href=\"#GCD使用步骤\" class=\"headerlink\" title=\"GCD使用步骤\"></a>GCD使用步骤</h3><p>GCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。</p>\n<p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p>\n<h4 id=\"获取主队列\"><a href=\"#获取主队列\" class=\"headerlink\" title=\"获取主队列\"></a>获取主队列</h4><p>主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过<code>dispatch_get_main_queue()</code>，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取主队列</div><div class=\"line\">dispatch_queue_t main_queue= dispatch_get_main_queue();</div></pre></td></tr></table></figure>\n<h4 id=\"获取全局队列\"><a href=\"#获取全局队列\" class=\"headerlink\" title=\"获取全局队列\"></a>获取全局队列</h4><p>全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>,第一个参数是<code>identifier</code>，表示队列的优先级，一般传入<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数<code>flags</code>，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自<a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></p>\n<blockquote>\n<p>Use the<br>.Fn dispatch_get_global_queue<br>function to obtain the global queue of given priority. The<br>.Fa flags<br>argument is reserved for future use and must be zero. Passing any value other<br>than zero may result in a NULL return value.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取全局队列</div><div class=\"line\">dispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>\n<h4 id=\"任务的创建\"><a href=\"#任务的创建\" class=\"headerlink\" title=\"任务的创建\"></a>任务的创建</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法的<code>spatch_async</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 同步执行任务创建方法</div><div class=\"line\">dispatch_sync(queue, ^&#123;</div><div class=\"line\">    // 这里放同步执行任务代码</div><div class=\"line\">&#125;);</div><div class=\"line\">// 异步执行任务创建方法</div><div class=\"line\">dispatch_async(queue, ^&#123;</div><div class=\"line\">    // 这里放异步执行任务代码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>虽然是只有同步异步但是他们组合的多变的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">并发队列</th>\n<th style=\"text-align:center\">创建的串行队列</th>\n<th style=\"text-align:center\">主队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">同步(sync)</td>\n<td style=\"text-align:center\">没开启新线程，串行执行</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步(async)</td>\n<td style=\"text-align:center\">能开启新线程，并发执行</td>\n<td style=\"text-align:center\">能开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"GCD的使用\"><a href=\"#GCD的使用\" class=\"headerlink\" title=\"GCD的使用\"></a>GCD的使用</h3><h4 id=\"主队列-同步\"><a href=\"#主队列-同步\" class=\"headerlink\" title=\"主队列+同步\"></a>主队列+同步</h4><p>在主队列中执行任务，并同步添加任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+同步</div><div class=\"line\">-(void)syn_main&#123;</div><div class=\"line\">\tNSLog(@&quot;1&quot;);</div><div class=\"line\">\tdispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_sync(main_queue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;2&quot;);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tNSLog(@&quot;3&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>看到日志只输出了1就崩溃了提示<code>exc_bad_instuction</code>,为什么出问题呢？<br>主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。<br><strong>what</strong>???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句<code>exc_bad_instuction</code>，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。<br>那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+同步</div><div class=\"line\">-(void)syn_main2&#123;</div><div class=\"line\">\tNSLog(@&quot;1任务执行&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\tNSLog(@&quot;2任务执行&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\tNSLog(@&quot;3任务执行&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">1任务执行</div><div class=\"line\">2任务执行</div><div class=\"line\">3任务执行</div></pre></td></tr></table></figure>\n<p>没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。</p>\n<h4 id=\"主队列-异步\"><a href=\"#主队列-异步\" class=\"headerlink\" title=\"主队列+异步\"></a>主队列+异步</h4><p>在主队列中异步添加任务并执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+异步</div><div class=\"line\">\tNSLog(@&quot;start&quot;);</div><div class=\"line\">\tdispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tNSLog(@&quot;end&quot;);</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 15:12:24.73 start</div><div class=\"line\">2019-07-24 15:12:24.73 end</div><div class=\"line\"></div><div class=\"line\">&lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\">2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\">2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\">2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\">2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\">2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\">2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 9</div></pre></td></tr></table></figure>\n<p>在主队列异步执行任务，从日志看出来<code>end</code>早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到</p>\n<ul>\n<li>主线程多个任务异步不能创建新线程</li>\n<li>主线程异步也是串行执行</li>\n</ul>\n<h4 id=\"全局队列-同步\"><a href=\"#全局队列-同步\" class=\"headerlink\" title=\"全局队列+同步\"></a>全局队列+同步</h4><p>全局队列是并行队列，和同步配合就是串行执行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">//全局队列+同步</div><div class=\"line\">-(void)sync_global&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">start</div><div class=\"line\"> 2019-07-24 15:35:36 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\"> 2019-07-24 15:35:37 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\"> 2019-07-24 15:35:38 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\"> 2019-07-24 15:35:39 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\"> 2019-07-24 15:35:40 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\"> 2019-07-24 15:35:41 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\"> 2019-07-24 15:35:42 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\"> 2019-07-24 15:35:43 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\"> 2019-07-24 15:35:44 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\"> end</div></pre></td></tr></table></figure>\n<p>在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。</p>\n<h4 id=\"全局队列-异步\"><a href=\"#全局队列-异步\" class=\"headerlink\" title=\"全局队列+异步\"></a>全局队列+异步</h4><p>全局队列有创建子线程的能力，但是需要异步<code>async</code>去执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">//全局队列+异步</div><div class=\"line\">-(void)async_global&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSString *)currentDateString&#123;</div><div class=\"line\">\tNSDate *date=[NSDate new];</div><div class=\"line\">\tNSDateFormatter *format = [[NSDateFormatter alloc]init];</div><div class=\"line\">\t[format setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class=\"line\">\treturn [format stringFromDate:date];</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\"> start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 9</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p>全局队列当搭配<code>async</code>的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。</p>\n<h4 id=\"创建串行队列-同步\"><a href=\"#创建串行队列-同步\" class=\"headerlink\" title=\"创建串行队列+同步\"></a>创建串行队列+同步</h4><p>开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建串行队列+同步</div><div class=\"line\">-(void)sync_cust_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\"> 2019-07-24 15:53:15 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\"> 2019-07-24 15:53:16 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\"> 2019-07-24 15:53:17 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\"> 2019-07-24 15:53:18 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\"> 2019-07-24 15:53:19 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\"> 2019-07-24 15:53:20 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\"> 2019-07-24 15:53:21 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\"> 2019-07-24 15:53:22 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\"> 2019-07-24 15:53:23 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\"> end</div></pre></td></tr></table></figure>\n<p>同步向串行队列添加任务并没有死锁！原因是添加任务是在<code>main_queue</code>执行的，添加的任务是在<code>cust-queue</code>中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在<code>main</code>线程中。</p>\n<h4 id=\"创建串行队列-异步\"><a href=\"#创建串行队列-异步\" class=\"headerlink\" title=\"创建串行队列+异步\"></a>创建串行队列+异步</h4><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建串行队列+异步</div><div class=\"line\">-(void)async_cust_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\"> start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 16:12:57 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:12:58 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:12:59 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:13:00 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:13:01 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:13:02 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 5</div><div class=\"line\"> 2019-07-24 16:13:03 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 16:13:04 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 16:13:05 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 9</div></pre></td></tr></table></figure>\n<p>在<code>异步 + 串行队列</code>可以看到：</p>\n<p>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。<br>所有任务是在打印的<code>end</code>之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>\n<h4 id=\"创建并行队列-同步\"><a href=\"#创建并行队列-同步\" class=\"headerlink\" title=\"创建并行队列+同步\"></a>创建并行队列+同步</h4><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">2019-07-24 16:21:24 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 16:21:25 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 16:21:26 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\">2019-07-24 16:21:27 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\">2019-07-24 16:21:28 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\">2019-07-24 16:21:29 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\">2019-07-24 16:21:30 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\">2019-07-24 16:21:31 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\">2019-07-24 16:21:32 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\">end</div></pre></td></tr></table></figure>\n<p>全局队列其实就是特殊的并行队列，这里结果和<code>全局队列+同步</code>一致。</p>\n<h4 id=\"创建并行队列-异步\"><a href=\"#创建并行队列-异步\" class=\"headerlink\" title=\"创建并行队列+异步\"></a>创建并行队列+异步</h4><p>在当前线程中执行任务，会开启新线程，可以同时执行多个任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建并行队列+异步</div><div class=\"line\">-(void)async_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 9</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p><code>并行队列+异步</code>和<code>全局队列+异步</code>一致，也会新建线程执行任务，且是并发执行。</p>\n<h3 id=\"GCD其他高级用法\"><a href=\"#GCD其他高级用法\" class=\"headerlink\" title=\"GCD其他高级用法\"></a>GCD其他高级用法</h3><h4 id=\"子线程执行任务-主线程刷新UI\"><a href=\"#子线程执行任务-主线程刷新UI\" class=\"headerlink\" title=\"子线程执行任务 主线程刷新UI\"></a>子线程执行任务 主线程刷新UI</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)backToMain&#123;</div><div class=\"line\">\tdispatch_queue_t main = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_async(glo, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tdispatch_sync(main, ^&#123;</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s 我在刷新UI&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;);\t</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"> 2019-07-24 16:45:07 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:45:08 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001ef2940&gt;&#123;number = 1, name = main&#125; 我在刷新UI</div></pre></td></tr></table></figure>\n<h4 id=\"队列分组-dispatch-group-t\"><a href=\"#队列分组-dispatch-group-t\" class=\"headerlink\" title=\"队列分组 dispatch_group_t\"></a>队列分组 dispatch_group_t</h4><h5 id=\"dispatch-group-notify\"><a href=\"#dispatch-group-notify\" class=\"headerlink\" title=\"dispatch_group_notify\"></a>dispatch_group_notify</h5><p>GCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过<code>dispatch_group_notify</code>完成回调，第一个参数<code>group</code>是某个分组的回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)group&#123;</div><div class=\"line\">\tdispatch_group_t group = dispatch_group_create();</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;cust2.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue2, ^&#123;</div><div class=\"line\">\t\tfor (int i = 4; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---end1----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 6; i &lt; 8; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue2, ^&#123;</div><div class=\"line\">\t\tfor (int i = 8; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave\"><a href=\"#dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave\" class=\"headerlink\" title=\"dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave\"></a>dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave</h5><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>需要成对使用，否则<code>dispatch_group_wait</code>在缺少<code>leave</code>的情况下会等待到死，造成线程阻塞。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">static\tdispatch_group_t group ;</div><div class=\"line\">if (group == nil) &#123;</div><div class=\"line\">\tgroup = dispatch_group_create();</div><div class=\"line\">&#125;</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">//\tdispatch_group_enter(group);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t[self print];</div><div class=\"line\">\t[NSThread sleepForTimeInterval:2];</div><div class=\"line\">//\t\tdispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_enter(group);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t[self print];</div><div class=\"line\">\t[NSThread sleepForTimeInterval:2];</div><div class=\"line\">\tdispatch_group_leave(group);</div><div class=\"line\">&#125;);</div><div class=\"line\">//log</div><div class=\"line\">2019-07-25 10:58:50 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">2019-07-25 10:58:52 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"栅栏函数-dispatch-barrier-sync\"><a href=\"#栅栏函数-dispatch-barrier-sync\" class=\"headerlink\" title=\"栅栏函数 dispatch_barrier_sync\"></a>栅栏函数 dispatch_barrier_sync</h4><p>栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)barry&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_barrier_sync(queue, ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---中间暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---中间第二次暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"> 2019-07-24 16:52:33 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:52:34 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:52:35 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:52:35 &lt;NSThread: 0x6000031293c0&gt;&#123;number = 1, name = main&#125; ---中间暂停一下----</div><div class=\"line\"> 2019-07-24 16:52:36 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:52:37 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 5</div><div class=\"line\"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; ---中间第二次暂停一下----</div></pre></td></tr></table></figure>\n<h4 id=\"单例-执行一次的函数-dispatch-once-t\"><a href=\"#单例-执行一次的函数-dispatch-once-t\" class=\"headerlink\" title=\"单例-执行一次的函数 dispatch_once_t\"></a>单例-执行一次的函数 dispatch_once_t</h4><p>单例可以通过这个函数实现，只执行一次的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//只执行一次的dispatch_once</div><div class=\"line\">-(void)exc_once&#123;</div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tstatic NSObject *obj;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tobj=[NSObject new];</div><div class=\"line\">\t\tprintf(&quot;\\n just once %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\">调用4次</div><div class=\"line\">dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\t[self exc_once];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">//log</div><div class=\"line\">just once 2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div></pre></td></tr></table></figure>\n<p>当调用4次的时候，日志打印的四次<code>obj</code>均为同一个地址，证明<code>block</code>回调四次但是只执行了一次。</p>\n<h4 id=\"延迟执行-dispatch-after\"><a href=\"#延迟执行-dispatch-after\" class=\"headerlink\" title=\"延迟执行 dispatch_after\"></a>延迟执行 dispatch_after</h4><p>当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//延迟执行</div><div class=\"line\">-(void)delayTimeExc&#123;</div><div class=\"line\">\tprintf(&quot;\\n %s %s begin&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n %s %s end&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; begin</div><div class=\"line\">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; end</div><div class=\"line\">2019-07-24 17:07:50 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"信号量-dispatch-semaphore-t\"><a href=\"#信号量-dispatch-semaphore-t\" class=\"headerlink\" title=\"信号量  dispatch_semaphore_t\"></a>信号量  dispatch_semaphore_t</h4><p>信号量为1可以作为线程锁来用，当N&gt;1的时候，同时执行的有N个任务。<br><code>dispatch_apply</code>可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">//信号量 当信号量为1 可以未做锁来用，当N&gt;1，t通知执行的数量则是数字N。</div><div class=\"line\">- (void)semaphore&#123;</div><div class=\"line\">\tstatic dispatch_semaphore_t sem;</div><div class=\"line\">\tif (sem == NULL) &#123;</div><div class=\"line\">\t\tsem = dispatch_semaphore_create(1);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tstatic int i = 0;</div><div class=\"line\">\tint currentI = i +2;</div><div class=\"line\">\tfor (; i &lt; currentI; i ++) &#123;</div><div class=\"line\">\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_signal(sem);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)asyn_semaphore&#123;</div><div class=\"line\">\tdispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\t[self semaphore];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-24 17:25:04 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 17:25:05 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 17:25:06 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\">2019-07-24 17:25:07 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\">2019-07-24 17:25:08 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 4</div><div class=\"line\">2019-07-24 17:25:09 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p>设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)muchQueueBuyTick&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:4];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue2, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:2];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)semaphore_buy_ticks:(NSInteger)windowsCount&#123;</div><div class=\"line\">\tstatic dispatch_semaphore_t sem;</div><div class=\"line\">\tif (sem == NULL) &#123;</div><div class=\"line\">\t\tsem = dispatch_semaphore_create(windowsCount);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//信号量-1</div><div class=\"line\">\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tself.count--;</div><div class=\"line\">\tif (self.count &gt; 0) &#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class=\"line\">\t\t[NSThread sleepForTimeInterval:0.2];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//信号量+1</div><div class=\"line\">\tdispatch_semaphore_signal(sem);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-24 18:01:44 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:44 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第0个人买到票了</div></pre></td></tr></table></figure>\n<p>两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。<br>当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)muchQueueBuyTick&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:1];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue2, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:1];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 18:03:56 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第9个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第7个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第5个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第3个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第1个人买到票了</div></pre></td></tr></table></figure>\n<p>顺序是对了，数量也对了。</p>\n<p>再换一种思路实现锁住窗口，我们使用串行队列也是可以的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用同步队列卖票</div><div class=\"line\">- (void)sync_buy_tick&#123;</div><div class=\"line\">\tdispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tself.count--;</div><div class=\"line\">\t\tif (self.count &gt; 0) &#123;</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:0.2];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第9个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第7个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第5个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第3个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第1个人买到票了</div></pre></td></tr></table></figure>\n<p>串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。</p>\n<h4 id=\"快速迭代方法：dispatch-apply\"><a href=\"#快速迭代方法：dispatch-apply\" class=\"headerlink\" title=\"快速迭代方法：dispatch_apply\"></a>快速迭代方法：dispatch_apply</h4><p>快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">同时新建了多条线程来做任务</div><div class=\"line\">*/</div><div class=\"line\">\tdispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s &quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t//log</div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000979dc0&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000090d3c0&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000095cfc0&gt;&#123;number = 6, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000950140&gt;&#123;number = 8, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000095d0c0&gt;&#123;number = 9, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a400&gt;&#123;number = 7, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>可以看到新建了<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>、<code>main</code>来执行任务。</p>\n<h3 id=\"多线程RunLoop实战\"><a href=\"#多线程RunLoop实战\" class=\"headerlink\" title=\"多线程RunLoop实战\"></a>多线程RunLoop实战</h3><p>问题一：请问下边代码输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    NSLog(@&quot;2&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>猜想1：结果是<code>123</code></li>\n<li>猜想2：结果是<code>132</code></li>\n</ul>\n<p>有没有第三种结果呢？</p>\n<p>猜想1分析：<br>因为是延迟<code>0</code>s执行，当然是先执行<code>2</code>，再执行<code>3</code>了。</p>\n<p>猜想2分析：</p>\n<p>我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出<code>1</code>，然后输出<code>3</code>，最后输出<code>2</code>.</p>\n<p>最后验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">3</div></pre></td></tr></table></figure>\n<p>为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在<code>runloop.h</code>文件中，我们猜测延迟执行是<code>timer</code>添加到<code>runloop</code>中了，添加进去也应该输出<code>132</code>的。因为在子线程中，没有主动调用不会有<code>runloop</code>的，及时调用了也需要保活技术，那么代码改进一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        // 相当于[self test];</div><div class=\"line\">//       [self performSelector:@selector(test) withObject:nil];</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">        </div><div class=\"line\">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class=\"line\">        [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>经测试输出了<code>12</code>，这和我们猜想的还是不对，原来输出<code>3</code>放在了最后，导致的问题，<code>RunLoop</code>运行起来，进入了循环，则后面的就不会执行了，除非停止当前<code>RunLoop</code>，我们再改进一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        // 相当于[self test];</div><div class=\"line\">//       [self performSelector:@selector(test) withObject:nil];</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">         NSLog(@&quot;3&quot;);</div><div class=\"line\">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class=\"line\">        [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>最后终于输出了<code>132</code>。缺点是子线程成了<strong>死待</strong>，不死之身，关于怎么杀死<strong>死待</strong>请看<a href=\"https://juejin.im/post/5d35b347f265da1b8608c49b\" target=\"_blank\" rel=\"external\">上篇优雅控制RunLoop生命周期</a>。<br>关于<code>performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>中有延迟的，都是添加到当前你线程的<code>RunLoop</code>，如果没有启动<code>RunLoop</code>和保活恐怕也不能一直执行。<code>[self performSelector:@selector(test) withObject:nil]</code>是在<code>Foudation</code>中，源码是直接<code>objc_msgSend()</code>，相当于直接<code>[self test]</code>，不会有延迟。</p>\n<p>问题2：请问输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSThread *thread=[[NSThread alloc]initWithBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;1&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">[thread start];</div><div class=\"line\">[self performSelector:@selector(test)</div><div class=\"line\">             onThread:thread</div><div class=\"line\">           withObject:nil</div><div class=\"line\">        waitUntilDone:YES];</div></pre></td></tr></table></figure>\n<p>这个和上面的类似，结果是打印了<code>1</code>就崩溃了，原因是<code>thread start</code>之后执行完<code>block</code>就结束了，没有<code>runloop</code>的支撑。当执行<code>performSelector</code>的时候，线程已经死掉。解决这个问题只需要向子线程中添加<code>RunLoop</code>，而且保证<code>RunLoop</code>不停止就行了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI</li>\n<li>队列多任务异步执行最后全局执行完毕可以使用<code>group_notify</code>来监听执行完毕时间</li>\n<li>队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用<code>dispatch_barrier_sync</code></li>\n<li>当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16\" target=\"_blank\" rel=\"external\">iOS多线程：『GCD』详尽总结</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></li>\n<li>iOS和OS多线程与内存管理<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>RunLoop</code>和线程的关系，以及<code>Thread</code>如何保活和控制生命周期，今天我们再探究下另外的一个线程<code>GCD</code>，揭开蒙娜丽莎的面纱。</p>\n<h3 id=\"GCD-基础知识\"><a href=\"#GCD-基础知识\" class=\"headerlink\" title=\"GCD 基础知识\"></a>GCD 基础知识</h3><p>GCD是什么呢？我们引用<a href=\"https://baike.baidu.com/item/GCD\" target=\"_blank\" rel=\"external\">百度百科</a>的一段话。</p>\n<blockquote>\n<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>\n</blockquote>\n<p>GCD有哪些优点</p>\n<ul>\n<li>GCD自动管理线程</li>\n<li>开发者只需要将task加入到队列中，不用关注细节，然后将task执行完的block传入即可</li>\n<li>GCD 自动管理线程，线程创建，挂起，销毁。</li>\n</ul>\n<p>那么我们研究下如何更好的使用GCD，首先要了解到串行队列、并行队列、并发</p>\n<h4 id=\"串行队列\"><a href=\"#串行队列\" class=\"headerlink\" title=\"串行队列\"></a>串行队列</h4><p>串行是基于队列的，队列会自己控制线程，在串行队列中，任务一次只能执行一个，执行完当前任务才能继续执行下个任务。</p>\n<h4 id=\"并行队列\"><a href=\"#并行队列\" class=\"headerlink\" title=\"并行队列\"></a>并行队列</h4><p>并行有通过新建线程来实现并发执行任务，并行队列中同时是可能执行多个任务，当并行数量没有限制的时候，理论上所有任务可以同时执行。</p>\n<h4 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h4><p>并发是基于线程的，同一个线程只能串行(同一时刻)执行，要想实现并发，只能多个线程一起干活</p>\n<p><strong>串行队列</strong>相当于工厂1条流水线4个工人生产设备，从开始到结束，一个人只能干一件事，甲做A不做B。</p>\n<p><strong>并行队列</strong>是一条流水线4个工人，当工人干活速度不够的时候可以再申请一条流水线，实现两条流水线同时干活，这就实现了并发。</p>\n<p><strong>并发</strong>是多个流水线在同时加工产品。</p>\n<h4 id=\"GCD中的串行队列\"><a href=\"#GCD中的串行队列\" class=\"headerlink\" title=\"GCD中的串行队列()\"></a>GCD中的串行队列()</h4><h5 id=\"串行队列（Serial-Dispatch-Queue）：\"><a href=\"#串行队列（Serial-Dispatch-Queue）：\" class=\"headerlink\" title=\"串行队列（Serial Dispatch Queue）：\"></a>串行队列（Serial Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到尾一个挨着一个执行，一次只能执行一个任务，不具备开辟新线程的能力。</p>\n<p><img src=\"../images/10-1.png\" alt=\"\"></p>\n<h5 id=\"并发队列（Concurrent-Dispatch-Queue）：\"><a href=\"#并发队列（Concurrent-Dispatch-Queue）：\" class=\"headerlink\" title=\"并发队列（Concurrent Dispatch Queue）：\"></a>并发队列（Concurrent Dispatch Queue）：</h5><p>按照<strong>FIFO</strong>(First In First Out先进先出)原则，先添加的任务在队首，后添加的任务在队尾，执行任务的时候按照队列的从首到若干个，执行到队尾，一次可以执行多个任务，具备开辟新线程的能力。</p>\n<p><img src=\"../images/10-2.png\" alt=\"\"></p>\n<h3 id=\"GCD使用步骤\"><a href=\"#GCD使用步骤\" class=\"headerlink\" title=\"GCD使用步骤\"></a>GCD使用步骤</h3><p>GCD的使用非常简单，创建队列或者在全局队列中新加任务就可以了。</p>\n<p>下边来看看 <strong>队列的创建方法/获取方法</strong>，以及 <strong>任务的创建方法</strong>。</p>\n<h4 id=\"获取主队列\"><a href=\"#获取主队列\" class=\"headerlink\" title=\"获取主队列\"></a>获取主队列</h4><p>主队列是一种特殊的队列，也是串行队列，负责UI的更新，也可以做其他事情，可以通过<code>dispatch_get_main_queue()</code>，一般写的代码没有声明多线程或者添加到其他队列中的代码都是在主队列中运行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取主队列</div><div class=\"line\">dispatch_queue_t main_queue= dispatch_get_main_queue();</div></pre></td></tr></table></figure>\n<h4 id=\"获取全局队列\"><a href=\"#获取全局队列\" class=\"headerlink\" title=\"获取全局队列\"></a>获取全局队列</h4><p>全局队列是一个特殊的并行队列，系统已经创建好了，使用的时候通过<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code>,第一个参数是<code>identifier</code>，表示队列的优先级，一般传入<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，第二个参数<code>flags</code>，官方说法是必须是0，否则返回NULL。暂且传入0。下边摘自<a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></p>\n<blockquote>\n<p>Use the<br>.Fn dispatch_get_global_queue<br>function to obtain the global queue of given priority. The<br>.Fa flags<br>argument is reserved for future use and must be zero. Passing any value other<br>than zero may result in a NULL return value.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取全局队列</div><div class=\"line\">dispatch_queue_t main_queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>\n<h4 id=\"任务的创建\"><a href=\"#任务的创建\" class=\"headerlink\" title=\"任务的创建\"></a>任务的创建</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法的<code>spatch_async</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 同步执行任务创建方法</div><div class=\"line\">dispatch_sync(queue, ^&#123;</div><div class=\"line\">    // 这里放同步执行任务代码</div><div class=\"line\">&#125;);</div><div class=\"line\">// 异步执行任务创建方法</div><div class=\"line\">dispatch_async(queue, ^&#123;</div><div class=\"line\">    // 这里放异步执行任务代码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>虽然是只有同步异步但是他们组合的多变的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">并发队列</th>\n<th style=\"text-align:center\">创建的串行队列</th>\n<th style=\"text-align:center\">主队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">同步(sync)</td>\n<td style=\"text-align:center\">没开启新线程，串行执行</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步(async)</td>\n<td style=\"text-align:center\">能开启新线程，并发执行</td>\n<td style=\"text-align:center\">能开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没开启新线程，串行执行任务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"GCD的使用\"><a href=\"#GCD的使用\" class=\"headerlink\" title=\"GCD的使用\"></a>GCD的使用</h3><h4 id=\"主队列-同步\"><a href=\"#主队列-同步\" class=\"headerlink\" title=\"主队列+同步\"></a>主队列+同步</h4><p>在主队列中执行任务，并同步添加任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+同步</div><div class=\"line\">-(void)syn_main&#123;</div><div class=\"line\">\tNSLog(@&quot;1&quot;);</div><div class=\"line\">\tdispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_sync(main_queue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;2&quot;);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tNSLog(@&quot;3&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>看到日志只输出了1就崩溃了提示<code>exc_bad_instuction</code>,为什么出问题呢？<br>主队列是同步的，任务前后执行的任务是在主队列中，添加的任务也是在主队列中，而且添加是同步添加。<br><strong>what</strong>???在同步队列中添加同步任务，到底是想让队列执行任务还是添加任务。队列遵循FIFO原则，假如要大家都在排队等打饭，新来的员工叫的A,后边代码叫B,然后都在一个队列中，突然来了个插队的，你说B能同意吗？明显和A干起来了，结果系统老师过来拉架了说了一句<code>exc_bad_instuction</code>，意思是你俩吵起来大家都吃不上饭了，结果他俩还是接着吵，把系统吵崩溃了。<br>那么我们能在主队列中同步添加任务吗？答案是可以的。看到答案不要笑哦</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+同步</div><div class=\"line\">-(void)syn_main2&#123;</div><div class=\"line\">\tNSLog(@&quot;1任务执行&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\tNSLog(@&quot;2任务执行&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\tNSLog(@&quot;3任务执行&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">1任务执行</div><div class=\"line\">2任务执行</div><div class=\"line\">3任务执行</div></pre></td></tr></table></figure>\n<p>没看错，保证在主队列中调用该函数，那么他就是主队列同步执行的,如果在其他队列中调用，那它则是在调用者队列中同步执行。</p>\n<h4 id=\"主队列-异步\"><a href=\"#主队列-异步\" class=\"headerlink\" title=\"主队列+异步\"></a>主队列+异步</h4><p>在主队列中异步添加任务并执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主队列+异步</div><div class=\"line\">\tNSLog(@&quot;start&quot;);</div><div class=\"line\">\tdispatch_queue_t main_queue = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(main_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tNSLog(@&quot;%@ %d&quot;,[NSThread currentThread],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tNSLog(@&quot;end&quot;);</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 15:12:24.73 start</div><div class=\"line\">2019-07-24 15:12:24.73 end</div><div class=\"line\"></div><div class=\"line\">&lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 15:18:14.971795+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 15:18:15.972421+0800 day15-GCDo[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\">2019-07-24 15:18:16.973529+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\">2019-07-24 15:18:17.974978+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\">2019-07-24 15:18:18.975800+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\">2019-07-24 15:18:19.977185+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\">2019-07-24 15:18:20.978615+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\">2019-07-24 15:18:21.979958+0800 day15-GCD[31837:35880409] &lt;NSThread: 0x600002f9a940&gt;&#123;number = 1, name = main&#125; 9</div></pre></td></tr></table></figure>\n<p>在主队列异步执行任务，从日志看出来<code>end</code>早于任务的执行，符合FIFO原则，都是在主线程执行，可以看到</p>\n<ul>\n<li>主线程多个任务异步不能创建新线程</li>\n<li>主线程异步也是串行执行</li>\n</ul>\n<h4 id=\"全局队列-同步\"><a href=\"#全局队列-同步\" class=\"headerlink\" title=\"全局队列+同步\"></a>全局队列+同步</h4><p>全局队列是并行队列，和同步配合就是串行执行了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">//全局队列+同步</div><div class=\"line\">-(void)sync_global&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(global_queue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">start</div><div class=\"line\"> 2019-07-24 15:35:36 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\"> 2019-07-24 15:35:37 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\"> 2019-07-24 15:35:38 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\"> 2019-07-24 15:35:39 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\"> 2019-07-24 15:35:40 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\"> 2019-07-24 15:35:41 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\"> 2019-07-24 15:35:42 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\"> 2019-07-24 15:35:43 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\"> 2019-07-24 15:35:44 &lt;NSThread: 0x600000592900&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\"> end</div></pre></td></tr></table></figure>\n<p>在全局队列中使用串行添加多个任务并没有新建子线程来解决问题，同步其实就是串行，使用FIFO原则，一个任务解决完再解决下一个任务。</p>\n<h4 id=\"全局队列-异步\"><a href=\"#全局队列-异步\" class=\"headerlink\" title=\"全局队列+异步\"></a>全局队列+异步</h4><p>全局队列有创建子线程的能力，但是需要异步<code>async</code>去执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">//全局队列+异步</div><div class=\"line\">-(void)async_global&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(global_queue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSString *)currentDateString&#123;</div><div class=\"line\">\tNSDate *date=[NSDate new];</div><div class=\"line\">\tNSDateFormatter *format = [[NSDateFormatter alloc]init];</div><div class=\"line\">\t[format setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class=\"line\">\treturn [format stringFromDate:date];</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\"> start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 15:40:21 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 15:40:22 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b45880&gt;&#123;number = 3, name = (null)&#125; 9</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b44e80&gt;&#123;number = 4, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 15:40:23 &lt;NSThread: 0x600003b43dc0&gt;&#123;number = 5, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p>全局队列当搭配<code>async</code>的时候，追加多个任务，这次是使用3个线程，而且不用我们来维护线程的生命周期，而且执行的顺序是无序的。</p>\n<h4 id=\"创建串行队列-同步\"><a href=\"#创建串行队列-同步\" class=\"headerlink\" title=\"创建串行队列+同步\"></a>创建串行队列+同步</h4><p>开发者自己创建的串行队列同步调用和系统主队列有类似的地方，也有区别。一样都是串行执行，区别是追加任务的时候一般是在主队列向串行队列添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建串行队列+同步</div><div class=\"line\">-(void)sync_cust_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_sync(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\"> 2019-07-24 15:53:15 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\"> 2019-07-24 15:53:16 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\"> 2019-07-24 15:53:17 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\"> 2019-07-24 15:53:18 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\"> 2019-07-24 15:53:19 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\"> 2019-07-24 15:53:20 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\"> 2019-07-24 15:53:21 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\"> 2019-07-24 15:53:22 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\"> 2019-07-24 15:53:23 &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\"> end</div></pre></td></tr></table></figure>\n<p>同步向串行队列添加任务并没有死锁！原因是添加任务是在<code>main_queue</code>执行的，添加的任务是在<code>cust-queue</code>中执行，符合FIFO原则，先添加的先执行，具体执行的线程由他们自己分配。执行的任务是在<code>main</code>线程中。</p>\n<h4 id=\"创建串行队列-异步\"><a href=\"#创建串行队列-异步\" class=\"headerlink\" title=\"创建串行队列+异步\"></a>创建串行队列+异步</h4><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建串行队列+异步</div><div class=\"line\">-(void)async_cust_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\"> start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 16:12:57 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:12:58 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:12:59 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:13:00 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:13:01 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:13:02 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 5</div><div class=\"line\"> 2019-07-24 16:13:03 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 16:13:04 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 16:13:05 &lt;NSThread: 0x600002b346c0&gt;&#123;number = 3, name = (null)&#125; 9</div></pre></td></tr></table></figure>\n<p>在<code>异步 + 串行队列</code>可以看到：</p>\n<p>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。<br>所有任务是在打印的<code>end</code>之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>\n<h4 id=\"创建并行队列-同步\"><a href=\"#创建并行队列-同步\" class=\"headerlink\" title=\"创建并行队列+同步\"></a>创建并行队列+同步</h4><p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">2019-07-24 16:21:24 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 16:21:25 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 16:21:26 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 2</div><div class=\"line\">2019-07-24 16:21:27 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 3</div><div class=\"line\">2019-07-24 16:21:28 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 4</div><div class=\"line\">2019-07-24 16:21:29 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 5</div><div class=\"line\">2019-07-24 16:21:30 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 7</div><div class=\"line\">2019-07-24 16:21:31 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 8</div><div class=\"line\">2019-07-24 16:21:32 &lt;NSThread: 0x6000031d1380&gt;&#123;number = 1, name = main&#125; 9</div><div class=\"line\">end</div></pre></td></tr></table></figure>\n<p>全局队列其实就是特殊的并行队列，这里结果和<code>全局队列+同步</code>一致。</p>\n<h4 id=\"创建并行队列-异步\"><a href=\"#创建并行队列-异步\" class=\"headerlink\" title=\"创建并行队列+异步\"></a>创建并行队列+异步</h4><p>在当前线程中执行任务，会开启新线程，可以同时执行多个任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建并行队列+异步</div><div class=\"line\">-(void)async_queue&#123;</div><div class=\"line\">\tprintf(&quot;\\n start&quot;);</div><div class=\"line\">\tdispatch_queue_t custQueue = dispatch_queue_create(&quot;cust-queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(custQueue, ^&#123;</div><div class=\"line\">\t\tNSThread *thread = [NSThread currentThread];</div><div class=\"line\">\t\tfor (int i = 7; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,thread.description.UTF8String,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n end&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">start</div><div class=\"line\"> end</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 7</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:22:09 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 8</div><div class=\"line\"> 2019-07-24 16:22:10 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004280c0&gt;&#123;number = 3, name = (null)&#125; 9</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x6000004104c0&gt;&#123;number = 5, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:22:11 &lt;NSThread: 0x600000422300&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p><code>并行队列+异步</code>和<code>全局队列+异步</code>一致，也会新建线程执行任务，且是并发执行。</p>\n<h3 id=\"GCD其他高级用法\"><a href=\"#GCD其他高级用法\" class=\"headerlink\" title=\"GCD其他高级用法\"></a>GCD其他高级用法</h3><h4 id=\"子线程执行任务-主线程刷新UI\"><a href=\"#子线程执行任务-主线程刷新UI\" class=\"headerlink\" title=\"子线程执行任务 主线程刷新UI\"></a>子线程执行任务 主线程刷新UI</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)backToMain&#123;</div><div class=\"line\">\tdispatch_queue_t main = dispatch_get_main_queue();</div><div class=\"line\">\tdispatch_queue_t glo = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">\tdispatch_async(glo, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tdispatch_sync(main, ^&#123;</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s 我在刷新UI&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;);\t</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"> 2019-07-24 16:45:07 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:45:08 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001e84380&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:45:09 &lt;NSThread: 0x600001ef2940&gt;&#123;number = 1, name = main&#125; 我在刷新UI</div></pre></td></tr></table></figure>\n<h4 id=\"队列分组-dispatch-group-t\"><a href=\"#队列分组-dispatch-group-t\" class=\"headerlink\" title=\"队列分组 dispatch_group_t\"></a>队列分组 dispatch_group_t</h4><h5 id=\"dispatch-group-notify\"><a href=\"#dispatch-group-notify\" class=\"headerlink\" title=\"dispatch_group_notify\"></a>dispatch_group_notify</h5><p>GCD有有分组的概念，当所有加入分组的队列中的任务都执行完成的时候，通过<code>dispatch_group_notify</code>完成回调，第一个参数<code>group</code>是某个分组的回调。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)group&#123;</div><div class=\"line\">\tdispatch_group_t group = dispatch_group_create();</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;cust2.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue2, ^&#123;</div><div class=\"line\">\t\tfor (int i = 4; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---end1----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 6; i &lt; 8; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_group_async(group, queue2, ^&#123;</div><div class=\"line\">\t\tfor (int i = 8; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave\"><a href=\"#dispatch-group-wait-amp-amp-dispatch-group-enter-amp-amp-dispatch-group-leave\" class=\"headerlink\" title=\"dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave\"></a>dispatch_group_wait &amp;&amp; dispatch_group_enter &amp;&amp; dispatch_group_leave</h5><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>需要成对使用，否则<code>dispatch_group_wait</code>在缺少<code>leave</code>的情况下会等待到死，造成线程阻塞。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">static\tdispatch_group_t group ;</div><div class=\"line\">if (group == nil) &#123;</div><div class=\"line\">\tgroup = dispatch_group_create();</div><div class=\"line\">&#125;</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">//\tdispatch_group_enter(group);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t[self print];</div><div class=\"line\">\t[NSThread sleepForTimeInterval:2];</div><div class=\"line\">//\t\tdispatch_group_leave(group);//当注释掉  阻塞在wait不继续向下执行</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_enter(group);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">\t[self print];</div><div class=\"line\">\t[NSThread sleepForTimeInterval:2];</div><div class=\"line\">\tdispatch_group_leave(group);</div><div class=\"line\">&#125;);</div><div class=\"line\">//log</div><div class=\"line\">2019-07-25 10:58:50 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">2019-07-25 10:58:52 &lt;NSThread: 0x600002d84180&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"栅栏函数-dispatch-barrier-sync\"><a href=\"#栅栏函数-dispatch-barrier-sync\" class=\"headerlink\" title=\"栅栏函数 dispatch_barrier_sync\"></a>栅栏函数 dispatch_barrier_sync</h4><p>栅栏函数实现了异步的队列中在多个任务结束的时候实行回调，回调分异步和同步，同步回调在主线程，异步在其他线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)barry&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;cust.queue.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 0; i &lt; 3; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_barrier_sync(queue, ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---中间暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (int i = 3; i &lt; 6; i ++) &#123;</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s %d&quot;,[self dateUTF8],[self threadInfo],i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s ---中间第二次暂停一下----&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"> 2019-07-24 16:52:33 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 0</div><div class=\"line\"> 2019-07-24 16:52:34 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 1</div><div class=\"line\"> 2019-07-24 16:52:35 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\"> 2019-07-24 16:52:35 &lt;NSThread: 0x6000031293c0&gt;&#123;number = 1, name = main&#125; ---中间暂停一下----</div><div class=\"line\"> 2019-07-24 16:52:36 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\"> 2019-07-24 16:52:37 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 4</div><div class=\"line\"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; 5</div><div class=\"line\"> 2019-07-24 16:52:38 &lt;NSThread: 0x600003158440&gt;&#123;number = 3, name = (null)&#125; ---中间第二次暂停一下----</div></pre></td></tr></table></figure>\n<h4 id=\"单例-执行一次的函数-dispatch-once-t\"><a href=\"#单例-执行一次的函数-dispatch-once-t\" class=\"headerlink\" title=\"单例-执行一次的函数 dispatch_once_t\"></a>单例-执行一次的函数 dispatch_once_t</h4><p>单例可以通过这个函数实现，只执行一次的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//只执行一次的dispatch_once</div><div class=\"line\">-(void)exc_once&#123;</div><div class=\"line\">\tstatic dispatch_once_t onceToken;</div><div class=\"line\">\tstatic NSObject *obj;</div><div class=\"line\">\tdispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">\t\tobj=[NSObject new];</div><div class=\"line\">\t\tprintf(&quot;\\n just once %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n %s %s&quot;,[self dateUTF8],obj.description.UTF8String);</div><div class=\"line\">&#125;</div><div class=\"line\">调用4次</div><div class=\"line\">dispatch_apply(4, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\t[self exc_once];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">//log</div><div class=\"line\">just once 2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div><div class=\"line\">2019-07-25 14:46:00 &lt;NSObject: 0x60000378b100&gt;</div></pre></td></tr></table></figure>\n<p>当调用4次的时候，日志打印的四次<code>obj</code>均为同一个地址，证明<code>block</code>回调四次但是只执行了一次。</p>\n<h4 id=\"延迟执行-dispatch-after\"><a href=\"#延迟执行-dispatch-after\" class=\"headerlink\" title=\"延迟执行 dispatch_after\"></a>延迟执行 dispatch_after</h4><p>当记录日志或者点击事件的方法我们不希望立即执行，则会用到延迟</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//延迟执行</div><div class=\"line\">-(void)delayTimeExc&#123;</div><div class=\"line\">\tprintf(&quot;\\n %s %s begin&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t</div><div class=\"line\">\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tprintf(&quot;\\n %s %s end&quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; begin</div><div class=\"line\">2019-07-24 17:07:48 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125; end</div><div class=\"line\">2019-07-24 17:07:50 &lt;NSThread: 0x600003cc6940&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"信号量-dispatch-semaphore-t\"><a href=\"#信号量-dispatch-semaphore-t\" class=\"headerlink\" title=\"信号量  dispatch_semaphore_t\"></a>信号量  dispatch_semaphore_t</h4><p>信号量为1可以作为线程锁来用，当N&gt;1的时候，同时执行的有N个任务。<br><code>dispatch_apply</code>可以通知创建多个线程来执行任务，用它来测试信号量再好不过了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">//信号量 当信号量为1 可以未做锁来用，当N&gt;1，t通知执行的数量则是数字N。</div><div class=\"line\">- (void)semaphore&#123;</div><div class=\"line\">\tstatic dispatch_semaphore_t sem;</div><div class=\"line\">\tif (sem == NULL) &#123;</div><div class=\"line\">\t\tsem = dispatch_semaphore_create(1);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tstatic int i = 0;</div><div class=\"line\">\tint currentI = i +2;</div><div class=\"line\">\tfor (; i &lt; currentI; i ++) &#123;</div><div class=\"line\">\t\t[NSThread sleepForTimeInterval:1];</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s %d&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,i);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdispatch_semaphore_signal(sem);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)asyn_semaphore&#123;</div><div class=\"line\">\tdispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\t[self semaphore];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-24 17:25:04 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 0</div><div class=\"line\">2019-07-24 17:25:05 &lt;NSThread: 0x6000002a2940&gt;&#123;number = 1, name = main&#125; 1</div><div class=\"line\">2019-07-24 17:25:06 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 2</div><div class=\"line\">2019-07-24 17:25:07 &lt;NSThread: 0x6000002e2b40&gt;&#123;number = 3, name = (null)&#125; 3</div><div class=\"line\">2019-07-24 17:25:08 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 4</div><div class=\"line\">2019-07-24 17:25:09 &lt;NSThread: 0x6000002d4740&gt;&#123;number = 4, name = (null)&#125; 5</div></pre></td></tr></table></figure>\n<p>设计一个经典问题，火车票窗口买票，火车站卖票一般有多个窗口，排队是每个窗口排一个队列，一个窗口同时只能卖一张票，那我们设计一下如何实现多队列同时访问多个窗口的的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)muchQueueBuyTick&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:4];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue2, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:2];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)semaphore_buy_ticks:(NSInteger)windowsCount&#123;</div><div class=\"line\">\tstatic dispatch_semaphore_t sem;</div><div class=\"line\">\tif (sem == NULL) &#123;</div><div class=\"line\">\t\tsem = dispatch_semaphore_create(windowsCount);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//信号量-1</div><div class=\"line\">\tdispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tself.count--;</div><div class=\"line\">\tif (self.count &gt; 0) &#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class=\"line\">\t\t[NSThread sleepForTimeInterval:0.2];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//信号量+1</div><div class=\"line\">\tdispatch_semaphore_signal(sem);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-24 18:01:44 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:44 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003904c40&gt;&#123;number = 3, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:01:45 &lt;NSThread: 0x600003935e00&gt;&#123;number = 4, name = (null)&#125; 第0个人买到票了</div></pre></td></tr></table></figure>\n<p>两个窗口(两个队列)，每个窗口排了5(循环5次)个人，一共10(count=10)张票。<br>当同时一张票可以分割2次，卖票的错乱了，明显错误了，现在把每张票都锁起来，同时只能允许同一个人卖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)muchQueueBuyTick&#123;</div><div class=\"line\">\tdispatch_queue_t queue= dispatch_queue_create(&quot;com.buy.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:1];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tdispatch_queue_t queue2= dispatch_queue_create(&quot;com.buy2.tick&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">\tdispatch_async(queue2, ^&#123;</div><div class=\"line\">\t\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\t\t[self semaphore_buy_ticks:1];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-24 18:03:56 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第9个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第7个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第5个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:57 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第3个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1e0c0&gt;&#123;number = 4, name = (null)&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-24 18:03:58 &lt;NSThread: 0x600000e1cac0&gt;&#123;number = 3, name = (null)&#125; 第1个人买到票了</div></pre></td></tr></table></figure>\n<p>顺序是对了，数量也对了。</p>\n<p>再换一种思路实现锁住窗口，我们使用串行队列也是可以的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用同步队列卖票</div><div class=\"line\">- (void)sync_buy_tick&#123;</div><div class=\"line\">\tdispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">\t\tself.count--;</div><div class=\"line\">\t\tif (self.count &gt; 0) &#123;</div><div class=\"line\">\t\t\tprintf(&quot;\\n %s %s 第%ld个人买到票了&quot;,[self currentDateString].UTF8String,[NSThread currentThread].description.UTF8String,(long)self.count);</div><div class=\"line\">\t\t\t[NSThread sleepForTimeInterval:0.2];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第9个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第8个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第7个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:56 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第6个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第5个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第4个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第3个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第2个人买到票了</div><div class=\"line\"> 2019-07-25 09:31:57 &lt;NSThread: 0x6000034d2e40&gt;&#123;number = 1, name = main&#125; 第1个人买到票了</div></pre></td></tr></table></figure>\n<p>串行队列不创建子线程，所有任务都在同一个线程执行，那么他们就会排队，其实不管多少人同时点击买票，票的分割还是串行的，所以线程锁的可以使用串行队列来解决。</p>\n<h4 id=\"快速迭代方法：dispatch-apply\"><a href=\"#快速迭代方法：dispatch-apply\" class=\"headerlink\" title=\"快速迭代方法：dispatch_apply\"></a>快速迭代方法：dispatch_apply</h4><p>快速迭代就是同时创建很多线程来在做事情，现在工厂收到一个亿的订单，工厂本来只有2条生产线，现在紧急新建很多生产线来生产产品。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">同时新建了多条线程来做任务</div><div class=\"line\">*/</div><div class=\"line\">\tdispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t idx) &#123;</div><div class=\"line\">\t\tprintf(&quot;\\n %s %s &quot;,[self dateUTF8],[self threadInfo]);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t//log</div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000979dc0&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000090d3c0&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x60000095cfc0&gt;&#123;number = 6, name = (null)&#125; </div><div class=\"line\">2019-07-25 09:38:38 &lt;NSThread: 0x600000950140&gt;&#123;number = 8, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000095d0c0&gt;&#123;number = 9, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a400&gt;&#123;number = 7, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x600000966180&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\"> 2019-07-25 09:38:38 &lt;NSThread: 0x60000094a3c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>可以看到新建了<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>、<code>main</code>来执行任务。</p>\n<h3 id=\"多线程RunLoop实战\"><a href=\"#多线程RunLoop实战\" class=\"headerlink\" title=\"多线程RunLoop实战\"></a>多线程RunLoop实战</h3><p>问题一：请问下边代码输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(0, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">    NSLog(@&quot;2&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>猜想1：结果是<code>123</code></li>\n<li>猜想2：结果是<code>132</code></li>\n</ul>\n<p>有没有第三种结果呢？</p>\n<p>猜想1分析：<br>因为是延迟<code>0</code>s执行，当然是先执行<code>2</code>，再执行<code>3</code>了。</p>\n<p>猜想2分析：</p>\n<p>我们来分析一下，异步加入全局队列中，单个任务的时候会加入到子线程中，那么会先输出<code>1</code>，然后输出<code>3</code>，最后输出<code>2</code>.</p>\n<p>最后验证一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">3</div></pre></td></tr></table></figure>\n<p>为什么2没有出来呢？在看一下代码，全局队列，延迟执行，点进去函数查看，原来是在<code>runloop.h</code>文件中，我们猜测延迟执行是<code>timer</code>添加到<code>runloop</code>中了，添加进去也应该输出<code>132</code>的。因为在子线程中，没有主动调用不会有<code>runloop</code>的，及时调用了也需要保活技术，那么代码改进一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        // 相当于[self test];</div><div class=\"line\">//       [self performSelector:@selector(test) withObject:nil];</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">        </div><div class=\"line\">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class=\"line\">        [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">        NSLog(@&quot;3&quot;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>经测试输出了<code>12</code>，这和我们猜想的还是不对，原来输出<code>3</code>放在了最后，导致的问题，<code>RunLoop</code>运行起来，进入了循环，则后面的就不会执行了，除非停止当前<code>RunLoop</code>，我们再改进一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t  que= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    dispatch_async(que, ^&#123;</div><div class=\"line\">        NSLog(@&quot;1&quot;);</div><div class=\"line\">        // 相当于[self test];</div><div class=\"line\">//       [self performSelector:@selector(test) withObject:nil];</div><div class=\"line\">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</div><div class=\"line\">         NSLog(@&quot;3&quot;);</div><div class=\"line\">        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSRunLoopCommonModes];</div><div class=\"line\">        [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>最后终于输出了<code>132</code>。缺点是子线程成了<strong>死待</strong>，不死之身，关于怎么杀死<strong>死待</strong>请看<a href=\"https://juejin.im/post/5d35b347f265da1b8608c49b\" target=\"_blank\" rel=\"external\">上篇优雅控制RunLoop生命周期</a>。<br>关于<code>performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>中有延迟的，都是添加到当前你线程的<code>RunLoop</code>，如果没有启动<code>RunLoop</code>和保活恐怕也不能一直执行。<code>[self performSelector:@selector(test) withObject:nil]</code>是在<code>Foudation</code>中，源码是直接<code>objc_msgSend()</code>，相当于直接<code>[self test]</code>，不会有延迟。</p>\n<p>问题2：请问输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSThread *thread=[[NSThread alloc]initWithBlock:^&#123;</div><div class=\"line\">    NSLog(@&quot;1&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">[thread start];</div><div class=\"line\">[self performSelector:@selector(test)</div><div class=\"line\">             onThread:thread</div><div class=\"line\">           withObject:nil</div><div class=\"line\">        waitUntilDone:YES];</div></pre></td></tr></table></figure>\n<p>这个和上面的类似，结果是打印了<code>1</code>就崩溃了，原因是<code>thread start</code>之后执行完<code>block</code>就结束了，没有<code>runloop</code>的支撑。当执行<code>performSelector</code>的时候，线程已经死掉。解决这个问题只需要向子线程中添加<code>RunLoop</code>，而且保证<code>RunLoop</code>不停止就行了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>GCD异步负责执行耗时任务(例如下载，复杂计算)，main线程负责更新UI</li>\n<li>队列多任务异步执行最后全局执行完毕可以使用<code>group_notify</code>来监听执行完毕时间</li>\n<li>队列多任务异步执行结束时间，中间拦截更新UI，然后再异步执行可以使用<code>dispatch_barrier_sync</code></li>\n<li>当多线程访问同一个资源，可以使用信号量来限制同时访问资源的线程数量</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16\" target=\"_blank\" rel=\"external\">iOS多线程：『GCD』详尽总结</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></li>\n<li>iOS和OS多线程与内存管理<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS线程之GCD初探","date":"2016-03-28T09:47:47.000Z","_content":"\n简述：\n       说道线程，离不开并行和串行，所谓并行，就是100赛跑，每个赛道就是一个线程，每个线程之间互不影响，同时都可以运行事件，就是10个赛道都可以有运动员跑步了，谁跑的慢或者跑的快，都不影响其他的人。串行就不一样了，串行是1个赛道10个运动员再跑接力赛，第一个跑到终点第二个在接着跑，依次类推，前边的不走，后边的也走不了的，所以串行上面的事件是一个一个运行的，同时只能是一个人再跑。\n\n在iOS或者OS里面，一般用GCD就能吃处理较多的事务，下面就谈一下GCD的用法。\n\n### 什么是GCD？\n全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”\n纯C语言，提供了非常多强大的函数\n\n### methodList info\n```\n\n//获取主线程 就是更新UI的线程\ndispatch_queue_t dispatch_get_main_queue(void);\n\n //获取全局队列\ndispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);\n\n//创建一个队列 名字是label 属性可以写为NULL  \ndispatch_queue_t dispatch_queue_create( const char *label dispatch_queue_attr_t attr);\ndispatch_release(queue)//释放队列\n\n//获取代码现在运行的queue\ndispatch_queue_t dispatch_get_current_queue( void);\n\n //获取队列的名字\nconst char * dispatch_queue_get_label(dispatch_queue_t queue);\n\n//异步把代码块block交给queue队列中处理\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n\n// 同步将block加入到queue中并且执行。\nvoid dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);\n\n //block 在指定时间在queue中执行\nvoid dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\n\n \n//几个调度事件同事加入到queue中去，最好是全局队列才行。\nvoid dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));\n\n// block 是否执行过\nvoid dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);\n \n//在分组group中的queue队列执行block\nvoid dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\n\n//创建线程分组\ndispatch_group_t dispatch_group_create( void);\n\n //分组的计数+1\nvoid dispatch_group_enter( dispatch_group_t group);\n\n//分组计数 -1\nvoid dispatch_group_leave( dispatch_group_t group);\n\n// 当分组中的事务处理完了执行block\nvoid dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\n\n//等待timeout时间后执行 group中的事务\nlong dispatch_group_wait( dispatch_group_t group, dispatch_time_t timeout);\n\n //并行状态下 queue前面的并行事务处理完成了在执行block，然后执行下边的并行代码\n//比如 ABCDEF D事务等到ABC都完成了在执行EF事务的\nvoid dispatch_barrier_async( dispatch_queue_t queue, dispatch_block_t block);\n\n```\n### 实战演练全局队列\n\n```\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\ndispatch_async(queue, ^{\n        //异步执行\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            //这里面更新UI\n        });\n    });\n    dispatch_sync(queue, ^{\n       //同步执行\n    });\n```\n### 自定义队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_SERIAL);\n    //\n//#define DISPATCH_QUEUE_SERIAL   同步队列\n//#define DISPATCH_QUEUE_CONCURRENT 异步队列\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片1=====%@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片2=====%@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片3=====%@\",[NSThread currentThread]);\n    });\n    NSLog(@\"main:%@\",[NSThread mainThread]);\n当queue属性为 DISPATCH_QUEUE_CONCURRENT输出：\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347984] ****下载图片****3=====<NSThread: 0x7fabda100250>{number = 4, name = (null)}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347982] ****下载图片****2=====<NSThread: 0x7fabda2008a0>{number = 3, name = (null)}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347937] main:<NSThread: 0x7fabd8c04ee0>{number = 1, name = main}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347981] ****下载图片****1=====<NSThread: 0x7fabd8c0a010>{number = 2, name = (null)}** 线程达到了4个\n当queue属性为DISPATCH_QUEUE_SERIAL输出：\n**2016-03-28 16:46:54.501 GCD_Demo[12272:344348] main:<NSThread: 0x7fd379704cf0>{number = 1, name = main}**\n**2016-03-28 16:46:54.501 GCD_Demo[12272:344382] ****下载图片****1=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****2=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****3=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n线程只有2个\n\n ```\n### 多个异步线程问题\n```\n# 当ABC 3个异步线程，要求前两个个执行完再去执行后面的三个的时候例子：\n     dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        NSLog(@\"queue1 begin\");\n        sleep(2);\n        NSLog(@\"queue1 end\");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"queue2 begin\");\n        sleep(2);\n        NSLog(@\"queue2 end\");\n    });\n    dispatch_barrier_sync(queue, ^{\n        NSLog(@\"main:%@\",[NSThread mainThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"queue3 begin\");\n        sleep(2);\n        NSLog(@\"queue3 end\");\n    });\n输出：\n\n**2016-03-28 17:01:01.319 GCD_Demo[12463:353702] queue2 begin**\n**2016-03-28 17:01:01.319 GCD_Demo[12463:353703] queue1 begin**\n**2016-03-28 17:01:03.324 GCD_Demo[12463:353703] queue1 end**\n**2016-03-28 17:01:03.324 GCD_Demo[12463:353702] queue2 end**\n**2016-03-28 17:01:03.325 GCD_Demo[12463:353657] main:<NSThread: 0x7f97ea604bf0>{number = 1, name = main}**\n**2016-03-28 17:01:03.325 GCD_Demo[12463:353702] queue3 begin**\n**2016-03-28 17:01:05.330 GCD_Demo[12463:353702] queue3 end**\n```\n### 线程分组\n```\n# 当多个任务同时进行的时候，也可以用group，ABCD任务进行完成的时候，最后在执行task。\n \n\n  dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task1 begin\");\n        sleep(2);\n        NSLog(@\"task1 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task2 begin\");\n        sleep(2);\n        NSLog(@\"task2 end\");\n    });\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@\"=================\");\n    });\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task3 begin\");\n        sleep(2);\n        NSLog(@\"task3 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task4 begin\");\n        sleep(2);\n        NSLog(@\"task4 end\");\n    });\n输出：\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357162] task1 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357164] task4 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357161] task2 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357163] task3 begin**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357162] task1 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357163] task3 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357164] task4 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357161] task2 end**\n**2016-03-28 17:08:47.006 GCD_Demo[12557:357161] =================**\n一个组内的所有任务都进行完了才会执行task的函数。\n\n\n# 分组多任务等待 ABCDEF ，ABCD执行5秒，5秒之后就执行EF任务，不管ABCD是否成功。\n\n    dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task1 begin\");\n        sleep(2);\n        NSLog(@\"task1 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task2 begin\");\n        sleep(2);\n        NSLog(@\"task2 end\");\n    });\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@\"=================\");\n    });\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task3 begin\");\n        sleep(6);\n        NSLog(@\"task3 end\");\n    });\n    dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)));\n    NSLog(@\"all end\");\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task4 begin\");\n        sleep(2);\n        NSLog(@\"task4 end\");\n    });\n输出：\n# 代码执行到wait的时候会等待5秒之后再执行wait下边的代码，和sleep有点相似。\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366983] task3 begin**\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366978] task1 begin**\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366979] task2 begin**\n**2016-03-28 17:26:33.340 GCD_Demo[12745:366978] task1 end**\n**2016-03-28 17:26:33.340 GCD_Demo[12745:366979] task2 end**\n**2016-03-28 17:26:36.336 GCD_Demo[12745:366894] all end**\n**2016-03-28 17:26:36.336 GCD_Demo[12745:366979] task4 begin**\n**2016-03-28 17:26:37.340 GCD_Demo[12745:366983] task3 end**\n**2016-03-28 17:26:38.342 GCD_Demo[12745:366979] task4 end**\n**2016-03-28 17:26:38.342 GCD_Demo[12745:366983] =================**\n```\n### 同时处理多数据不管顺序\n```\n          dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    \n    \n          /*! dispatch_apply函数说明\n           10      *\n           11      *  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API\n           12      *         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束\n           13      *\n           14      *  @param 10    指定重复次数  指定10次\n           15      *  @param queue 追加对象的Dispatch Queue\n           16      *  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block\n           17      *\n           18      */\n          dispatch_apply(10, queue, ^(size_t index) {\n                  NSLog(@\"%d\", index);\n              \n              });\n          NSLog(@\"done\");\n输出：\n# 这个和上边讲的分组类似，多事务处理，处理结束后再执行代码。\n# 这个是同步的，代码按顺序执行，分组的是异步执行的block\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372458] 1**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372463] 5**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372429] 4**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372464] 6**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372465] 7**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372462] 2**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372457] 0**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372461] 3**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372458] 8**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] 9**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] done**\n    \n```\n参考文章：[Grand Central Dispatch (GCD) Reference](https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/macro/DISPATCH_QUEUE_CONCURRENT)\nGCD提供的接口蛮多的,适用场景还是要熟练掌握，才能运用自如。","source":"_posts/iOS线程之GCD初探.md","raw":"title: iOS线程之GCD初探\ndate: 2016-03-28 17:47:47\ntags:\n- iOS\n- iOS高级\ncategories: iOS\n---\n\n简述：\n       说道线程，离不开并行和串行，所谓并行，就是100赛跑，每个赛道就是一个线程，每个线程之间互不影响，同时都可以运行事件，就是10个赛道都可以有运动员跑步了，谁跑的慢或者跑的快，都不影响其他的人。串行就不一样了，串行是1个赛道10个运动员再跑接力赛，第一个跑到终点第二个在接着跑，依次类推，前边的不走，后边的也走不了的，所以串行上面的事件是一个一个运行的，同时只能是一个人再跑。\n\n在iOS或者OS里面，一般用GCD就能吃处理较多的事务，下面就谈一下GCD的用法。\n\n### 什么是GCD？\n全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”\n纯C语言，提供了非常多强大的函数\n\n### methodList info\n```\n\n//获取主线程 就是更新UI的线程\ndispatch_queue_t dispatch_get_main_queue(void);\n\n //获取全局队列\ndispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);\n\n//创建一个队列 名字是label 属性可以写为NULL  \ndispatch_queue_t dispatch_queue_create( const char *label dispatch_queue_attr_t attr);\ndispatch_release(queue)//释放队列\n\n//获取代码现在运行的queue\ndispatch_queue_t dispatch_get_current_queue( void);\n\n //获取队列的名字\nconst char * dispatch_queue_get_label(dispatch_queue_t queue);\n\n//异步把代码块block交给queue队列中处理\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n\n// 同步将block加入到queue中并且执行。\nvoid dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);\n\n //block 在指定时间在queue中执行\nvoid dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\n\n \n//几个调度事件同事加入到queue中去，最好是全局队列才行。\nvoid dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));\n\n// block 是否执行过\nvoid dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);\n \n//在分组group中的queue队列执行block\nvoid dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\n\n//创建线程分组\ndispatch_group_t dispatch_group_create( void);\n\n //分组的计数+1\nvoid dispatch_group_enter( dispatch_group_t group);\n\n//分组计数 -1\nvoid dispatch_group_leave( dispatch_group_t group);\n\n// 当分组中的事务处理完了执行block\nvoid dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\n\n//等待timeout时间后执行 group中的事务\nlong dispatch_group_wait( dispatch_group_t group, dispatch_time_t timeout);\n\n //并行状态下 queue前面的并行事务处理完成了在执行block，然后执行下边的并行代码\n//比如 ABCDEF D事务等到ABC都完成了在执行EF事务的\nvoid dispatch_barrier_async( dispatch_queue_t queue, dispatch_block_t block);\n\n```\n### 实战演练全局队列\n\n```\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\ndispatch_async(queue, ^{\n        //异步执行\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            //这里面更新UI\n        });\n    });\n    dispatch_sync(queue, ^{\n       //同步执行\n    });\n```\n### 自定义队列\n```\ndispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_SERIAL);\n    //\n//#define DISPATCH_QUEUE_SERIAL   同步队列\n//#define DISPATCH_QUEUE_CONCURRENT 异步队列\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片1=====%@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片2=====%@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"下载图片3=====%@\",[NSThread currentThread]);\n    });\n    NSLog(@\"main:%@\",[NSThread mainThread]);\n当queue属性为 DISPATCH_QUEUE_CONCURRENT输出：\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347984] ****下载图片****3=====<NSThread: 0x7fabda100250>{number = 4, name = (null)}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347982] ****下载图片****2=====<NSThread: 0x7fabda2008a0>{number = 3, name = (null)}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347937] main:<NSThread: 0x7fabd8c04ee0>{number = 1, name = main}**\n**2016-03-28 16:53:25.848 GCD_Demo[12338:347981] ****下载图片****1=====<NSThread: 0x7fabd8c0a010>{number = 2, name = (null)}** 线程达到了4个\n当queue属性为DISPATCH_QUEUE_SERIAL输出：\n**2016-03-28 16:46:54.501 GCD_Demo[12272:344348] main:<NSThread: 0x7fd379704cf0>{number = 1, name = main}**\n**2016-03-28 16:46:54.501 GCD_Demo[12272:344382] ****下载图片****1=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****2=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****3=====<NSThread: 0x7fd37971bda0>{number = 2, name = (null)}**\n线程只有2个\n\n ```\n### 多个异步线程问题\n```\n# 当ABC 3个异步线程，要求前两个个执行完再去执行后面的三个的时候例子：\n     dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        NSLog(@\"queue1 begin\");\n        sleep(2);\n        NSLog(@\"queue1 end\");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"queue2 begin\");\n        sleep(2);\n        NSLog(@\"queue2 end\");\n    });\n    dispatch_barrier_sync(queue, ^{\n        NSLog(@\"main:%@\",[NSThread mainThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"queue3 begin\");\n        sleep(2);\n        NSLog(@\"queue3 end\");\n    });\n输出：\n\n**2016-03-28 17:01:01.319 GCD_Demo[12463:353702] queue2 begin**\n**2016-03-28 17:01:01.319 GCD_Demo[12463:353703] queue1 begin**\n**2016-03-28 17:01:03.324 GCD_Demo[12463:353703] queue1 end**\n**2016-03-28 17:01:03.324 GCD_Demo[12463:353702] queue2 end**\n**2016-03-28 17:01:03.325 GCD_Demo[12463:353657] main:<NSThread: 0x7f97ea604bf0>{number = 1, name = main}**\n**2016-03-28 17:01:03.325 GCD_Demo[12463:353702] queue3 begin**\n**2016-03-28 17:01:05.330 GCD_Demo[12463:353702] queue3 end**\n```\n### 线程分组\n```\n# 当多个任务同时进行的时候，也可以用group，ABCD任务进行完成的时候，最后在执行task。\n \n\n  dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task1 begin\");\n        sleep(2);\n        NSLog(@\"task1 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task2 begin\");\n        sleep(2);\n        NSLog(@\"task2 end\");\n    });\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@\"=================\");\n    });\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task3 begin\");\n        sleep(2);\n        NSLog(@\"task3 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task4 begin\");\n        sleep(2);\n        NSLog(@\"task4 end\");\n    });\n输出：\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357162] task1 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357164] task4 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357161] task2 begin**\n**2016-03-28 17:08:45.002 GCD_Demo[12557:357163] task3 begin**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357162] task1 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357163] task3 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357164] task4 end**\n**2016-03-28 17:08:47.005 GCD_Demo[12557:357161] task2 end**\n**2016-03-28 17:08:47.006 GCD_Demo[12557:357161] =================**\n一个组内的所有任务都进行完了才会执行task的函数。\n\n\n# 分组多任务等待 ABCDEF ，ABCD执行5秒，5秒之后就执行EF任务，不管ABCD是否成功。\n\n    dispatch_queue_t queue = dispatch_queue_create(\"com.apple.fgyong\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_group_t group = dispatch_group_create();\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task1 begin\");\n        sleep(2);\n        NSLog(@\"task1 end\");\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task2 begin\");\n        sleep(2);\n        NSLog(@\"task2 end\");\n    });\n    dispatch_group_notify(group, queue, ^{\n        NSLog(@\"=================\");\n    });\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task3 begin\");\n        sleep(6);\n        NSLog(@\"task3 end\");\n    });\n    dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)));\n    NSLog(@\"all end\");\n    dispatch_group_async(group, queue, ^{\n        \n        NSLog(@\"task4 begin\");\n        sleep(2);\n        NSLog(@\"task4 end\");\n    });\n输出：\n# 代码执行到wait的时候会等待5秒之后再执行wait下边的代码，和sleep有点相似。\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366983] task3 begin**\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366978] task1 begin**\n**2016-03-28 17:26:31.335 GCD_Demo[12745:366979] task2 begin**\n**2016-03-28 17:26:33.340 GCD_Demo[12745:366978] task1 end**\n**2016-03-28 17:26:33.340 GCD_Demo[12745:366979] task2 end**\n**2016-03-28 17:26:36.336 GCD_Demo[12745:366894] all end**\n**2016-03-28 17:26:36.336 GCD_Demo[12745:366979] task4 begin**\n**2016-03-28 17:26:37.340 GCD_Demo[12745:366983] task3 end**\n**2016-03-28 17:26:38.342 GCD_Demo[12745:366979] task4 end**\n**2016-03-28 17:26:38.342 GCD_Demo[12745:366983] =================**\n```\n### 同时处理多数据不管顺序\n```\n          dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    \n    \n          /*! dispatch_apply函数说明\n           10      *\n           11      *  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API\n           12      *         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束\n           13      *\n           14      *  @param 10    指定重复次数  指定10次\n           15      *  @param queue 追加对象的Dispatch Queue\n           16      *  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block\n           17      *\n           18      */\n          dispatch_apply(10, queue, ^(size_t index) {\n                  NSLog(@\"%d\", index);\n              \n              });\n          NSLog(@\"done\");\n输出：\n# 这个和上边讲的分组类似，多事务处理，处理结束后再执行代码。\n# 这个是同步的，代码按顺序执行，分组的是异步执行的block\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372458] 1**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372463] 5**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372429] 4**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372464] 6**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372465] 7**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372462] 2**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372457] 0**\n**2016-03-28 17:36:35.698 GCD_Demo[12857:372461] 3**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372458] 8**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] 9**\n**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] done**\n    \n```\n参考文章：[Grand Central Dispatch (GCD) Reference](https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/macro/DISPATCH_QUEUE_CONCURRENT)\nGCD提供的接口蛮多的,适用场景还是要熟练掌握，才能运用自如。","slug":"iOS线程之GCD初探","published":1,"updated":"2019-12-03T04:48:00.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2m000p9zskdz8jqwjl","content":"<p>简述：<br>       说道线程，离不开并行和串行，所谓并行，就是100赛跑，每个赛道就是一个线程，每个线程之间互不影响，同时都可以运行事件，就是10个赛道都可以有运动员跑步了，谁跑的慢或者跑的快，都不影响其他的人。串行就不一样了，串行是1个赛道10个运动员再跑接力赛，第一个跑到终点第二个在接着跑，依次类推，前边的不走，后边的也走不了的，所以串行上面的事件是一个一个运行的，同时只能是一个人再跑。</p>\n<p>在iOS或者OS里面，一般用GCD就能吃处理较多的事务，下面就谈一下GCD的用法。</p>\n<h3 id=\"什么是GCD？\"><a href=\"#什么是GCD？\" class=\"headerlink\" title=\"什么是GCD？\"></a>什么是GCD？</h3><p>全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”<br>纯C语言，提供了非常多强大的函数</p>\n<h3 id=\"methodList-info\"><a href=\"#methodList-info\" class=\"headerlink\" title=\"methodList info\"></a>methodList info</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//获取主线程 就是更新UI的线程</div><div class=\"line\">dispatch_queue_t dispatch_get_main_queue(void);</div><div class=\"line\"></div><div class=\"line\"> //获取全局队列</div><div class=\"line\">dispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);</div><div class=\"line\"></div><div class=\"line\">//创建一个队列 名字是label 属性可以写为NULL  </div><div class=\"line\">dispatch_queue_t dispatch_queue_create( const char *label dispatch_queue_attr_t attr);</div><div class=\"line\">dispatch_release(queue)//释放队列</div><div class=\"line\"></div><div class=\"line\">//获取代码现在运行的queue</div><div class=\"line\">dispatch_queue_t dispatch_get_current_queue( void);</div><div class=\"line\"></div><div class=\"line\"> //获取队列的名字</div><div class=\"line\">const char * dispatch_queue_get_label(dispatch_queue_t queue);</div><div class=\"line\"></div><div class=\"line\">//异步把代码块block交给queue队列中处理</div><div class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">// 同步将block加入到queue中并且执行。</div><div class=\"line\">void dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"> //block 在指定时间在queue中执行</div><div class=\"line\">void dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\">//几个调度事件同事加入到queue中去，最好是全局队列才行。</div><div class=\"line\">void dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));</div><div class=\"line\"></div><div class=\"line\">// block 是否执行过</div><div class=\"line\">void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);</div><div class=\"line\"> </div><div class=\"line\">//在分组group中的queue队列执行block</div><div class=\"line\">void dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">//创建线程分组</div><div class=\"line\">dispatch_group_t dispatch_group_create( void);</div><div class=\"line\"></div><div class=\"line\"> //分组的计数+1</div><div class=\"line\">void dispatch_group_enter( dispatch_group_t group);</div><div class=\"line\"></div><div class=\"line\">//分组计数 -1</div><div class=\"line\">void dispatch_group_leave( dispatch_group_t group);</div><div class=\"line\"></div><div class=\"line\">// 当分组中的事务处理完了执行block</div><div class=\"line\">void dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">//等待timeout时间后执行 group中的事务</div><div class=\"line\">long dispatch_group_wait( dispatch_group_t group, dispatch_time_t timeout);</div><div class=\"line\"></div><div class=\"line\"> //并行状态下 queue前面的并行事务处理完成了在执行block，然后执行下边的并行代码</div><div class=\"line\">//比如 ABCDEF D事务等到ABC都完成了在执行EF事务的</div><div class=\"line\">void dispatch_barrier_async( dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n<h3 id=\"实战演练全局队列\"><a href=\"#实战演练全局队列\" class=\"headerlink\" title=\"实战演练全局队列\"></a>实战演练全局队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\"></div><div class=\"line\">dispatch_async(queue, ^&#123;</div><div class=\"line\">        //异步执行</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            //这里面更新UI</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_sync(queue, ^&#123;</div><div class=\"line\">       //同步执行</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"自定义队列\"><a href=\"#自定义队列\" class=\"headerlink\" title=\"自定义队列\"></a>自定义队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">    //</div><div class=\"line\">//#define DISPATCH_QUEUE_SERIAL   同步队列</div><div class=\"line\">//#define DISPATCH_QUEUE_CONCURRENT 异步队列</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片1=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片2=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片3=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;main:%@&quot;,[NSThread mainThread]);</div><div class=\"line\">当queue属性为 DISPATCH_QUEUE_CONCURRENT输出：</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347984] ****下载图片****3=====&lt;NSThread: 0x7fabda100250&gt;&#123;number = 4, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347982] ****下载图片****2=====&lt;NSThread: 0x7fabda2008a0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347937] main:&lt;NSThread: 0x7fabd8c04ee0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347981] ****下载图片****1=====&lt;NSThread: 0x7fabd8c0a010&gt;&#123;number = 2, name = (null)&#125;** 线程达到了4个</div><div class=\"line\">当queue属性为DISPATCH_QUEUE_SERIAL输出：</div><div class=\"line\">**2016-03-28 16:46:54.501 GCD_Demo[12272:344348] main:&lt;NSThread: 0x7fd379704cf0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.501 GCD_Demo[12272:344382] ****下载图片****1=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****2=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****3=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">线程只有2个</div></pre></td></tr></table></figure>\n<h3 id=\"多个异步线程问题\"><a href=\"#多个异步线程问题\" class=\"headerlink\" title=\"多个异步线程问题\"></a>多个异步线程问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 当ABC 3个异步线程，要求前两个个执行完再去执行后面的三个的时候例子：</div><div class=\"line\">     dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\"></div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_barrier_sync(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;main:%@&quot;,[NSThread mainThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue3 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\"></div><div class=\"line\">**2016-03-28 17:01:01.319 GCD_Demo[12463:353702] queue2 begin**</div><div class=\"line\">**2016-03-28 17:01:01.319 GCD_Demo[12463:353703] queue1 begin**</div><div class=\"line\">**2016-03-28 17:01:03.324 GCD_Demo[12463:353703] queue1 end**</div><div class=\"line\">**2016-03-28 17:01:03.324 GCD_Demo[12463:353702] queue2 end**</div><div class=\"line\">**2016-03-28 17:01:03.325 GCD_Demo[12463:353657] main:&lt;NSThread: 0x7f97ea604bf0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 17:01:03.325 GCD_Demo[12463:353702] queue3 begin**</div><div class=\"line\">**2016-03-28 17:01:05.330 GCD_Demo[12463:353702] queue3 end**</div></pre></td></tr></table></figure>\n<h3 id=\"线程分组\"><a href=\"#线程分组\" class=\"headerlink\" title=\"线程分组\"></a>线程分组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 当多个任务同时进行的时候，也可以用group，ABCD任务进行完成的时候，最后在执行task。</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">  dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;=================&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task3 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task4 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task4 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357162] task1 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357164] task4 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357161] task2 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357163] task3 begin**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357162] task1 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357163] task3 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357164] task4 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357161] task2 end**</div><div class=\"line\">**2016-03-28 17:08:47.006 GCD_Demo[12557:357161] =================**</div><div class=\"line\">一个组内的所有任务都进行完了才会执行task的函数。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 分组多任务等待 ABCDEF ，ABCD执行5秒，5秒之后就执行EF任务，不管ABCD是否成功。</div><div class=\"line\"></div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;=================&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task3 begin&quot;);</div><div class=\"line\">        sleep(6);</div><div class=\"line\">        NSLog(@&quot;task3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)));</div><div class=\"line\">    NSLog(@&quot;all end&quot;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task4 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task4 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\"># 代码执行到wait的时候会等待5秒之后再执行wait下边的代码，和sleep有点相似。</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366983] task3 begin**</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366978] task1 begin**</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366979] task2 begin**</div><div class=\"line\">**2016-03-28 17:26:33.340 GCD_Demo[12745:366978] task1 end**</div><div class=\"line\">**2016-03-28 17:26:33.340 GCD_Demo[12745:366979] task2 end**</div><div class=\"line\">**2016-03-28 17:26:36.336 GCD_Demo[12745:366894] all end**</div><div class=\"line\">**2016-03-28 17:26:36.336 GCD_Demo[12745:366979] task4 begin**</div><div class=\"line\">**2016-03-28 17:26:37.340 GCD_Demo[12745:366983] task3 end**</div><div class=\"line\">**2016-03-28 17:26:38.342 GCD_Demo[12745:366979] task4 end**</div><div class=\"line\">**2016-03-28 17:26:38.342 GCD_Demo[12745:366983] =================**</div></pre></td></tr></table></figure>\n<h3 id=\"同时处理多数据不管顺序\"><a href=\"#同时处理多数据不管顺序\" class=\"headerlink\" title=\"同时处理多数据不管顺序\"></a>同时处理多数据不管顺序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">          dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">          /*! dispatch_apply函数说明</div><div class=\"line\">           10      *</div><div class=\"line\">           11      *  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API</div><div class=\"line\">           12      *         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束</div><div class=\"line\">           13      *</div><div class=\"line\">           14      *  @param 10    指定重复次数  指定10次</div><div class=\"line\">           15      *  @param queue 追加对象的Dispatch Queue</div><div class=\"line\">           16      *  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block</div><div class=\"line\">           17      *</div><div class=\"line\">           18      */</div><div class=\"line\">          dispatch_apply(10, queue, ^(size_t index) &#123;</div><div class=\"line\">                  NSLog(@&quot;%d&quot;, index);</div><div class=\"line\">              </div><div class=\"line\">              &#125;);</div><div class=\"line\">          NSLog(@&quot;done&quot;);</div><div class=\"line\">输出：</div><div class=\"line\"># 这个和上边讲的分组类似，多事务处理，处理结束后再执行代码。</div><div class=\"line\"># 这个是同步的，代码按顺序执行，分组的是异步执行的block</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372458] 1**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372463] 5**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372429] 4**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372464] 6**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372465] 7**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372462] 2**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372457] 0**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372461] 3**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372458] 8**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] 9**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] done**</div></pre></td></tr></table></figure>\n<p>参考文章：<a href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/macro/DISPATCH_QUEUE_CONCURRENT\" target=\"_blank\" rel=\"external\">Grand Central Dispatch (GCD) Reference</a><br>GCD提供的接口蛮多的,适用场景还是要熟练掌握，才能运用自如。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>简述：<br>       说道线程，离不开并行和串行，所谓并行，就是100赛跑，每个赛道就是一个线程，每个线程之间互不影响，同时都可以运行事件，就是10个赛道都可以有运动员跑步了，谁跑的慢或者跑的快，都不影响其他的人。串行就不一样了，串行是1个赛道10个运动员再跑接力赛，第一个跑到终点第二个在接着跑，依次类推，前边的不走，后边的也走不了的，所以串行上面的事件是一个一个运行的，同时只能是一个人再跑。</p>\n<p>在iOS或者OS里面，一般用GCD就能吃处理较多的事务，下面就谈一下GCD的用法。</p>\n<h3 id=\"什么是GCD？\"><a href=\"#什么是GCD？\" class=\"headerlink\" title=\"什么是GCD？\"></a>什么是GCD？</h3><p>全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”<br>纯C语言，提供了非常多强大的函数</p>\n<h3 id=\"methodList-info\"><a href=\"#methodList-info\" class=\"headerlink\" title=\"methodList info\"></a>methodList info</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//获取主线程 就是更新UI的线程</div><div class=\"line\">dispatch_queue_t dispatch_get_main_queue(void);</div><div class=\"line\"></div><div class=\"line\"> //获取全局队列</div><div class=\"line\">dispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);</div><div class=\"line\"></div><div class=\"line\">//创建一个队列 名字是label 属性可以写为NULL  </div><div class=\"line\">dispatch_queue_t dispatch_queue_create( const char *label dispatch_queue_attr_t attr);</div><div class=\"line\">dispatch_release(queue)//释放队列</div><div class=\"line\"></div><div class=\"line\">//获取代码现在运行的queue</div><div class=\"line\">dispatch_queue_t dispatch_get_current_queue( void);</div><div class=\"line\"></div><div class=\"line\"> //获取队列的名字</div><div class=\"line\">const char * dispatch_queue_get_label(dispatch_queue_t queue);</div><div class=\"line\"></div><div class=\"line\">//异步把代码块block交给queue队列中处理</div><div class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">// 同步将block加入到queue中并且执行。</div><div class=\"line\">void dispatch_sync( dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"> //block 在指定时间在queue中执行</div><div class=\"line\">void dispatch_after( dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\">//几个调度事件同事加入到queue中去，最好是全局队列才行。</div><div class=\"line\">void dispatch_apply( size_t iterations, dispatch_queue_t queue, void (^block)( size_t));</div><div class=\"line\"></div><div class=\"line\">// block 是否执行过</div><div class=\"line\">void dispatch_once( dispatch_once_t *predicate, dispatch_block_t block);</div><div class=\"line\"> </div><div class=\"line\">//在分组group中的queue队列执行block</div><div class=\"line\">void dispatch_group_async( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">//创建线程分组</div><div class=\"line\">dispatch_group_t dispatch_group_create( void);</div><div class=\"line\"></div><div class=\"line\"> //分组的计数+1</div><div class=\"line\">void dispatch_group_enter( dispatch_group_t group);</div><div class=\"line\"></div><div class=\"line\">//分组计数 -1</div><div class=\"line\">void dispatch_group_leave( dispatch_group_t group);</div><div class=\"line\"></div><div class=\"line\">// 当分组中的事务处理完了执行block</div><div class=\"line\">void dispatch_group_notify( dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</div><div class=\"line\"></div><div class=\"line\">//等待timeout时间后执行 group中的事务</div><div class=\"line\">long dispatch_group_wait( dispatch_group_t group, dispatch_time_t timeout);</div><div class=\"line\"></div><div class=\"line\"> //并行状态下 queue前面的并行事务处理完成了在执行block，然后执行下边的并行代码</div><div class=\"line\">//比如 ABCDEF D事务等到ABC都完成了在执行EF事务的</div><div class=\"line\">void dispatch_barrier_async( dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>\n<h3 id=\"实战演练全局队列\"><a href=\"#实战演练全局队列\" class=\"headerlink\" title=\"实战演练全局队列\"></a>实战演练全局队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\"></div><div class=\"line\">dispatch_async(queue, ^&#123;</div><div class=\"line\">        //异步执行</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            //这里面更新UI</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_sync(queue, ^&#123;</div><div class=\"line\">       //同步执行</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"自定义队列\"><a href=\"#自定义队列\" class=\"headerlink\" title=\"自定义队列\"></a>自定义队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">    //</div><div class=\"line\">//#define DISPATCH_QUEUE_SERIAL   同步队列</div><div class=\"line\">//#define DISPATCH_QUEUE_CONCURRENT 异步队列</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片1=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片2=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;下载图片3=====%@&quot;,[NSThread currentThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    NSLog(@&quot;main:%@&quot;,[NSThread mainThread]);</div><div class=\"line\">当queue属性为 DISPATCH_QUEUE_CONCURRENT输出：</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347984] ****下载图片****3=====&lt;NSThread: 0x7fabda100250&gt;&#123;number = 4, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347982] ****下载图片****2=====&lt;NSThread: 0x7fabda2008a0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347937] main:&lt;NSThread: 0x7fabd8c04ee0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 16:53:25.848 GCD_Demo[12338:347981] ****下载图片****1=====&lt;NSThread: 0x7fabd8c0a010&gt;&#123;number = 2, name = (null)&#125;** 线程达到了4个</div><div class=\"line\">当queue属性为DISPATCH_QUEUE_SERIAL输出：</div><div class=\"line\">**2016-03-28 16:46:54.501 GCD_Demo[12272:344348] main:&lt;NSThread: 0x7fd379704cf0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.501 GCD_Demo[12272:344382] ****下载图片****1=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****2=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-28 16:46:54.502 GCD_Demo[12272:344382] ****下载图片****3=====&lt;NSThread: 0x7fd37971bda0&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">线程只有2个</div></pre></td></tr></table></figure>\n<h3 id=\"多个异步线程问题\"><a href=\"#多个异步线程问题\" class=\"headerlink\" title=\"多个异步线程问题\"></a>多个异步线程问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 当ABC 3个异步线程，要求前两个个执行完再去执行后面的三个的时候例子：</div><div class=\"line\">     dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\"></div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_barrier_sync(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;main:%@&quot;,[NSThread mainThread]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;queue3 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;queue3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\"></div><div class=\"line\">**2016-03-28 17:01:01.319 GCD_Demo[12463:353702] queue2 begin**</div><div class=\"line\">**2016-03-28 17:01:01.319 GCD_Demo[12463:353703] queue1 begin**</div><div class=\"line\">**2016-03-28 17:01:03.324 GCD_Demo[12463:353703] queue1 end**</div><div class=\"line\">**2016-03-28 17:01:03.324 GCD_Demo[12463:353702] queue2 end**</div><div class=\"line\">**2016-03-28 17:01:03.325 GCD_Demo[12463:353657] main:&lt;NSThread: 0x7f97ea604bf0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-28 17:01:03.325 GCD_Demo[12463:353702] queue3 begin**</div><div class=\"line\">**2016-03-28 17:01:05.330 GCD_Demo[12463:353702] queue3 end**</div></pre></td></tr></table></figure>\n<h3 id=\"线程分组\"><a href=\"#线程分组\" class=\"headerlink\" title=\"线程分组\"></a>线程分组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 当多个任务同时进行的时候，也可以用group，ABCD任务进行完成的时候，最后在执行task。</div><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">  dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;=================&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task3 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task4 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task4 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357162] task1 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357164] task4 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357161] task2 begin**</div><div class=\"line\">**2016-03-28 17:08:45.002 GCD_Demo[12557:357163] task3 begin**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357162] task1 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357163] task3 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357164] task4 end**</div><div class=\"line\">**2016-03-28 17:08:47.005 GCD_Demo[12557:357161] task2 end**</div><div class=\"line\">**2016-03-28 17:08:47.006 GCD_Demo[12557:357161] =================**</div><div class=\"line\">一个组内的所有任务都进行完了才会执行task的函数。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 分组多任务等待 ABCDEF ，ABCD执行5秒，5秒之后就执行EF任务，不管ABCD是否成功。</div><div class=\"line\"></div><div class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.apple.fgyong&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_group_t group = dispatch_group_create();</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task1 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task1 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task2 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task2 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">        NSLog(@&quot;=================&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task3 begin&quot;);</div><div class=\"line\">        sleep(6);</div><div class=\"line\">        NSLog(@&quot;task3 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)));</div><div class=\"line\">    NSLog(@&quot;all end&quot;);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;task4 begin&quot;);</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;task4 end&quot;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">输出：</div><div class=\"line\"># 代码执行到wait的时候会等待5秒之后再执行wait下边的代码，和sleep有点相似。</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366983] task3 begin**</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366978] task1 begin**</div><div class=\"line\">**2016-03-28 17:26:31.335 GCD_Demo[12745:366979] task2 begin**</div><div class=\"line\">**2016-03-28 17:26:33.340 GCD_Demo[12745:366978] task1 end**</div><div class=\"line\">**2016-03-28 17:26:33.340 GCD_Demo[12745:366979] task2 end**</div><div class=\"line\">**2016-03-28 17:26:36.336 GCD_Demo[12745:366894] all end**</div><div class=\"line\">**2016-03-28 17:26:36.336 GCD_Demo[12745:366979] task4 begin**</div><div class=\"line\">**2016-03-28 17:26:37.340 GCD_Demo[12745:366983] task3 end**</div><div class=\"line\">**2016-03-28 17:26:38.342 GCD_Demo[12745:366979] task4 end**</div><div class=\"line\">**2016-03-28 17:26:38.342 GCD_Demo[12745:366983] =================**</div></pre></td></tr></table></figure>\n<h3 id=\"同时处理多数据不管顺序\"><a href=\"#同时处理多数据不管顺序\" class=\"headerlink\" title=\"同时处理多数据不管顺序\"></a>同时处理多数据不管顺序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">          dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">          /*! dispatch_apply函数说明</div><div class=\"line\">           10      *</div><div class=\"line\">           11      *  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API</div><div class=\"line\">           12      *         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束</div><div class=\"line\">           13      *</div><div class=\"line\">           14      *  @param 10    指定重复次数  指定10次</div><div class=\"line\">           15      *  @param queue 追加对象的Dispatch Queue</div><div class=\"line\">           16      *  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block</div><div class=\"line\">           17      *</div><div class=\"line\">           18      */</div><div class=\"line\">          dispatch_apply(10, queue, ^(size_t index) &#123;</div><div class=\"line\">                  NSLog(@&quot;%d&quot;, index);</div><div class=\"line\">              </div><div class=\"line\">              &#125;);</div><div class=\"line\">          NSLog(@&quot;done&quot;);</div><div class=\"line\">输出：</div><div class=\"line\"># 这个和上边讲的分组类似，多事务处理，处理结束后再执行代码。</div><div class=\"line\"># 这个是同步的，代码按顺序执行，分组的是异步执行的block</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372458] 1**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372463] 5**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372429] 4**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372464] 6**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372465] 7**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372462] 2**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372457] 0**</div><div class=\"line\">**2016-03-28 17:36:35.698 GCD_Demo[12857:372461] 3**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372458] 8**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] 9**</div><div class=\"line\">**2016-03-28 17:36:35.699 GCD_Demo[12857:372429] done**</div></pre></td></tr></table></figure>\n<p>参考文章：<a href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/macro/DISPATCH_QUEUE_CONCURRENT\" target=\"_blank\" rel=\"external\">Grand Central Dispatch (GCD) Reference</a><br>GCD提供的接口蛮多的,适用场景还是要熟练掌握，才能运用自如。</p>\n"},{"title":"iOS底层原理 runtime-object_class拾遗基础篇--(6)","date":"2019-12-01T03:16:58.000Z","_content":"\n### runtime 基础知识\n`runtime`是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个`union`共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：\n\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\npublic:\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n    //****\n}\n\n\n#include \"isa.h\"\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n```\n\n`objc_object`是结构体，包含了私有属性`isa_t`,`isa_t isa`是一个共用体，包含了`ISA_BITFIELD`是一个宏(结构体)，`bits`是`uintptr_t`类型，`uintptr_t`其实是`unsign long`类型占用8字节，就是64位，我们进入到`ISA_BITFIELD`内部：\n\n```\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                         \n      uintptr_t nonpointer        : 1;                              \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                 \n      uintptr_t nonpointer        : 1;                                  \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n# else\n#   error unknown architecture for packed isa\n# endif\n```\n\n`ISA_BITFIELD`在`arm64`和`x86`是两种结构，存储了`nonpointer`,`has_assoc`,`has_cxx_dtor`,`shiftcls`,`magic`,`weakly_referenced`,`deallocating`,`has_sidetable_rc`,`extra_rc`这些信息，`:1`就占用了一位，`:44`就是占用了44位，`:6`就是占用了6位，`:8`就是占用了8位，那么共用体`isa_t`简化之后\n\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n    struct {\n      uintptr_t nonpointer        : 1;                                \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 8\n    };\n};\n```\n\n`isa_t`是使用共用体结构，使用`bits`存储了结构体的数据，那么共用体是如何使用的？我们来探究一下\n#### 共用体基础知识\n首先我们定义一个`FYPerson`，添加2个属性\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,assign) BOOL rich;\n@property (nonatomic,assign) BOOL tell;\n@property (nonatomic,assign) BOOL handsome;\n@end\n```\n\n然后查看该类的实例占用空间大小\n\n```\nFYPerson *p=[[FYPerson alloc]init];\n\t\tp.handsome = YES;\n\t\tp.rich = NO;\n\t\tNSLog(@\"大小：%zu\",class_getInstanceSize(FYPerson.class));\n\t\t//16\n```\n\n`FYPerson`定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。\n我们定义6个方法，3个set方法，3个get方法。\n\n```\n- (void)setTall:(BOOL)tall;\n- (void)setRich:(BOOL)rich;\n- (void)setHandsome:(BOOL)handsome;\n\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n\n//实现：\n//使用0b00000000不是很易读，我们换成下边的写法1<<0\n//#define FYHandsomeMask 0b00000001\n//#define FYTallMask 0b00000010\n//#define FYRichMask 0b00000001\n\n\n#define FYHandsomeMask (1<<0)\n#define FYTallMask (1<<1)\n#define FYRichMask (1<<2)\n\n@interface FYPerson()\n{\n\tchar _richTellHandsome;//0000 0000 rich tall handsome\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYRichMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYRichMask;\n\t}\n\t\n}\n- (void)setTall:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYTallMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYTallMask;\n\t}\n\t\n}\n- (void)setHandsome:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYHandsomeMask;\n\n\t}\n}\n- (BOOL)isRich{\n\treturn !!(_richTellHandsome&FYRichMask);\n}\n- (BOOL)isTall{\n\treturn !!(_richTellHandsome&FYTallMask);\n}\n- (BOOL)isHandsome{\n\treturn !!(_richTellHandsome&FYHandsomeMask);\n}\n@end\n```\n\n我们定义了一个char类型的变量`_richTellHandsome`,4字节，32位，可以存储32个bool类型的变量。赋值是使用`_richTellHandsome = _richTellHandsome|FYRichMask`,或`_richTellHandsome = _richTellHandsome&~FYRichMask`,取值是`!!(_richTellHandsome&FYRichMask)`，前边加`!!`是转化成`bool`类型的，否则取值出来是`1 or  2 or 4 `。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。\n\n```\n@interface FYPerson()\n{\n//\tchar _richTellHandsome;//0000 0000 rich tall handsome\n\t//位域\n\tstruct{\n\t\tchar tall : 1;//高度\n\t\tchar rich : 1;//富有\n\t\tchar handsome : 1; //帅\n\t} _richTellHandsome; // 0b0000 0000\n\t//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1\n\t//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\t_richTellHandsome.rich = tall;\n}\n- (void)setTall:(BOOL)tall{\n\t_richTellHandsome.tall = tall;\n}\n- (void)setHandsome:(BOOL)tall{\n\t_richTellHandsome.handsome = tall;\n}\n- (BOOL)isRich{\n\treturn !!_richTellHandsome.rich;\n}\n- (BOOL)isTall{\n\treturn !!_richTellHandsome.tall;\n}\n- (BOOL)isHandsome{\n\treturn !!_richTellHandsome.handsome;\n}\n@end\n\t\n```\n\n\n结构体`_richTellHandsome`包含三个变量`char tall : 1;`,`char rich : 1;`,`char handsome : 1`。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用`!!(_richTellHandsome&FYHandsomeMask)`，赋值使用\n\n```\nif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYHandsomeMask\n\t}\n```\n\n我们采用位域来存储信息，\n位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。\n\n另外一个省空间的思路是使用`联合`,\n使用`union`，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。\n\n```\n@interface FYPerson()\n{\n\tunion {\n\t\tchar bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间\n\t\tstruct{\n\t\t\tchar tall : 1;//高度\n\t\t\tchar rich : 1;//富有\n\t\t\tchar handsome : 1; //帅\n\t\t}; // 0b0000 0000\n\t}_richTellHandsome;\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYRichMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYRichMask;\n\t}\n}\n- (void)setTall:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYTallMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYTallMask;\n\t}\n}\n- (void)setHandsome:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYHandsomeMask;\n\t}\n}\n- (BOOL)isRich{\n\treturn !!(_richTellHandsome.bits & FYRichMask);\n}\n- (BOOL)isTall{\n\treturn !!(_richTellHandsome.bits & FYTallMask);\n}\n- (BOOL)isHandsome{\n\treturn (_richTellHandsome.bits & FYHandsomeMask);\n}\n```\n\n使用`联合`共用体，达到省空间的目的，`runtime`源码中是用来很多`union`和位运算。\n例如KVO 的NSKeyValueObservingOptions\n```\ntypedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions){\n        NSKeyValueObservingOptionNew = 0x01,\n    NSKeyValueObservingOptionOld = 0x02,\n    NSKeyValueObservingOptionInitial = 0x04,\n    NSKeyValueObservingOptionPrior = 0x08\n}\n```\n这个`NSKeyValueObservingOptions`使用位域，当传进去的时候`NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld`,则传进去的值为`0x3`,转化成二进制就是`0b11`，则两位都是`1`可以包含2个值。\n那么我们来设计一个简单的可以使用或来传值的枚举\n\n```\ntypedef enum {\n\tFYOne = 1,//  0b 0001\n\tFYTwo = 2,//  0b 0010\n\tFYTHree = 4,//0b 0100\n\tFYFour = 8,// 0b 1000\n}FYOptions;\n\n- (void)setOptions:(FYOptions )ops{\n\tif (ops &FYOne) {\n\t\tNSLog(@\"FYOne is show\");\n\t}\n\tif (ops &FYTwo) {\n\t\tNSLog(@\"FYTwo is show\");\n\t}\n\tif (ops &FYTHree) {\n\t\tNSLog(@\"FYTHree is show\");\n\t}\n\tif (ops &FYFour) {\n\t\tNSLog(@\"FYFour is show\");\n\t}\n}\n\n[self setOptions:FYOne|FYTwo|FYTHree];\n\n//输出是：\nFYOne is show\nFYTwo is show\nFYTHree is show\n\n```\n这是一个名字为`FYOptions`的枚举，第一个是十进制是1，二进制是`0b 0001`,第二个十进制是2，二进制是`0b 0010`,第三个十进制是4，二进制是`0b 0100`,第四个十进制是8，二进制是`0b 1000`。\n那么我们使用的时候可以`FYOne|FYTwo|FYTHree`，打包成一个值，相当于`1|2|4 = 7`,二进制表示是`0b0111`，后三位都是1，可以通过&mask取出对应的每一位的数值。\n\n#### Class的结构\n\nisa详解 – 位域存储的数据及其含义\n\n|参数|含义|\n|---|---|\n|nonpointer|0->代表普通的指针，存储着Class、Meta-Class对象的内存地址。1->代表优化过，使用位域存储更多的信息|\n|has_assoc|是否有设置过关联对象，如果没有，释放时会更快|\n|has_cxx_dtor|是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快|\n|shiftcls|存储着Class、Meta-Class对象的内存地址信息|\n|magic|用于在调试时分辨对象是否未完成初始化|\n|weakly_referenced|是否有被弱引用指向过，如果没有，释放时会更快|\n|deallocating|对象是否正在释放|\n|extra_rc|里面存储的值是引用计数器减1|\n|has_sidetable_rc|引用计数器是否过大无法存储在isa中\n如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|\n\nclass结构\n\n```\nstruct fy_objc_class : xx_objc_object {\n\tClass superclass;\n\tcache_t cache;\n\tclass_data_bits_t bits;\npublic:\n\tclass_rw_t* data() {\n\t\treturn bits.data();\n\t}\n\t\n\tfy_objc_class* metaClass() { // 提供metaClass函数，获取元类对象\n\t\t// 上一篇我们讲解过，isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址\n\t\treturn (fy_objc_class *)((long long)isa & ISA_MASK);\n\t}\n};\nstruct class_rw_t {\n\tuint32_t flags;\n\tuint32_t version;\n\tconst class_ro_t *ro;//只读 数据\n\tmethod_list_t * methods;    // 方法列表\n\tproperty_list_t *properties;    // 属性列表\n\tconst protocol_list_t * protocols;  // 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchar *demangledName;\n};\n\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tuint32_t instanceStart;\n\tuint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n\tuint32_t reserved;\n#endif\n\tconst uint8_t * ivarLayout;\n\tconst char * name;  // 类名\n\tmethod_list_t * baseMethodList;\n\tprotocol_list_t * baseProtocols;\n\tconst ivar_list_t * ivars;  // 成员变量列表\n\tconst uint8_t * weakIvarLayout;\n\tproperty_list_t *baseProperties;\n};\n```\n\n`class_ro_t`是只读的，`class_rw_t`是读写的，在源码中`runtime`->`Source`->`objc-runtime-new.mm`->`static Class realizeClass(Class cls) 1869行`\n\n```\n\n    const class_ro_t *ro;\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n    bool isMeta;\n\n    if (!cls) return nil;\n    //如果已注册 就返回\n    if (cls->isRealized()) return cls;\n    assert(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n//只读ro\n    ro = (const class_ro_t *)cls->data();\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();//初始化ro\n        ro = cls->data()->ro;\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        //初始化 rw \n        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\n        rw->ro = ro;\n        rw->flags = RW_REALIZED|RW_REALIZING;\n        //指针指向rw 一开始是指向ro的\n        cls->setData(rw);\n    }\n\n    isMeta = ro->flags & RO_META;\n\n    rw->version = isMeta ? 7 : 0;  // old runtime went up to 6\n````\n\n开始`cls->data`指向的是`ro`，初始化之后，指向的`rw`,`rw->ro`指向的是原来的`ro`。\n`class_rw_t`中的`method_array_t`是存储的方法列表，我们进入到`method_array_t`看下它的数据结构：\n\n```\nclass method_array_t : \n    public list_array_tt<method_t, method_list_t> \n{\n    typedef list_array_tt<method_t, method_list_t> Super;\n\n public:\n    method_list_t **beginCategoryMethodLists() {\n        return beginLists();\n    }\n    \n    method_list_t **endCategoryMethodLists(Class cls);\n\n    method_array_t duplicate() {\n        return Super::duplicate<method_array_t>();\n    }\n};\n```\n\n`method_array_t`是一个类，存储了`method_t`二维数组，那么我们看下`method_t`的结构\n\n```\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function<const method_t&,const method_t&, bool>\n    {\n        bool operator() (const method_t& lhs,\n                         const method_t& rhs)\n        { return lhs.name < rhs.name; }\n    };\n};\n```\n\n`method_t`是存储了3个变量的结构体，`SEL`是方法名，`types`是编码(方法返回类型，参数类型)， `imp`函数指针(函数地址)。\n##### SEL\n- SEL代表方法\\函数名，一般叫做选择器，底层结构跟char *类似\n- 可以通过@selector()和sel_registerName()获得\n- 可以通过sel_getName()和NSStringFromSelector()转成字符串\n- 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n##### Type Encoding\n\niOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，[官方网站插件encodeing](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n\n|code|Meaning|\n|---|---|\n|c|A char|\n|i  | An int|\n|s|A short|\n|l|A long|\n|l| is treated as a 32-bit quantity on 64-bit programs.|\n|q|A long long|\n|C|An unsigned char|\n|I|An unsigned int|\n|S|An unsigned short|\n|L|An unsigned long|\n|Q|An unsigned long long|\n|f|A float|\n|d|A double|\n|B|A C++ bool or a C99 _Bool|\n|v|A void|\n|*|A character string (char *)|\n|@|An object (whether statically typed or typed id)|\n|#|A class object (Class)|\n|:|A method selector (SEL)|\n|[array type]|An array|\n|{name=type...}|A structure|\n|(name=type...)|A union|\n|bnum|A bit field of num bits|\n|^type|A pointer to type|\n|?|An unknown type (among other things, this code is used for function pointers)|\n\n\n我们通过一个例子来了解encode\n\n```\n-(void)test:(int)age heiht:(float)height{\n}\n\n\nFYPerson *p=[[FYPerson alloc]init];\n\tSEL sel = @selector(test:heiht:);\n\tMethod m1= class_getInstanceMethod(p.class, sel);\n\tconst char *type = method_getTypeEncoding(m1);\n\tNSLog(@\"%s\",type);\n\t\n\t//输出\n\tv24@0:8i16f20\n\t//0id 8 SEL 16 int 20 float = 24\n```\n\n`v24@0:8i16f20`是encoding的值，我们来分解一下，前边是`v24`是函数返回值是`void`，所有参数占用了`24`字节,`@0:8`是从第0开始，长度是8字节的位置，`i16`是从16字节开始的`int`类型，`f20`是从20字节开始，类型是`float`。\n\n#### 方法缓存\nClass内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。\n我们来到`cache_t`内部\n\n```\nstruct cache_t {\n    struct bucket_t *_buckets;//散列表\n    mask_t _mask;//散列表长度-1\n    mask_t _occupied;//已经存储的方法数量\n}\n\nstruct bucket_t {\n#if __arm64__\n    MethodCacheIMP _imp;\n    cache_key_t _key;\n#else\n    cache_key_t _key;//SEL作为key \n    MethodCacheIMP _imp; //函数地址\n#endif\n}\n```\n\n散列表的数据结构表格所示\n\n|索引|bucket_t|\n|---|---|\n|0|bucket_t(_key,_imp)|\n|1|bucket_t(_key,_imp)|\n|2|bucket_t(_key,_imp)|\n|3|bucket_t(_key,_imp)|\n|4|bucket_t(_key,_imp)|\n|...|...|\n通过`cache_getImp(cls, sel)`获取`IMP`。具体在`cache_t::find`函数中\n\n```\nbucket_t * cache_t::find(cache_key_t k, id receiver)\n{\n    assert(k != 0);\n\n    bucket_t *b = buckets();\n    mask_t m = mask();\n\t//key&mask 得到索引\n    mask_t begin = cache_hash(k, m);\n    mask_t i = begin;\n    do {\n        if (b[i].key() == 0  ||  b[i].key() == k) {\n            return &b[i];\n        }\n    } while ((i = cache_next(i, m)) != begin);\n\n    // hack\n    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));\n    cache_t::bad_cache(receiver, (SEL)k, cls);\n}\n\n// Class points to cache. SEL is key. Cache buckets store SEL+IMP.\n// Caches are never built in the dyld shared cache.\n\nstatic inline mask_t cache_hash(cache_key_t key, mask_t mask) \n{\n    return (mask_t)(key & mask);\n}\n```\n\n首先获取`buckets()`获取`butket_t`,然后获取`_mask`，通过\n`cache_hash(k, m)`获取第一次访问的索引`i`，`cache_hash`通过`(mask_t)(key & mask)`得出具体的`索引`,当第一次成功获取到`butket_t`则直接返回,否则执行`cache_next(i, m)`获取下一个索引，直到获取到或者循环一遍结束。\n那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了`class_rw_t`\n\n```\n#import <Foundation/Foundation.h>\n\n#ifndef MJClassInfo_h\n#define MJClassInfo_h\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\n#if __arm__  ||  __x86_64__  ||  __i386__\n// objc_msgSend has few registers available.\n// Cache scan increments and wraps at special end-marking bucket.\n#define CACHE_END_MARKER 1\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return (i+1) & mask;\n}\n\n#elif __arm64__\n// objc_msgSend has lots of registers available.\n// Cache scan decrements. No end marker needed.\n#define CACHE_END_MARKER 0\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return i ? i-1 : mask;\n}\n\n#else\n#error unknown architecture\n#endif\n\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n    \n    IMP imp(SEL selector)\n    {\n        mask_t begin = _mask & (long long)selector;\n        mask_t i = begin;\n        do {\n            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) {\n                return _buckets[i]._imp;\n            }\n        } while ((i = cache_next(i, _mask)) != begin);\n        return NULL;\n    }\n};\n\nstruct entsize_list_tt {\n    uint32_t entsizeAndFlags;\n    uint32_t count;\n};\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n    method_t first;\n};\n\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n    uint32_t alignment_raw;\n    uint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n    ivar_t first;\n};\n\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n    property_t first;\n};\n\nstruct chained_property_list {\n    chained_property_list *next;\n    uint32_t count;\n    property_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n    uintptr_t count;\n    protocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout;\n    const char * name;  // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;  // 成员变量列表\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const class_ro_t *ro;\n    method_list_t * methods;    // 方法列表\n    property_list_t *properties;    // 属性列表\n    const protocol_list_t * protocols;  // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n    uintptr_t bits;\npublic:\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n};\n\n/* OC对象 */\nstruct mj_objc_object {\n    void *isa;\n};\n\n/* 类对象 */\nstruct mj_objc_class : mj_objc_object {\n    Class superclass;\n    cache_t cache;\n    class_data_bits_t bits;\npublic:\n    class_rw_t* data() {\n        return bits.data();\n    }\n    \n    mj_objc_class* metaClass() {\n        return (mj_objc_class *)((long long)isa & ISA_MASK);\n    }\n};\n\n#endif\n```\n\n测试代码是\n\n```\nFYPerson *p = [[FYPerson alloc]init];\n\t\tMethod test1Method = class_getInstanceMethod(p.class, @selector(test));\n\t\tMethod test2Method = class_getInstanceMethod(p.class, @selector(test2));\n\t\tIMP imp1= method_getImplementation(test1Method);\n\t\tIMP imp2= method_getImplementation(test2Method);\n\n\t\tmj_objc_class *cls = (__bridge mj_objc_class *)p.class;\n\t\tNSLog(@\"-----\");\n\t\t[p test];\n\t\t[p test2];\n\t\tcache_t cache = cls->cache;\n\t\tbucket_t *buck = cache._buckets;\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= cache._mask; i ++) {\n\t\t\tbucket_t item = buck[i];\n\t\t\tif (item._key != 0) {\n\t\t\t\tNSLog(@\"key:%lu imp:%p\",item._key,item._imp);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//输出\np imp1\n(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)\n(lldb) p imp2\n(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)\np/d @selector(test)             //输出 test方法的sel地址\n(SEL) $6 = 140734025103231 \"test\"\n(lldb) p/d @selector(test2)     //输出 test2方法的sel地址\n(SEL) $7 = 4294971267 \"test2\"\n\nkey1:140733954181041 imp1:0x7fff59fc4cd1\nkey2:4294971267 imp2:0x100000e20         //对应test2\nkey3:140734025103231 imp3:0x100000df0    //对应test1\n```\n\n可以看出来`IMP1`和`IMP2`、`key1` 和`key2`分别对应了`bucket_t`中的`key2`,`key3`和`imp2`和`imp3`。\n\n\n```\nstatic void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)\n{\n    cacheUpdateLock.assertLocked();\n\n    //当initialized 没有执行完毕的时候不缓存\n    if (!cls->isInitialized()) return;\n\n    // Make sure the entry wasn't added to the cache by some other thread \n    // before we grabbed the cacheUpdateLock.\n    if (cache_getImp(cls, sel)) return;\n\n    cache_t *cache = getCache(cls);\n    cache_key_t key = getKey(sel);\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = cache->occupied() + 1;\n    mask_t capacity = cache->capacity();\n    if (cache->isConstantEmptyCache()) {\n        // Cache is read-only. Replace it.\n        cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE);\n    }\n    else if (newOccupied <= capacity / 4 * 3) {\n        // Cache <= 3/4 \n    }\n    else {\n        扩容 之后，缓存清空\n        cache->expand();\n    }\n//bucket_t 最小是4，当>3/4时候，扩容，空间扩容之后是之前的2️倍。\n    bucket_t *bucket = cache->find(key, receiver);\n    if (bucket->key() == 0) cache->incrementOccupied();\n    bucket->set(key, imp);\n}\n```\n\n`cache_t`初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，`cacha->_occupied`恢复为0。\n验证代码如下：\n\n```\nFYPerson *p = [[FYPerson alloc]init];\nmj_objc_class *cls = (__bridge mj_objc_class *)p.class;\nNSLog(@\"-----\");\n[p test];\n/*\n key:init imp:0x7fff58807c2d\n key:class imp:0x7fff588084b7\n key:(null) imp:0x0\n key:test imp:0x100000bf0\n Program ended with exit code: 0\n */\n[p test2]; //当执行该函数的时候\n/*\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:test2 imp:0x100000c20\n key:(null) imp:0x0\n */\n\ncache_t cache = cls->cache;\nbucket_t *buck = cache._buckets;\n\n\nfor (int i = 0; i <= cache._mask; i ++) {\n\tbucket_t item = buck[i];\n//            if (item._key != 0) {\n////                printf(\"key:%s imp:%p \\n\",(const char *)item._key,item._imp);\n//            }\n    printf(\"key:%s imp:%p \\n\",(const char *)item._key,item._imp);\n\n}\n```\n\n### 总结\n- arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。\n- 函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中\n- 从`class->cache`查找`bucket_t`的key需要先`&_mask`之后再判断是否有该`key`\n- cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，`imp`个数清空\n- `class->rw`在初始化中讲`class_ro_t`值赋值给`rw`,然后`rw->ro`指向之前的`ro`。\n\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)\n\n\n\n","source":"_posts/iOS底层原理 runtime-object_class拾遗基础篇--(6).md","raw":"title: iOS底层原理 runtime-object_class拾遗基础篇--(6)\ndate: 2019-12-1 11:16:58\ntags:\n- iOS\ncategories: iOS\n---\n\n### runtime 基础知识\n`runtime`是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个`union`共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：\n\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\npublic:\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n    //****\n}\n\n\n#include \"isa.h\"\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n```\n\n`objc_object`是结构体，包含了私有属性`isa_t`,`isa_t isa`是一个共用体，包含了`ISA_BITFIELD`是一个宏(结构体)，`bits`是`uintptr_t`类型，`uintptr_t`其实是`unsign long`类型占用8字节，就是64位，我们进入到`ISA_BITFIELD`内部：\n\n```\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                         \n      uintptr_t nonpointer        : 1;                              \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 19\n#   define RC_ONE   (1ULL<<45)\n#   define RC_HALF  (1ULL<<18)\n\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n#   define ISA_MAGIC_MASK  0x001f800000000001ULL\n#   define ISA_MAGIC_VALUE 0x001d800000000001ULL\n#   define ISA_BITFIELD                                                 \n      uintptr_t nonpointer        : 1;                                  \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 8\n#   define RC_ONE   (1ULL<<56)\n#   define RC_HALF  (1ULL<<7)\n# else\n#   error unknown architecture for packed isa\n# endif\n```\n\n`ISA_BITFIELD`在`arm64`和`x86`是两种结构，存储了`nonpointer`,`has_assoc`,`has_cxx_dtor`,`shiftcls`,`magic`,`weakly_referenced`,`deallocating`,`has_sidetable_rc`,`extra_rc`这些信息，`:1`就占用了一位，`:44`就是占用了44位，`:6`就是占用了6位，`:8`就是占用了8位，那么共用体`isa_t`简化之后\n\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n    struct {\n      uintptr_t nonpointer        : 1;                                \n      uintptr_t has_assoc         : 1;                                  \n      uintptr_t has_cxx_dtor      : 1;                                  \n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\n      uintptr_t magic             : 6;                                  \n      uintptr_t weakly_referenced : 1;                                  \n      uintptr_t deallocating      : 1;                                  \n      uintptr_t has_sidetable_rc  : 1;                                  \n      uintptr_t extra_rc          : 8\n    };\n};\n```\n\n`isa_t`是使用共用体结构，使用`bits`存储了结构体的数据，那么共用体是如何使用的？我们来探究一下\n#### 共用体基础知识\n首先我们定义一个`FYPerson`，添加2个属性\n\n```\n@interface FYPerson : NSObject\n@property (nonatomic,assign) BOOL rich;\n@property (nonatomic,assign) BOOL tell;\n@property (nonatomic,assign) BOOL handsome;\n@end\n```\n\n然后查看该类的实例占用空间大小\n\n```\nFYPerson *p=[[FYPerson alloc]init];\n\t\tp.handsome = YES;\n\t\tp.rich = NO;\n\t\tNSLog(@\"大小：%zu\",class_getInstanceSize(FYPerson.class));\n\t\t//16\n```\n\n`FYPerson`定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。\n我们定义6个方法，3个set方法，3个get方法。\n\n```\n- (void)setTall:(BOOL)tall;\n- (void)setRich:(BOOL)rich;\n- (void)setHandsome:(BOOL)handsome;\n\n- (BOOL)isTall;\n- (BOOL)isRich;\n- (BOOL)isHandsome;\n\n//实现：\n//使用0b00000000不是很易读，我们换成下边的写法1<<0\n//#define FYHandsomeMask 0b00000001\n//#define FYTallMask 0b00000010\n//#define FYRichMask 0b00000001\n\n\n#define FYHandsomeMask (1<<0)\n#define FYTallMask (1<<1)\n#define FYRichMask (1<<2)\n\n@interface FYPerson()\n{\n\tchar _richTellHandsome;//0000 0000 rich tall handsome\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYRichMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYRichMask;\n\t}\n\t\n}\n- (void)setTall:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYTallMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYTallMask;\n\t}\n\t\n}\n- (void)setHandsome:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYHandsomeMask;\n\n\t}\n}\n- (BOOL)isRich{\n\treturn !!(_richTellHandsome&FYRichMask);\n}\n- (BOOL)isTall{\n\treturn !!(_richTellHandsome&FYTallMask);\n}\n- (BOOL)isHandsome{\n\treturn !!(_richTellHandsome&FYHandsomeMask);\n}\n@end\n```\n\n我们定义了一个char类型的变量`_richTellHandsome`,4字节，32位，可以存储32个bool类型的变量。赋值是使用`_richTellHandsome = _richTellHandsome|FYRichMask`,或`_richTellHandsome = _richTellHandsome&~FYRichMask`,取值是`!!(_richTellHandsome&FYRichMask)`，前边加`!!`是转化成`bool`类型的，否则取值出来是`1 or  2 or 4 `。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。\n\n```\n@interface FYPerson()\n{\n//\tchar _richTellHandsome;//0000 0000 rich tall handsome\n\t//位域\n\tstruct{\n\t\tchar tall : 1;//高度\n\t\tchar rich : 1;//富有\n\t\tchar handsome : 1; //帅\n\t} _richTellHandsome; // 0b0000 0000\n\t//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1\n\t//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\t_richTellHandsome.rich = tall;\n}\n- (void)setTall:(BOOL)tall{\n\t_richTellHandsome.tall = tall;\n}\n- (void)setHandsome:(BOOL)tall{\n\t_richTellHandsome.handsome = tall;\n}\n- (BOOL)isRich{\n\treturn !!_richTellHandsome.rich;\n}\n- (BOOL)isTall{\n\treturn !!_richTellHandsome.tall;\n}\n- (BOOL)isHandsome{\n\treturn !!_richTellHandsome.handsome;\n}\n@end\n\t\n```\n\n\n结构体`_richTellHandsome`包含三个变量`char tall : 1;`,`char rich : 1;`,`char handsome : 1`。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用`!!(_richTellHandsome&FYHandsomeMask)`，赋值使用\n\n```\nif (tall) {\n\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome = _richTellHandsome&~FYHandsomeMask\n\t}\n```\n\n我们采用位域来存储信息，\n位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。\n\n另外一个省空间的思路是使用`联合`,\n使用`union`，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。\n\n```\n@interface FYPerson()\n{\n\tunion {\n\t\tchar bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间\n\t\tstruct{\n\t\t\tchar tall : 1;//高度\n\t\t\tchar rich : 1;//富有\n\t\t\tchar handsome : 1; //帅\n\t\t}; // 0b0000 0000\n\t}_richTellHandsome;\n}\n@end\n\n\n@implementation FYPerson\n\n- (void)setRich:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYRichMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYRichMask;\n\t}\n}\n- (void)setTall:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYTallMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYTallMask;\n\t}\n}\n- (void)setHandsome:(BOOL)tall{\n\tif (tall) {\n\t\t_richTellHandsome.bits |= FYHandsomeMask;\n\t}else{\n\t\t_richTellHandsome.bits &= ~FYHandsomeMask;\n\t}\n}\n- (BOOL)isRich{\n\treturn !!(_richTellHandsome.bits & FYRichMask);\n}\n- (BOOL)isTall{\n\treturn !!(_richTellHandsome.bits & FYTallMask);\n}\n- (BOOL)isHandsome{\n\treturn (_richTellHandsome.bits & FYHandsomeMask);\n}\n```\n\n使用`联合`共用体，达到省空间的目的，`runtime`源码中是用来很多`union`和位运算。\n例如KVO 的NSKeyValueObservingOptions\n```\ntypedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions){\n        NSKeyValueObservingOptionNew = 0x01,\n    NSKeyValueObservingOptionOld = 0x02,\n    NSKeyValueObservingOptionInitial = 0x04,\n    NSKeyValueObservingOptionPrior = 0x08\n}\n```\n这个`NSKeyValueObservingOptions`使用位域，当传进去的时候`NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld`,则传进去的值为`0x3`,转化成二进制就是`0b11`，则两位都是`1`可以包含2个值。\n那么我们来设计一个简单的可以使用或来传值的枚举\n\n```\ntypedef enum {\n\tFYOne = 1,//  0b 0001\n\tFYTwo = 2,//  0b 0010\n\tFYTHree = 4,//0b 0100\n\tFYFour = 8,// 0b 1000\n}FYOptions;\n\n- (void)setOptions:(FYOptions )ops{\n\tif (ops &FYOne) {\n\t\tNSLog(@\"FYOne is show\");\n\t}\n\tif (ops &FYTwo) {\n\t\tNSLog(@\"FYTwo is show\");\n\t}\n\tif (ops &FYTHree) {\n\t\tNSLog(@\"FYTHree is show\");\n\t}\n\tif (ops &FYFour) {\n\t\tNSLog(@\"FYFour is show\");\n\t}\n}\n\n[self setOptions:FYOne|FYTwo|FYTHree];\n\n//输出是：\nFYOne is show\nFYTwo is show\nFYTHree is show\n\n```\n这是一个名字为`FYOptions`的枚举，第一个是十进制是1，二进制是`0b 0001`,第二个十进制是2，二进制是`0b 0010`,第三个十进制是4，二进制是`0b 0100`,第四个十进制是8，二进制是`0b 1000`。\n那么我们使用的时候可以`FYOne|FYTwo|FYTHree`，打包成一个值，相当于`1|2|4 = 7`,二进制表示是`0b0111`，后三位都是1，可以通过&mask取出对应的每一位的数值。\n\n#### Class的结构\n\nisa详解 – 位域存储的数据及其含义\n\n|参数|含义|\n|---|---|\n|nonpointer|0->代表普通的指针，存储着Class、Meta-Class对象的内存地址。1->代表优化过，使用位域存储更多的信息|\n|has_assoc|是否有设置过关联对象，如果没有，释放时会更快|\n|has_cxx_dtor|是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快|\n|shiftcls|存储着Class、Meta-Class对象的内存地址信息|\n|magic|用于在调试时分辨对象是否未完成初始化|\n|weakly_referenced|是否有被弱引用指向过，如果没有，释放时会更快|\n|deallocating|对象是否正在释放|\n|extra_rc|里面存储的值是引用计数器减1|\n|has_sidetable_rc|引用计数器是否过大无法存储在isa中\n如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|\n\nclass结构\n\n```\nstruct fy_objc_class : xx_objc_object {\n\tClass superclass;\n\tcache_t cache;\n\tclass_data_bits_t bits;\npublic:\n\tclass_rw_t* data() {\n\t\treturn bits.data();\n\t}\n\t\n\tfy_objc_class* metaClass() { // 提供metaClass函数，获取元类对象\n\t\t// 上一篇我们讲解过，isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址\n\t\treturn (fy_objc_class *)((long long)isa & ISA_MASK);\n\t}\n};\nstruct class_rw_t {\n\tuint32_t flags;\n\tuint32_t version;\n\tconst class_ro_t *ro;//只读 数据\n\tmethod_list_t * methods;    // 方法列表\n\tproperty_list_t *properties;    // 属性列表\n\tconst protocol_list_t * protocols;  // 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchar *demangledName;\n};\n\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tuint32_t instanceStart;\n\tuint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n\tuint32_t reserved;\n#endif\n\tconst uint8_t * ivarLayout;\n\tconst char * name;  // 类名\n\tmethod_list_t * baseMethodList;\n\tprotocol_list_t * baseProtocols;\n\tconst ivar_list_t * ivars;  // 成员变量列表\n\tconst uint8_t * weakIvarLayout;\n\tproperty_list_t *baseProperties;\n};\n```\n\n`class_ro_t`是只读的，`class_rw_t`是读写的，在源码中`runtime`->`Source`->`objc-runtime-new.mm`->`static Class realizeClass(Class cls) 1869行`\n\n```\n\n    const class_ro_t *ro;\n    class_rw_t *rw;\n    Class supercls;\n    Class metacls;\n    bool isMeta;\n\n    if (!cls) return nil;\n    //如果已注册 就返回\n    if (cls->isRealized()) return cls;\n    assert(cls == remapClass(cls));\n\n    // fixme verify class is not in an un-dlopened part of the shared cache?\n//只读ro\n    ro = (const class_ro_t *)cls->data();\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();//初始化ro\n        ro = cls->data()->ro;\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        //初始化 rw \n        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\n        rw->ro = ro;\n        rw->flags = RW_REALIZED|RW_REALIZING;\n        //指针指向rw 一开始是指向ro的\n        cls->setData(rw);\n    }\n\n    isMeta = ro->flags & RO_META;\n\n    rw->version = isMeta ? 7 : 0;  // old runtime went up to 6\n````\n\n开始`cls->data`指向的是`ro`，初始化之后，指向的`rw`,`rw->ro`指向的是原来的`ro`。\n`class_rw_t`中的`method_array_t`是存储的方法列表，我们进入到`method_array_t`看下它的数据结构：\n\n```\nclass method_array_t : \n    public list_array_tt<method_t, method_list_t> \n{\n    typedef list_array_tt<method_t, method_list_t> Super;\n\n public:\n    method_list_t **beginCategoryMethodLists() {\n        return beginLists();\n    }\n    \n    method_list_t **endCategoryMethodLists(Class cls);\n\n    method_array_t duplicate() {\n        return Super::duplicate<method_array_t>();\n    }\n};\n```\n\n`method_array_t`是一个类，存储了`method_t`二维数组，那么我们看下`method_t`的结构\n\n```\nstruct method_t {\n    SEL name;\n    const char *types;\n    MethodListIMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function<const method_t&,const method_t&, bool>\n    {\n        bool operator() (const method_t& lhs,\n                         const method_t& rhs)\n        { return lhs.name < rhs.name; }\n    };\n};\n```\n\n`method_t`是存储了3个变量的结构体，`SEL`是方法名，`types`是编码(方法返回类型，参数类型)， `imp`函数指针(函数地址)。\n##### SEL\n- SEL代表方法\\函数名，一般叫做选择器，底层结构跟char *类似\n- 可以通过@selector()和sel_registerName()获得\n- 可以通过sel_getName()和NSStringFromSelector()转成字符串\n- 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n##### Type Encoding\n\niOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，[官方网站插件encodeing](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)\n\n|code|Meaning|\n|---|---|\n|c|A char|\n|i  | An int|\n|s|A short|\n|l|A long|\n|l| is treated as a 32-bit quantity on 64-bit programs.|\n|q|A long long|\n|C|An unsigned char|\n|I|An unsigned int|\n|S|An unsigned short|\n|L|An unsigned long|\n|Q|An unsigned long long|\n|f|A float|\n|d|A double|\n|B|A C++ bool or a C99 _Bool|\n|v|A void|\n|*|A character string (char *)|\n|@|An object (whether statically typed or typed id)|\n|#|A class object (Class)|\n|:|A method selector (SEL)|\n|[array type]|An array|\n|{name=type...}|A structure|\n|(name=type...)|A union|\n|bnum|A bit field of num bits|\n|^type|A pointer to type|\n|?|An unknown type (among other things, this code is used for function pointers)|\n\n\n我们通过一个例子来了解encode\n\n```\n-(void)test:(int)age heiht:(float)height{\n}\n\n\nFYPerson *p=[[FYPerson alloc]init];\n\tSEL sel = @selector(test:heiht:);\n\tMethod m1= class_getInstanceMethod(p.class, sel);\n\tconst char *type = method_getTypeEncoding(m1);\n\tNSLog(@\"%s\",type);\n\t\n\t//输出\n\tv24@0:8i16f20\n\t//0id 8 SEL 16 int 20 float = 24\n```\n\n`v24@0:8i16f20`是encoding的值，我们来分解一下，前边是`v24`是函数返回值是`void`，所有参数占用了`24`字节,`@0:8`是从第0开始，长度是8字节的位置，`i16`是从16字节开始的`int`类型，`f20`是从20字节开始，类型是`float`。\n\n#### 方法缓存\nClass内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。\n我们来到`cache_t`内部\n\n```\nstruct cache_t {\n    struct bucket_t *_buckets;//散列表\n    mask_t _mask;//散列表长度-1\n    mask_t _occupied;//已经存储的方法数量\n}\n\nstruct bucket_t {\n#if __arm64__\n    MethodCacheIMP _imp;\n    cache_key_t _key;\n#else\n    cache_key_t _key;//SEL作为key \n    MethodCacheIMP _imp; //函数地址\n#endif\n}\n```\n\n散列表的数据结构表格所示\n\n|索引|bucket_t|\n|---|---|\n|0|bucket_t(_key,_imp)|\n|1|bucket_t(_key,_imp)|\n|2|bucket_t(_key,_imp)|\n|3|bucket_t(_key,_imp)|\n|4|bucket_t(_key,_imp)|\n|...|...|\n通过`cache_getImp(cls, sel)`获取`IMP`。具体在`cache_t::find`函数中\n\n```\nbucket_t * cache_t::find(cache_key_t k, id receiver)\n{\n    assert(k != 0);\n\n    bucket_t *b = buckets();\n    mask_t m = mask();\n\t//key&mask 得到索引\n    mask_t begin = cache_hash(k, m);\n    mask_t i = begin;\n    do {\n        if (b[i].key() == 0  ||  b[i].key() == k) {\n            return &b[i];\n        }\n    } while ((i = cache_next(i, m)) != begin);\n\n    // hack\n    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));\n    cache_t::bad_cache(receiver, (SEL)k, cls);\n}\n\n// Class points to cache. SEL is key. Cache buckets store SEL+IMP.\n// Caches are never built in the dyld shared cache.\n\nstatic inline mask_t cache_hash(cache_key_t key, mask_t mask) \n{\n    return (mask_t)(key & mask);\n}\n```\n\n首先获取`buckets()`获取`butket_t`,然后获取`_mask`，通过\n`cache_hash(k, m)`获取第一次访问的索引`i`，`cache_hash`通过`(mask_t)(key & mask)`得出具体的`索引`,当第一次成功获取到`butket_t`则直接返回,否则执行`cache_next(i, m)`获取下一个索引，直到获取到或者循环一遍结束。\n那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了`class_rw_t`\n\n```\n#import <Foundation/Foundation.h>\n\n#ifndef MJClassInfo_h\n#define MJClassInfo_h\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\n#if __arm__  ||  __x86_64__  ||  __i386__\n// objc_msgSend has few registers available.\n// Cache scan increments and wraps at special end-marking bucket.\n#define CACHE_END_MARKER 1\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return (i+1) & mask;\n}\n\n#elif __arm64__\n// objc_msgSend has lots of registers available.\n// Cache scan decrements. No end marker needed.\n#define CACHE_END_MARKER 0\nstatic inline mask_t cache_next(mask_t i, mask_t mask) {\n    return i ? i-1 : mask;\n}\n\n#else\n#error unknown architecture\n#endif\n\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n    \n    IMP imp(SEL selector)\n    {\n        mask_t begin = _mask & (long long)selector;\n        mask_t i = begin;\n        do {\n            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) {\n                return _buckets[i]._imp;\n            }\n        } while ((i = cache_next(i, _mask)) != begin);\n        return NULL;\n    }\n};\n\nstruct entsize_list_tt {\n    uint32_t entsizeAndFlags;\n    uint32_t count;\n};\n\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n    method_t first;\n};\n\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n    uint32_t alignment_raw;\n    uint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n    ivar_t first;\n};\n\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n    property_t first;\n};\n\nstruct chained_property_list {\n    chained_property_list *next;\n    uint32_t count;\n    property_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n    uintptr_t count;\n    protocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n    const uint8_t * ivarLayout;\n    const char * name;  // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;  // 成员变量列表\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const class_ro_t *ro;\n    method_list_t * methods;    // 方法列表\n    property_list_t *properties;    // 属性列表\n    const protocol_list_t * protocols;  // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n    uintptr_t bits;\npublic:\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n};\n\n/* OC对象 */\nstruct mj_objc_object {\n    void *isa;\n};\n\n/* 类对象 */\nstruct mj_objc_class : mj_objc_object {\n    Class superclass;\n    cache_t cache;\n    class_data_bits_t bits;\npublic:\n    class_rw_t* data() {\n        return bits.data();\n    }\n    \n    mj_objc_class* metaClass() {\n        return (mj_objc_class *)((long long)isa & ISA_MASK);\n    }\n};\n\n#endif\n```\n\n测试代码是\n\n```\nFYPerson *p = [[FYPerson alloc]init];\n\t\tMethod test1Method = class_getInstanceMethod(p.class, @selector(test));\n\t\tMethod test2Method = class_getInstanceMethod(p.class, @selector(test2));\n\t\tIMP imp1= method_getImplementation(test1Method);\n\t\tIMP imp2= method_getImplementation(test2Method);\n\n\t\tmj_objc_class *cls = (__bridge mj_objc_class *)p.class;\n\t\tNSLog(@\"-----\");\n\t\t[p test];\n\t\t[p test2];\n\t\tcache_t cache = cls->cache;\n\t\tbucket_t *buck = cache._buckets;\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= cache._mask; i ++) {\n\t\t\tbucket_t item = buck[i];\n\t\t\tif (item._key != 0) {\n\t\t\t\tNSLog(@\"key:%lu imp:%p\",item._key,item._imp);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//输出\np imp1\n(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)\n(lldb) p imp2\n(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)\np/d @selector(test)             //输出 test方法的sel地址\n(SEL) $6 = 140734025103231 \"test\"\n(lldb) p/d @selector(test2)     //输出 test2方法的sel地址\n(SEL) $7 = 4294971267 \"test2\"\n\nkey1:140733954181041 imp1:0x7fff59fc4cd1\nkey2:4294971267 imp2:0x100000e20         //对应test2\nkey3:140734025103231 imp3:0x100000df0    //对应test1\n```\n\n可以看出来`IMP1`和`IMP2`、`key1` 和`key2`分别对应了`bucket_t`中的`key2`,`key3`和`imp2`和`imp3`。\n\n\n```\nstatic void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)\n{\n    cacheUpdateLock.assertLocked();\n\n    //当initialized 没有执行完毕的时候不缓存\n    if (!cls->isInitialized()) return;\n\n    // Make sure the entry wasn't added to the cache by some other thread \n    // before we grabbed the cacheUpdateLock.\n    if (cache_getImp(cls, sel)) return;\n\n    cache_t *cache = getCache(cls);\n    cache_key_t key = getKey(sel);\n\n    // Use the cache as-is if it is less than 3/4 full\n    mask_t newOccupied = cache->occupied() + 1;\n    mask_t capacity = cache->capacity();\n    if (cache->isConstantEmptyCache()) {\n        // Cache is read-only. Replace it.\n        cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE);\n    }\n    else if (newOccupied <= capacity / 4 * 3) {\n        // Cache <= 3/4 \n    }\n    else {\n        扩容 之后，缓存清空\n        cache->expand();\n    }\n//bucket_t 最小是4，当>3/4时候，扩容，空间扩容之后是之前的2️倍。\n    bucket_t *bucket = cache->find(key, receiver);\n    if (bucket->key() == 0) cache->incrementOccupied();\n    bucket->set(key, imp);\n}\n```\n\n`cache_t`初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，`cacha->_occupied`恢复为0。\n验证代码如下：\n\n```\nFYPerson *p = [[FYPerson alloc]init];\nmj_objc_class *cls = (__bridge mj_objc_class *)p.class;\nNSLog(@\"-----\");\n[p test];\n/*\n key:init imp:0x7fff58807c2d\n key:class imp:0x7fff588084b7\n key:(null) imp:0x0\n key:test imp:0x100000bf0\n Program ended with exit code: 0\n */\n[p test2]; //当执行该函数的时候\n/*\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:(null) imp:0x0\n key:test2 imp:0x100000c20\n key:(null) imp:0x0\n */\n\ncache_t cache = cls->cache;\nbucket_t *buck = cache._buckets;\n\n\nfor (int i = 0; i <= cache._mask; i ++) {\n\tbucket_t item = buck[i];\n//            if (item._key != 0) {\n////                printf(\"key:%s imp:%p \\n\",(const char *)item._key,item._imp);\n//            }\n    printf(\"key:%s imp:%p \\n\",(const char *)item._key,item._imp);\n\n}\n```\n\n### 总结\n- arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。\n- 函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中\n- 从`class->cache`查找`bucket_t`的key需要先`&_mask`之后再判断是否有该`key`\n- cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，`imp`个数清空\n- `class->rw`在初始化中讲`class_ro_t`值赋值给`rw`,然后`rw->ro`指向之前的`ro`。\n\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n ---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)\n\n\n\n","slug":"iOS底层原理 runtime-object_class拾遗基础篇--(6)","published":1,"updated":"2019-12-03T05:02:33.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2m000q9zskzddqeqqg","content":"<h3 id=\"runtime-基础知识\"><a href=\"#runtime-基础知识\" class=\"headerlink\" title=\"runtime 基础知识\"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123;</div><div class=\"line\">private:</div><div class=\"line\">    isa_t isa;</div><div class=\"line\">public:</div><div class=\"line\">    // ISA() assumes this is NOT a tagged pointer object</div><div class=\"line\">    Class ISA();</div><div class=\"line\">    // getIsa() allows this to be a tagged pointer object</div><div class=\"line\">    Class getIsa();</div><div class=\"line\">    //****</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#include &quot;isa.h&quot;</div><div class=\"line\">union isa_t &#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">#if defined(ISA_BITFIELD)</div><div class=\"line\">    struct &#123;</div><div class=\"line\">        ISA_BITFIELD;  // defined in isa.h</div><div class=\"line\">    &#125;;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class=\"line\">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class=\"line\">#   define ISA_BITFIELD                                         </div><div class=\"line\">      uintptr_t nonpointer        : 1;                              </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 19</div><div class=\"line\">#   define RC_ONE   (1ULL&lt;&lt;45)</div><div class=\"line\">#   define RC_HALF  (1ULL&lt;&lt;18)</div><div class=\"line\"></div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class=\"line\">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class=\"line\">#   define ISA_BITFIELD                                                 </div><div class=\"line\">      uintptr_t nonpointer        : 1;                                  </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 8</div><div class=\"line\">#   define RC_ONE   (1ULL&lt;&lt;56)</div><div class=\"line\">#   define RC_HALF  (1ULL&lt;&lt;7)</div><div class=\"line\"># else</div><div class=\"line\">#   error unknown architecture for packed isa</div><div class=\"line\"># endif</div></pre></td></tr></table></figure>\n<p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">union isa_t &#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">    struct &#123;</div><div class=\"line\">      uintptr_t nonpointer        : 1;                                </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 8</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p>\n<h4 id=\"共用体基础知识\"><a href=\"#共用体基础知识\" class=\"headerlink\" title=\"共用体基础知识\"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) BOOL rich;</div><div class=\"line\">@property (nonatomic,assign) BOOL tell;</div><div class=\"line\">@property (nonatomic,assign) BOOL handsome;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>然后查看该类的实例占用空间大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\t\tp.handsome = YES;</div><div class=\"line\">\t\tp.rich = NO;</div><div class=\"line\">\t\tNSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</div><div class=\"line\">\t\t//16</div></pre></td></tr></table></figure>\n<p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setTall:(BOOL)tall;</div><div class=\"line\">- (void)setRich:(BOOL)rich;</div><div class=\"line\">- (void)setHandsome:(BOOL)handsome;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isTall;</div><div class=\"line\">- (BOOL)isRich;</div><div class=\"line\">- (BOOL)isHandsome;</div><div class=\"line\"></div><div class=\"line\">//实现：</div><div class=\"line\">//使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</div><div class=\"line\">//#define FYHandsomeMask 0b00000001</div><div class=\"line\">//#define FYTallMask 0b00000010</div><div class=\"line\">//#define FYRichMask 0b00000001</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define FYHandsomeMask (1&lt;&lt;0)</div><div class=\"line\">#define FYTallMask (1&lt;&lt;1)</div><div class=\"line\">#define FYRichMask (1&lt;&lt;2)</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar _richTellHandsome;//0000 0000 rich tall handsome</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYRichMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYRichMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYTallMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYTallMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYRichMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYTallMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYHandsomeMask);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">//\tchar _richTellHandsome;//0000 0000 rich tall handsome</div><div class=\"line\">\t//位域</div><div class=\"line\">\tstruct&#123;</div><div class=\"line\">\t\tchar tall : 1;//高度</div><div class=\"line\">\t\tchar rich : 1;//富有</div><div class=\"line\">\t\tchar handsome : 1; //帅</div><div class=\"line\">\t&#125; _richTellHandsome; // 0b0000 0000</div><div class=\"line\">\t//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</div><div class=\"line\">\t//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.rich = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.tall = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.handsome = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.rich;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.handsome;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>\n<p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tchar bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间</div><div class=\"line\">\t\tstruct&#123;</div><div class=\"line\">\t\t\tchar tall : 1;//高度</div><div class=\"line\">\t\t\tchar rich : 1;//富有</div><div class=\"line\">\t\t\tchar handsome : 1; //帅</div><div class=\"line\">\t\t&#125;; // 0b0000 0000</div><div class=\"line\">\t&#125;_richTellHandsome;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYRichMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYRichMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYTallMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYTallMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYHandsomeMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome.bits &amp; FYRichMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome.bits &amp; FYTallMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn (_richTellHandsome.bits &amp; FYHandsomeMask);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</div><div class=\"line\">        NSKeyValueObservingOptionNew = 0x01,</div><div class=\"line\">    NSKeyValueObservingOptionOld = 0x02,</div><div class=\"line\">    NSKeyValueObservingOptionInitial = 0x04,</div><div class=\"line\">    NSKeyValueObservingOptionPrior = 0x08</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum &#123;</div><div class=\"line\">\tFYOne = 1,//  0b 0001</div><div class=\"line\">\tFYTwo = 2,//  0b 0010</div><div class=\"line\">\tFYTHree = 4,//0b 0100</div><div class=\"line\">\tFYFour = 8,// 0b 1000</div><div class=\"line\">&#125;FYOptions;</div><div class=\"line\"></div><div class=\"line\">- (void)setOptions:(FYOptions )ops&#123;</div><div class=\"line\">\tif (ops &amp;FYOne) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYOne is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYTwo) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYTwo is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYTHree) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYTHree is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYFour) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYFour is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self setOptions:FYOne|FYTwo|FYTHree];</div><div class=\"line\"></div><div class=\"line\">//输出是：</div><div class=\"line\">FYOne is show</div><div class=\"line\">FYTwo is show</div><div class=\"line\">FYTHree is show</div></pre></td></tr></table></figure>\n<p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p>\n<h4 id=\"Class的结构\"><a href=\"#Class的结构\" class=\"headerlink\" title=\"Class的结构\"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nonpointer</td>\n<td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td>\n</tr>\n<tr>\n<td>has_assoc</td>\n<td>是否有设置过关联对象，如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>has_cxx_dtor</td>\n<td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>shiftcls</td>\n<td>存储着Class、Meta-Class对象的内存地址信息</td>\n</tr>\n<tr>\n<td>magic</td>\n<td>用于在调试时分辨对象是否未完成初始化</td>\n</tr>\n<tr>\n<td>weakly_referenced</td>\n<td>是否有被弱引用指向过，如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>deallocating</td>\n<td>对象是否正在释放</td>\n</tr>\n<tr>\n<td>extra_rc</td>\n<td>里面存储的值是引用计数器减1</td>\n</tr>\n<tr>\n<td>has_sidetable_rc</td>\n<td>引用计数器是否过大无法存储在isa中</td>\n</tr>\n</tbody>\n</table>\n<p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p>\n<p>class结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct fy_objc_class : xx_objc_object &#123;</div><div class=\"line\">\tClass superclass;</div><div class=\"line\">\tcache_t cache;</div><div class=\"line\">\tclass_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123;</div><div class=\"line\">\t\treturn bits.data();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</div><div class=\"line\">\t\t// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</div><div class=\"line\">\t\treturn (fy_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t version;</div><div class=\"line\">\tconst class_ro_t *ro;//只读 数据</div><div class=\"line\">\tmethod_list_t * methods;    // 方法列表</div><div class=\"line\">\tproperty_list_t *properties;    // 属性列表</div><div class=\"line\">\tconst protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">\tClass firstSubclass;</div><div class=\"line\">\tClass nextSiblingClass;</div><div class=\"line\">\tchar *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t instanceStart;</div><div class=\"line\">\tuint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">\tuint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">\tconst uint8_t * ivarLayout;</div><div class=\"line\">\tconst char * name;  // 类名</div><div class=\"line\">\tmethod_list_t * baseMethodList;</div><div class=\"line\">\tprotocol_list_t * baseProtocols;</div><div class=\"line\">\tconst ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">\tconst uint8_t * weakIvarLayout;</div><div class=\"line\">\tproperty_list_t *baseProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    class_rw_t *rw;</div><div class=\"line\">    Class supercls;</div><div class=\"line\">    Class metacls;</div><div class=\"line\">    bool isMeta;</div><div class=\"line\"></div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    //如果已注册 就返回</div><div class=\"line\">    if (cls-&gt;isRealized()) return cls;</div><div class=\"line\">    assert(cls == remapClass(cls));</div><div class=\"line\"></div><div class=\"line\">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class=\"line\">//只读ro</div><div class=\"line\">    ro = (const class_ro_t *)cls-&gt;data();</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</div><div class=\"line\">        // This was a future class. rw data is already allocated.</div><div class=\"line\">        rw = cls-&gt;data();//初始化ro</div><div class=\"line\">        ro = cls-&gt;data()-&gt;ro;</div><div class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Normal class. Allocate writeable class data.</div><div class=\"line\">        //初始化 rw </div><div class=\"line\">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class=\"line\">        rw-&gt;ro = ro;</div><div class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</div><div class=\"line\">        //指针指向rw 一开始是指向ro的</div><div class=\"line\">        cls-&gt;setData(rw);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    isMeta = ro-&gt;flags &amp; RO_META;</div><div class=\"line\"></div><div class=\"line\">    rw-&gt;version = isMeta ? 7 : 0;  // old runtime went up to 6</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class method_array_t : </div><div class=\"line\">    public list_array_tt&lt;method_t, method_list_t&gt; </div><div class=\"line\">&#123;</div><div class=\"line\">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</div><div class=\"line\"></div><div class=\"line\"> public:</div><div class=\"line\">    method_list_t **beginCategoryMethodLists() &#123;</div><div class=\"line\">        return beginLists();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    method_list_t **endCategoryMethodLists(Class cls);</div><div class=\"line\"></div><div class=\"line\">    method_array_t duplicate() &#123;</div><div class=\"line\">        return Super::duplicate&lt;method_array_t&gt;();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    MethodListIMP imp;</div><div class=\"line\"></div><div class=\"line\">    struct SortBySELAddress :</div><div class=\"line\">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        bool operator() (const method_t&amp; lhs,</div><div class=\"line\">                         const method_t&amp; rhs)</div><div class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p>\n<h5 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h5><ul>\n<li>SEL代表方法\\函数名，一般叫做选择器，底层结构跟char *类似</li>\n<li>可以通过@selector()和sel_registerName()获得</li>\n<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>\n<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>\n</ul>\n<h5 id=\"Type-Encoding\"><a href=\"#Type-Encoding\" class=\"headerlink\" title=\"Type Encoding\"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"external\">官方网站插件encodeing</a></p>\n<table>\n<thead>\n<tr>\n<th>code</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td>A char</td>\n</tr>\n<tr>\n<td>i</td>\n<td>An int</td>\n</tr>\n<tr>\n<td>s</td>\n<td>A short</td>\n</tr>\n<tr>\n<td>l</td>\n<td>A long</td>\n</tr>\n<tr>\n<td>l</td>\n<td>is treated as a 32-bit quantity on 64-bit programs.</td>\n</tr>\n<tr>\n<td>q</td>\n<td>A long long</td>\n</tr>\n<tr>\n<td>C</td>\n<td>An unsigned char</td>\n</tr>\n<tr>\n<td>I</td>\n<td>An unsigned int</td>\n</tr>\n<tr>\n<td>S</td>\n<td>An unsigned short</td>\n</tr>\n<tr>\n<td>L</td>\n<td>An unsigned long</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>An unsigned long long</td>\n</tr>\n<tr>\n<td>f</td>\n<td>A float</td>\n</tr>\n<tr>\n<td>d</td>\n<td>A double</td>\n</tr>\n<tr>\n<td>B</td>\n<td>A C++ bool or a C99 _Bool</td>\n</tr>\n<tr>\n<td>v</td>\n<td>A void</td>\n</tr>\n<tr>\n<td>*</td>\n<td>A character string (char *)</td>\n</tr>\n<tr>\n<td>@</td>\n<td>An object (whether statically typed or typed id)</td>\n</tr>\n<tr>\n<td>#</td>\n<td>A class object (Class)</td>\n</tr>\n<tr>\n<td>:</td>\n<td>A method selector (SEL)</td>\n</tr>\n<tr>\n<td>[array type]</td>\n<td>An array</td>\n</tr>\n<tr>\n<td>{name=type…}</td>\n<td>A structure</td>\n</tr>\n<tr>\n<td>(name=type…)</td>\n<td>A union</td>\n</tr>\n<tr>\n<td>bnum</td>\n<td>A bit field of num bits</td>\n</tr>\n<tr>\n<td>^type</td>\n<td>A pointer to type</td>\n</tr>\n<tr>\n<td>?</td>\n<td>An unknown type (among other things, this code is used for function pointers)</td>\n</tr>\n</tbody>\n</table>\n<p>我们通过一个例子来了解encode</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)test:(int)age heiht:(float)height&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\tSEL sel = @selector(test:heiht:);</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(p.class, sel);</div><div class=\"line\">\tconst char *type = method_getTypeEncoding(m1);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,type);</div><div class=\"line\">\t</div><div class=\"line\">\t//输出</div><div class=\"line\">\tv24@0:8i16f20</div><div class=\"line\">\t//0id 8 SEL 16 int 20 float = 24</div></pre></td></tr></table></figure>\n<p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p>\n<h4 id=\"方法缓存\"><a href=\"#方法缓存\" class=\"headerlink\" title=\"方法缓存\"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">    struct bucket_t *_buckets;//散列表</div><div class=\"line\">    mask_t _mask;//散列表长度-1</div><div class=\"line\">    mask_t _occupied;//已经存储的方法数量</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">#if __arm64__</div><div class=\"line\">    MethodCacheIMP _imp;</div><div class=\"line\">    cache_key_t _key;</div><div class=\"line\">#else</div><div class=\"line\">    cache_key_t _key;//SEL作为key </div><div class=\"line\">    MethodCacheIMP _imp; //函数地址</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>散列表的数据结构表格所示</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>bucket_t</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">bucket_t * cache_t::find(cache_key_t k, id receiver)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(k != 0);</div><div class=\"line\"></div><div class=\"line\">    bucket_t *b = buckets();</div><div class=\"line\">    mask_t m = mask();</div><div class=\"line\">\t//key&amp;mask 得到索引</div><div class=\"line\">    mask_t begin = cache_hash(k, m);</div><div class=\"line\">    mask_t i = begin;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</div><div class=\"line\">            return &amp;b[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while ((i = cache_next(i, m)) != begin);</div><div class=\"line\"></div><div class=\"line\">    // hack</div><div class=\"line\">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</div><div class=\"line\">    cache_t::bad_cache(receiver, (SEL)k, cls);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</div><div class=\"line\">// Caches are never built in the dyld shared cache.</div><div class=\"line\"></div><div class=\"line\">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </div><div class=\"line\">&#123;</div><div class=\"line\">    return (mask_t)(key &amp; mask);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">#ifndef MJClassInfo_h</div><div class=\"line\">#define MJClassInfo_h</div><div class=\"line\"></div><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\"># endif</div><div class=\"line\"></div><div class=\"line\">#if __LP64__</div><div class=\"line\">typedef uint32_t mask_t;</div><div class=\"line\">#else</div><div class=\"line\">typedef uint16_t mask_t;</div><div class=\"line\">#endif</div><div class=\"line\">typedef uintptr_t cache_key_t;</div><div class=\"line\"></div><div class=\"line\">#if __arm__  ||  __x86_64__  ||  __i386__</div><div class=\"line\">// objc_msgSend has few registers available.</div><div class=\"line\">// Cache scan increments and wraps at special end-marking bucket.</div><div class=\"line\">#define CACHE_END_MARKER 1</div><div class=\"line\">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class=\"line\">    return (i+1) &amp; mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#elif __arm64__</div><div class=\"line\">// objc_msgSend has lots of registers available.</div><div class=\"line\">// Cache scan decrements. No end marker needed.</div><div class=\"line\">#define CACHE_END_MARKER 0</div><div class=\"line\">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class=\"line\">    return i ? i-1 : mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#else</div><div class=\"line\">#error unknown architecture</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">    cache_key_t _key;</div><div class=\"line\">    IMP _imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">    bucket_t *_buckets;</div><div class=\"line\">    mask_t _mask;</div><div class=\"line\">    mask_t _occupied;</div><div class=\"line\">    </div><div class=\"line\">    IMP imp(SEL selector)</div><div class=\"line\">    &#123;</div><div class=\"line\">        mask_t begin = _mask &amp; (long long)selector;</div><div class=\"line\">        mask_t i = begin;</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) &#123;</div><div class=\"line\">                return _buckets[i]._imp;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while ((i = cache_next(i, _mask)) != begin);</div><div class=\"line\">        return NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct entsize_list_tt &#123;</div><div class=\"line\">    uint32_t entsizeAndFlags;</div><div class=\"line\">    uint32_t count;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_list_t : entsize_list_tt &#123;</div><div class=\"line\">    method_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *type;</div><div class=\"line\">    uint32_t alignment_raw;</div><div class=\"line\">    uint32_t size;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_list_t : entsize_list_tt &#123;</div><div class=\"line\">    ivar_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *attributes;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_list_t : entsize_list_tt &#123;</div><div class=\"line\">    property_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct chained_property_list &#123;</div><div class=\"line\">    chained_property_list *next;</div><div class=\"line\">    uint32_t count;</div><div class=\"line\">    property_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef uintptr_t protocol_ref_t;</div><div class=\"line\">struct protocol_list_t &#123;</div><div class=\"line\">    uintptr_t count;</div><div class=\"line\">    protocol_ref_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t instanceStart;</div><div class=\"line\">    uint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">    uint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">    const uint8_t * ivarLayout;</div><div class=\"line\">    const char * name;  // 类名</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    const ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">    const uint8_t * weakIvarLayout;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    method_list_t * methods;    // 方法列表</div><div class=\"line\">    property_list_t *properties;    // 属性列表</div><div class=\"line\">    const protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">    Class firstSubclass;</div><div class=\"line\">    Class nextSiblingClass;</div><div class=\"line\">    char *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</div><div class=\"line\">struct class_data_bits_t &#123;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">public:</div><div class=\"line\">    class_rw_t* data() &#123;</div><div class=\"line\">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* OC对象 */</div><div class=\"line\">struct mj_objc_object &#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* 类对象 */</div><div class=\"line\">struct mj_objc_class : mj_objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;</div><div class=\"line\">    class_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">    class_rw_t* data() &#123;</div><div class=\"line\">        return bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    mj_objc_class* metaClass() &#123;</div><div class=\"line\">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>测试代码是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t\tMethod test1Method = class_getInstanceMethod(p.class, @selector(test));</div><div class=\"line\">\t\tMethod test2Method = class_getInstanceMethod(p.class, @selector(test2));</div><div class=\"line\">\t\tIMP imp1= method_getImplementation(test1Method);</div><div class=\"line\">\t\tIMP imp2= method_getImplementation(test2Method);</div><div class=\"line\"></div><div class=\"line\">\t\tmj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class=\"line\">\t\tNSLog(@&quot;-----&quot;);</div><div class=\"line\">\t\t[p test];</div><div class=\"line\">\t\t[p test2];</div><div class=\"line\">\t\tcache_t cache = cls-&gt;cache;</div><div class=\"line\">\t\tbucket_t *buck = cache._buckets;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tfor (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class=\"line\">\t\t\tbucket_t item = buck[i];</div><div class=\"line\">\t\t\tif (item._key != 0) &#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//输出</div><div class=\"line\">p imp1</div><div class=\"line\">(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)</div><div class=\"line\">(lldb) p imp2</div><div class=\"line\">(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)</div><div class=\"line\">p/d @selector(test)             //输出 test方法的sel地址</div><div class=\"line\">(SEL) $6 = 140734025103231 &quot;test&quot;</div><div class=\"line\">(lldb) p/d @selector(test2)     //输出 test2方法的sel地址</div><div class=\"line\">(SEL) $7 = 4294971267 &quot;test2&quot;</div><div class=\"line\"></div><div class=\"line\">key1:140733954181041 imp1:0x7fff59fc4cd1</div><div class=\"line\">key2:4294971267 imp2:0x100000e20         //对应test2</div><div class=\"line\">key3:140734025103231 imp3:0x100000df0    //对应test1</div></pre></td></tr></table></figure>\n<p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</div><div class=\"line\">&#123;</div><div class=\"line\">    cacheUpdateLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    //当initialized 没有执行完毕的时候不缓存</div><div class=\"line\">    if (!cls-&gt;isInitialized()) return;</div><div class=\"line\"></div><div class=\"line\">    // Make sure the entry wasn&apos;t added to the cache by some other thread </div><div class=\"line\">    // before we grabbed the cacheUpdateLock.</div><div class=\"line\">    if (cache_getImp(cls, sel)) return;</div><div class=\"line\"></div><div class=\"line\">    cache_t *cache = getCache(cls);</div><div class=\"line\">    cache_key_t key = getKey(sel);</div><div class=\"line\"></div><div class=\"line\">    // Use the cache as-is if it is less than 3/4 full</div><div class=\"line\">    mask_t newOccupied = cache-&gt;occupied() + 1;</div><div class=\"line\">    mask_t capacity = cache-&gt;capacity();</div><div class=\"line\">    if (cache-&gt;isConstantEmptyCache()) &#123;</div><div class=\"line\">        // Cache is read-only. Replace it.</div><div class=\"line\">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</div><div class=\"line\">        // Cache &lt;= 3/4 </div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        扩容 之后，缓存清空</div><div class=\"line\">        cache-&gt;expand();</div><div class=\"line\">    &#125;</div><div class=\"line\">//bucket_t 最小是4，当&gt;3/4时候，扩容，空间扩容之后是之前的2️倍。</div><div class=\"line\">    bucket_t *bucket = cache-&gt;find(key, receiver);</div><div class=\"line\">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</div><div class=\"line\">    bucket-&gt;set(key, imp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class=\"line\">NSLog(@&quot;-----&quot;);</div><div class=\"line\">[p test];</div><div class=\"line\">/*</div><div class=\"line\"> key:init imp:0x7fff58807c2d</div><div class=\"line\"> key:class imp:0x7fff588084b7</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:test imp:0x100000bf0</div><div class=\"line\"> Program ended with exit code: 0</div><div class=\"line\"> */</div><div class=\"line\">[p test2]; //当执行该函数的时候</div><div class=\"line\">/*</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:test2 imp:0x100000c20</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">cache_t cache = cls-&gt;cache;</div><div class=\"line\">bucket_t *buck = cache._buckets;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">for (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class=\"line\">\tbucket_t item = buck[i];</div><div class=\"line\">//            if (item._key != 0) &#123;</div><div class=\"line\">////                printf(&quot;key:%s imp:%p \\n&quot;,(const char *)item._key,item._imp);</div><div class=\"line\">//            &#125;</div><div class=\"line\">    printf(&quot;key:%s imp:%p \\n&quot;,(const char *)item._key,item._imp);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li>\n<li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li>\n<li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li>\n<li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li>\n<li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n</li>\n</ul>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"runtime-基础知识\"><a href=\"#runtime-基础知识\" class=\"headerlink\" title=\"runtime 基础知识\"></a>runtime 基础知识</h3><p><code>runtime</code>是运行时，在运行的时候做一些事请，可以动态添加类和交换函数，那么有一个基础知识需要了解，arm64架构前，isa指针是普通指针，存储class和meta-class对象的内存地址，从arm64架构开始，对isa进行了优化，变成了一个<code>union</code>共用体，还是用位域来存储更多的信息，我们首先看一下isa指针的结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123;</div><div class=\"line\">private:</div><div class=\"line\">    isa_t isa;</div><div class=\"line\">public:</div><div class=\"line\">    // ISA() assumes this is NOT a tagged pointer object</div><div class=\"line\">    Class ISA();</div><div class=\"line\">    // getIsa() allows this to be a tagged pointer object</div><div class=\"line\">    Class getIsa();</div><div class=\"line\">    //****</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#include &quot;isa.h&quot;</div><div class=\"line\">union isa_t &#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">#if defined(ISA_BITFIELD)</div><div class=\"line\">    struct &#123;</div><div class=\"line\">        ISA_BITFIELD;  // defined in isa.h</div><div class=\"line\">    &#125;;</div><div class=\"line\">#endif</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>objc_object</code>是结构体，包含了私有属性<code>isa_t</code>,<code>isa_t isa</code>是一个共用体，包含了<code>ISA_BITFIELD</code>是一个宏(结构体)，<code>bits</code>是<code>uintptr_t</code>类型，<code>uintptr_t</code>其实是<code>unsign long</code>类型占用8字节，就是64位，我们进入到<code>ISA_BITFIELD</code>内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class=\"line\">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class=\"line\">#   define ISA_BITFIELD                                         </div><div class=\"line\">      uintptr_t nonpointer        : 1;                              </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 19</div><div class=\"line\">#   define RC_ONE   (1ULL&lt;&lt;45)</div><div class=\"line\">#   define RC_HALF  (1ULL&lt;&lt;18)</div><div class=\"line\"></div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class=\"line\">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class=\"line\">#   define ISA_BITFIELD                                                 </div><div class=\"line\">      uintptr_t nonpointer        : 1;                                  </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 8</div><div class=\"line\">#   define RC_ONE   (1ULL&lt;&lt;56)</div><div class=\"line\">#   define RC_HALF  (1ULL&lt;&lt;7)</div><div class=\"line\"># else</div><div class=\"line\">#   error unknown architecture for packed isa</div><div class=\"line\"># endif</div></pre></td></tr></table></figure>\n<p><code>ISA_BITFIELD</code>在<code>arm64</code>和<code>x86</code>是两种结构，存储了<code>nonpointer</code>,<code>has_assoc</code>,<code>has_cxx_dtor</code>,<code>shiftcls</code>,<code>magic</code>,<code>weakly_referenced</code>,<code>deallocating</code>,<code>has_sidetable_rc</code>,<code>extra_rc</code>这些信息，<code>:1</code>就占用了一位，<code>:44</code>就是占用了44位，<code>:6</code>就是占用了6位，<code>:8</code>就是占用了8位，那么共用体<code>isa_t</code>简化之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">union isa_t &#123;</div><div class=\"line\">    isa_t() &#123; &#125;</div><div class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">    Class cls;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">    struct &#123;</div><div class=\"line\">      uintptr_t nonpointer        : 1;                                </div><div class=\"line\">      uintptr_t has_assoc         : 1;                                  </div><div class=\"line\">      uintptr_t has_cxx_dtor      : 1;                                  </div><div class=\"line\">      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\</div><div class=\"line\">      uintptr_t magic             : 6;                                  </div><div class=\"line\">      uintptr_t weakly_referenced : 1;                                  </div><div class=\"line\">      uintptr_t deallocating      : 1;                                  </div><div class=\"line\">      uintptr_t has_sidetable_rc  : 1;                                  </div><div class=\"line\">      uintptr_t extra_rc          : 8</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>isa_t</code>是使用共用体结构，使用<code>bits</code>存储了结构体的数据，那么共用体是如何使用的？我们来探究一下</p>\n<h4 id=\"共用体基础知识\"><a href=\"#共用体基础知识\" class=\"headerlink\" title=\"共用体基础知识\"></a>共用体基础知识</h4><p>首先我们定义一个<code>FYPerson</code>，添加2个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson : NSObject</div><div class=\"line\">@property (nonatomic,assign) BOOL rich;</div><div class=\"line\">@property (nonatomic,assign) BOOL tell;</div><div class=\"line\">@property (nonatomic,assign) BOOL handsome;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>然后查看该类的实例占用空间大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\t\tp.handsome = YES;</div><div class=\"line\">\t\tp.rich = NO;</div><div class=\"line\">\t\tNSLog(@&quot;大小：%zu&quot;,class_getInstanceSize(FYPerson.class));</div><div class=\"line\">\t\t//16</div></pre></td></tr></table></figure>\n<p><code>FYPerson</code>定义了三个属性，占用空间是16字节，那么我们换一种方法实现这个三个属性的功能。<br>我们定义6个方法，3个set方法，3个get方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setTall:(BOOL)tall;</div><div class=\"line\">- (void)setRich:(BOOL)rich;</div><div class=\"line\">- (void)setHandsome:(BOOL)handsome;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)isTall;</div><div class=\"line\">- (BOOL)isRich;</div><div class=\"line\">- (BOOL)isHandsome;</div><div class=\"line\"></div><div class=\"line\">//实现：</div><div class=\"line\">//使用0b00000000不是很易读，我们换成下边的写法1&lt;&lt;0</div><div class=\"line\">//#define FYHandsomeMask 0b00000001</div><div class=\"line\">//#define FYTallMask 0b00000010</div><div class=\"line\">//#define FYRichMask 0b00000001</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define FYHandsomeMask (1&lt;&lt;0)</div><div class=\"line\">#define FYTallMask (1&lt;&lt;1)</div><div class=\"line\">#define FYRichMask (1&lt;&lt;2)</div><div class=\"line\"></div><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">\tchar _richTellHandsome;//0000 0000 rich tall handsome</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYRichMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYRichMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYTallMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYTallMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYRichMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYTallMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome&amp;FYHandsomeMask);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们定义了一个char类型的变量<code>_richTellHandsome</code>,4字节，32位，可以存储32个bool类型的变量。赋值是使用<code>_richTellHandsome = _richTellHandsome|FYRichMask</code>,或<code>_richTellHandsome = _richTellHandsome&amp;~FYRichMask</code>,取值是<code>!!(_richTellHandsome&amp;FYRichMask)</code>，前边加<code>!!</code>是转化成<code>bool</code>类型的，否则取值出来是<code>1 or  2 or 4</code>。我们再换一种思路将三个变量定义成一个结构体，取值和赋值都是可以直接操作的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">//\tchar _richTellHandsome;//0000 0000 rich tall handsome</div><div class=\"line\">\t//位域</div><div class=\"line\">\tstruct&#123;</div><div class=\"line\">\t\tchar tall : 1;//高度</div><div class=\"line\">\t\tchar rich : 1;//富有</div><div class=\"line\">\t\tchar handsome : 1; //帅</div><div class=\"line\">\t&#125; _richTellHandsome; // 0b0000 0000</div><div class=\"line\">\t//使用2位 yes就是0b01 转化成1字节8位就是:0o0101 0101 结果是1</div><div class=\"line\">\t//使用1位 yes就是0b1 转化成1字节8位就是:0o1111 1111 所以结果是-1</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.rich = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.tall = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\t_richTellHandsome.handsome = tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.rich;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.tall;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn !!_richTellHandsome.handsome;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>结构体<code>_richTellHandsome</code>包含三个变量<code>char tall : 1;</code>,<code>char rich : 1;</code>,<code>char handsome : 1</code>。每一个变量占用空间为1位，3个变量占用3位。取值的时候使用<code>!!(_richTellHandsome&amp;FYHandsomeMask)</code>，赋值使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome|FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome = _richTellHandsome&amp;~FYHandsomeMask</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>我们采用位域来存储信息，<br>位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>\n<p>另外一个省空间的思路是使用<code>联合</code>,<br>使用<code>union</code>，可以更省空间，“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。另外，同struct一样，联合默认访问权限也是公有的，并且，也具有成员函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYPerson()</div><div class=\"line\">&#123;</div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tchar bits; //一个字节8位 ricH /tall/handsome都是占用的bits的内存空间</div><div class=\"line\">\t\tstruct&#123;</div><div class=\"line\">\t\t\tchar tall : 1;//高度</div><div class=\"line\">\t\t\tchar rich : 1;//富有</div><div class=\"line\">\t\t\tchar handsome : 1; //帅</div><div class=\"line\">\t\t&#125;; // 0b0000 0000</div><div class=\"line\">\t&#125;_richTellHandsome;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation FYPerson</div><div class=\"line\"></div><div class=\"line\">- (void)setRich:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYRichMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYRichMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setTall:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYTallMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYTallMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)setHandsome:(BOOL)tall&#123;</div><div class=\"line\">\tif (tall) &#123;</div><div class=\"line\">\t\t_richTellHandsome.bits |= FYHandsomeMask;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\t_richTellHandsome.bits &amp;= ~FYHandsomeMask;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isRich&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome.bits &amp; FYRichMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isTall&#123;</div><div class=\"line\">\treturn !!(_richTellHandsome.bits &amp; FYTallMask);</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isHandsome&#123;</div><div class=\"line\">\treturn (_richTellHandsome.bits &amp; FYHandsomeMask);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>联合</code>共用体，达到省空间的目的，<code>runtime</code>源码中是用来很多<code>union</code>和位运算。<br>例如KVO 的NSKeyValueObservingOptions<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions)&#123;</div><div class=\"line\">        NSKeyValueObservingOptionNew = 0x01,</div><div class=\"line\">    NSKeyValueObservingOptionOld = 0x02,</div><div class=\"line\">    NSKeyValueObservingOptionInitial = 0x04,</div><div class=\"line\">    NSKeyValueObservingOptionPrior = 0x08</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个<code>NSKeyValueObservingOptions</code>使用位域，当传进去的时候<code>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld</code>,则传进去的值为<code>0x3</code>,转化成二进制就是<code>0b11</code>，则两位都是<code>1</code>可以包含2个值。<br>那么我们来设计一个简单的可以使用或来传值的枚举</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef enum &#123;</div><div class=\"line\">\tFYOne = 1,//  0b 0001</div><div class=\"line\">\tFYTwo = 2,//  0b 0010</div><div class=\"line\">\tFYTHree = 4,//0b 0100</div><div class=\"line\">\tFYFour = 8,// 0b 1000</div><div class=\"line\">&#125;FYOptions;</div><div class=\"line\"></div><div class=\"line\">- (void)setOptions:(FYOptions )ops&#123;</div><div class=\"line\">\tif (ops &amp;FYOne) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYOne is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYTwo) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYTwo is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYTHree) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYTHree is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (ops &amp;FYFour) &#123;</div><div class=\"line\">\t\tNSLog(@&quot;FYFour is show&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self setOptions:FYOne|FYTwo|FYTHree];</div><div class=\"line\"></div><div class=\"line\">//输出是：</div><div class=\"line\">FYOne is show</div><div class=\"line\">FYTwo is show</div><div class=\"line\">FYTHree is show</div></pre></td></tr></table></figure>\n<p>这是一个名字为<code>FYOptions</code>的枚举，第一个是十进制是1，二进制是<code>0b 0001</code>,第二个十进制是2，二进制是<code>0b 0010</code>,第三个十进制是4，二进制是<code>0b 0100</code>,第四个十进制是8，二进制是<code>0b 1000</code>。<br>那么我们使用的时候可以<code>FYOne|FYTwo|FYTHree</code>，打包成一个值，相当于<code>1|2|4 = 7</code>,二进制表示是<code>0b0111</code>，后三位都是1，可以通过&amp;mask取出对应的每一位的数值。</p>\n<h4 id=\"Class的结构\"><a href=\"#Class的结构\" class=\"headerlink\" title=\"Class的结构\"></a>Class的结构</h4><p>isa详解 – 位域存储的数据及其含义</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nonpointer</td>\n<td>0-&gt;代表普通的指针，存储着Class、Meta-Class对象的内存地址。1-&gt;代表优化过，使用位域存储更多的信息</td>\n</tr>\n<tr>\n<td>has_assoc</td>\n<td>是否有设置过关联对象，如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>has_cxx_dtor</td>\n<td>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>shiftcls</td>\n<td>存储着Class、Meta-Class对象的内存地址信息</td>\n</tr>\n<tr>\n<td>magic</td>\n<td>用于在调试时分辨对象是否未完成初始化</td>\n</tr>\n<tr>\n<td>weakly_referenced</td>\n<td>是否有被弱引用指向过，如果没有，释放时会更快</td>\n</tr>\n<tr>\n<td>deallocating</td>\n<td>对象是否正在释放</td>\n</tr>\n<tr>\n<td>extra_rc</td>\n<td>里面存储的值是引用计数器减1</td>\n</tr>\n<tr>\n<td>has_sidetable_rc</td>\n<td>引用计数器是否过大无法存储在isa中</td>\n</tr>\n</tbody>\n</table>\n<p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中|</p>\n<p>class结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct fy_objc_class : xx_objc_object &#123;</div><div class=\"line\">\tClass superclass;</div><div class=\"line\">\tcache_t cache;</div><div class=\"line\">\tclass_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123;</div><div class=\"line\">\t\treturn bits.data();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</div><div class=\"line\">\t\t// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</div><div class=\"line\">\t\treturn (fy_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t version;</div><div class=\"line\">\tconst class_ro_t *ro;//只读 数据</div><div class=\"line\">\tmethod_list_t * methods;    // 方法列表</div><div class=\"line\">\tproperty_list_t *properties;    // 属性列表</div><div class=\"line\">\tconst protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">\tClass firstSubclass;</div><div class=\"line\">\tClass nextSiblingClass;</div><div class=\"line\">\tchar *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t instanceStart;</div><div class=\"line\">\tuint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">\tuint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">\tconst uint8_t * ivarLayout;</div><div class=\"line\">\tconst char * name;  // 类名</div><div class=\"line\">\tmethod_list_t * baseMethodList;</div><div class=\"line\">\tprotocol_list_t * baseProtocols;</div><div class=\"line\">\tconst ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">\tconst uint8_t * weakIvarLayout;</div><div class=\"line\">\tproperty_list_t *baseProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>class_ro_t</code>是只读的，<code>class_rw_t</code>是读写的，在源码中<code>runtime</code>-&gt;<code>Source</code>-&gt;<code>objc-runtime-new.mm</code>-&gt;<code>static Class realizeClass(Class cls) 1869行</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    class_rw_t *rw;</div><div class=\"line\">    Class supercls;</div><div class=\"line\">    Class metacls;</div><div class=\"line\">    bool isMeta;</div><div class=\"line\"></div><div class=\"line\">    if (!cls) return nil;</div><div class=\"line\">    //如果已注册 就返回</div><div class=\"line\">    if (cls-&gt;isRealized()) return cls;</div><div class=\"line\">    assert(cls == remapClass(cls));</div><div class=\"line\"></div><div class=\"line\">    // fixme verify class is not in an un-dlopened part of the shared cache?</div><div class=\"line\">//只读ro</div><div class=\"line\">    ro = (const class_ro_t *)cls-&gt;data();</div><div class=\"line\">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</div><div class=\"line\">        // This was a future class. rw data is already allocated.</div><div class=\"line\">        rw = cls-&gt;data();//初始化ro</div><div class=\"line\">        ro = cls-&gt;data()-&gt;ro;</div><div class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Normal class. Allocate writeable class data.</div><div class=\"line\">        //初始化 rw </div><div class=\"line\">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);</div><div class=\"line\">        rw-&gt;ro = ro;</div><div class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</div><div class=\"line\">        //指针指向rw 一开始是指向ro的</div><div class=\"line\">        cls-&gt;setData(rw);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    isMeta = ro-&gt;flags &amp; RO_META;</div><div class=\"line\"></div><div class=\"line\">    rw-&gt;version = isMeta ? 7 : 0;  // old runtime went up to 6</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>开始<code>cls-&gt;data</code>指向的是<code>ro</code>，初始化之后，指向的<code>rw</code>,<code>rw-&gt;ro</code>指向的是原来的<code>ro</code>。<br><code>class_rw_t</code>中的<code>method_array_t</code>是存储的方法列表，我们进入到<code>method_array_t</code>看下它的数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class method_array_t : </div><div class=\"line\">    public list_array_tt&lt;method_t, method_list_t&gt; </div><div class=\"line\">&#123;</div><div class=\"line\">    typedef list_array_tt&lt;method_t, method_list_t&gt; Super;</div><div class=\"line\"></div><div class=\"line\"> public:</div><div class=\"line\">    method_list_t **beginCategoryMethodLists() &#123;</div><div class=\"line\">        return beginLists();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    method_list_t **endCategoryMethodLists(Class cls);</div><div class=\"line\"></div><div class=\"line\">    method_array_t duplicate() &#123;</div><div class=\"line\">        return Super::duplicate&lt;method_array_t&gt;();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>method_array_t</code>是一个类，存储了<code>method_t</code>二维数组，那么我们看下<code>method_t</code>的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    MethodListIMP imp;</div><div class=\"line\"></div><div class=\"line\">    struct SortBySELAddress :</div><div class=\"line\">        public std::binary_function&lt;const method_t&amp;,const method_t&amp;, bool&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        bool operator() (const method_t&amp; lhs,</div><div class=\"line\">                         const method_t&amp; rhs)</div><div class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>method_t</code>是存储了3个变量的结构体，<code>SEL</code>是方法名，<code>types</code>是编码(方法返回类型，参数类型)， <code>imp</code>函数指针(函数地址)。</p>\n<h5 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h5><ul>\n<li>SEL代表方法\\函数名，一般叫做选择器，底层结构跟char *类似</li>\n<li>可以通过@selector()和sel_registerName()获得</li>\n<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>\n<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>\n</ul>\n<h5 id=\"Type-Encoding\"><a href=\"#Type-Encoding\" class=\"headerlink\" title=\"Type Encoding\"></a>Type Encoding</h5><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型转成字符编码，<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"external\">官方网站插件encodeing</a></p>\n<table>\n<thead>\n<tr>\n<th>code</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td>A char</td>\n</tr>\n<tr>\n<td>i</td>\n<td>An int</td>\n</tr>\n<tr>\n<td>s</td>\n<td>A short</td>\n</tr>\n<tr>\n<td>l</td>\n<td>A long</td>\n</tr>\n<tr>\n<td>l</td>\n<td>is treated as a 32-bit quantity on 64-bit programs.</td>\n</tr>\n<tr>\n<td>q</td>\n<td>A long long</td>\n</tr>\n<tr>\n<td>C</td>\n<td>An unsigned char</td>\n</tr>\n<tr>\n<td>I</td>\n<td>An unsigned int</td>\n</tr>\n<tr>\n<td>S</td>\n<td>An unsigned short</td>\n</tr>\n<tr>\n<td>L</td>\n<td>An unsigned long</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>An unsigned long long</td>\n</tr>\n<tr>\n<td>f</td>\n<td>A float</td>\n</tr>\n<tr>\n<td>d</td>\n<td>A double</td>\n</tr>\n<tr>\n<td>B</td>\n<td>A C++ bool or a C99 _Bool</td>\n</tr>\n<tr>\n<td>v</td>\n<td>A void</td>\n</tr>\n<tr>\n<td>*</td>\n<td>A character string (char *)</td>\n</tr>\n<tr>\n<td>@</td>\n<td>An object (whether statically typed or typed id)</td>\n</tr>\n<tr>\n<td>#</td>\n<td>A class object (Class)</td>\n</tr>\n<tr>\n<td>:</td>\n<td>A method selector (SEL)</td>\n</tr>\n<tr>\n<td>[array type]</td>\n<td>An array</td>\n</tr>\n<tr>\n<td>{name=type…}</td>\n<td>A structure</td>\n</tr>\n<tr>\n<td>(name=type…)</td>\n<td>A union</td>\n</tr>\n<tr>\n<td>bnum</td>\n<td>A bit field of num bits</td>\n</tr>\n<tr>\n<td>^type</td>\n<td>A pointer to type</td>\n</tr>\n<tr>\n<td>?</td>\n<td>An unknown type (among other things, this code is used for function pointers)</td>\n</tr>\n</tbody>\n</table>\n<p>我们通过一个例子来了解encode</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)test:(int)age heiht:(float)height&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">FYPerson *p=[[FYPerson alloc]init];</div><div class=\"line\">\tSEL sel = @selector(test:heiht:);</div><div class=\"line\">\tMethod m1= class_getInstanceMethod(p.class, sel);</div><div class=\"line\">\tconst char *type = method_getTypeEncoding(m1);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,type);</div><div class=\"line\">\t</div><div class=\"line\">\t//输出</div><div class=\"line\">\tv24@0:8i16f20</div><div class=\"line\">\t//0id 8 SEL 16 int 20 float = 24</div></pre></td></tr></table></figure>\n<p><code>v24@0:8i16f20</code>是encoding的值，我们来分解一下，前边是<code>v24</code>是函数返回值是<code>void</code>，所有参数占用了<code>24</code>字节,<code>@0:8</code>是从第0开始，长度是8字节的位置，<code>i16</code>是从16字节开始的<code>int</code>类型，<code>f20</code>是从20字节开始，类型是<code>float</code>。</p>\n<h4 id=\"方法缓存\"><a href=\"#方法缓存\" class=\"headerlink\" title=\"方法缓存\"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。<br>我们来到<code>cache_t</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">    struct bucket_t *_buckets;//散列表</div><div class=\"line\">    mask_t _mask;//散列表长度-1</div><div class=\"line\">    mask_t _occupied;//已经存储的方法数量</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">#if __arm64__</div><div class=\"line\">    MethodCacheIMP _imp;</div><div class=\"line\">    cache_key_t _key;</div><div class=\"line\">#else</div><div class=\"line\">    cache_key_t _key;//SEL作为key </div><div class=\"line\">    MethodCacheIMP _imp; //函数地址</div><div class=\"line\">#endif</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>散列表的数据结构表格所示</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>bucket_t</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>bucket_t(_key,_imp)</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<p>通过<code>cache_getImp(cls, sel)</code>获取<code>IMP</code>。具体在<code>cache_t::find</code>函数中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">bucket_t * cache_t::find(cache_key_t k, id receiver)</div><div class=\"line\">&#123;</div><div class=\"line\">    assert(k != 0);</div><div class=\"line\"></div><div class=\"line\">    bucket_t *b = buckets();</div><div class=\"line\">    mask_t m = mask();</div><div class=\"line\">\t//key&amp;mask 得到索引</div><div class=\"line\">    mask_t begin = cache_hash(k, m);</div><div class=\"line\">    mask_t i = begin;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</div><div class=\"line\">            return &amp;b[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; while ((i = cache_next(i, m)) != begin);</div><div class=\"line\"></div><div class=\"line\">    // hack</div><div class=\"line\">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</div><div class=\"line\">    cache_t::bad_cache(receiver, (SEL)k, cls);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</div><div class=\"line\">// Caches are never built in the dyld shared cache.</div><div class=\"line\"></div><div class=\"line\">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </div><div class=\"line\">&#123;</div><div class=\"line\">    return (mask_t)(key &amp; mask);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先获取<code>buckets()</code>获取<code>butket_t</code>,然后获取<code>_mask</code>，通过<br><code>cache_hash(k, m)</code>获取第一次访问的索引<code>i</code>，<code>cache_hash</code>通过<code>(mask_t)(key &amp; mask)</code>得出具体的<code>索引</code>,当第一次成功获取到<code>butket_t</code>则直接返回,否则执行<code>cache_next(i, m)</code>获取下一个索引，直到获取到或者循环一遍结束。<br>那么我们来验证一下已经执行的函数的确是存在cache中的，我们自定义了<code>class_rw_t</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">#ifndef MJClassInfo_h</div><div class=\"line\">#define MJClassInfo_h</div><div class=\"line\"></div><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\"># endif</div><div class=\"line\"></div><div class=\"line\">#if __LP64__</div><div class=\"line\">typedef uint32_t mask_t;</div><div class=\"line\">#else</div><div class=\"line\">typedef uint16_t mask_t;</div><div class=\"line\">#endif</div><div class=\"line\">typedef uintptr_t cache_key_t;</div><div class=\"line\"></div><div class=\"line\">#if __arm__  ||  __x86_64__  ||  __i386__</div><div class=\"line\">// objc_msgSend has few registers available.</div><div class=\"line\">// Cache scan increments and wraps at special end-marking bucket.</div><div class=\"line\">#define CACHE_END_MARKER 1</div><div class=\"line\">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class=\"line\">    return (i+1) &amp; mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#elif __arm64__</div><div class=\"line\">// objc_msgSend has lots of registers available.</div><div class=\"line\">// Cache scan decrements. No end marker needed.</div><div class=\"line\">#define CACHE_END_MARKER 0</div><div class=\"line\">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</div><div class=\"line\">    return i ? i-1 : mask;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#else</div><div class=\"line\">#error unknown architecture</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">    cache_key_t _key;</div><div class=\"line\">    IMP _imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">    bucket_t *_buckets;</div><div class=\"line\">    mask_t _mask;</div><div class=\"line\">    mask_t _occupied;</div><div class=\"line\">    </div><div class=\"line\">    IMP imp(SEL selector)</div><div class=\"line\">    &#123;</div><div class=\"line\">        mask_t begin = _mask &amp; (long long)selector;</div><div class=\"line\">        mask_t i = begin;</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if (_buckets[i]._key == 0  ||  _buckets[i]._key == (long long)selector) &#123;</div><div class=\"line\">                return _buckets[i]._imp;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; while ((i = cache_next(i, _mask)) != begin);</div><div class=\"line\">        return NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct entsize_list_tt &#123;</div><div class=\"line\">    uint32_t entsizeAndFlags;</div><div class=\"line\">    uint32_t count;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_list_t : entsize_list_tt &#123;</div><div class=\"line\">    method_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *type;</div><div class=\"line\">    uint32_t alignment_raw;</div><div class=\"line\">    uint32_t size;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_list_t : entsize_list_tt &#123;</div><div class=\"line\">    ivar_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    const char *attributes;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_list_t : entsize_list_tt &#123;</div><div class=\"line\">    property_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct chained_property_list &#123;</div><div class=\"line\">    chained_property_list *next;</div><div class=\"line\">    uint32_t count;</div><div class=\"line\">    property_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef uintptr_t protocol_ref_t;</div><div class=\"line\">struct protocol_list_t &#123;</div><div class=\"line\">    uintptr_t count;</div><div class=\"line\">    protocol_ref_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t instanceStart;</div><div class=\"line\">    uint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">    uint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">    const uint8_t * ivarLayout;</div><div class=\"line\">    const char * name;  // 类名</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    const ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">    const uint8_t * weakIvarLayout;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\">    method_list_t * methods;    // 方法列表</div><div class=\"line\">    property_list_t *properties;    // 属性列表</div><div class=\"line\">    const protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">    Class firstSubclass;</div><div class=\"line\">    Class nextSiblingClass;</div><div class=\"line\">    char *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</div><div class=\"line\">struct class_data_bits_t &#123;</div><div class=\"line\">    uintptr_t bits;</div><div class=\"line\">public:</div><div class=\"line\">    class_rw_t* data() &#123;</div><div class=\"line\">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* OC对象 */</div><div class=\"line\">struct mj_objc_object &#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* 类对象 */</div><div class=\"line\">struct mj_objc_class : mj_objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;</div><div class=\"line\">    class_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">    class_rw_t* data() &#123;</div><div class=\"line\">        return bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    mj_objc_class* metaClass() &#123;</div><div class=\"line\">        return (mj_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>测试代码是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">\t\tMethod test1Method = class_getInstanceMethod(p.class, @selector(test));</div><div class=\"line\">\t\tMethod test2Method = class_getInstanceMethod(p.class, @selector(test2));</div><div class=\"line\">\t\tIMP imp1= method_getImplementation(test1Method);</div><div class=\"line\">\t\tIMP imp2= method_getImplementation(test2Method);</div><div class=\"line\"></div><div class=\"line\">\t\tmj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class=\"line\">\t\tNSLog(@&quot;-----&quot;);</div><div class=\"line\">\t\t[p test];</div><div class=\"line\">\t\t[p test2];</div><div class=\"line\">\t\tcache_t cache = cls-&gt;cache;</div><div class=\"line\">\t\tbucket_t *buck = cache._buckets;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tfor (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class=\"line\">\t\t\tbucket_t item = buck[i];</div><div class=\"line\">\t\t\tif (item._key != 0) &#123;</div><div class=\"line\">\t\t\t\tNSLog(@&quot;key:%lu imp:%p&quot;,item._key,item._imp);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//输出</div><div class=\"line\">p imp1</div><div class=\"line\">(IMP) $0 = 0x0000000100000df0 (day11-runtime1`-[FYPerson test] at FYPerson.m:12)</div><div class=\"line\">(lldb) p imp2</div><div class=\"line\">(IMP) $1 = 0x0000000100000e20 (day11-runtime1`-[FYPerson test2] at FYPerson.m:15)</div><div class=\"line\">p/d @selector(test)             //输出 test方法的sel地址</div><div class=\"line\">(SEL) $6 = 140734025103231 &quot;test&quot;</div><div class=\"line\">(lldb) p/d @selector(test2)     //输出 test2方法的sel地址</div><div class=\"line\">(SEL) $7 = 4294971267 &quot;test2&quot;</div><div class=\"line\"></div><div class=\"line\">key1:140733954181041 imp1:0x7fff59fc4cd1</div><div class=\"line\">key2:4294971267 imp2:0x100000e20         //对应test2</div><div class=\"line\">key3:140734025103231 imp3:0x100000df0    //对应test1</div></pre></td></tr></table></figure>\n<p>可以看出来<code>IMP1</code>和<code>IMP2</code>、<code>key1</code> 和<code>key2</code>分别对应了<code>bucket_t</code>中的<code>key2</code>,<code>key3</code>和<code>imp2</code>和<code>imp3</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</div><div class=\"line\">&#123;</div><div class=\"line\">    cacheUpdateLock.assertLocked();</div><div class=\"line\"></div><div class=\"line\">    //当initialized 没有执行完毕的时候不缓存</div><div class=\"line\">    if (!cls-&gt;isInitialized()) return;</div><div class=\"line\"></div><div class=\"line\">    // Make sure the entry wasn&apos;t added to the cache by some other thread </div><div class=\"line\">    // before we grabbed the cacheUpdateLock.</div><div class=\"line\">    if (cache_getImp(cls, sel)) return;</div><div class=\"line\"></div><div class=\"line\">    cache_t *cache = getCache(cls);</div><div class=\"line\">    cache_key_t key = getKey(sel);</div><div class=\"line\"></div><div class=\"line\">    // Use the cache as-is if it is less than 3/4 full</div><div class=\"line\">    mask_t newOccupied = cache-&gt;occupied() + 1;</div><div class=\"line\">    mask_t capacity = cache-&gt;capacity();</div><div class=\"line\">    if (cache-&gt;isConstantEmptyCache()) &#123;</div><div class=\"line\">        // Cache is read-only. Replace it.</div><div class=\"line\">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else if (newOccupied &lt;= capacity / 4 * 3) &#123;</div><div class=\"line\">        // Cache &lt;= 3/4 </div><div class=\"line\">    &#125;</div><div class=\"line\">    else &#123;</div><div class=\"line\">        扩容 之后，缓存清空</div><div class=\"line\">        cache-&gt;expand();</div><div class=\"line\">    &#125;</div><div class=\"line\">//bucket_t 最小是4，当&gt;3/4时候，扩容，空间扩容之后是之前的2️倍。</div><div class=\"line\">    bucket_t *bucket = cache-&gt;find(key, receiver);</div><div class=\"line\">    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();</div><div class=\"line\">    bucket-&gt;set(key, imp);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>cache_t</code>初始化是大小是4，当大于3/4时，进行扩容，扩容之后是之前的2倍，数据被清空，<code>cacha-&gt;_occupied</code>恢复为0。<br>验证代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">FYPerson *p = [[FYPerson alloc]init];</div><div class=\"line\">mj_objc_class *cls = (__bridge mj_objc_class *)p.class;</div><div class=\"line\">NSLog(@&quot;-----&quot;);</div><div class=\"line\">[p test];</div><div class=\"line\">/*</div><div class=\"line\"> key:init imp:0x7fff58807c2d</div><div class=\"line\"> key:class imp:0x7fff588084b7</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:test imp:0x100000bf0</div><div class=\"line\"> Program ended with exit code: 0</div><div class=\"line\"> */</div><div class=\"line\">[p test2]; //当执行该函数的时候</div><div class=\"line\">/*</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> key:test2 imp:0x100000c20</div><div class=\"line\"> key:(null) imp:0x0</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">cache_t cache = cls-&gt;cache;</div><div class=\"line\">bucket_t *buck = cache._buckets;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">for (int i = 0; i &lt;= cache._mask; i ++) &#123;</div><div class=\"line\">\tbucket_t item = buck[i];</div><div class=\"line\">//            if (item._key != 0) &#123;</div><div class=\"line\">////                printf(&quot;key:%s imp:%p \\n&quot;,(const char *)item._key,item._imp);</div><div class=\"line\">//            &#125;</div><div class=\"line\">    printf(&quot;key:%s imp:%p \\n&quot;,(const char *)item._key,item._imp);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>arm64之后isa使用联合体用更少的空间存储更多的数据，arm64之前存储class和meta-class指针。</li>\n<li>函数执行会先从cache中查找，没有的话，当再次找到该函数会添加到cache中</li>\n<li>从<code>class-&gt;cache</code>查找<code>bucket_t</code>的key需要先<code>&amp;_mask</code>之后再判断是否有该<code>key</code></li>\n<li>cache扩容在大于3/4进行2倍扩容，扩容之后，旧数据删除，<code>imp</code>个数清空</li>\n<li><code>class-&gt;rw</code>在初始化中讲<code>class_ro_t</code>值赋值给<code>rw</code>,然后<code>rw-&gt;ro</code>指向之前的<code>ro</code>。</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n<li><p><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码</a></p>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n</li>\n</ul>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)","date":"2019-12-01T03:21:58.000Z","_content":"\n只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？\n这篇文章主要讲解线程安全。\n\n### 线程安全\n线程安全是什么呢？摘抄一段[百度百科](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin)的一段话\n> 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。\n\n#### 为什么需要线程安全\nATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。\n\n那么在iOS中，锁是如何使用的呢？\n### 自旋锁 OS_SPINLOCK\n#### 什么是优先级反转\n简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？\n\n假设三个任务准备执行，A，B，C，优先级依次是A>B>C；\n\n首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；\n\n其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；\n\n第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；\n\n第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；\n\n第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。\n\n`OS_SPINLOCK`叫做`自旋锁`，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。\n\n`OS_SPINLOCK`API\n\n```\n//初始化 一般是0，或者直接数字0也是ok的。\n#define\tOS_SPINLOCK_INIT    0\n//锁的初始化\nOSSpinLock lock = OS_SPINLOCK_INIT;\n//尝试加锁\nbool ret = OSSpinLockTry(&lock);\n//加锁\nOSSpinLockLock(&lock);\n//解锁\nOSSpinLockUnlock(&lock);\n```\n\n`OSSpinLock`简单实现12306如何卖票\n\n```\n//基类实现的卖票\n- (void)__saleTicket{\n    NSInteger oldCount = self.ticketsCount;\n\tif (isLog) {\n\t\tsleep(sleepTime);\n\t}\n    oldCount --;\n    self.ticketsCount = oldCount;\n\tif (isLog) {\n\tprintf(\"还剩% 2ld 张票 - %s \\n\",(long)oldCount,[NSThread currentThread].description.UTF8String);\n\t}\n\t\n}\n\n\n\n- (void)ticketTest{\n    self.ticketsCount = 10000;\n\tNSInteger count = self.ticketsCount/3;\n\tdispatch_queue_t queue = dispatch_queue_create(\"tick.com\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n\tdispatch_barrier_async(queue, ^{\n\t\tCFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;\n\t\tprintf(\"tick cost time:%f\",time);\n\t});\n}\n- (void)__getMonery{\n    OSSpinLockLock(&_moneyLock);\n    [super __getMonery];\n    OSSpinLockUnlock(&_moneyLock);\n}\n- (void)__saleTicket{\n    OSSpinLockLock(&_moneyLock);\n    [super __saleTicket];\n    OSSpinLockUnlock(&_moneyLock);\n}\n- (void)__saveMonery{\n    OSSpinLockLock(&_moneyLock);\n    [super __saveMonery];\n    OSSpinLockUnlock(&_moneyLock);\n}\n\n- (void)__saleTicket{\n    NSInteger oldCount = self.ticketsCount;\n    oldCount --;\n    self.ticketsCount = oldCount;\n}\n//log\n还剩 9 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n```\n\n#### 汇编分析\n\n```\nfor (NSInteger i = 0; i < 5; i ++) {\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];\n}\n\n然后将睡眠时间设置为600s，方便我们调试。\n- (void)__saleTicket{\n    OSSpinLockLock(&_moneyLock);//此行打断点\n    [super __saleTicket];\n    OSSpinLockUnlock(&_moneyLock);\n}\n```\n到了断点进入`Debug->Debug WorkFlow ->Always Show Disassembly`，到了汇编界面，在`LLDB`输入`stepi`，然后一直按`enter`，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现`ja`跳转到地址`0x103f3d0f9`，每次执行到`ja`总是跳转到`0x103f3d0f9`，直到线程睡眠结束。\n\n```\n->  0x103f3d0f9 <+241>: movq   %rcx, (%r8)\n0x103f3d0fc <+244>: addq   $0x8, %r8\n0x103f3d100 <+248>: cmpq   %r8, %r9\n0x103f3d103 <+251>: ja     0x103f3d0f9\n```\n可以通过汇编分析了解到`自旋锁`是真的`忙等`，闲不住的锁。\n### os_unfair_lock\n`os_unfair_lock`被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的`OSSpinLock`，而且必须使用`OS_UNFAIR_LOCK_INIT`来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在`__IOS_AVAILABLE(10.0)`，锁的数据结构是一个结构体\n\n```\nOS_UNFAIR_LOCK_AVAILABILITY\ntypedef struct os_unfair_lock_s {\n\tuint32_t _os_unfair_lock_opaque;\n} os_unfair_lock, *os_unfair_lock_t;\n```\n\n`os_unfair_lock`使用非常简单，只需要在任务前加锁，任务后解锁即可。\n\n```\n@interface FYOSUnfairLockDemo : FYBaseDemo\n@property (nonatomic,assign) os_unfair_lock lock;\n@end\n\n@implementation FYOSUnfairLockDemo\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\tself.lock = OS_UNFAIR_LOCK_INIT;\n\t}\n\treturn self;\n}\n\n- (void)__saveMonery{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __saveMonery];\n\tos_unfair_lock_unlock(&_unlock);\n}\n- (void)__getMonery{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __getMonery];\n\tos_unfair_lock_unlock(&_unlock);\n}\n- (void)__saleTicket{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __saleTicket];\n\tos_unfair_lock_unlock(&_unlock);\n}\n@end\n//log\n还剩 9 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n```\n#### 汇编分析\n\n`LLDB` 中命令`stepi`遇到函数会进入到函数，`nexti`会跳过函数。我们将断点打到添加锁的位置\n\n```\n- (void)__saleTicket{\n \tos_unfair_lock_lock(&_unlock);//断点位置\n\t[super __saleTicket];\n\tos_unfair_lock_unlock(&_unlock);\n}\n```\n\n执行`si`,一直`enter`，最终是停止该位子，模拟器缺跳出来了，再`enter`也没用了，因为线程在睡眠了。`syscall`是调用系统函数的命令。\n\n```\nlibsystem_kernel.dylib`__ulock_wait:\n    0x107a3b9d4 <+0>:  movl   $0x2000203, %eax          ; imm = 0x2000203 \n    0x107a3b9d9 <+5>:  movq   %rcx, %r10\n->  0x107a3b9dc <+8>:  syscall\n```\n\n\n### 互斥锁 pthread_mutex_t\n`mutex`叫互斥锁，等待锁的线程会处于休眠状态。\n\n\n\n```\n-(void)dealloc{\n\tpthread_mutex_destroy(&_plock);\n\tpthread_mutexattr_destroy(&t);\n}\n-(instancetype)init{\n\tif (self =[super init]) {\n\t\t//初始化锁的属性 \n//\t\tpthread_mutexattr_init(&t);\n//\t\tpthread_mutexattr_settype(&t, PTHREAD_MUTEX_NORMAL);\n//\t\t//初始化锁\n//\t\tpthread_mutex_init(&_plock, &t);\n\t\t\n\t\tpthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;\n\t\tself.plock = plock;\n\t}\n\treturn self;\n}\n-(void)__saleTicket{\n\tpthread_mutex_lock(&_plock);\n\t[super __saleTicket];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)__getMonery{\n\tpthread_mutex_lock(&_plock);\n\t[super __getMonery];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)__saveMonery{\n\tpthread_mutex_lock(&_plock);\n\t[super __saveMonery];\n\tpthread_mutex_unlock(&_plock);\n}\n//log\n\n还剩 9 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 4 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 5 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 6 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n```\n互斥锁有三个类型\n\n```\n/*\n * Mutex type attributes\n */\n 普通锁\n#define PTHREAD_MUTEX_NORMAL\t\t0\n//检查错误\n#define PTHREAD_MUTEX_ERRORCHECK\t1\n//递归锁\n#define PTHREAD_MUTEX_RECURSIVE\t\t2\n//普通锁\n#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL\n```\n当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。\n\n```\n- (void)otherTest{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\t[self otherTest2];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)otherTest2{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\tpthread_mutex_unlock(&_plock);\n}\n\n//log\n-[FYPthread_mutex2 otherTest]\n```\n上面这个需求需要使用两把锁，或者使用递归锁来解决问题。\n\n```\n- (void)otherTest{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\t[self otherTest2];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)otherTest2{\n\tpthread_mutex_lock(&_plock2);\n\tNSLog(@\"%s\",__func__);\n\tpthread_mutex_unlock(&_plock2);\n}\n\n//log\n-[FYPthread_mutex2 otherTest]\n-[FYPthread_mutex2 otherTest2]\n```\n从使用2把锁是可以解决这个问题的。\n递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。\n\n### NSLock、NSRecursiveLosk\n\n`NSLock`是对`mutex`普通锁的封装\n\n使用`(LLDB) si`可以跟踪`[myLock lock];`的内部函数最终是`pthread_mutex_lock`\n\n```\nFoundation`-[NSLock lock]:\n    0x1090dfb5a <+0>:  pushq  %rbp\n    0x1090dfb5b <+1>:  movq   %rsp, %rbp\n    0x1090dfb5e <+4>:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars\n    0x1090dfb63 <+9>:  movq   %rax, %rdi\n    0x1090dfb66 <+12>: popq   %rbp\n->  0x1090dfb67 <+13>: jmp    0x1092ca596   ;\n//  symbol stub for: pthread_mutex_lock\n```\n\n`NSLock API`大全\n\n```\n//协议NSLocking\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n- (BOOL)tryLock;//尝试加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n@end\n```\n用法也很简单\n\n```\n@interface FYNSLock(){\n\tNSLock *_lock;\n}\n@end\n\n@implementation FYNSLock\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//封装了mutex的普通锁\n\t\t_lock=[[NSLock alloc]init];\n\t}\n\treturn self;\n}\n\n- (void)__saveMonery{\n\t[_lock lock];\n\t[super __saveMonery];\n\t[_lock unlock];\n}\n- (void)__saleTicket{\n\t[_lock lock];\n\t[super __saleTicket];\n\t[_lock unlock];\n}\n- (void)__getMonery{\n\t[_lock lock];\n\t[super __getMonery];\n\t[_lock unlock];\n}\n@end\n//log\n\n还剩 9 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n```\n`NSRecursiveLock`也是对`mutex递归锁`的封装，`API`跟`NSLock`基本一致\n\n```\n- (BOOL)tryLock;//尝试加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁\n```\n\n\n递归锁可以对相同的线程进行反复加锁\n\n```\n@implementation FYRecursiveLockDemo\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//封装了mutex的递归锁\n\t\t_lock=[[NSRecursiveLock alloc]init];\n\t}\n\treturn self;\n}\n- (void)otherTest{\n\tstatic int count = 10;\n\t[_lock lock];\n\twhile (count > 0) {\n\t\tcount -= 1;\n\t\tprintf(\"循环% 2d次 - %s \\n\",count,[NSThread currentThread].description.UTF8String);\n\t\t[self otherTest];\n\t}\n\t[_lock unlock];\n}\n@end\n\n//log\n循环 9次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 8次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 7次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 6次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 5次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 4次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 3次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 2次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 1次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 0次 - <NSThread: 0x60000274e900>{number = 1, name = main}\n```\n### NSCondition 条件\n\n```\n- (void)wait;//等待\n- (BOOL)waitUntilDate:(NSDate *)limit;\n- (void)signal;//唤醒一个线程\n- (void)broadcast;//唤醒多个线程\n```\n\n`NSCondition`是对`mutex`和`cond`的封装\n\n```\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//遵守的 lock协议 的 条件🔐\n\t\t_lock=[[NSCondition alloc]init];\n\t\tself.array =[NSMutableArray array];\n\t}\n\treturn self;\n}\n- (void)otherTest{\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];\n}\n- (void)__add{\n\t[_lock lock];\n\t[self.array addObject:@\"Test\"];\n\tNSLog(@\"添加成功\");\n\tsleep(1);\n\t[_lock signal];//唤醒一个线程\n\t[_lock unlock];\n}\n- (void)__remove{\n\t[_lock lock];\n\tif (self.array.count == 0) {\n\t\t[_lock wait];\n\t}\n\t[self.array removeLastObject];\n\tNSLog(@\"删除成功\");\n\n\t[_lock unlock];\n}\n@end\n//Log\n\n2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功\n2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功\n```\n可以看到时间上差了1秒，正好是我们设定的`sleep(1);`。优点是可以让线程之间形成依赖，缺点是没有明确的条件。\n\n\n### NSConditionLock 可以实现线程依赖的锁\n`NSConditionLock`是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用`NSConditionLock`来解决问题。\n首先看下`API`\n\n```\n@property (readonly) NSInteger condition;//条件值\n- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住\n//尝试加锁\n- (BOOL)tryLock;\n//当con为condition进行尝试锁住\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n//当con为condition进行解锁\n- (void)unlockWithCondition:(NSInteger)condition;\n//NSDate 小余 limit进行 加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n//条件为condition 在limit之前进行加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n```\n\n条件锁的使用，在`lockWhenCondition:(NSInteger)condition`的条件到达的时候才能进行正常的加锁和`unlockWithCondition:(NSInteger)condition`解锁，否则会阻塞线程。\n\n```\n- (void)otherTest{\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];\n\n}\n- (void)__test1{\n\t[_lock lockWhenCondition:1];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:2];//解锁 并赋值2\n}\n- (void)__test2{\n\t[_lock lockWhenCondition:2];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:3];//解锁 并赋值3\n}\n- (void)__test3{\n\t[_lock lockWhenCondition:3];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:4];//解锁 并赋值4\n}\n@end\n//log\n-[FYCondLockDemo2 __test1]\n-[FYCondLockDemo2 __test2]\n-[FYCondLockDemo2 __test3]\n```\n\n当`con = 1`进行`test1`加锁和执行任务`A`，任务`A`执行完毕，进行解锁，并把值2赋值给`lock`，这是当`con = 2`的锁开始加锁，进入任务`B`，开始执行任务`B`，当任务`B`执行完毕，进行解锁并赋值为3，然后`con=3`的锁进行加锁，解锁并赋值4来进行线程之间的依赖。\n### dispatch_queue 特殊的锁\n其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。\n\n```\n@interface FYSerialQueueDemo(){\n\tdispatch_queue_t _queue;\n}@end\n@implementation FYSerialQueueDemo\n- (instancetype)init{\n\tif (self =[super init]) {\n\t\t_queue = dispatch_queue_create(\"fyserial.queue\", DISPATCH_QUEUE_SERIAL);\n\t}\n\treturn self;\n}\n- (void)__saleTicket{\n\tdispatch_sync(_queue, ^{\n\t\t[super __saleTicket];\n\t});\n}\n- (void)__getMonery{\n\tdispatch_sync(_queue, ^{\n\t\t[super __getMonery];\n\t});\n}\n- (void)__saveMonery{\n\tdispatch_sync(_queue, ^{\n\t\t[super __saveMonery];\n\t});\n}\n@end\n//log\n还剩 9 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)}\n```\n\n### dispatch_semaphore 信号量控制并发数量\n当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？`dispatch_semaphore`信号量正好可以满足我们的需求。\n`dispatch_semaphore`可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。\n\n```\n//初始化信号量 值为2，就是最多允许同时2个线程执行\n_semaphore = dispatch_semaphore_create(2);\n//生成多个线程进行并发访问test\n- (void)otherTest{\n\tfor (int i = 0; i < 10; i ++) {\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];\n\t}\n}\n- (void)test{\n//如果信号量>0 ，让信号量-1，继续向下执行。\n//如果信号量 <= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER\n\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);\n\tsleep(2);//睡眠时间2s\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\t//释放一个信号量\n\tdispatch_semaphore_signal(_semaphore);\n}\n//log\n\n2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] <NSThread: 0x600002c45240>{number = 4, name = (null)}\n2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] <NSThread: 0x600002c45200>{number = 3, name = (null)}\n2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] <NSThread: 0x600002c45540>{number = 10, name = (null)}\n2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] <NSThread: 0x600002c45440>{number = 6, name = (null)}\n2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] <NSThread: 0x600002c45480>{number = 7, name = (null)}\n2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] <NSThread: 0x600002c454c0>{number = 8, name = (null)}\n2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] <NSThread: 0x600002c45500>{number = 9, name = (null)}\n2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] <NSThread: 0x600002c45400>{number = 5, name = (null)}\n2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] <NSThread: 0x600002c455c0>{number = 12, name = (null)}\n2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] <NSThread: 0x600002c45580>{number = 11, name = (null)}\n```\n\n一次最多2个线程同时执行任务，暂停时间是2s。\n使用信号量实现线程最大并发锁，\n同时只有2个线程执行的。\n\n```\n- (instancetype)init{\n\tif (self =[super init]) {\n\t\t_semaphore = dispatch_semaphore_create(1);\n\t}\n\treturn self;\n}\n- (void)__saleTicket{\n\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);\n\t[super __saleTicket];\n\tdispatch_semaphore_signal(_semaphore);\n}\n//log\n还剩 9 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n```\n\n### @synchronized\n`@synchronized(id obj){}`锁的是对象`obj`，使用该锁的时候，底层是对象计算出来的值作为`key`，生成一把锁，不同的资源的读写可以使用不同`obj`作为锁对象。\n\n```\n- (void)__saleTicket{\n\t@synchronized (self) {\n\t\t[super __saleTicket];\n\t}\n }\n //log\n还剩 9 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n```\n\n### atmoic 原子操作\n给属性添加`atmoic`修饰，可以保证属性的`setter`和`getter`都是原子性操作，也就保证了`setter`和`getter`的内部是线程同步的。\n原子操作是最终调用了`static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行`，我们进入到函数内部\n\n```\n//设置属性原子操作\nvoid objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)\n{\n    reallySetProperty(self, _cmd, newValue, offset, true, false, false);\n}\n//非原子操作设置属性\nvoid objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)\n{\n    reallySetProperty(self, _cmd, newValue, offset, false, false, false);\n}\n\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{//偏移量等于0则是class指针\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n//其他的value\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n    //如果是copy 用copyWithZone:\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        //mutableCopy则调用mutableCopyWithZone:\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n    //如果赋值和原来的相等 则不操作\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {//非原子操作 直接赋值\n        oldValue = *slot;\n        *slot = newValue;\n    } else {//原子操作 加锁\n    //锁和属性是一一对应的->自旋锁\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;//赋值\n        slotlock.unlock();//解锁\n    }\n    objc_release(oldValue);\n}\n\n\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    // Retain release world\n    id *slot = (id*) ((char*)self + offset);\n    if (!atomic) return *slot;//非原子操作 直接返回值\n        \n    // Atomic retain release world\n\t//原子操作 加锁->自旋锁\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();//加锁\n    id value = objc_retain(*slot);\n    slotlock.unlock();//解锁\n    \n    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.\n    return objc_autoreleaseReturnValue(value);\n}\n\n//以属性的地址为参数计算出key ，锁为value\nStripedMap<spinlock_t> PropertyLocks;\n```\n从源码了解到设置属性读取是`self`+属性的偏移量，当`copy`或`mutableCopy`会调用到`[newValue copyWithZone:nil]`或`[newValue mutableCopyWithZone:nil]`，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取`spinlock_t& slotlock = PropertyLocks[slot]`进行加锁、赋值、解锁操作。而且`PropertyLocks`是一个类，类有一个数组属性，使用`*p`计算出来的值作为`key`。\n\n我们提取出来关键代码\n\n```\n//原子操作 加锁\nspinlock_t& slotlock = PropertyLocks[slot];\nslotlock.lock();\noldValue = *slot;\n*slot = newValue;//赋值\nslotlock.unlock();//解锁\n```\n使用自旋锁对赋值操作进行加锁，保证了`setter()`方法的安全性\n\n```\n//原子操作 加锁 ->自旋锁\nspinlock_t& slotlock = PropertyLocks[slot];\nslotlock.lock();//加锁\nid value = objc_retain(*slot);\nslotlock.unlock();//解锁\n```\n取值之前进行加锁，取值之后进行解锁，保证了`getter()`方法的安全。\n\n由上面得知`atmoic`仅仅是对方法`setter()`和`getter()`安全，对成员变量不保证安全，对于属性的读写一般使用`nonatomic`，性能好，`atomic`读取频率高的时候会导致线程都在排队，浪费CPU时间。\n\n大概使用者几种锁分别对卖票功能进行了性能测试，\n性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)\n\n|锁类型|1万次|100万次|1000万次|\n|:-:|:-:|:-:|:-:|\n|pthread_mutex_t|0.000309|0.027238|0.284714|\n|os_unfair_lock|0.000274|0.028266|0.285685|\n|OSSpinLock|0.030688|0.410067|0.437702|\n|NSCondition|0.005067 |0.323492|1.078636|\n|NSLock|0.038692|0.151601|1.322062|\n|NSRecursiveLock|0.007973|0.151601|1.673409|\n|@synchronized|0.008953|0.640234|2.790291|\n|NSConditionLock|0.229148  |5.325272|10.681123|\n|semaphore|0.094267|0.415351|24.699100|\n|SerialQueue|0.213386|9.058581|50.820202|\n\n### 建议\n平时我们简单使用的话没有很大的区别，还是推荐使用`NSLock`和信号量,最简单的是`@synchronized`，不用声明和初始化，直接拿来就用。\n\n### 自旋锁、互斥锁比较\n自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。\n#### 自旋锁\n- 自旋锁在等待时间比较短的时候比较合适\n- 临界区代码经常被调用，但竞争很少发生\n- CPU不紧张\n- 多核处理器\n#### 互斥锁\n- 预计线程等待时间比较长\n- 单核处理器\n- 临界区IO操作\n- 临界区代码比较多、复杂，或者循环量大\n- 临界区竞争非常激烈\n\n## 锁的应用\n#### 简单读写锁\n一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.semaphore = dispatch_semaphore_create(1);\n\t\n\tfor (NSInteger i = 0; i < 10; i ++) {\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];\n\t}\n}\n\n- (void)read{\n\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n\tNSLog(@\"%s\",__func__);\n\tdispatch_semaphore_signal(self.semaphore);\n}\n- (void)write{\n\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n\tNSLog(@\"%s\",__func__);\n\tdispatch_semaphore_signal(self.semaphore);\n}\n```\n\n当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点\n1. 同一时间，只能有1个线程进行写操作\n2. 同一时间，允许有多个线程进行读的操作\n3. 同一时间，不允许读写操作同时进行\n\n典型的`多读单写`，经常用于文件等数据的读写操作，我们实现2种\n\n#### 读写锁 pthread_rwlock\n这是有c语言封装的读写锁\n\n```\n//初始化读写锁\nint pthread_rwlock_init(pthread_rwlock_t * __restrict,\n\t\tconst pthread_rwlockattr_t * _Nullable __restrict)\n//读上锁\npthread_rwlock_rdlock(pthread_rwlock_t *)\n//尝试加锁读\npthread_rwlock_tryrdlock(pthread_rwlock_t *)\n//尝试加锁写\nint pthread_rwlock_trywrlock(pthread_rwlock_t *)\n//写入加锁\npthread_rwlock_wrlock(pthread_rwlock_t *)\n//解锁\npthread_rwlock_unlock(pthread_rwlock_t *)\n//销毁锁属性\npthread_rwlockattr_destroy(pthread_rwlockattr_t *)\n//销毁锁\npthread_rwlock_destroy(pthread_rwlock_t * )\n```\n\n`pthread_rwlock_t`使用很简单，只需要在读之前使用`pthread_rwlock_rdlock`，读完解锁`pthread_rwlock_unlock`,写入前需要加锁`pthread_rwlock_wrlock`，写入完成之后解锁`pthread_rwlock_unlock`，任务都执行完了可以选择销毁`pthread_rwlock_destroy`或者等待下次使用。\n\n```\n@property (nonatomic,assign) pthread_rwlock_t rwlock;\n\n\n- (void)dealloc{\n\tpthread_rwlock_destroy(&_rwlock);//销毁锁\n}\n//初始化读写锁\npthread_rwlock_init(&_rwlock, NULL);\n\t\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];\n\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];\n\t\t});\n\t}\n\t\n\t\n- (void)readPthreadRWLock{\n    pthread_rwlock_rdlock(&_rwlock);\n    NSLog(@\"读文件\");\n    sleep(1);\n    pthread_rwlock_unlock(&_rwlock);\n}\n- (void)writePthreadRWLock{\n    pthread_rwlock_wrlock(&_rwlock);\n    NSLog(@\" 写入文件\");\n    sleep(1);\n    pthread_rwlock_unlock(&_rwlock);\n}\n\n//log\n2019-07-30 10:47:16 读文件\n2019-07-30 10:47:16 读文件\n2019-07-30 10:47:17 写入文件\n2019-07-30 10:47:18 写入文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:20 写入文件\n2019-07-30 10:47:21 写入文件\n2019-07-30 10:47:22 写入文件\n```\n读文件会出现同一秒读多次，写文件同一秒只有一个。\n\n#### 异步栅栏调用 dispatch_barrier_async\n栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序\n\n|操作|任务|任务|任务|\n|:-:|:-:|:-:|:-:|\n|读|A|B||\n|读|A|B||\n|写|||C|\n|写|||C|\n|读|A|||\n|读|A|B||\n\n\n这个函数传入的并发队列必须是通过`dispatch_queue_create`创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于`dispatch_async`的效果。\n\n```\n//初始化 异步队列\nself.rwqueue = dispatch_queue_create(\"rw.thread\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\nfor (NSInteger i = 0; i < 5; i ++) {\n\tdispatch_async(queue, ^{\n\t\t[self readBarryier];\n\t\t[self readBarryier];\n\t\t[self readBarryier];\n\t\t[self writeBarrier];\n\t});\n}\n\n- (void)readBarryier{\n//添加任务到rwqueue\n\tdispatch_async(self.rwqueue, ^{\n\t\tNSLog(@\"读文件 %@\",[NSThread currentThread]);\n\t\tsleep(1);\n\t});\n}\n- (void)writeBarrier{\n//barrier_async添加任务到self.rwqueue中\n\tdispatch_barrier_async(self.rwqueue, ^{\n\t\tNSLog(@\"写入文件 %@\",[NSThread currentThread]);\n\t\tsleep(1);\n\t});\n}\n\n//log\n\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae0740>{number = 9, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae8500>{number = 10, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae8040>{number = 8, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:54 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:55 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:56 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n```\n读文件会出现同一秒读多个，写文件同一秒只有一个。\n\n\n读写任务都添加到异步队列`rwqueue`中，使用栅栏函数`dispatch_barrier_async`拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。\n\n\n### 总结\n- 普通线程锁本质就是同步执行\n- `atomic`原子操作只限制`setter`和`getter`方法，不限制成员变量\n- 读写锁高性能可以使用`pthread_rwlock_t`和`dispatch_barrier_async`\n### 参考资料\n- [优先级反转](https://blog.csdn.net/Fly_as_tadpole/article/details/86436161 )\n- [iOS多线程：『GCD』详尽总结](https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n- iOS和OS多线程与内存管理\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","source":"_posts/iOS底层原理 多线程之安全锁以及常用的读写锁 --(11).md","raw":"title: iOS底层原理  多线程之安全锁以及常用的读写锁 --(11)\ndate: 2019-12-1 11:21:58\ntags:\n- iOS\ncategories: iOS\n---\n\n只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？\n这篇文章主要讲解线程安全。\n\n### 线程安全\n线程安全是什么呢？摘抄一段[百度百科](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin)的一段话\n> 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。\n\n#### 为什么需要线程安全\nATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。\n\n那么在iOS中，锁是如何使用的呢？\n### 自旋锁 OS_SPINLOCK\n#### 什么是优先级反转\n简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？\n\n假设三个任务准备执行，A，B，C，优先级依次是A>B>C；\n\n首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；\n\n其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；\n\n第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；\n\n第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；\n\n第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。\n\n`OS_SPINLOCK`叫做`自旋锁`，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。\n\n`OS_SPINLOCK`API\n\n```\n//初始化 一般是0，或者直接数字0也是ok的。\n#define\tOS_SPINLOCK_INIT    0\n//锁的初始化\nOSSpinLock lock = OS_SPINLOCK_INIT;\n//尝试加锁\nbool ret = OSSpinLockTry(&lock);\n//加锁\nOSSpinLockLock(&lock);\n//解锁\nOSSpinLockUnlock(&lock);\n```\n\n`OSSpinLock`简单实现12306如何卖票\n\n```\n//基类实现的卖票\n- (void)__saleTicket{\n    NSInteger oldCount = self.ticketsCount;\n\tif (isLog) {\n\t\tsleep(sleepTime);\n\t}\n    oldCount --;\n    self.ticketsCount = oldCount;\n\tif (isLog) {\n\tprintf(\"还剩% 2ld 张票 - %s \\n\",(long)oldCount,[NSThread currentThread].description.UTF8String);\n\t}\n\t\n}\n\n\n\n- (void)ticketTest{\n    self.ticketsCount = 10000;\n\tNSInteger count = self.ticketsCount/3;\n\tdispatch_queue_t queue = dispatch_queue_create(\"tick.com\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n    \n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n    dispatch_async(queue, ^{\n\t\tif (time1 == 0) {\n\t\t\ttime1 = CFAbsoluteTimeGetCurrent();\n\t\t}\n        for (int i = 0; i < count; i ++) {\n            [self __saleTicket];\n        }\n    });\n\tdispatch_barrier_async(queue, ^{\n\t\tCFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;\n\t\tprintf(\"tick cost time:%f\",time);\n\t});\n}\n- (void)__getMonery{\n    OSSpinLockLock(&_moneyLock);\n    [super __getMonery];\n    OSSpinLockUnlock(&_moneyLock);\n}\n- (void)__saleTicket{\n    OSSpinLockLock(&_moneyLock);\n    [super __saleTicket];\n    OSSpinLockUnlock(&_moneyLock);\n}\n- (void)__saveMonery{\n    OSSpinLockLock(&_moneyLock);\n    [super __saveMonery];\n    OSSpinLockUnlock(&_moneyLock);\n}\n\n- (void)__saleTicket{\n    NSInteger oldCount = self.ticketsCount;\n    oldCount --;\n    self.ticketsCount = oldCount;\n}\n//log\n还剩 9 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600003dc6080>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600003df3a00>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600003dc0000>{number = 5, name = (null)} \n```\n\n#### 汇编分析\n\n```\nfor (NSInteger i = 0; i < 5; i ++) {\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];\n}\n\n然后将睡眠时间设置为600s，方便我们调试。\n- (void)__saleTicket{\n    OSSpinLockLock(&_moneyLock);//此行打断点\n    [super __saleTicket];\n    OSSpinLockUnlock(&_moneyLock);\n}\n```\n到了断点进入`Debug->Debug WorkFlow ->Always Show Disassembly`，到了汇编界面，在`LLDB`输入`stepi`，然后一直按`enter`，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现`ja`跳转到地址`0x103f3d0f9`，每次执行到`ja`总是跳转到`0x103f3d0f9`，直到线程睡眠结束。\n\n```\n->  0x103f3d0f9 <+241>: movq   %rcx, (%r8)\n0x103f3d0fc <+244>: addq   $0x8, %r8\n0x103f3d100 <+248>: cmpq   %r8, %r9\n0x103f3d103 <+251>: ja     0x103f3d0f9\n```\n可以通过汇编分析了解到`自旋锁`是真的`忙等`，闲不住的锁。\n### os_unfair_lock\n`os_unfair_lock`被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的`OSSpinLock`，而且必须使用`OS_UNFAIR_LOCK_INIT`来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在`__IOS_AVAILABLE(10.0)`，锁的数据结构是一个结构体\n\n```\nOS_UNFAIR_LOCK_AVAILABILITY\ntypedef struct os_unfair_lock_s {\n\tuint32_t _os_unfair_lock_opaque;\n} os_unfair_lock, *os_unfair_lock_t;\n```\n\n`os_unfair_lock`使用非常简单，只需要在任务前加锁，任务后解锁即可。\n\n```\n@interface FYOSUnfairLockDemo : FYBaseDemo\n@property (nonatomic,assign) os_unfair_lock lock;\n@end\n\n@implementation FYOSUnfairLockDemo\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\tself.lock = OS_UNFAIR_LOCK_INIT;\n\t}\n\treturn self;\n}\n\n- (void)__saveMonery{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __saveMonery];\n\tos_unfair_lock_unlock(&_unlock);\n}\n- (void)__getMonery{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __getMonery];\n\tos_unfair_lock_unlock(&_unlock);\n}\n- (void)__saleTicket{\n\tos_unfair_lock_lock(&_unlock);\n\t[super __saleTicket];\n\tos_unfair_lock_unlock(&_unlock);\n}\n@end\n//log\n还剩 9 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600002eb4bc0>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600002eb1500>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600002ed4340>{number = 5, name = (null)} \n```\n#### 汇编分析\n\n`LLDB` 中命令`stepi`遇到函数会进入到函数，`nexti`会跳过函数。我们将断点打到添加锁的位置\n\n```\n- (void)__saleTicket{\n \tos_unfair_lock_lock(&_unlock);//断点位置\n\t[super __saleTicket];\n\tos_unfair_lock_unlock(&_unlock);\n}\n```\n\n执行`si`,一直`enter`，最终是停止该位子，模拟器缺跳出来了，再`enter`也没用了，因为线程在睡眠了。`syscall`是调用系统函数的命令。\n\n```\nlibsystem_kernel.dylib`__ulock_wait:\n    0x107a3b9d4 <+0>:  movl   $0x2000203, %eax          ; imm = 0x2000203 \n    0x107a3b9d9 <+5>:  movq   %rcx, %r10\n->  0x107a3b9dc <+8>:  syscall\n```\n\n\n### 互斥锁 pthread_mutex_t\n`mutex`叫互斥锁，等待锁的线程会处于休眠状态。\n\n\n\n```\n-(void)dealloc{\n\tpthread_mutex_destroy(&_plock);\n\tpthread_mutexattr_destroy(&t);\n}\n-(instancetype)init{\n\tif (self =[super init]) {\n\t\t//初始化锁的属性 \n//\t\tpthread_mutexattr_init(&t);\n//\t\tpthread_mutexattr_settype(&t, PTHREAD_MUTEX_NORMAL);\n//\t\t//初始化锁\n//\t\tpthread_mutex_init(&_plock, &t);\n\t\t\n\t\tpthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;\n\t\tself.plock = plock;\n\t}\n\treturn self;\n}\n-(void)__saleTicket{\n\tpthread_mutex_lock(&_plock);\n\t[super __saleTicket];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)__getMonery{\n\tpthread_mutex_lock(&_plock);\n\t[super __getMonery];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)__saveMonery{\n\tpthread_mutex_lock(&_plock);\n\t[super __saveMonery];\n\tpthread_mutex_unlock(&_plock);\n}\n//log\n\n还剩 9 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 4 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x6000014c8f40>{number = 5, name = (null)} \n还剩 5 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 6 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x6000014c8d80>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x6000014e3600>{number = 3, name = (null)} \n```\n互斥锁有三个类型\n\n```\n/*\n * Mutex type attributes\n */\n 普通锁\n#define PTHREAD_MUTEX_NORMAL\t\t0\n//检查错误\n#define PTHREAD_MUTEX_ERRORCHECK\t1\n//递归锁\n#define PTHREAD_MUTEX_RECURSIVE\t\t2\n//普通锁\n#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL\n```\n当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。\n\n```\n- (void)otherTest{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\t[self otherTest2];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)otherTest2{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\tpthread_mutex_unlock(&_plock);\n}\n\n//log\n-[FYPthread_mutex2 otherTest]\n```\n上面这个需求需要使用两把锁，或者使用递归锁来解决问题。\n\n```\n- (void)otherTest{\n\tpthread_mutex_lock(&_plock);\n\tNSLog(@\"%s\",__func__);\n\t[self otherTest2];\n\tpthread_mutex_unlock(&_plock);\n}\n- (void)otherTest2{\n\tpthread_mutex_lock(&_plock2);\n\tNSLog(@\"%s\",__func__);\n\tpthread_mutex_unlock(&_plock2);\n}\n\n//log\n-[FYPthread_mutex2 otherTest]\n-[FYPthread_mutex2 otherTest2]\n```\n从使用2把锁是可以解决这个问题的。\n递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。\n\n### NSLock、NSRecursiveLosk\n\n`NSLock`是对`mutex`普通锁的封装\n\n使用`(LLDB) si`可以跟踪`[myLock lock];`的内部函数最终是`pthread_mutex_lock`\n\n```\nFoundation`-[NSLock lock]:\n    0x1090dfb5a <+0>:  pushq  %rbp\n    0x1090dfb5b <+1>:  movq   %rsp, %rbp\n    0x1090dfb5e <+4>:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars\n    0x1090dfb63 <+9>:  movq   %rax, %rdi\n    0x1090dfb66 <+12>: popq   %rbp\n->  0x1090dfb67 <+13>: jmp    0x1092ca596   ;\n//  symbol stub for: pthread_mutex_lock\n```\n\n`NSLock API`大全\n\n```\n//协议NSLocking\n@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n\n@interface NSLock : NSObject <NSLocking> {\n@private\n    void *_priv;\n}\n- (BOOL)tryLock;//尝试加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，\n@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));\n@end\n```\n用法也很简单\n\n```\n@interface FYNSLock(){\n\tNSLock *_lock;\n}\n@end\n\n@implementation FYNSLock\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//封装了mutex的普通锁\n\t\t_lock=[[NSLock alloc]init];\n\t}\n\treturn self;\n}\n\n- (void)__saveMonery{\n\t[_lock lock];\n\t[super __saveMonery];\n\t[_lock unlock];\n}\n- (void)__saleTicket{\n\t[_lock lock];\n\t[super __saleTicket];\n\t[_lock unlock];\n}\n- (void)__getMonery{\n\t[_lock lock];\n\t[super __getMonery];\n\t[_lock unlock];\n}\n@end\n//log\n\n还剩 9 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 7 张票 - <NSThread: 0x600003d4dc40>{number = 3, name = (null)} \n还剩 6 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 5 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x600003d7bfc0>{number = 4, name = (null)} \n还剩 3 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n还剩 2 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n还剩 1 张票 - <NSThread: 0x600003d66c00>{number = 5, name = (null)} \n```\n`NSRecursiveLock`也是对`mutex递归锁`的封装，`API`跟`NSLock`基本一致\n\n```\n- (BOOL)tryLock;//尝试加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁\n```\n\n\n递归锁可以对相同的线程进行反复加锁\n\n```\n@implementation FYRecursiveLockDemo\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//封装了mutex的递归锁\n\t\t_lock=[[NSRecursiveLock alloc]init];\n\t}\n\treturn self;\n}\n- (void)otherTest{\n\tstatic int count = 10;\n\t[_lock lock];\n\twhile (count > 0) {\n\t\tcount -= 1;\n\t\tprintf(\"循环% 2d次 - %s \\n\",count,[NSThread currentThread].description.UTF8String);\n\t\t[self otherTest];\n\t}\n\t[_lock unlock];\n}\n@end\n\n//log\n循环 9次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 8次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 7次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 6次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 5次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 4次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 3次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 2次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 1次 - <NSThread: 0x60000274e900>{number = 1, name = main} \n循环 0次 - <NSThread: 0x60000274e900>{number = 1, name = main}\n```\n### NSCondition 条件\n\n```\n- (void)wait;//等待\n- (BOOL)waitUntilDate:(NSDate *)limit;\n- (void)signal;//唤醒一个线程\n- (void)broadcast;//唤醒多个线程\n```\n\n`NSCondition`是对`mutex`和`cond`的封装\n\n```\n- (instancetype)init{\n\tif (self = [super init]) {\n\t\t//遵守的 lock协议 的 条件🔐\n\t\t_lock=[[NSCondition alloc]init];\n\t\tself.array =[NSMutableArray array];\n\t}\n\treturn self;\n}\n- (void)otherTest{\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];\n}\n- (void)__add{\n\t[_lock lock];\n\t[self.array addObject:@\"Test\"];\n\tNSLog(@\"添加成功\");\n\tsleep(1);\n\t[_lock signal];//唤醒一个线程\n\t[_lock unlock];\n}\n- (void)__remove{\n\t[_lock lock];\n\tif (self.array.count == 0) {\n\t\t[_lock wait];\n\t}\n\t[self.array removeLastObject];\n\tNSLog(@\"删除成功\");\n\n\t[_lock unlock];\n}\n@end\n//Log\n\n2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功\n2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功\n```\n可以看到时间上差了1秒，正好是我们设定的`sleep(1);`。优点是可以让线程之间形成依赖，缺点是没有明确的条件。\n\n\n### NSConditionLock 可以实现线程依赖的锁\n`NSConditionLock`是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用`NSConditionLock`来解决问题。\n首先看下`API`\n\n```\n@property (readonly) NSInteger condition;//条件值\n- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住\n//尝试加锁\n- (BOOL)tryLock;\n//当con为condition进行尝试锁住\n- (BOOL)tryLockWhenCondition:(NSInteger)condition;\n//当con为condition进行解锁\n- (void)unlockWithCondition:(NSInteger)condition;\n//NSDate 小余 limit进行 加锁\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n//条件为condition 在limit之前进行加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;\n```\n\n条件锁的使用，在`lockWhenCondition:(NSInteger)condition`的条件到达的时候才能进行正常的加锁和`unlockWithCondition:(NSInteger)condition`解锁，否则会阻塞线程。\n\n```\n- (void)otherTest{\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];\n\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];\n\n}\n- (void)__test1{\n\t[_lock lockWhenCondition:1];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:2];//解锁 并赋值2\n}\n- (void)__test2{\n\t[_lock lockWhenCondition:2];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:3];//解锁 并赋值3\n}\n- (void)__test3{\n\t[_lock lockWhenCondition:3];\n\tNSLog(@\"%s\",__func__);\n\t[_lock unlockWithCondition:4];//解锁 并赋值4\n}\n@end\n//log\n-[FYCondLockDemo2 __test1]\n-[FYCondLockDemo2 __test2]\n-[FYCondLockDemo2 __test3]\n```\n\n当`con = 1`进行`test1`加锁和执行任务`A`，任务`A`执行完毕，进行解锁，并把值2赋值给`lock`，这是当`con = 2`的锁开始加锁，进入任务`B`，开始执行任务`B`，当任务`B`执行完毕，进行解锁并赋值为3，然后`con=3`的锁进行加锁，解锁并赋值4来进行线程之间的依赖。\n### dispatch_queue 特殊的锁\n其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。\n\n```\n@interface FYSerialQueueDemo(){\n\tdispatch_queue_t _queue;\n}@end\n@implementation FYSerialQueueDemo\n- (instancetype)init{\n\tif (self =[super init]) {\n\t\t_queue = dispatch_queue_create(\"fyserial.queue\", DISPATCH_QUEUE_SERIAL);\n\t}\n\treturn self;\n}\n- (void)__saleTicket{\n\tdispatch_sync(_queue, ^{\n\t\t[super __saleTicket];\n\t});\n}\n- (void)__getMonery{\n\tdispatch_sync(_queue, ^{\n\t\t[super __getMonery];\n\t});\n}\n- (void)__saveMonery{\n\tdispatch_sync(_queue, ^{\n\t\t[super __saveMonery];\n\t});\n}\n@end\n//log\n还剩 9 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x600001211b40>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x600001243700>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x60000121dd80>{number = 5, name = (null)}\n```\n\n### dispatch_semaphore 信号量控制并发数量\n当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？`dispatch_semaphore`信号量正好可以满足我们的需求。\n`dispatch_semaphore`可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。\n\n```\n//初始化信号量 值为2，就是最多允许同时2个线程执行\n_semaphore = dispatch_semaphore_create(2);\n//生成多个线程进行并发访问test\n- (void)otherTest{\n\tfor (int i = 0; i < 10; i ++) {\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];\n\t}\n}\n- (void)test{\n//如果信号量>0 ，让信号量-1，继续向下执行。\n//如果信号量 <= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER\n\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);\n\tsleep(2);//睡眠时间2s\n\tNSLog(@\"%@\",[NSThread currentThread]);\n\t//释放一个信号量\n\tdispatch_semaphore_signal(_semaphore);\n}\n//log\n\n2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] <NSThread: 0x600002c45240>{number = 4, name = (null)}\n2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] <NSThread: 0x600002c45200>{number = 3, name = (null)}\n2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] <NSThread: 0x600002c45540>{number = 10, name = (null)}\n2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] <NSThread: 0x600002c45440>{number = 6, name = (null)}\n2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] <NSThread: 0x600002c45480>{number = 7, name = (null)}\n2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] <NSThread: 0x600002c454c0>{number = 8, name = (null)}\n2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] <NSThread: 0x600002c45500>{number = 9, name = (null)}\n2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] <NSThread: 0x600002c45400>{number = 5, name = (null)}\n2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] <NSThread: 0x600002c455c0>{number = 12, name = (null)}\n2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] <NSThread: 0x600002c45580>{number = 11, name = (null)}\n```\n\n一次最多2个线程同时执行任务，暂停时间是2s。\n使用信号量实现线程最大并发锁，\n同时只有2个线程执行的。\n\n```\n- (instancetype)init{\n\tif (self =[super init]) {\n\t\t_semaphore = dispatch_semaphore_create(1);\n\t}\n\treturn self;\n}\n- (void)__saleTicket{\n\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);\n\t[super __saleTicket];\n\tdispatch_semaphore_signal(_semaphore);\n}\n//log\n还剩 9 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x6000022e0c00>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x6000022e0dc0>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x6000022ce880>{number = 5, name = (null)} \n```\n\n### @synchronized\n`@synchronized(id obj){}`锁的是对象`obj`，使用该锁的时候，底层是对象计算出来的值作为`key`，生成一把锁，不同的资源的读写可以使用不同`obj`作为锁对象。\n\n```\n- (void)__saleTicket{\n\t@synchronized (self) {\n\t\t[super __saleTicket];\n\t}\n }\n //log\n还剩 9 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 8 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 7 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n还剩 6 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 5 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 4 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n还剩 3 张票 - <NSThread: 0x60000057d5c0>{number = 3, name = (null)} \n还剩 2 张票 - <NSThread: 0x60000056f340>{number = 4, name = (null)} \n还剩 1 张票 - <NSThread: 0x60000057d500>{number = 5, name = (null)} \n```\n\n### atmoic 原子操作\n给属性添加`atmoic`修饰，可以保证属性的`setter`和`getter`都是原子性操作，也就保证了`setter`和`getter`的内部是线程同步的。\n原子操作是最终调用了`static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行`，我们进入到函数内部\n\n```\n//设置属性原子操作\nvoid objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)\n{\n    reallySetProperty(self, _cmd, newValue, offset, true, false, false);\n}\n//非原子操作设置属性\nvoid objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)\n{\n    reallySetProperty(self, _cmd, newValue, offset, false, false, false);\n}\n\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{//偏移量等于0则是class指针\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n//其他的value\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n    //如果是copy 用copyWithZone:\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        //mutableCopy则调用mutableCopyWithZone:\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n    //如果赋值和原来的相等 则不操作\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {//非原子操作 直接赋值\n        oldValue = *slot;\n        *slot = newValue;\n    } else {//原子操作 加锁\n    //锁和属性是一一对应的->自旋锁\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;//赋值\n        slotlock.unlock();//解锁\n    }\n    objc_release(oldValue);\n}\n\n\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    // Retain release world\n    id *slot = (id*) ((char*)self + offset);\n    if (!atomic) return *slot;//非原子操作 直接返回值\n        \n    // Atomic retain release world\n\t//原子操作 加锁->自旋锁\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();//加锁\n    id value = objc_retain(*slot);\n    slotlock.unlock();//解锁\n    \n    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.\n    return objc_autoreleaseReturnValue(value);\n}\n\n//以属性的地址为参数计算出key ，锁为value\nStripedMap<spinlock_t> PropertyLocks;\n```\n从源码了解到设置属性读取是`self`+属性的偏移量，当`copy`或`mutableCopy`会调用到`[newValue copyWithZone:nil]`或`[newValue mutableCopyWithZone:nil]`，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取`spinlock_t& slotlock = PropertyLocks[slot]`进行加锁、赋值、解锁操作。而且`PropertyLocks`是一个类，类有一个数组属性，使用`*p`计算出来的值作为`key`。\n\n我们提取出来关键代码\n\n```\n//原子操作 加锁\nspinlock_t& slotlock = PropertyLocks[slot];\nslotlock.lock();\noldValue = *slot;\n*slot = newValue;//赋值\nslotlock.unlock();//解锁\n```\n使用自旋锁对赋值操作进行加锁，保证了`setter()`方法的安全性\n\n```\n//原子操作 加锁 ->自旋锁\nspinlock_t& slotlock = PropertyLocks[slot];\nslotlock.lock();//加锁\nid value = objc_retain(*slot);\nslotlock.unlock();//解锁\n```\n取值之前进行加锁，取值之后进行解锁，保证了`getter()`方法的安全。\n\n由上面得知`atmoic`仅仅是对方法`setter()`和`getter()`安全，对成员变量不保证安全，对于属性的读写一般使用`nonatomic`，性能好，`atomic`读取频率高的时候会导致线程都在排队，浪费CPU时间。\n\n大概使用者几种锁分别对卖票功能进行了性能测试，\n性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)\n\n|锁类型|1万次|100万次|1000万次|\n|:-:|:-:|:-:|:-:|\n|pthread_mutex_t|0.000309|0.027238|0.284714|\n|os_unfair_lock|0.000274|0.028266|0.285685|\n|OSSpinLock|0.030688|0.410067|0.437702|\n|NSCondition|0.005067 |0.323492|1.078636|\n|NSLock|0.038692|0.151601|1.322062|\n|NSRecursiveLock|0.007973|0.151601|1.673409|\n|@synchronized|0.008953|0.640234|2.790291|\n|NSConditionLock|0.229148  |5.325272|10.681123|\n|semaphore|0.094267|0.415351|24.699100|\n|SerialQueue|0.213386|9.058581|50.820202|\n\n### 建议\n平时我们简单使用的话没有很大的区别，还是推荐使用`NSLock`和信号量,最简单的是`@synchronized`，不用声明和初始化，直接拿来就用。\n\n### 自旋锁、互斥锁比较\n自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。\n#### 自旋锁\n- 自旋锁在等待时间比较短的时候比较合适\n- 临界区代码经常被调用，但竞争很少发生\n- CPU不紧张\n- 多核处理器\n#### 互斥锁\n- 预计线程等待时间比较长\n- 单核处理器\n- 临界区IO操作\n- 临界区代码比较多、复杂，或者循环量大\n- 临界区竞争非常激烈\n\n## 锁的应用\n#### 简单读写锁\n一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。\n\n```\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\t// Do any additional setup after loading the view.\n\tself.semaphore = dispatch_semaphore_create(1);\n\t\n\tfor (NSInteger i = 0; i < 10; i ++) {\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];\n\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];\n\t}\n}\n\n- (void)read{\n\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n\tNSLog(@\"%s\",__func__);\n\tdispatch_semaphore_signal(self.semaphore);\n}\n- (void)write{\n\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);\n\tNSLog(@\"%s\",__func__);\n\tdispatch_semaphore_signal(self.semaphore);\n}\n```\n\n当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点\n1. 同一时间，只能有1个线程进行写操作\n2. 同一时间，允许有多个线程进行读的操作\n3. 同一时间，不允许读写操作同时进行\n\n典型的`多读单写`，经常用于文件等数据的读写操作，我们实现2种\n\n#### 读写锁 pthread_rwlock\n这是有c语言封装的读写锁\n\n```\n//初始化读写锁\nint pthread_rwlock_init(pthread_rwlock_t * __restrict,\n\t\tconst pthread_rwlockattr_t * _Nullable __restrict)\n//读上锁\npthread_rwlock_rdlock(pthread_rwlock_t *)\n//尝试加锁读\npthread_rwlock_tryrdlock(pthread_rwlock_t *)\n//尝试加锁写\nint pthread_rwlock_trywrlock(pthread_rwlock_t *)\n//写入加锁\npthread_rwlock_wrlock(pthread_rwlock_t *)\n//解锁\npthread_rwlock_unlock(pthread_rwlock_t *)\n//销毁锁属性\npthread_rwlockattr_destroy(pthread_rwlockattr_t *)\n//销毁锁\npthread_rwlock_destroy(pthread_rwlock_t * )\n```\n\n`pthread_rwlock_t`使用很简单，只需要在读之前使用`pthread_rwlock_rdlock`，读完解锁`pthread_rwlock_unlock`,写入前需要加锁`pthread_rwlock_wrlock`，写入完成之后解锁`pthread_rwlock_unlock`，任务都执行完了可以选择销毁`pthread_rwlock_destroy`或者等待下次使用。\n\n```\n@property (nonatomic,assign) pthread_rwlock_t rwlock;\n\n\n- (void)dealloc{\n\tpthread_rwlock_destroy(&_rwlock);//销毁锁\n}\n//初始化读写锁\npthread_rwlock_init(&_rwlock, NULL);\n\t\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\tfor (NSInteger i = 0; i < 5; i ++) {\n\t\tdispatch_async(queue, ^{\n\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];\n\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];\n\t\t});\n\t}\n\t\n\t\n- (void)readPthreadRWLock{\n    pthread_rwlock_rdlock(&_rwlock);\n    NSLog(@\"读文件\");\n    sleep(1);\n    pthread_rwlock_unlock(&_rwlock);\n}\n- (void)writePthreadRWLock{\n    pthread_rwlock_wrlock(&_rwlock);\n    NSLog(@\" 写入文件\");\n    sleep(1);\n    pthread_rwlock_unlock(&_rwlock);\n}\n\n//log\n2019-07-30 10:47:16 读文件\n2019-07-30 10:47:16 读文件\n2019-07-30 10:47:17 写入文件\n2019-07-30 10:47:18 写入文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:19 读文件\n2019-07-30 10:47:20 写入文件\n2019-07-30 10:47:21 写入文件\n2019-07-30 10:47:22 写入文件\n```\n读文件会出现同一秒读多次，写文件同一秒只有一个。\n\n#### 异步栅栏调用 dispatch_barrier_async\n栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序\n\n|操作|任务|任务|任务|\n|:-:|:-:|:-:|:-:|\n|读|A|B||\n|读|A|B||\n|写|||C|\n|写|||C|\n|读|A|||\n|读|A|B||\n\n\n这个函数传入的并发队列必须是通过`dispatch_queue_create`创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于`dispatch_async`的效果。\n\n```\n//初始化 异步队列\nself.rwqueue = dispatch_queue_create(\"rw.thread\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\nfor (NSInteger i = 0; i < 5; i ++) {\n\tdispatch_async(queue, ^{\n\t\t[self readBarryier];\n\t\t[self readBarryier];\n\t\t[self readBarryier];\n\t\t[self writeBarrier];\n\t});\n}\n\n- (void)readBarryier{\n//添加任务到rwqueue\n\tdispatch_async(self.rwqueue, ^{\n\t\tNSLog(@\"读文件 %@\",[NSThread currentThread]);\n\t\tsleep(1);\n\t});\n}\n- (void)writeBarrier{\n//barrier_async添加任务到self.rwqueue中\n\tdispatch_barrier_async(self.rwqueue, ^{\n\t\tNSLog(@\"写入文件 %@\",[NSThread currentThread]);\n\t\tsleep(1);\n\t});\n}\n\n//log\n\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae0740>{number = 9, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae8500>{number = 10, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ae8040>{number = 8, name = (null)}\n2019-07-30 11:16:53 读文件 <NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:54 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:55 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n2019-07-30 11:16:56 写入文件<NSThread: 0x600001ac3a80>{number = 11, name = (null)}\n```\n读文件会出现同一秒读多个，写文件同一秒只有一个。\n\n\n读写任务都添加到异步队列`rwqueue`中，使用栅栏函数`dispatch_barrier_async`拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。\n\n\n### 总结\n- 普通线程锁本质就是同步执行\n- `atomic`原子操作只限制`setter`和`getter`方法，不限制成员变量\n- 读写锁高性能可以使用`pthread_rwlock_t`和`dispatch_barrier_async`\n### 参考资料\n- [优先级反转](https://blog.csdn.net/Fly_as_tadpole/article/details/86436161 )\n- [iOS多线程：『GCD』详尽总结](https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16)\n- [小码哥视频](http://www.520it.com/zt/ios_mj/)\n- [任务调度](http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html)\n- [libdispatch](https://opensource.apple.com/tarballs/libdispatch/)\n- iOS和OS多线程与内存管理\n### 资料下载\n- [学习资料下载git](https://github.com/ifgyong/iOSDataFactory)\n- [demo code git](https://github.com/ifgyong/demo/tree/master/OC)\n- [runtime可运行的源码git](https://github.com/ifgyong/demo/tree/master/OC/objc4-750)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n广告时间\n\n![](../images/0.png)","slug":"iOS底层原理 多线程之安全锁以及常用的读写锁 --(11)","published":1,"updated":"2019-12-03T05:06:56.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2n000r9zsk2ebt2nd1","content":"<p>只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？<br>这篇文章主要讲解线程安全。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>线程安全是什么呢？摘抄一段<a href=\"https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin\" target=\"_blank\" rel=\"external\">百度百科</a>的一段话</p>\n<blockquote>\n<p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>\n</blockquote>\n<h4 id=\"为什么需要线程安全\"><a href=\"#为什么需要线程安全\" class=\"headerlink\" title=\"为什么需要线程安全\"></a>为什么需要线程安全</h4><p>ATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。</p>\n<p>那么在iOS中，锁是如何使用的呢？</p>\n<h3 id=\"自旋锁-OS-SPINLOCK\"><a href=\"#自旋锁-OS-SPINLOCK\" class=\"headerlink\" title=\"自旋锁 OS_SPINLOCK\"></a>自旋锁 OS_SPINLOCK</h3><h4 id=\"什么是优先级反转\"><a href=\"#什么是优先级反转\" class=\"headerlink\" title=\"什么是优先级反转\"></a>什么是优先级反转</h4><p>简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</p>\n<p>假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</p>\n<p>首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</p>\n<p>其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</p>\n<p>第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</p>\n<p>第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</p>\n<p>第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。</p>\n<p><code>OS_SPINLOCK</code>叫做<code>自旋锁</code>，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。</p>\n<p><code>OS_SPINLOCK</code>API</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化 一般是0，或者直接数字0也是ok的。</div><div class=\"line\">#define\tOS_SPINLOCK_INIT    0</div><div class=\"line\">//锁的初始化</div><div class=\"line\">OSSpinLock lock = OS_SPINLOCK_INIT;</div><div class=\"line\">//尝试加锁</div><div class=\"line\">bool ret = OSSpinLockTry(&amp;lock);</div><div class=\"line\">//加锁</div><div class=\"line\">OSSpinLockLock(&amp;lock);</div><div class=\"line\">//解锁</div><div class=\"line\">OSSpinLockUnlock(&amp;lock);</div></pre></td></tr></table></figure>\n<p><code>OSSpinLock</code>简单实现12306如何卖票</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">//基类实现的卖票</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    NSInteger oldCount = self.ticketsCount;</div><div class=\"line\">\tif (isLog) &#123;</div><div class=\"line\">\t\tsleep(sleepTime);</div><div class=\"line\">\t&#125;</div><div class=\"line\">    oldCount --;</div><div class=\"line\">    self.ticketsCount = oldCount;</div><div class=\"line\">\tif (isLog) &#123;</div><div class=\"line\">\tprintf(&quot;还剩% 2ld 张票 - %s \\n&quot;,(long)oldCount,[NSThread currentThread].description.UTF8String);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)ticketTest&#123;</div><div class=\"line\">    self.ticketsCount = 10000;</div><div class=\"line\">\tNSInteger count = self.ticketsCount/3;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_queue_create(&quot;tick.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">\tdispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">\t\tCFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;</div><div class=\"line\">\t\tprintf(&quot;tick cost time:%f&quot;,time);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __getMonery];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __saleTicket];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __saveMonery];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    NSInteger oldCount = self.ticketsCount;</div><div class=\"line\">    oldCount --;</div><div class=\"line\">    self.ticketsCount = oldCount;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"汇编分析\"><a href=\"#汇编分析\" class=\"headerlink\" title=\"汇编分析\"></a>汇编分析</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">然后将睡眠时间设置为600s，方便我们调试。</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);//此行打断点</div><div class=\"line\">    [super __saleTicket];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到了断点进入<code>Debug-&gt;Debug WorkFlow -&gt;Always Show Disassembly</code>，到了汇编界面，在<code>LLDB</code>输入<code>stepi</code>，然后一直按<code>enter</code>，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现<code>ja</code>跳转到地址<code>0x103f3d0f9</code>，每次执行到<code>ja</code>总是跳转到<code>0x103f3d0f9</code>，直到线程睡眠结束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-&gt;  0x103f3d0f9 &lt;+241&gt;: movq   %rcx, (%r8)</div><div class=\"line\">0x103f3d0fc &lt;+244&gt;: addq   $0x8, %r8</div><div class=\"line\">0x103f3d100 &lt;+248&gt;: cmpq   %r8, %r9</div><div class=\"line\">0x103f3d103 &lt;+251&gt;: ja     0x103f3d0f9</div></pre></td></tr></table></figure>\n<p>可以通过汇编分析了解到<code>自旋锁</code>是真的<code>忙等</code>，闲不住的锁。</p>\n<h3 id=\"os-unfair-lock\"><a href=\"#os-unfair-lock\" class=\"headerlink\" title=\"os_unfair_lock\"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的<code>OSSpinLock</code>，而且必须使用<code>OS_UNFAIR_LOCK_INIT</code>来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在<code>__IOS_AVAILABLE(10.0)</code>，锁的数据结构是一个结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS_UNFAIR_LOCK_AVAILABILITY</div><div class=\"line\">typedef struct os_unfair_lock_s &#123;</div><div class=\"line\">\tuint32_t _os_unfair_lock_opaque;</div><div class=\"line\">&#125; os_unfair_lock, *os_unfair_lock_t;</div></pre></td></tr></table></figure>\n<p><code>os_unfair_lock</code>使用非常简单，只需要在任务前加锁，任务后解锁即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYOSUnfairLockDemo : FYBaseDemo</div><div class=\"line\">@property (nonatomic,assign) os_unfair_lock lock;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYOSUnfairLockDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\tself.lock = OS_UNFAIR_LOCK_INIT;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"汇编分析-1\"><a href=\"#汇编分析-1\" class=\"headerlink\" title=\"汇编分析\"></a>汇编分析</h4><p><code>LLDB</code> 中命令<code>stepi</code>遇到函数会进入到函数，<code>nexti</code>会跳过函数。我们将断点打到添加锁的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\"> \tos_unfair_lock_lock(&amp;_unlock);//断点位置</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行<code>si</code>,一直<code>enter</code>，最终是停止该位子，模拟器缺跳出来了，再<code>enter</code>也没用了，因为线程在睡眠了。<code>syscall</code>是调用系统函数的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">libsystem_kernel.dylib`__ulock_wait:</div><div class=\"line\">    0x107a3b9d4 &lt;+0&gt;:  movl   $0x2000203, %eax          ; imm = 0x2000203 </div><div class=\"line\">    0x107a3b9d9 &lt;+5&gt;:  movq   %rcx, %r10</div><div class=\"line\">-&gt;  0x107a3b9dc &lt;+8&gt;:  syscall</div></pre></td></tr></table></figure>\n<h3 id=\"互斥锁-pthread-mutex-t\"><a href=\"#互斥锁-pthread-mutex-t\" class=\"headerlink\" title=\"互斥锁 pthread_mutex_t\"></a>互斥锁 pthread_mutex_t</h3><p><code>mutex</code>叫互斥锁，等待锁的线程会处于休眠状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\tpthread_mutex_destroy(&amp;_plock);</div><div class=\"line\">\tpthread_mutexattr_destroy(&amp;t);</div><div class=\"line\">&#125;</div><div class=\"line\">-(instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t//初始化锁的属性 </div><div class=\"line\">//\t\tpthread_mutexattr_init(&amp;t);</div><div class=\"line\">//\t\tpthread_mutexattr_settype(&amp;t, PTHREAD_MUTEX_NORMAL);</div><div class=\"line\">//\t\t//初始化锁</div><div class=\"line\">//\t\tpthread_mutex_init(&amp;_plock, &amp;t);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;</div><div class=\"line\">\t\tself.plock = plock;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)__saleTicket&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>互斥锁有三个类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> * Mutex type attributes</div><div class=\"line\"> */</div><div class=\"line\"> 普通锁</div><div class=\"line\">#define PTHREAD_MUTEX_NORMAL\t\t0</div><div class=\"line\">//检查错误</div><div class=\"line\">#define PTHREAD_MUTEX_ERRORCHECK\t1</div><div class=\"line\">//递归锁</div><div class=\"line\">#define PTHREAD_MUTEX_RECURSIVE\t\t2</div><div class=\"line\">//普通锁</div><div class=\"line\">#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL</div></pre></td></tr></table></figure>\n<p>当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self otherTest2];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest2&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">-[FYPthread_mutex2 otherTest]</div></pre></td></tr></table></figure>\n<p>上面这个需求需要使用两把锁，或者使用递归锁来解决问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self otherTest2];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest2&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock2);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">-[FYPthread_mutex2 otherTest]</div><div class=\"line\">-[FYPthread_mutex2 otherTest2]</div></pre></td></tr></table></figure>\n<p>从使用2把锁是可以解决这个问题的。<br>递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。</p>\n<h3 id=\"NSLock、NSRecursiveLosk\"><a href=\"#NSLock、NSRecursiveLosk\" class=\"headerlink\" title=\"NSLock、NSRecursiveLosk\"></a>NSLock、NSRecursiveLosk</h3><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p>\n<p>使用<code>(LLDB) si</code>可以跟踪<code>[myLock lock];</code>的内部函数最终是<code>pthread_mutex_lock</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foundation`-[NSLock lock]:</div><div class=\"line\">    0x1090dfb5a &lt;+0&gt;:  pushq  %rbp</div><div class=\"line\">    0x1090dfb5b &lt;+1&gt;:  movq   %rsp, %rbp</div><div class=\"line\">    0x1090dfb5e &lt;+4&gt;:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars</div><div class=\"line\">    0x1090dfb63 &lt;+9&gt;:  movq   %rax, %rdi</div><div class=\"line\">    0x1090dfb66 &lt;+12&gt;: popq   %rbp</div><div class=\"line\">-&gt;  0x1090dfb67 &lt;+13&gt;: jmp    0x1092ca596   ;</div><div class=\"line\">//  symbol stub for: pthread_mutex_lock</div></pre></td></tr></table></figure>\n<p><code>NSLock API</code>大全</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//协议NSLocking</div><div class=\"line\">@protocol NSLocking</div><div class=\"line\"></div><div class=\"line\">- (void)lock;</div><div class=\"line\">- (void)unlock;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</div><div class=\"line\">@private</div><div class=\"line\">    void *_priv;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)tryLock;//尝试加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，</div><div class=\"line\">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>用法也很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNSLock()&#123;</div><div class=\"line\">\tNSLock *_lock;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYNSLock</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//封装了mutex的普通锁</div><div class=\"line\">\t\t_lock=[[NSLock alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)tryLock;//尝试加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁</div></pre></td></tr></table></figure>\n<p>递归锁可以对相同的线程进行反复加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation FYRecursiveLockDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//封装了mutex的递归锁</div><div class=\"line\">\t\t_lock=[[NSRecursiveLock alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tstatic int count = 10;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\twhile (count &gt; 0) &#123;</div><div class=\"line\">\t\tcount -= 1;</div><div class=\"line\">\t\tprintf(&quot;循环% 2d次 - %s \\n&quot;,count,[NSThread currentThread].description.UTF8String);</div><div class=\"line\">\t\t[self otherTest];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">循环 9次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 8次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 7次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 6次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 5次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 4次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 3次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 2次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 1次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 0次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"NSCondition-条件\"><a href=\"#NSCondition-条件\" class=\"headerlink\" title=\"NSCondition 条件\"></a>NSCondition 条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)wait;//等待</div><div class=\"line\">- (BOOL)waitUntilDate:(NSDate *)limit;</div><div class=\"line\">- (void)signal;//唤醒一个线程</div><div class=\"line\">- (void)broadcast;//唤醒多个线程</div></pre></td></tr></table></figure>\n<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//遵守的 lock协议 的 条件🔐</div><div class=\"line\">\t\t_lock=[[NSCondition alloc]init];</div><div class=\"line\">\t\tself.array =[NSMutableArray array];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__add&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[self.array addObject:@&quot;Test&quot;];</div><div class=\"line\">\tNSLog(@&quot;添加成功&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\t[_lock signal];//唤醒一个线程</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__remove&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\tif (self.array.count == 0) &#123;</div><div class=\"line\">\t\t[_lock wait];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t[self.array removeLastObject];</div><div class=\"line\">\tNSLog(@&quot;删除成功&quot;);</div><div class=\"line\"></div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//Log</div><div class=\"line\"></div><div class=\"line\">2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功</div><div class=\"line\">2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功</div></pre></td></tr></table></figure>\n<p>可以看到时间上差了1秒，正好是我们设定的<code>sleep(1);</code>。优点是可以让线程之间形成依赖，缺点是没有明确的条件。</p>\n<h3 id=\"NSConditionLock-可以实现线程依赖的锁\"><a href=\"#NSConditionLock-可以实现线程依赖的锁\" class=\"headerlink\" title=\"NSConditionLock 可以实现线程依赖的锁\"></a>NSConditionLock 可以实现线程依赖的锁</h3><p><code>NSConditionLock</code>是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用<code>NSConditionLock</code>来解决问题。<br>首先看下<code>API</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (readonly) NSInteger condition;//条件值</div><div class=\"line\">- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住</div><div class=\"line\">//尝试加锁</div><div class=\"line\">- (BOOL)tryLock;</div><div class=\"line\">//当con为condition进行尝试锁住</div><div class=\"line\">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</div><div class=\"line\">//当con为condition进行解锁</div><div class=\"line\">- (void)unlockWithCondition:(NSInteger)condition;</div><div class=\"line\">//NSDate 小余 limit进行 加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class=\"line\">//条件为condition 在limit之前进行加锁</div><div class=\"line\">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure>\n<p>条件锁的使用，在<code>lockWhenCondition:(NSInteger)condition</code>的条件到达的时候才能进行正常的加锁和<code>unlockWithCondition:(NSInteger)condition</code>解锁，否则会阻塞线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test1&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:1];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:2];//解锁 并赋值2</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test2&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:2];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:3];//解锁 并赋值3</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test3&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:3];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:4];//解锁 并赋值4</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">-[FYCondLockDemo2 __test1]</div><div class=\"line\">-[FYCondLockDemo2 __test2]</div><div class=\"line\">-[FYCondLockDemo2 __test3]</div></pre></td></tr></table></figure>\n<p>当<code>con = 1</code>进行<code>test1</code>加锁和执行任务<code>A</code>，任务<code>A</code>执行完毕，进行解锁，并把值2赋值给<code>lock</code>，这是当<code>con = 2</code>的锁开始加锁，进入任务<code>B</code>，开始执行任务<code>B</code>，当任务<code>B</code>执行完毕，进行解锁并赋值为3，然后<code>con=3</code>的锁进行加锁，解锁并赋值4来进行线程之间的依赖。</p>\n<h3 id=\"dispatch-queue-特殊的锁\"><a href=\"#dispatch-queue-特殊的锁\" class=\"headerlink\" title=\"dispatch_queue 特殊的锁\"></a>dispatch_queue 特殊的锁</h3><p>其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYSerialQueueDemo()&#123;</div><div class=\"line\">\tdispatch_queue_t _queue;</div><div class=\"line\">&#125;@end</div><div class=\"line\">@implementation FYSerialQueueDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t_queue = dispatch_queue_create(&quot;fyserial.queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __saleTicket];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __getMonery];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __saveMonery];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"dispatch-semaphore-信号量控制并发数量\"><a href=\"#dispatch-semaphore-信号量控制并发数量\" class=\"headerlink\" title=\"dispatch_semaphore 信号量控制并发数量\"></a>dispatch_semaphore 信号量控制并发数量</h3><p>当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？<code>dispatch_semaphore</code>信号量正好可以满足我们的需求。<br><code>dispatch_semaphore</code>可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化信号量 值为2，就是最多允许同时2个线程执行</div><div class=\"line\">_semaphore = dispatch_semaphore_create(2);</div><div class=\"line\">//生成多个线程进行并发访问test</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tfor (int i = 0; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">//如果信号量&gt;0 ，让信号量-1，继续向下执行。</div><div class=\"line\">//如果信号量 &lt;= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER</div><div class=\"line\">\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tsleep(2);//睡眠时间2s</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t//释放一个信号量</div><div class=\"line\">\tdispatch_semaphore_signal(_semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] &lt;NSThread: 0x600002c45240&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] &lt;NSThread: 0x600002c45200&gt;&#123;number = 3, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] &lt;NSThread: 0x600002c45540&gt;&#123;number = 10, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] &lt;NSThread: 0x600002c45440&gt;&#123;number = 6, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] &lt;NSThread: 0x600002c45480&gt;&#123;number = 7, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] &lt;NSThread: 0x600002c454c0&gt;&#123;number = 8, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] &lt;NSThread: 0x600002c45500&gt;&#123;number = 9, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] &lt;NSThread: 0x600002c45400&gt;&#123;number = 5, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] &lt;NSThread: 0x600002c455c0&gt;&#123;number = 12, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] &lt;NSThread: 0x600002c45580&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>一次最多2个线程同时执行任务，暂停时间是2s。<br>使用信号量实现线程最大并发锁，<br>同时只有2个线程执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t_semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tdispatch_semaphore_signal(_semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h3><p><code>@synchronized(id obj){}</code>锁的是对象<code>obj</code>，使用该锁的时候，底层是对象计算出来的值作为<code>key</code>，生成一把锁，不同的资源的读写可以使用不同<code>obj</code>作为锁对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\t[super __saleTicket];</div><div class=\"line\">\t&#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> //log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"atmoic-原子操作\"><a href=\"#atmoic-原子操作\" class=\"headerlink\" title=\"atmoic 原子操作\"></a>atmoic 原子操作</h3><p>给属性添加<code>atmoic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证了<code>setter</code>和<code>getter</code>的内部是线程同步的。<br>原子操作是最终调用了<code>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行</code>，我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置属性原子操作</div><div class=\"line\">void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class=\"line\">&#123;</div><div class=\"line\">    reallySetProperty(self, _cmd, newValue, offset, true, false, false);</div><div class=\"line\">&#125;</div><div class=\"line\">//非原子操作设置属性</div><div class=\"line\">void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class=\"line\">&#123;</div><div class=\"line\">    reallySetProperty(self, _cmd, newValue, offset, false, false, false);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</div><div class=\"line\">&#123;//偏移量等于0则是class指针</div><div class=\"line\">    if (offset == 0) &#123;</div><div class=\"line\">        object_setClass(self, newValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">//其他的value</div><div class=\"line\">    id oldValue;</div><div class=\"line\">    id *slot = (id*) ((char*)self + offset);</div><div class=\"line\"></div><div class=\"line\">    if (copy) &#123;</div><div class=\"line\">    //如果是copy 用copyWithZone:</div><div class=\"line\">        newValue = [newValue copyWithZone:nil];</div><div class=\"line\">    &#125; else if (mutableCopy) &#123;</div><div class=\"line\">        //mutableCopy则调用mutableCopyWithZone:</div><div class=\"line\">        newValue = [newValue mutableCopyWithZone:nil];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    //如果赋值和原来的相等 则不操作</div><div class=\"line\">        if (*slot == newValue) return;</div><div class=\"line\">        newValue = objc_retain(newValue);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!atomic) &#123;//非原子操作 直接赋值</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;</div><div class=\"line\">    &#125; else &#123;//原子操作 加锁</div><div class=\"line\">    //锁和属性是一一对应的-&gt;自旋锁</div><div class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">        slotlock.lock();</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;//赋值</div><div class=\"line\">        slotlock.unlock();//解锁</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(oldValue);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</div><div class=\"line\">    if (offset == 0) &#123;</div><div class=\"line\">        return object_getClass(self);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Retain release world</div><div class=\"line\">    id *slot = (id*) ((char*)self + offset);</div><div class=\"line\">    if (!atomic) return *slot;//非原子操作 直接返回值</div><div class=\"line\">        </div><div class=\"line\">    // Atomic retain release world</div><div class=\"line\">\t//原子操作 加锁-&gt;自旋锁</div><div class=\"line\">    spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">    slotlock.lock();//加锁</div><div class=\"line\">    id value = objc_retain(*slot);</div><div class=\"line\">    slotlock.unlock();//解锁</div><div class=\"line\">    </div><div class=\"line\">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</div><div class=\"line\">    return objc_autoreleaseReturnValue(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以属性的地址为参数计算出key ，锁为value</div><div class=\"line\">StripedMap&lt;spinlock_t&gt; PropertyLocks;</div></pre></td></tr></table></figure>\n<p>从源码了解到设置属性读取是<code>self</code>+属性的偏移量，当<code>copy</code>或<code>mutableCopy</code>会调用到<code>[newValue copyWithZone:nil]</code>或<code>[newValue mutableCopyWithZone:nil]</code>，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取<code>spinlock_t&amp; slotlock = PropertyLocks[slot]</code>进行加锁、赋值、解锁操作。而且<code>PropertyLocks</code>是一个类，类有一个数组属性，使用<code>*p</code>计算出来的值作为<code>key</code>。</p>\n<p>我们提取出来关键代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原子操作 加锁</div><div class=\"line\">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">slotlock.lock();</div><div class=\"line\">oldValue = *slot;</div><div class=\"line\">*slot = newValue;//赋值</div><div class=\"line\">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>\n<p>使用自旋锁对赋值操作进行加锁，保证了<code>setter()</code>方法的安全性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原子操作 加锁 -&gt;自旋锁</div><div class=\"line\">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">slotlock.lock();//加锁</div><div class=\"line\">id value = objc_retain(*slot);</div><div class=\"line\">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>\n<p>取值之前进行加锁，取值之后进行解锁，保证了<code>getter()</code>方法的安全。</p>\n<p>由上面得知<code>atmoic</code>仅仅是对方法<code>setter()</code>和<code>getter()</code>安全，对成员变量不保证安全，对于属性的读写一般使用<code>nonatomic</code>，性能好，<code>atomic</code>读取频率高的时候会导致线程都在排队，浪费CPU时间。</p>\n<p>大概使用者几种锁分别对卖票功能进行了性能测试，<br>性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">锁类型</th>\n<th style=\"text-align:center\">1万次</th>\n<th style=\"text-align:center\">100万次</th>\n<th style=\"text-align:center\">1000万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">pthread_mutex_t</td>\n<td style=\"text-align:center\">0.000309</td>\n<td style=\"text-align:center\">0.027238</td>\n<td style=\"text-align:center\">0.284714</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">os_unfair_lock</td>\n<td style=\"text-align:center\">0.000274</td>\n<td style=\"text-align:center\">0.028266</td>\n<td style=\"text-align:center\">0.285685</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OSSpinLock</td>\n<td style=\"text-align:center\">0.030688</td>\n<td style=\"text-align:center\">0.410067</td>\n<td style=\"text-align:center\">0.437702</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSCondition</td>\n<td style=\"text-align:center\">0.005067</td>\n<td style=\"text-align:center\">0.323492</td>\n<td style=\"text-align:center\">1.078636</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSLock</td>\n<td style=\"text-align:center\">0.038692</td>\n<td style=\"text-align:center\">0.151601</td>\n<td style=\"text-align:center\">1.322062</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSRecursiveLock</td>\n<td style=\"text-align:center\">0.007973</td>\n<td style=\"text-align:center\">0.151601</td>\n<td style=\"text-align:center\">1.673409</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@synchronized</td>\n<td style=\"text-align:center\">0.008953</td>\n<td style=\"text-align:center\">0.640234</td>\n<td style=\"text-align:center\">2.790291</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSConditionLock</td>\n<td style=\"text-align:center\">0.229148</td>\n<td style=\"text-align:center\">5.325272</td>\n<td style=\"text-align:center\">10.681123</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">semaphore</td>\n<td style=\"text-align:center\">0.094267</td>\n<td style=\"text-align:center\">0.415351</td>\n<td style=\"text-align:center\">24.699100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SerialQueue</td>\n<td style=\"text-align:center\">0.213386</td>\n<td style=\"text-align:center\">9.058581</td>\n<td style=\"text-align:center\">50.820202</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><p>平时我们简单使用的话没有很大的区别，还是推荐使用<code>NSLock</code>和信号量,最简单的是<code>@synchronized</code>，不用声明和初始化，直接拿来就用。</p>\n<h3 id=\"自旋锁、互斥锁比较\"><a href=\"#自旋锁、互斥锁比较\" class=\"headerlink\" title=\"自旋锁、互斥锁比较\"></a>自旋锁、互斥锁比较</h3><p>自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><ul>\n<li>自旋锁在等待时间比较短的时候比较合适</li>\n<li>临界区代码经常被调用，但竞争很少发生</li>\n<li>CPU不紧张</li>\n<li>多核处理器<h4 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h4></li>\n<li>预计线程等待时间比较长</li>\n<li>单核处理器</li>\n<li>临界区IO操作</li>\n<li>临界区代码比较多、复杂，或者循环量大</li>\n<li>临界区竞争非常激烈</li>\n</ul>\n<h2 id=\"锁的应用\"><a href=\"#锁的应用\" class=\"headerlink\" title=\"锁的应用\"></a>锁的应用</h2><h4 id=\"简单读写锁\"><a href=\"#简单读写锁\" class=\"headerlink\" title=\"简单读写锁\"></a>简单读写锁</h4><p>一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">\t</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)read&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tdispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)write&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tdispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点</p>\n<ol>\n<li>同一时间，只能有1个线程进行写操作</li>\n<li>同一时间，允许有多个线程进行读的操作</li>\n<li>同一时间，不允许读写操作同时进行</li>\n</ol>\n<p>典型的<code>多读单写</code>，经常用于文件等数据的读写操作，我们实现2种</p>\n<h4 id=\"读写锁-pthread-rwlock\"><a href=\"#读写锁-pthread-rwlock\" class=\"headerlink\" title=\"读写锁 pthread_rwlock\"></a>读写锁 pthread_rwlock</h4><p>这是有c语言封装的读写锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化读写锁</div><div class=\"line\">int pthread_rwlock_init(pthread_rwlock_t * __restrict,</div><div class=\"line\">\t\tconst pthread_rwlockattr_t * _Nullable __restrict)</div><div class=\"line\">//读上锁</div><div class=\"line\">pthread_rwlock_rdlock(pthread_rwlock_t *)</div><div class=\"line\">//尝试加锁读</div><div class=\"line\">pthread_rwlock_tryrdlock(pthread_rwlock_t *)</div><div class=\"line\">//尝试加锁写</div><div class=\"line\">int pthread_rwlock_trywrlock(pthread_rwlock_t *)</div><div class=\"line\">//写入加锁</div><div class=\"line\">pthread_rwlock_wrlock(pthread_rwlock_t *)</div><div class=\"line\">//解锁</div><div class=\"line\">pthread_rwlock_unlock(pthread_rwlock_t *)</div><div class=\"line\">//销毁锁属性</div><div class=\"line\">pthread_rwlockattr_destroy(pthread_rwlockattr_t *)</div><div class=\"line\">//销毁锁</div><div class=\"line\">pthread_rwlock_destroy(pthread_rwlock_t * )</div></pre></td></tr></table></figure>\n<p><code>pthread_rwlock_t</code>使用很简单，只需要在读之前使用<code>pthread_rwlock_rdlock</code>，读完解锁<code>pthread_rwlock_unlock</code>,写入前需要加锁<code>pthread_rwlock_wrlock</code>，写入完成之后解锁<code>pthread_rwlock_unlock</code>，任务都执行完了可以选择销毁<code>pthread_rwlock_destroy</code>或者等待下次使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,assign) pthread_rwlock_t rwlock;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tpthread_rwlock_destroy(&amp;_rwlock);//销毁锁</div><div class=\"line\">&#125;</div><div class=\"line\">//初始化读写锁</div><div class=\"line\">pthread_rwlock_init(&amp;_rwlock, NULL);</div><div class=\"line\">\t</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];</div><div class=\"line\">\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">- (void)readPthreadRWLock&#123;</div><div class=\"line\">    pthread_rwlock_rdlock(&amp;_rwlock);</div><div class=\"line\">    NSLog(@&quot;读文件&quot;);</div><div class=\"line\">    sleep(1);</div><div class=\"line\">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)writePthreadRWLock&#123;</div><div class=\"line\">    pthread_rwlock_wrlock(&amp;_rwlock);</div><div class=\"line\">    NSLog(@&quot; 写入文件&quot;);</div><div class=\"line\">    sleep(1);</div><div class=\"line\">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 10:47:16 读文件</div><div class=\"line\">2019-07-30 10:47:16 读文件</div><div class=\"line\">2019-07-30 10:47:17 写入文件</div><div class=\"line\">2019-07-30 10:47:18 写入文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:20 写入文件</div><div class=\"line\">2019-07-30 10:47:21 写入文件</div><div class=\"line\">2019-07-30 10:47:22 写入文件</div></pre></td></tr></table></figure>\n<p>读文件会出现同一秒读多次，写文件同一秒只有一个。</p>\n<h4 id=\"异步栅栏调用-dispatch-barrier-async\"><a href=\"#异步栅栏调用-dispatch-barrier-async\" class=\"headerlink\" title=\"异步栅栏调用 dispatch_barrier_async\"></a>异步栅栏调用 dispatch_barrier_async</h4><p>栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">任务</th>\n<th style=\"text-align:center\">任务</th>\n<th style=\"text-align:center\">任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">写</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">写</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n</tbody>\n</table>\n<p>这个函数传入的并发队列必须是通过<code>dispatch_queue_create</code>创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于<code>dispatch_async</code>的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化 异步队列</div><div class=\"line\">self.rwqueue = dispatch_queue_create(&quot;rw.thread&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self writeBarrier];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)readBarryier&#123;</div><div class=\"line\">//添加任务到rwqueue</div><div class=\"line\">\tdispatch_async(self.rwqueue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;读文件 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t\tsleep(1);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)writeBarrier&#123;</div><div class=\"line\">//barrier_async添加任务到self.rwqueue中</div><div class=\"line\">\tdispatch_barrier_async(self.rwqueue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;写入文件 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t\tsleep(1);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae0740&gt;&#123;number = 9, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8500&gt;&#123;number = 10, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8040&gt;&#123;number = 8, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:54 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:55 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:56 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>读文件会出现同一秒读多个，写文件同一秒只有一个。</p>\n<p>读写任务都添加到异步队列<code>rwqueue</code>中，使用栅栏函数<code>dispatch_barrier_async</code>拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>普通线程锁本质就是同步执行</li>\n<li><code>atomic</code>原子操作只限制<code>setter</code>和<code>getter</code>方法，不限制成员变量</li>\n<li>读写锁高性能可以使用<code>pthread_rwlock_t</code>和<code>dispatch_barrier_async</code><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3></li>\n<li><a href=\"https://blog.csdn.net/Fly_as_tadpole/article/details/86436161\" target=\"_blank\" rel=\"external\">优先级反转</a></li>\n<li><a href=\"https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16\" target=\"_blank\" rel=\"external\">iOS多线程：『GCD』详尽总结</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></li>\n<li>iOS和OS多线程与内存管理<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>只要提到了多线程就应该想到线程安全，那么怎么做才能做到在多个线程中保证安全呢？<br>这篇文章主要讲解线程安全。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>线程安全是什么呢？摘抄一段<a href=\"https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin\" target=\"_blank\" rel=\"external\">百度百科</a>的一段话</p>\n<blockquote>\n<p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>\n</blockquote>\n<h4 id=\"为什么需要线程安全\"><a href=\"#为什么需要线程安全\" class=\"headerlink\" title=\"为什么需要线程安全\"></a>为什么需要线程安全</h4><p>ATM肯定用过，你要是边取钱，边存钱，会出问题吗？当你取钱的时候，正在取，结果有人汇款正好到账，本来1000块取了100剩下900，结果到账200，1000+200=1200，因为你取的时候，还没取完，汇款到账了结果数字又加上去了。你取的钱跑哪里去了，这里就需要取钱的时候不能写入数据，就是汇款需要在你取钱完成之后再汇款，不能同时进行。</p>\n<p>那么在iOS中，锁是如何使用的呢？</p>\n<h3 id=\"自旋锁-OS-SPINLOCK\"><a href=\"#自旋锁-OS-SPINLOCK\" class=\"headerlink\" title=\"自旋锁 OS_SPINLOCK\"></a>自旋锁 OS_SPINLOCK</h3><h4 id=\"什么是优先级反转\"><a href=\"#什么是优先级反转\" class=\"headerlink\" title=\"什么是优先级反转\"></a>什么是优先级反转</h4><p>简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</p>\n<p>假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</p>\n<p>首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</p>\n<p>其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</p>\n<p>第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</p>\n<p>第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</p>\n<p>第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就是优先反转。</p>\n<p><code>OS_SPINLOCK</code>叫做<code>自旋锁</code>，等待锁的进程会处于忙等(busy-wait)状态，一直占用着CPU资源，目前已经不安全，可能会出现优先级翻转问题。</p>\n<p><code>OS_SPINLOCK</code>API</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化 一般是0，或者直接数字0也是ok的。</div><div class=\"line\">#define\tOS_SPINLOCK_INIT    0</div><div class=\"line\">//锁的初始化</div><div class=\"line\">OSSpinLock lock = OS_SPINLOCK_INIT;</div><div class=\"line\">//尝试加锁</div><div class=\"line\">bool ret = OSSpinLockTry(&amp;lock);</div><div class=\"line\">//加锁</div><div class=\"line\">OSSpinLockLock(&amp;lock);</div><div class=\"line\">//解锁</div><div class=\"line\">OSSpinLockUnlock(&amp;lock);</div></pre></td></tr></table></figure>\n<p><code>OSSpinLock</code>简单实现12306如何卖票</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">//基类实现的卖票</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    NSInteger oldCount = self.ticketsCount;</div><div class=\"line\">\tif (isLog) &#123;</div><div class=\"line\">\t\tsleep(sleepTime);</div><div class=\"line\">\t&#125;</div><div class=\"line\">    oldCount --;</div><div class=\"line\">    self.ticketsCount = oldCount;</div><div class=\"line\">\tif (isLog) &#123;</div><div class=\"line\">\tprintf(&quot;还剩% 2ld 张票 - %s \\n&quot;,(long)oldCount,[NSThread currentThread].description.UTF8String);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)ticketTest&#123;</div><div class=\"line\">    self.ticketsCount = 10000;</div><div class=\"line\">\tNSInteger count = self.ticketsCount/3;</div><div class=\"line\">\tdispatch_queue_t queue = dispatch_queue_create(&quot;tick.com&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    dispatch_async(queue, ^&#123;</div><div class=\"line\">\t\tif (time1 == 0) &#123;</div><div class=\"line\">\t\t\ttime1 = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">            [self __saleTicket];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">\tdispatch_barrier_async(queue, ^&#123;</div><div class=\"line\">\t\tCFAbsoluteTime time = CFAbsoluteTimeGetCurrent() - time1;</div><div class=\"line\">\t\tprintf(&quot;tick cost time:%f&quot;,time);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __getMonery];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __saleTicket];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);</div><div class=\"line\">    [super __saveMonery];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    NSInteger oldCount = self.ticketsCount;</div><div class=\"line\">    oldCount --;</div><div class=\"line\">    self.ticketsCount = oldCount;</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600003dc6080&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600003df3a00&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600003dc0000&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"汇编分析\"><a href=\"#汇编分析\" class=\"headerlink\" title=\"汇编分析\"></a>汇编分析</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__saleTicket) object:nil] start];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">然后将睡眠时间设置为600s，方便我们调试。</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">    OSSpinLockLock(&amp;_moneyLock);//此行打断点</div><div class=\"line\">    [super __saleTicket];</div><div class=\"line\">    OSSpinLockUnlock(&amp;_moneyLock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到了断点进入<code>Debug-&gt;Debug WorkFlow -&gt;Always Show Disassembly</code>，到了汇编界面，在<code>LLDB</code>输入<code>stepi</code>，然后一直按<code>enter</code>，一直重复执行上句命令，直到进入了循环，就是类似下列的三行，发现<code>ja</code>跳转到地址<code>0x103f3d0f9</code>，每次执行到<code>ja</code>总是跳转到<code>0x103f3d0f9</code>，直到线程睡眠结束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-&gt;  0x103f3d0f9 &lt;+241&gt;: movq   %rcx, (%r8)</div><div class=\"line\">0x103f3d0fc &lt;+244&gt;: addq   $0x8, %r8</div><div class=\"line\">0x103f3d100 &lt;+248&gt;: cmpq   %r8, %r9</div><div class=\"line\">0x103f3d103 &lt;+251&gt;: ja     0x103f3d0f9</div></pre></td></tr></table></figure>\n<p>可以通过汇编分析了解到<code>自旋锁</code>是真的<code>忙等</code>，闲不住的锁。</p>\n<h3 id=\"os-unfair-lock\"><a href=\"#os-unfair-lock\" class=\"headerlink\" title=\"os_unfair_lock\"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>被系统定义为低级锁，一般低级锁都是闲的时候在睡眠，在等待的时候被内核唤醒，目的是替换已弃用的<code>OSSpinLock</code>，而且必须使用<code>OS_UNFAIR_LOCK_INIT</code>来初始化，加锁和解锁必须在相同的线程，否则会中断进程，使用该锁需要系统在<code>__IOS_AVAILABLE(10.0)</code>，锁的数据结构是一个结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS_UNFAIR_LOCK_AVAILABILITY</div><div class=\"line\">typedef struct os_unfair_lock_s &#123;</div><div class=\"line\">\tuint32_t _os_unfair_lock_opaque;</div><div class=\"line\">&#125; os_unfair_lock, *os_unfair_lock_t;</div></pre></td></tr></table></figure>\n<p><code>os_unfair_lock</code>使用非常简单，只需要在任务前加锁，任务后解锁即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYOSUnfairLockDemo : FYBaseDemo</div><div class=\"line\">@property (nonatomic,assign) os_unfair_lock lock;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYOSUnfairLockDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\tself.lock = OS_UNFAIR_LOCK_INIT;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tos_unfair_lock_lock(&amp;_unlock);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600002eb4bc0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600002eb1500&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600002ed4340&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"汇编分析-1\"><a href=\"#汇编分析-1\" class=\"headerlink\" title=\"汇编分析\"></a>汇编分析</h4><p><code>LLDB</code> 中命令<code>stepi</code>遇到函数会进入到函数，<code>nexti</code>会跳过函数。我们将断点打到添加锁的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\"> \tos_unfair_lock_lock(&amp;_unlock);//断点位置</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tos_unfair_lock_unlock(&amp;_unlock);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行<code>si</code>,一直<code>enter</code>，最终是停止该位子，模拟器缺跳出来了，再<code>enter</code>也没用了，因为线程在睡眠了。<code>syscall</code>是调用系统函数的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">libsystem_kernel.dylib`__ulock_wait:</div><div class=\"line\">    0x107a3b9d4 &lt;+0&gt;:  movl   $0x2000203, %eax          ; imm = 0x2000203 </div><div class=\"line\">    0x107a3b9d9 &lt;+5&gt;:  movq   %rcx, %r10</div><div class=\"line\">-&gt;  0x107a3b9dc &lt;+8&gt;:  syscall</div></pre></td></tr></table></figure>\n<h3 id=\"互斥锁-pthread-mutex-t\"><a href=\"#互斥锁-pthread-mutex-t\" class=\"headerlink\" title=\"互斥锁 pthread_mutex_t\"></a>互斥锁 pthread_mutex_t</h3><p><code>mutex</code>叫互斥锁，等待锁的线程会处于休眠状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)dealloc&#123;</div><div class=\"line\">\tpthread_mutex_destroy(&amp;_plock);</div><div class=\"line\">\tpthread_mutexattr_destroy(&amp;t);</div><div class=\"line\">&#125;</div><div class=\"line\">-(instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t//初始化锁的属性 </div><div class=\"line\">//\t\tpthread_mutexattr_init(&amp;t);</div><div class=\"line\">//\t\tpthread_mutexattr_settype(&amp;t, PTHREAD_MUTEX_NORMAL);</div><div class=\"line\">//\t\t//初始化锁</div><div class=\"line\">//\t\tpthread_mutex_init(&amp;_plock, &amp;t);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tpthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;</div><div class=\"line\">\t\tself.plock = plock;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)__saleTicket&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x6000014c8f40&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x6000014c8d80&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x6000014e3600&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>互斥锁有三个类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> * Mutex type attributes</div><div class=\"line\"> */</div><div class=\"line\"> 普通锁</div><div class=\"line\">#define PTHREAD_MUTEX_NORMAL\t\t0</div><div class=\"line\">//检查错误</div><div class=\"line\">#define PTHREAD_MUTEX_ERRORCHECK\t1</div><div class=\"line\">//递归锁</div><div class=\"line\">#define PTHREAD_MUTEX_RECURSIVE\t\t2</div><div class=\"line\">//普通锁</div><div class=\"line\">#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL</div></pre></td></tr></table></figure>\n<p>当我们这样子函数调用函数会出现死锁的问题，这是怎么出现的呢？第一把锁是锁住状态，然后进入第二个函数，锁在锁住状态，在等待，但是这把锁需要向后执行才会解锁，到时无限期的等待。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self otherTest2];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest2&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">-[FYPthread_mutex2 otherTest]</div></pre></td></tr></table></figure>\n<p>上面这个需求需要使用两把锁，或者使用递归锁来解决问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[self otherTest2];</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest2&#123;</div><div class=\"line\">\tpthread_mutex_lock(&amp;_plock2);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tpthread_mutex_unlock(&amp;_plock2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">-[FYPthread_mutex2 otherTest]</div><div class=\"line\">-[FYPthread_mutex2 otherTest2]</div></pre></td></tr></table></figure>\n<p>从使用2把锁是可以解决这个问题的。<br>递归锁是什么锁呢？允许同一个线程对一把锁重复加锁。</p>\n<h3 id=\"NSLock、NSRecursiveLosk\"><a href=\"#NSLock、NSRecursiveLosk\" class=\"headerlink\" title=\"NSLock、NSRecursiveLosk\"></a>NSLock、NSRecursiveLosk</h3><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p>\n<p>使用<code>(LLDB) si</code>可以跟踪<code>[myLock lock];</code>的内部函数最终是<code>pthread_mutex_lock</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foundation`-[NSLock lock]:</div><div class=\"line\">    0x1090dfb5a &lt;+0&gt;:  pushq  %rbp</div><div class=\"line\">    0x1090dfb5b &lt;+1&gt;:  movq   %rsp, %rbp</div><div class=\"line\">    0x1090dfb5e &lt;+4&gt;:  callq  0x1092ca3fe               ; symbol stub for: object_getIndexedIvars</div><div class=\"line\">    0x1090dfb63 &lt;+9&gt;:  movq   %rax, %rdi</div><div class=\"line\">    0x1090dfb66 &lt;+12&gt;: popq   %rbp</div><div class=\"line\">-&gt;  0x1090dfb67 &lt;+13&gt;: jmp    0x1092ca596   ;</div><div class=\"line\">//  symbol stub for: pthread_mutex_lock</div></pre></td></tr></table></figure>\n<p><code>NSLock API</code>大全</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//协议NSLocking</div><div class=\"line\">@protocol NSLocking</div><div class=\"line\"></div><div class=\"line\">- (void)lock;</div><div class=\"line\">- (void)unlock;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</div><div class=\"line\">@private</div><div class=\"line\">    void *_priv;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)tryLock;//尝试加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;//在某个日期前加锁，</div><div class=\"line\">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>用法也很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYNSLock()&#123;</div><div class=\"line\">\tNSLock *_lock;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation FYNSLock</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//封装了mutex的普通锁</div><div class=\"line\">\t\t_lock=[[NSLock alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __saveMonery];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[super __getMonery];</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x600003d4dc40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x600003d7bfc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x600003d66c00&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，<code>API</code>跟<code>NSLock</code>基本一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)tryLock;//尝试加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;//日期前加锁</div></pre></td></tr></table></figure>\n<p>递归锁可以对相同的线程进行反复加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation FYRecursiveLockDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//封装了mutex的递归锁</div><div class=\"line\">\t\t_lock=[[NSRecursiveLock alloc]init];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tstatic int count = 10;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\twhile (count &gt; 0) &#123;</div><div class=\"line\">\t\tcount -= 1;</div><div class=\"line\">\t\tprintf(&quot;循环% 2d次 - %s \\n&quot;,count,[NSThread currentThread].description.UTF8String);</div><div class=\"line\">\t\t[self otherTest];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">循环 9次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 8次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 7次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 6次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 5次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 4次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 3次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 2次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 1次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125; </div><div class=\"line\">循环 0次 - &lt;NSThread: 0x60000274e900&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"NSCondition-条件\"><a href=\"#NSCondition-条件\" class=\"headerlink\" title=\"NSCondition 条件\"></a>NSCondition 条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)wait;//等待</div><div class=\"line\">- (BOOL)waitUntilDate:(NSDate *)limit;</div><div class=\"line\">- (void)signal;//唤醒一个线程</div><div class=\"line\">- (void)broadcast;//唤醒多个线程</div></pre></td></tr></table></figure>\n<p><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self = [super init]) &#123;</div><div class=\"line\">\t\t//遵守的 lock协议 的 条件🔐</div><div class=\"line\">\t\t_lock=[[NSCondition alloc]init];</div><div class=\"line\">\t\tself.array =[NSMutableArray array];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil] start];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__add&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\t[self.array addObject:@&quot;Test&quot;];</div><div class=\"line\">\tNSLog(@&quot;添加成功&quot;);</div><div class=\"line\">\tsleep(1);</div><div class=\"line\">\t[_lock signal];//唤醒一个线程</div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__remove&#123;</div><div class=\"line\">\t[_lock lock];</div><div class=\"line\">\tif (self.array.count == 0) &#123;</div><div class=\"line\">\t\t[_lock wait];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t[self.array removeLastObject];</div><div class=\"line\">\tNSLog(@&quot;删除成功&quot;);</div><div class=\"line\"></div><div class=\"line\">\t[_lock unlock];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//Log</div><div class=\"line\"></div><div class=\"line\">2019-07-29 10:06:48.904648+0800 day16--线程安全[43603:4402260] 添加成功</div><div class=\"line\">2019-07-29 10:06:49.907641+0800 day16--线程安全[43603:4402259] 删除成功</div></pre></td></tr></table></figure>\n<p>可以看到时间上差了1秒，正好是我们设定的<code>sleep(1);</code>。优点是可以让线程之间形成依赖，缺点是没有明确的条件。</p>\n<h3 id=\"NSConditionLock-可以实现线程依赖的锁\"><a href=\"#NSConditionLock-可以实现线程依赖的锁\" class=\"headerlink\" title=\"NSConditionLock 可以实现线程依赖的锁\"></a>NSConditionLock 可以实现线程依赖的锁</h3><p><code>NSConditionLock</code>是可以实现多个子线程进行线程间的依赖，A依赖于B执行完成，B依赖于C执行完毕则可以使用<code>NSConditionLock</code>来解决问题。<br>首先看下<code>API</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (readonly) NSInteger condition;//条件值</div><div class=\"line\">- (void)lockWhenCondition:(NSInteger)condition;//当con为condition进行锁住</div><div class=\"line\">//尝试加锁</div><div class=\"line\">- (BOOL)tryLock;</div><div class=\"line\">//当con为condition进行尝试锁住</div><div class=\"line\">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</div><div class=\"line\">//当con为condition进行解锁</div><div class=\"line\">- (void)unlockWithCondition:(NSInteger)condition;</div><div class=\"line\">//NSDate 小余 limit进行 加锁</div><div class=\"line\">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class=\"line\">//条件为condition 在limit之前进行加锁</div><div class=\"line\">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure>\n<p>条件锁的使用，在<code>lockWhenCondition:(NSInteger)condition</code>的条件到达的时候才能进行正常的加锁和<code>unlockWithCondition:(NSInteger)condition</code>解锁，否则会阻塞线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test2) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test1) object:nil] start];</div><div class=\"line\">\t[[[NSThread alloc]initWithTarget:self selector:@selector(__test3) object:nil] start];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test1&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:1];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:2];//解锁 并赋值2</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test2&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:2];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:3];//解锁 并赋值3</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__test3&#123;</div><div class=\"line\">\t[_lock lockWhenCondition:3];</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\t[_lock unlockWithCondition:4];//解锁 并赋值4</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">-[FYCondLockDemo2 __test1]</div><div class=\"line\">-[FYCondLockDemo2 __test2]</div><div class=\"line\">-[FYCondLockDemo2 __test3]</div></pre></td></tr></table></figure>\n<p>当<code>con = 1</code>进行<code>test1</code>加锁和执行任务<code>A</code>，任务<code>A</code>执行完毕，进行解锁，并把值2赋值给<code>lock</code>，这是当<code>con = 2</code>的锁开始加锁，进入任务<code>B</code>，开始执行任务<code>B</code>，当任务<code>B</code>执行完毕，进行解锁并赋值为3，然后<code>con=3</code>的锁进行加锁，解锁并赋值4来进行线程之间的依赖。</p>\n<h3 id=\"dispatch-queue-特殊的锁\"><a href=\"#dispatch-queue-特殊的锁\" class=\"headerlink\" title=\"dispatch_queue 特殊的锁\"></a>dispatch_queue 特殊的锁</h3><p>其实直接使用GCD的串行队列，也是可以实现线程同步的。串行队列其实就是线程的任务在队列中按照顺序执行，达到了锁的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface FYSerialQueueDemo()&#123;</div><div class=\"line\">\tdispatch_queue_t _queue;</div><div class=\"line\">&#125;@end</div><div class=\"line\">@implementation FYSerialQueueDemo</div><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t_queue = dispatch_queue_create(&quot;fyserial.queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __saleTicket];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__getMonery&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __getMonery];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saveMonery&#123;</div><div class=\"line\">\tdispatch_sync(_queue, ^&#123;</div><div class=\"line\">\t\t[super __saveMonery];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x600001211b40&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x600001243700&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x60000121dd80&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"dispatch-semaphore-信号量控制并发数量\"><a href=\"#dispatch-semaphore-信号量控制并发数量\" class=\"headerlink\" title=\"dispatch_semaphore 信号量控制并发数量\"></a>dispatch_semaphore 信号量控制并发数量</h3><p>当我们有大量任务需要并发执行，而且同时最大并发量为5个线程，这样子又该如何控制呢？<code>dispatch_semaphore</code>信号量正好可以满足我们的需求。<br><code>dispatch_semaphore</code>可以控制并发线程的数量，当设置为1时，可以作为同步锁来用，设置多个的时候，就是异步并发队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化信号量 值为2，就是最多允许同时2个线程执行</div><div class=\"line\">_semaphore = dispatch_semaphore_create(2);</div><div class=\"line\">//生成多个线程进行并发访问test</div><div class=\"line\">- (void)otherTest&#123;</div><div class=\"line\">\tfor (int i = 0; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test&#123;</div><div class=\"line\">//如果信号量&gt;0 ，让信号量-1，继续向下执行。</div><div class=\"line\">//如果信号量 &lt;= 0;就会等待，等待时间是 DISPATCH_TIME_FOREVER</div><div class=\"line\">\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tsleep(2);//睡眠时间2s</div><div class=\"line\">\tNSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t//释放一个信号量</div><div class=\"line\">\tdispatch_semaphore_signal(_semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-29 11:17:53.233318+0800 day16--线程安全[47907:4529610] &lt;NSThread: 0x600002c45240&gt;&#123;number = 4, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:53.233329+0800 day16--线程安全[47907:4529609] &lt;NSThread: 0x600002c45200&gt;&#123;number = 3, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529616] &lt;NSThread: 0x600002c45540&gt;&#123;number = 10, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:55.233879+0800 day16--线程安全[47907:4529612] &lt;NSThread: 0x600002c45440&gt;&#123;number = 6, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:57.238860+0800 day16--线程安全[47907:4529613] &lt;NSThread: 0x600002c45480&gt;&#123;number = 7, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:57.238867+0800 day16--线程安全[47907:4529614] &lt;NSThread: 0x600002c454c0&gt;&#123;number = 8, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:59.241352+0800 day16--线程安全[47907:4529615] &lt;NSThread: 0x600002c45500&gt;&#123;number = 9, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:17:59.241324+0800 day16--线程安全[47907:4529611] &lt;NSThread: 0x600002c45400&gt;&#123;number = 5, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529618] &lt;NSThread: 0x600002c455c0&gt;&#123;number = 12, name = (null)&#125;</div><div class=\"line\">2019-07-29 11:18:01.245790+0800 day16--线程安全[47907:4529617] &lt;NSThread: 0x600002c45580&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>一次最多2个线程同时执行任务，暂停时间是2s。<br>使用信号量实现线程最大并发锁，<br>同时只有2个线程执行的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)init&#123;</div><div class=\"line\">\tif (self =[super init]) &#123;</div><div class=\"line\">\t\t_semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\t[super __saleTicket];</div><div class=\"line\">\tdispatch_semaphore_signal(_semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">//log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x6000022e0c00&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x6000022e0dc0&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x6000022ce880&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h3><p><code>@synchronized(id obj){}</code>锁的是对象<code>obj</code>，使用该锁的时候，底层是对象计算出来的值作为<code>key</code>，生成一把锁，不同的资源的读写可以使用不同<code>obj</code>作为锁对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)__saleTicket&#123;</div><div class=\"line\">\t@synchronized (self) &#123;</div><div class=\"line\">\t\t[super __saleTicket];</div><div class=\"line\">\t&#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> //log</div><div class=\"line\">还剩 9 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 8 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 7 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 6 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 5 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 4 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125; </div><div class=\"line\">还剩 3 张票 - &lt;NSThread: 0x60000057d5c0&gt;&#123;number = 3, name = (null)&#125; </div><div class=\"line\">还剩 2 张票 - &lt;NSThread: 0x60000056f340&gt;&#123;number = 4, name = (null)&#125; </div><div class=\"line\">还剩 1 张票 - &lt;NSThread: 0x60000057d500&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"atmoic-原子操作\"><a href=\"#atmoic-原子操作\" class=\"headerlink\" title=\"atmoic 原子操作\"></a>atmoic 原子操作</h3><p>给属性添加<code>atmoic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就保证了<code>setter</code>和<code>getter</code>的内部是线程同步的。<br>原子操作是最终调用了<code>static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) objc-accessors.mm 48行</code>，我们进入到函数内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置属性原子操作</div><div class=\"line\">void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class=\"line\">&#123;</div><div class=\"line\">    reallySetProperty(self, _cmd, newValue, offset, true, false, false);</div><div class=\"line\">&#125;</div><div class=\"line\">//非原子操作设置属性</div><div class=\"line\">void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)</div><div class=\"line\">&#123;</div><div class=\"line\">    reallySetProperty(self, _cmd, newValue, offset, false, false, false);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</div><div class=\"line\">&#123;//偏移量等于0则是class指针</div><div class=\"line\">    if (offset == 0) &#123;</div><div class=\"line\">        object_setClass(self, newValue);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">//其他的value</div><div class=\"line\">    id oldValue;</div><div class=\"line\">    id *slot = (id*) ((char*)self + offset);</div><div class=\"line\"></div><div class=\"line\">    if (copy) &#123;</div><div class=\"line\">    //如果是copy 用copyWithZone:</div><div class=\"line\">        newValue = [newValue copyWithZone:nil];</div><div class=\"line\">    &#125; else if (mutableCopy) &#123;</div><div class=\"line\">        //mutableCopy则调用mutableCopyWithZone:</div><div class=\"line\">        newValue = [newValue mutableCopyWithZone:nil];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    //如果赋值和原来的相等 则不操作</div><div class=\"line\">        if (*slot == newValue) return;</div><div class=\"line\">        newValue = objc_retain(newValue);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!atomic) &#123;//非原子操作 直接赋值</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;</div><div class=\"line\">    &#125; else &#123;//原子操作 加锁</div><div class=\"line\">    //锁和属性是一一对应的-&gt;自旋锁</div><div class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">        slotlock.lock();</div><div class=\"line\">        oldValue = *slot;</div><div class=\"line\">        *slot = newValue;//赋值</div><div class=\"line\">        slotlock.unlock();//解锁</div><div class=\"line\">    &#125;</div><div class=\"line\">    objc_release(oldValue);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</div><div class=\"line\">    if (offset == 0) &#123;</div><div class=\"line\">        return object_getClass(self);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Retain release world</div><div class=\"line\">    id *slot = (id*) ((char*)self + offset);</div><div class=\"line\">    if (!atomic) return *slot;//非原子操作 直接返回值</div><div class=\"line\">        </div><div class=\"line\">    // Atomic retain release world</div><div class=\"line\">\t//原子操作 加锁-&gt;自旋锁</div><div class=\"line\">    spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">    slotlock.lock();//加锁</div><div class=\"line\">    id value = objc_retain(*slot);</div><div class=\"line\">    slotlock.unlock();//解锁</div><div class=\"line\">    </div><div class=\"line\">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</div><div class=\"line\">    return objc_autoreleaseReturnValue(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以属性的地址为参数计算出key ，锁为value</div><div class=\"line\">StripedMap&lt;spinlock_t&gt; PropertyLocks;</div></pre></td></tr></table></figure>\n<p>从源码了解到设置属性读取是<code>self</code>+属性的偏移量，当<code>copy</code>或<code>mutableCopy</code>会调用到<code>[newValue copyWithZone:nil]</code>或<code>[newValue mutableCopyWithZone:nil]</code>，如果新旧值相等则不进行操作，非原子操作直接赋值，原子操作则获取<code>spinlock_t&amp; slotlock = PropertyLocks[slot]</code>进行加锁、赋值、解锁操作。而且<code>PropertyLocks</code>是一个类，类有一个数组属性，使用<code>*p</code>计算出来的值作为<code>key</code>。</p>\n<p>我们提取出来关键代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原子操作 加锁</div><div class=\"line\">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">slotlock.lock();</div><div class=\"line\">oldValue = *slot;</div><div class=\"line\">*slot = newValue;//赋值</div><div class=\"line\">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>\n<p>使用自旋锁对赋值操作进行加锁，保证了<code>setter()</code>方法的安全性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//原子操作 加锁 -&gt;自旋锁</div><div class=\"line\">spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class=\"line\">slotlock.lock();//加锁</div><div class=\"line\">id value = objc_retain(*slot);</div><div class=\"line\">slotlock.unlock();//解锁</div></pre></td></tr></table></figure>\n<p>取值之前进行加锁，取值之后进行解锁，保证了<code>getter()</code>方法的安全。</p>\n<p>由上面得知<code>atmoic</code>仅仅是对方法<code>setter()</code>和<code>getter()</code>安全，对成员变量不保证安全，对于属性的读写一般使用<code>nonatomic</code>，性能好，<code>atomic</code>读取频率高的时候会导致线程都在排队，浪费CPU时间。</p>\n<p>大概使用者几种锁分别对卖票功能进行了性能测试，<br>性能分别1万次、100万次、1000万次锁花费的时间对比，单位是秒。(仅供参考，不同环境时间略有差异)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">锁类型</th>\n<th style=\"text-align:center\">1万次</th>\n<th style=\"text-align:center\">100万次</th>\n<th style=\"text-align:center\">1000万次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">pthread_mutex_t</td>\n<td style=\"text-align:center\">0.000309</td>\n<td style=\"text-align:center\">0.027238</td>\n<td style=\"text-align:center\">0.284714</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">os_unfair_lock</td>\n<td style=\"text-align:center\">0.000274</td>\n<td style=\"text-align:center\">0.028266</td>\n<td style=\"text-align:center\">0.285685</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OSSpinLock</td>\n<td style=\"text-align:center\">0.030688</td>\n<td style=\"text-align:center\">0.410067</td>\n<td style=\"text-align:center\">0.437702</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSCondition</td>\n<td style=\"text-align:center\">0.005067</td>\n<td style=\"text-align:center\">0.323492</td>\n<td style=\"text-align:center\">1.078636</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSLock</td>\n<td style=\"text-align:center\">0.038692</td>\n<td style=\"text-align:center\">0.151601</td>\n<td style=\"text-align:center\">1.322062</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSRecursiveLock</td>\n<td style=\"text-align:center\">0.007973</td>\n<td style=\"text-align:center\">0.151601</td>\n<td style=\"text-align:center\">1.673409</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@synchronized</td>\n<td style=\"text-align:center\">0.008953</td>\n<td style=\"text-align:center\">0.640234</td>\n<td style=\"text-align:center\">2.790291</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NSConditionLock</td>\n<td style=\"text-align:center\">0.229148</td>\n<td style=\"text-align:center\">5.325272</td>\n<td style=\"text-align:center\">10.681123</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">semaphore</td>\n<td style=\"text-align:center\">0.094267</td>\n<td style=\"text-align:center\">0.415351</td>\n<td style=\"text-align:center\">24.699100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SerialQueue</td>\n<td style=\"text-align:center\">0.213386</td>\n<td style=\"text-align:center\">9.058581</td>\n<td style=\"text-align:center\">50.820202</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><p>平时我们简单使用的话没有很大的区别，还是推荐使用<code>NSLock</code>和信号量,最简单的是<code>@synchronized</code>，不用声明和初始化，直接拿来就用。</p>\n<h3 id=\"自旋锁、互斥锁比较\"><a href=\"#自旋锁、互斥锁比较\" class=\"headerlink\" title=\"自旋锁、互斥锁比较\"></a>自旋锁、互斥锁比较</h3><p>自旋锁和互斥锁各有优劣，代码执行频率高，CPU充足，可以使用互斥锁，频率低，代码复杂则需要互斥锁。</p>\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><ul>\n<li>自旋锁在等待时间比较短的时候比较合适</li>\n<li>临界区代码经常被调用，但竞争很少发生</li>\n<li>CPU不紧张</li>\n<li>多核处理器<h4 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h4></li>\n<li>预计线程等待时间比较长</li>\n<li>单核处理器</li>\n<li>临界区IO操作</li>\n<li>临界区代码比较多、复杂，或者循环量大</li>\n<li>临界区竞争非常激烈</li>\n</ul>\n<h2 id=\"锁的应用\"><a href=\"#锁的应用\" class=\"headerlink\" title=\"锁的应用\"></a>锁的应用</h2><h4 id=\"简单读写锁\"><a href=\"#简单读写锁\" class=\"headerlink\" title=\"简单读写锁\"></a>简单读写锁</h4><p>一个简单的读写锁，读写互斥即可，我们使用信号量，值设定为1.同时只能一个线程来操作文件,读写互斥。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">\t[super viewDidLoad];</div><div class=\"line\">\t// Do any additional setup after loading the view.</div><div class=\"line\">\tself.semaphore = dispatch_semaphore_create(1);</div><div class=\"line\">\t</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 10; i ++) &#123;</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(read) object:nil]start];</div><div class=\"line\">\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(write) object:nil]start];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)read&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tdispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)write&#123;</div><div class=\"line\">\tdispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</div><div class=\"line\">\tNSLog(@&quot;%s&quot;,__func__);</div><div class=\"line\">\tdispatch_semaphore_signal(self.semaphore);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当读写都是一个线程来操作，会降低性能，当多个线程在读资源的时候，其实不需要同步操作的，有读没写，理论上说不用限制异步数量，写入的时候不能读，才是真正限制线程性能的地方，读写锁具备以下特点</p>\n<ol>\n<li>同一时间，只能有1个线程进行写操作</li>\n<li>同一时间，允许有多个线程进行读的操作</li>\n<li>同一时间，不允许读写操作同时进行</li>\n</ol>\n<p>典型的<code>多读单写</code>，经常用于文件等数据的读写操作，我们实现2种</p>\n<h4 id=\"读写锁-pthread-rwlock\"><a href=\"#读写锁-pthread-rwlock\" class=\"headerlink\" title=\"读写锁 pthread_rwlock\"></a>读写锁 pthread_rwlock</h4><p>这是有c语言封装的读写锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化读写锁</div><div class=\"line\">int pthread_rwlock_init(pthread_rwlock_t * __restrict,</div><div class=\"line\">\t\tconst pthread_rwlockattr_t * _Nullable __restrict)</div><div class=\"line\">//读上锁</div><div class=\"line\">pthread_rwlock_rdlock(pthread_rwlock_t *)</div><div class=\"line\">//尝试加锁读</div><div class=\"line\">pthread_rwlock_tryrdlock(pthread_rwlock_t *)</div><div class=\"line\">//尝试加锁写</div><div class=\"line\">int pthread_rwlock_trywrlock(pthread_rwlock_t *)</div><div class=\"line\">//写入加锁</div><div class=\"line\">pthread_rwlock_wrlock(pthread_rwlock_t *)</div><div class=\"line\">//解锁</div><div class=\"line\">pthread_rwlock_unlock(pthread_rwlock_t *)</div><div class=\"line\">//销毁锁属性</div><div class=\"line\">pthread_rwlockattr_destroy(pthread_rwlockattr_t *)</div><div class=\"line\">//销毁锁</div><div class=\"line\">pthread_rwlock_destroy(pthread_rwlock_t * )</div></pre></td></tr></table></figure>\n<p><code>pthread_rwlock_t</code>使用很简单，只需要在读之前使用<code>pthread_rwlock_rdlock</code>，读完解锁<code>pthread_rwlock_unlock</code>,写入前需要加锁<code>pthread_rwlock_wrlock</code>，写入完成之后解锁<code>pthread_rwlock_unlock</code>，任务都执行完了可以选择销毁<code>pthread_rwlock_destroy</code>或者等待下次使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic,assign) pthread_rwlock_t rwlock;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)dealloc&#123;</div><div class=\"line\">\tpthread_rwlock_destroy(&amp;_rwlock);//销毁锁</div><div class=\"line\">&#125;</div><div class=\"line\">//初始化读写锁</div><div class=\"line\">pthread_rwlock_init(&amp;_rwlock, NULL);</div><div class=\"line\">\t</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">\tfor (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\t\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(readPthreadRWLock) object:nil]start];</div><div class=\"line\">\t\t\t[[[NSThread alloc]initWithTarget:self selector:@selector(writePthreadRWLock) object:nil]start];</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">- (void)readPthreadRWLock&#123;</div><div class=\"line\">    pthread_rwlock_rdlock(&amp;_rwlock);</div><div class=\"line\">    NSLog(@&quot;读文件&quot;);</div><div class=\"line\">    sleep(1);</div><div class=\"line\">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)writePthreadRWLock&#123;</div><div class=\"line\">    pthread_rwlock_wrlock(&amp;_rwlock);</div><div class=\"line\">    NSLog(@&quot; 写入文件&quot;);</div><div class=\"line\">    sleep(1);</div><div class=\"line\">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\">2019-07-30 10:47:16 读文件</div><div class=\"line\">2019-07-30 10:47:16 读文件</div><div class=\"line\">2019-07-30 10:47:17 写入文件</div><div class=\"line\">2019-07-30 10:47:18 写入文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:19 读文件</div><div class=\"line\">2019-07-30 10:47:20 写入文件</div><div class=\"line\">2019-07-30 10:47:21 写入文件</div><div class=\"line\">2019-07-30 10:47:22 写入文件</div></pre></td></tr></table></figure>\n<p>读文件会出现同一秒读多次，写文件同一秒只有一个。</p>\n<h4 id=\"异步栅栏调用-dispatch-barrier-async\"><a href=\"#异步栅栏调用-dispatch-barrier-async\" class=\"headerlink\" title=\"异步栅栏调用 dispatch_barrier_async\"></a>异步栅栏调用 dispatch_barrier_async</h4><p>栅栏大家都见过，为了分开一个地区而使用的，线程的栅栏函数是分开任务的执行顺序</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">任务</th>\n<th style=\"text-align:center\">任务</th>\n<th style=\"text-align:center\">任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">写</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">写</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n</tbody>\n</table>\n<p>这个函数传入的并发队列必须是通过<code>dispatch_queue_create</code>创建，如果传入的是一个串行的或者全局并发队列，这个函数便等同于<code>dispatch_async</code>的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化 异步队列</div><div class=\"line\">self.rwqueue = dispatch_queue_create(&quot;rw.thread&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\">for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class=\"line\">\tdispatch_async(queue, ^&#123;</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self readBarryier];</div><div class=\"line\">\t\t[self writeBarrier];</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)readBarryier&#123;</div><div class=\"line\">//添加任务到rwqueue</div><div class=\"line\">\tdispatch_async(self.rwqueue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;读文件 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t\tsleep(1);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)writeBarrier&#123;</div><div class=\"line\">//barrier_async添加任务到self.rwqueue中</div><div class=\"line\">\tdispatch_barrier_async(self.rwqueue, ^&#123;</div><div class=\"line\">\t\tNSLog(@&quot;写入文件 %@&quot;,[NSThread currentThread]);</div><div class=\"line\">\t\tsleep(1);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//log</div><div class=\"line\"></div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae0740&gt;&#123;number = 9, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8500&gt;&#123;number = 10, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ae8040&gt;&#123;number = 8, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:53 读文件 &lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:54 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:55 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div><div class=\"line\">2019-07-30 11:16:56 写入文件&lt;NSThread: 0x600001ac3a80&gt;&#123;number = 11, name = (null)&#125;</div></pre></td></tr></table></figure>\n<p>读文件会出现同一秒读多个，写文件同一秒只有一个。</p>\n<p>读写任务都添加到异步队列<code>rwqueue</code>中，使用栅栏函数<code>dispatch_barrier_async</code>拦截一下，实现读写互斥，读可以异步无限读，写只能一个同步写的功能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>普通线程锁本质就是同步执行</li>\n<li><code>atomic</code>原子操作只限制<code>setter</code>和<code>getter</code>方法，不限制成员变量</li>\n<li>读写锁高性能可以使用<code>pthread_rwlock_t</code>和<code>dispatch_barrier_async</code><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3></li>\n<li><a href=\"https://blog.csdn.net/Fly_as_tadpole/article/details/86436161\" target=\"_blank\" rel=\"external\">优先级反转</a></li>\n<li><a href=\"https://juejin.im/post/5a90de68f265da4e9b592b40#heading-16\" target=\"_blank\" rel=\"external\">iOS多线程：『GCD』详尽总结</a></li>\n<li><a href=\"http://www.520it.com/zt/ios_mj/\" target=\"_blank\" rel=\"external\">小码哥视频</a></li>\n<li><a href=\"http://awayqu.1024ul.com/ios/2018/05/02/gcd-3.html\" target=\"_blank\" rel=\"external\">任务调度</a></li>\n<li><a href=\"https://opensource.apple.com/tarballs/libdispatch/\" target=\"_blank\" rel=\"external\">libdispatch</a></li>\n<li>iOS和OS多线程与内存管理<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3></li>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code git</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC/objc4-750\" target=\"_blank\" rel=\"external\">runtime可运行的源码git</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>广告时间</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS底层原理  类的本质 --(2)","date":"2019-12-01T03:12:58.000Z","_content":"\n### 底层原理 类的本质\n复习一下[IOS 底层原理 对象的本质--(1)]()，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。\n\n```\n//Person\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes\n\tint _level;//4bytes\n\tint _code;//4bytes\n}\n@end\n@implementation Person\n@end\n```\n\n经过`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`编译之后其实`Person`对象是:\n\n```\nstruct Person_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tint _age;\n\tint _level;\n\tint _code;\n};\n```\n\n`NSObject_IMPL`结构体：\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n那么`NSObject`在内存中包括\n- `isa`指针\n- 其他成员变量\n\n![](../images/2-1.png)\n\n`isa`地址就是`instance`的地址，其他成员变量排在后边，也就是`instance`的地址就是`isa`的地址。\n\n那么这个`isa`指向的到底是什么呢？\n请往下继续看：\n先看下这段代码：\n\n```\nNSObject *ob1=[[NSObject alloc]init];\nNSObject *ob2=[[NSObject alloc]init];\n\nClass cl1 = object_getClass([ob1 class]);\nClass cl2 = object_getClass([ob2 class]);\n\nClass cl3 = ob1.class;\nClass cl4 = ob2.class;\n\nClass cl5 = NSObject.class;\n\nNSLog(@\" %p %p %p %p %p\",cl1,cl2,cl3,cl4,cl5);\n//0x7fff8e3ba0f0 0x7fff8e3ba0f0 \n//0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140\n```\n\n这代码是输出了几个`NSObject`的对象的类和`NSObject`的类对象的地址，可以看到`cl1==cl2`、`cl3==cl4==cl5`。\n\n\n#### Class的本质\n我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。\n\n```\nClass objectClass = [NSObject class];        \nClass objectMetaClass = object_getClass([NSObject class]);\n\n```\n\n点击class来到内部，可以发现\n\n```\ntypedef struct objc_class *Class;\n```\n\n`class`对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。\n\n来到`objc_class`内部，在源码中经常看到这段源码\n\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;//isa\n\n#if !__OBJC2__\n    Class _Nullable super_class                    //父类          OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                              //obj名字 OBJC2_UNAVAILABLE;\n    long version                                            //版本 OBJC2_UNAVAILABLE;\n    long info                                               //info OBJC2_UNAVAILABLE;\n    long instance_size                                      // OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars             //成员变量链表     OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;//方法链表\n    struct objc_cache * _Nonnull cache      //缓存链表                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols         //协议链表 OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n/* Use `Class` instead of `struct objc_class *` */\n```\n\n这段代码明显是 已经`OBJC2_UNAVAILABLE`，说明代码已经不在使用了。那么`objc_class`结构体内部结构到底是什么呢？通过objc搜寻`runtime`的内容可以看到`objc_class`内部\n\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n\n    void setInfo(uint32_t set) {\n        assert(isFuture()  ||  isRealized());\n        data()->setFlags(set);\n    }\n\n    void clearInfo(uint32_t clear) {\n        assert(isFuture()  ||  isRealized());\n        data()->clearFlags(clear);\n    }\n    //**后边省略\n```\n\n我们发现这个结构体继承 `objc_object` 并且结构体内有一些函数，因为这是`c++`结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到`objc_object`内，截取部分代码\n\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n\n    // initIsa() should be used to init the isa of new objects only.\n    // If this object already has an isa, use changeIsa() for correctness.\n    // initInstanceIsa(): objects with no custom RR/AWZ\n    // initClassIsa(): class objects\n    // initProtocolIsa(): protocol objects\n    // initIsa(): other objects\n    void initIsa(Class cls /*nonpointer=false*/);\n    void initClassIsa(Class cls /*nonpointer=maybe*/);\n    void initProtocolIsa(Class cls /*nonpointer=maybe*/);\n    void initInstanceIsa(Class cls, bool hasCxxDtor);\n```\n那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取`class_rw_t`内部实现代码\n\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;//方法列表\n    property_array_t properties;//属性列表\n    protocol_array_t protocols;//协议列表\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n**\n//后边省略\n}\n```\n\n而`class_rw_t`是通过`bits.data()`获取的，截取`bits.data()`查看内部实现,而仅仅是`bits&FAST_DATA_MASK`。\n\n```\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n```\n\n而成员变量则是存储在`class_ro_t`内部中的，我们来到`class_ro_t`内部查看：\n\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList;//方法列表\n    protocol_list_t * baseProtocols;//协议列表\n    const ivar_list_t * ivars;//成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;//属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n};\n```\n\n最后通过一张图总结一下：\n\n![](../images/2-2.png)\n\n那么我们来证明一下：\n我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。\n下边代码是我们自定义的值：\n\n```\n//\n//  Header.h\n//  day02-类的本质1\n//\n//  Created by Charlie on 2019/7/2.\n//  Copyright © 2019 www.fgyong.cn. All rights reserved.\n//\n\n#ifndef Header_h\n#define Header_h\n\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\nstruct bucket_t {\n\tcache_key_t _key;\n\tIMP _imp;\n};\n\nstruct cache_t {\n\tbucket_t *_buckets;\n\tmask_t _mask;\n\tmask_t _occupied;\n};\n\nstruct entsize_list_tt {\n\tuint32_t entsizeAndFlags;\n\tuint32_t count;\n};\n\nstruct method_t {\n\tSEL name;\n\tconst char *types;\n\tIMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n\tmethod_t first;\n};\n\nstruct ivar_t {\n\tint32_t *offset;\n\tconst char *name;\n\tconst char *type;\n\tuint32_t alignment_raw;\n\tuint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n\tivar_t first;\n};\n\nstruct property_t {\n\tconst char *name;\n\tconst char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n\tproperty_t first;\n};\n\nstruct chained_property_list {\n\tchained_property_list *next;\n\tuint32_t count;\n\tproperty_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n\tuintptr_t count;\n\tprotocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tuint32_t instanceStart;\n\tuint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n\tuint32_t reserved;\n#endif\n\tconst uint8_t * ivarLayout;\n\tconst char * name;  // 类名\n\tmethod_list_t * baseMethodList;\n\tprotocol_list_t * baseProtocols;\n\tconst ivar_list_t * ivars;  // 成员变量列表\n\tconst uint8_t * weakIvarLayout;\n\tproperty_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n\tuint32_t flags;\n\tuint32_t version;\n\tconst class_ro_t *ro;\n\tmethod_list_t * methods;    // 方法列表\n\tproperty_list_t *properties;    // 属性列表\n\tconst protocol_list_t * protocols;  // 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchar *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n\tuintptr_t bits;\npublic:\n\tclass_rw_t* data() { // 提供data()方法进行 & FAST_DATA_MASK 操作\n\t\treturn (class_rw_t *)(bits & FAST_DATA_MASK);\n\t}\n};\n\n/* OC对象 */\nstruct xx_objc_object {\n\tvoid *isa;\n};\n\n/* 类对象 */\nstruct fy_objc_class : xx_objc_object {\n\tClass superclass;\n\tcache_t cache;\n\tclass_data_bits_t bits;\npublic:\n\tclass_rw_t* data() {\n\t\treturn bits.data();\n\t}\n\t\n\tfy_objc_class* metaClass() { // 提供metaClass函数，获取元类对象\n\t\t// 上一篇我们讲解过，isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址\n\t\treturn (fy_objc_class *)((long long)isa & ISA_MASK);\n\t}\n};\n#endif /* Header_h */\n\n```\n\n这段代码亲测可用，直接复制自己新建`.h`文件导入'main.m'即可，将`main.m`改成`main.mm`或者将其他某一个`.m`改成`.mm`运行就可以运行了。\n\n那么我们再拿出来经典的那张图挨着分析`isa` 和`superclass`的指向\n\n![](../images/2-2.png)\n#### instance 对象验证\n使用 `p/x`输出`obj`16进制的地址，然后**isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址**。实施之后：\n\n```\n//object\n\nPrinting description of student:\n<Student: 0x1021729c0>\n(lldb) p/x object->isa //查看isa指针地址\n(Class) $0 = 0x001dffff8e3ba141 NSObject \n(lldb) p/x objectClass//输出 objectClass的地址\n(fy_objc_class *) $1 = 0x00007fff8e3ba140\n(lldb) p/x 0x001dffff8e3ba141&0x00007ffffffffff8//计算得出object->isa真正的地址\n(long) $2 = 0x00007fff8e3ba140 //0x00007fff8e3ba140是 objectClass地址和object->isa地址一样\n\n\n//person\n\nPrinting description of person: <Person: 0x102175300>\n(lldb) p/x person->isa\n(Class) $3 = 0x001d800100002469 Person\n(lldb) p/x 0x001d800100002469&0x00007ffffffffff8\n(long) $4 = 0x0000000100002468\n(lldb) p/x personClass\n(fy_objc_class *) $5 = 0x0000000100002468//isa 和personclass地址都是0x0000000100002468\n\n//student\n\n(lldb) p/x student->isa\n(Class) $6 = 0x001d8001000024b9 Student\n(lldb) p/x 0x001d8001000024b9&0x00007ffffffffff8\n(long) $7 = 0x00000001000024b8\n(lldb) p/x studentClass\n(fy_objc_class *) $8 = 0x00000001000024b8//studentclass 和isa地址都是0x00000001000024b8\n(lldb) \n```\n从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。\n\n\n\n#### class 对象验证\n接着我们来看`class`对象，同样通过上一篇文章，我们明确`class`对象中存储着`isa`指针，`superclass`指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对`object`源码的分析，我们知道这些信息存储在`class`对象的`class_rw_t`中，我们通过强制转化来窥探其中的内容\n\n```\n//objectClass and objectMetaClass\n\n(lldb) p/x objectClass->isa\n(__NSAtom *) $6 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1&0x00007ffffffffff8\n(long) $7 = 0x00007fff8e3ba0f0\n(lldb) p/x objectMetaClass\n(fy_objc_class *) $8 = 0x00007fff8e3ba0f0\n\n//personClass and personMetaClass\n\n(lldb) p/x personClass->isa\n(__NSAtom *) $9 = 0x001d800100002441\n(lldb) p/x personMetaClass\n(fy_objc_class *) $10 = 0x0000000100002440\n(lldb) p/x 0x001d800100002441&0x00007ffffffffff8\n(long) $11 = 0x0000000100002440\n\n//sutdentClass and studentMetaClass\n\n(lldb) p/x studentClass->isa\n(__NSAtom *) $12 = 0x001d800100002491\n(lldb) p/x 0x001d800100002491&0x00007ffffffffff8\n(long) $13 = 0x0000000100002490\n(lldb) p/x studentMetaClass\n(fy_objc_class *) $14 = 0x0000000100002490\n\n```\n有此结果得知`objectMetaClass==objectClass->isa==0x00007fff8e3ba0f0`,`personClass->isa==personMetaClass==0x0000000100002440`,`studentClass->isa==studentMetaClass==0x0000000100002490`。\n由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。\n\n#### meta-class对象验证\n\n最后我们来看`meta-class`元类对象，上文提到`meta-class`中存储着`isa`指针，`superclass`指针，以及类的类方法信息。同时我们知道`meta-class`元类对象与`class`类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的`isa`指针指向基类的元类对象，基类的元类对象的`isa`指针指向自己。元类对象的`superclass`指针指向其父类的元类对象，基类的元类对象的`superclass`指针指向其类对象。\n与`class`对象相同，我们同样通过模拟对`person`元类对象调用`.data`函数，即对`bits`进行`&FAST_DATA_MASK(0x00007ffffffffff8UL)`运算，并转化为`class_rw_t`。\n\n```\n// objectMetaClass->superclass = 0x00007fff8e3ba140  NSObject\n//objectMetaClass->isa =   0x00007fff8e3ba0f0\n//objectMetaClass = 0x00007fff8e3ba0f0\n\n(lldb) p/x objectMetaClass->superclass\n(Class) $20 = 0x00007fff8e3ba140 NSObject\n(lldb) p/x objectMetaClass->isa\n(__NSAtom *) $21 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1&0x00007ffffffffff8\n(long) $22 = 0x00007fff8e3ba0f0\n(lldb) p/x objectMetaClass\n(fy_objc_class *) $23 = 0x00007fff8e3ba0f0\n\n// personMetaClass->superclas=0x00007fff8e3ba0f0\n//personMetaClass->isa=0x00007fff8e3ba0f0\n//personMetaClass = 0x0000000100002440\n\n(lldb) p/x personMetaClass->superclass\n(Class) $25 = 0x00007fff8e3ba0f0\n(lldb) p/x personMetaClass->isa\n(__NSAtom *) $26 = 0x001dffff8e3ba0f1\n(lldb) p/x personMetaClass\n(fy_objc_class *) $30 = 0x0000000100002440\n\n// studentMetaClass->superclas=0x0000000100002440\n//studentMetaClass->isa=0x00007fff8e3ba0f0\n\n\n(lldb) p/x studentMetaClass->superclass\n(Class) $27 = 0x0000000100002440\n(lldb) p/x studentMetaClass->isa\n(__NSAtom *) $28 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1 & 0x00007ffffffffff8\n(long) $29 = 0x00007fff8e3ba0f0\n```\n\n由上面可以看出，`studentMetaClass->isa`,`personMetaClass->isa`,`objectMetaClass->isa`结果`mask`之后都是`0x00007fff8e3ba0f0`，与`p/x objectMetaClass`结果一致，则验证了13，14，15号线，`studentMetaClass->superclass =0x0000000100002440 `,`personMetaClass = 0x0000000100002440`验证12号线，`personMetaClass->isa=0x00007fff8e3ba0f0\n`和`objectMetaClass = 0x00007fff8e3ba0f0`验证了11号线，`objectMetaClass->superclass = 0x00007fff8e3ba140  NSObject`验证10号线。\n\n#### 总结：\n对象的isa指向哪里？\n- instance对象的isa指向class对象\n- class对象的isa指向meta-class对象\n- meta-class对象的isa指向基类的meta-class对象\n- class和meta-class的内存结构一样的，只是值不一样\n\n\nOC的类信息存放在哪里？\n- 对象方法、属性、成员变量、协议信息存放在class对象中\n- 类方法存放在meta-class对象中\n- 成员变量具体值存放在instance对象中\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n\n\n![](../images/0.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS底层原理 类的本质--(2).md","raw":"title: iOS底层原理  类的本质 --(2)\ndate: 2019-12-1 11:12:58\ntags:\n- iOS\ncategories: iOS\n---\n\n### 底层原理 类的本质\n复习一下[IOS 底层原理 对象的本质--(1)]()，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。\n\n```\n//Person\n@interface Person : NSObject\n{\n\t@public\n\tint _age;//4bytes\n\tint _level;//4bytes\n\tint _code;//4bytes\n}\n@end\n@implementation Person\n@end\n```\n\n经过`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp`编译之后其实`Person`对象是:\n\n```\nstruct Person_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tint _age;\n\tint _level;\n\tint _code;\n};\n```\n\n`NSObject_IMPL`结构体：\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n那么`NSObject`在内存中包括\n- `isa`指针\n- 其他成员变量\n\n![](../images/2-1.png)\n\n`isa`地址就是`instance`的地址，其他成员变量排在后边，也就是`instance`的地址就是`isa`的地址。\n\n那么这个`isa`指向的到底是什么呢？\n请往下继续看：\n先看下这段代码：\n\n```\nNSObject *ob1=[[NSObject alloc]init];\nNSObject *ob2=[[NSObject alloc]init];\n\nClass cl1 = object_getClass([ob1 class]);\nClass cl2 = object_getClass([ob2 class]);\n\nClass cl3 = ob1.class;\nClass cl4 = ob2.class;\n\nClass cl5 = NSObject.class;\n\nNSLog(@\" %p %p %p %p %p\",cl1,cl2,cl3,cl4,cl5);\n//0x7fff8e3ba0f0 0x7fff8e3ba0f0 \n//0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140\n```\n\n这代码是输出了几个`NSObject`的对象的类和`NSObject`的类对象的地址，可以看到`cl1==cl2`、`cl3==cl4==cl5`。\n\n\n#### Class的本质\n我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。\n\n```\nClass objectClass = [NSObject class];        \nClass objectMetaClass = object_getClass([NSObject class]);\n\n```\n\n点击class来到内部，可以发现\n\n```\ntypedef struct objc_class *Class;\n```\n\n`class`对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。\n\n来到`objc_class`内部，在源码中经常看到这段源码\n\n```\nstruct objc_class {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;//isa\n\n#if !__OBJC2__\n    Class _Nullable super_class                    //父类          OBJC2_UNAVAILABLE;\n    const char * _Nonnull name                              //obj名字 OBJC2_UNAVAILABLE;\n    long version                                            //版本 OBJC2_UNAVAILABLE;\n    long info                                               //info OBJC2_UNAVAILABLE;\n    long instance_size                                      // OBJC2_UNAVAILABLE;\n    struct objc_ivar_list * _Nullable ivars             //成员变量链表     OBJC2_UNAVAILABLE;\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;//方法链表\n    struct objc_cache * _Nonnull cache      //缓存链表                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list * _Nullable protocols         //协议链表 OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n/* Use `Class` instead of `struct objc_class *` */\n```\n\n这段代码明显是 已经`OBJC2_UNAVAILABLE`，说明代码已经不在使用了。那么`objc_class`结构体内部结构到底是什么呢？通过objc搜寻`runtime`的内容可以看到`objc_class`内部\n\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n    void setData(class_rw_t *newData) {\n        bits.setData(newData);\n    }\n\n    void setInfo(uint32_t set) {\n        assert(isFuture()  ||  isRealized());\n        data()->setFlags(set);\n    }\n\n    void clearInfo(uint32_t clear) {\n        assert(isFuture()  ||  isRealized());\n        data()->clearFlags(clear);\n    }\n    //**后边省略\n```\n\n我们发现这个结构体继承 `objc_object` 并且结构体内有一些函数，因为这是`c++`结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到`objc_object`内，截取部分代码\n\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n\n    // initIsa() should be used to init the isa of new objects only.\n    // If this object already has an isa, use changeIsa() for correctness.\n    // initInstanceIsa(): objects with no custom RR/AWZ\n    // initClassIsa(): class objects\n    // initProtocolIsa(): protocol objects\n    // initIsa(): other objects\n    void initIsa(Class cls /*nonpointer=false*/);\n    void initClassIsa(Class cls /*nonpointer=maybe*/);\n    void initProtocolIsa(Class cls /*nonpointer=maybe*/);\n    void initInstanceIsa(Class cls, bool hasCxxDtor);\n```\n那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取`class_rw_t`内部实现代码\n\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;//方法列表\n    property_array_t properties;//属性列表\n    protocol_array_t protocols;//协议列表\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n**\n//后边省略\n}\n```\n\n而`class_rw_t`是通过`bits.data()`获取的，截取`bits.data()`查看内部实现,而仅仅是`bits&FAST_DATA_MASK`。\n\n```\n    class_rw_t* data() {\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\n    }\n```\n\n而成员变量则是存储在`class_ro_t`内部中的，我们来到`class_ro_t`内部查看：\n\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList;//方法列表\n    protocol_list_t * baseProtocols;//协议列表\n    const ivar_list_t * ivars;//成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;//属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n};\n```\n\n最后通过一张图总结一下：\n\n![](../images/2-2.png)\n\n那么我们来证明一下：\n我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。\n下边代码是我们自定义的值：\n\n```\n//\n//  Header.h\n//  day02-类的本质1\n//\n//  Created by Charlie on 2019/7/2.\n//  Copyright © 2019 www.fgyong.cn. All rights reserved.\n//\n\n#ifndef Header_h\n#define Header_h\n\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n# elif __x86_64__\n#   define ISA_MASK        0x00007ffffffffff8ULL\n# endif\n\n#if __LP64__\ntypedef uint32_t mask_t;\n#else\ntypedef uint16_t mask_t;\n#endif\ntypedef uintptr_t cache_key_t;\n\nstruct bucket_t {\n\tcache_key_t _key;\n\tIMP _imp;\n};\n\nstruct cache_t {\n\tbucket_t *_buckets;\n\tmask_t _mask;\n\tmask_t _occupied;\n};\n\nstruct entsize_list_tt {\n\tuint32_t entsizeAndFlags;\n\tuint32_t count;\n};\n\nstruct method_t {\n\tSEL name;\n\tconst char *types;\n\tIMP imp;\n};\n\nstruct method_list_t : entsize_list_tt {\n\tmethod_t first;\n};\n\nstruct ivar_t {\n\tint32_t *offset;\n\tconst char *name;\n\tconst char *type;\n\tuint32_t alignment_raw;\n\tuint32_t size;\n};\n\nstruct ivar_list_t : entsize_list_tt {\n\tivar_t first;\n};\n\nstruct property_t {\n\tconst char *name;\n\tconst char *attributes;\n};\n\nstruct property_list_t : entsize_list_tt {\n\tproperty_t first;\n};\n\nstruct chained_property_list {\n\tchained_property_list *next;\n\tuint32_t count;\n\tproperty_t list[0];\n};\n\ntypedef uintptr_t protocol_ref_t;\nstruct protocol_list_t {\n\tuintptr_t count;\n\tprotocol_ref_t list[0];\n};\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tuint32_t instanceStart;\n\tuint32_t instanceSize;  // instance对象占用的内存空间\n#ifdef __LP64__\n\tuint32_t reserved;\n#endif\n\tconst uint8_t * ivarLayout;\n\tconst char * name;  // 类名\n\tmethod_list_t * baseMethodList;\n\tprotocol_list_t * baseProtocols;\n\tconst ivar_list_t * ivars;  // 成员变量列表\n\tconst uint8_t * weakIvarLayout;\n\tproperty_list_t *baseProperties;\n};\n\nstruct class_rw_t {\n\tuint32_t flags;\n\tuint32_t version;\n\tconst class_ro_t *ro;\n\tmethod_list_t * methods;    // 方法列表\n\tproperty_list_t *properties;    // 属性列表\n\tconst protocol_list_t * protocols;  // 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchar *demangledName;\n};\n\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\nstruct class_data_bits_t {\n\tuintptr_t bits;\npublic:\n\tclass_rw_t* data() { // 提供data()方法进行 & FAST_DATA_MASK 操作\n\t\treturn (class_rw_t *)(bits & FAST_DATA_MASK);\n\t}\n};\n\n/* OC对象 */\nstruct xx_objc_object {\n\tvoid *isa;\n};\n\n/* 类对象 */\nstruct fy_objc_class : xx_objc_object {\n\tClass superclass;\n\tcache_t cache;\n\tclass_data_bits_t bits;\npublic:\n\tclass_rw_t* data() {\n\t\treturn bits.data();\n\t}\n\t\n\tfy_objc_class* metaClass() { // 提供metaClass函数，获取元类对象\n\t\t// 上一篇我们讲解过，isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址\n\t\treturn (fy_objc_class *)((long long)isa & ISA_MASK);\n\t}\n};\n#endif /* Header_h */\n\n```\n\n这段代码亲测可用，直接复制自己新建`.h`文件导入'main.m'即可，将`main.m`改成`main.mm`或者将其他某一个`.m`改成`.mm`运行就可以运行了。\n\n那么我们再拿出来经典的那张图挨着分析`isa` 和`superclass`的指向\n\n![](../images/2-2.png)\n#### instance 对象验证\n使用 `p/x`输出`obj`16进制的地址，然后**isa指针需要经过一次 & ISA_MASK操作之后才得到真正的地址**。实施之后：\n\n```\n//object\n\nPrinting description of student:\n<Student: 0x1021729c0>\n(lldb) p/x object->isa //查看isa指针地址\n(Class) $0 = 0x001dffff8e3ba141 NSObject \n(lldb) p/x objectClass//输出 objectClass的地址\n(fy_objc_class *) $1 = 0x00007fff8e3ba140\n(lldb) p/x 0x001dffff8e3ba141&0x00007ffffffffff8//计算得出object->isa真正的地址\n(long) $2 = 0x00007fff8e3ba140 //0x00007fff8e3ba140是 objectClass地址和object->isa地址一样\n\n\n//person\n\nPrinting description of person: <Person: 0x102175300>\n(lldb) p/x person->isa\n(Class) $3 = 0x001d800100002469 Person\n(lldb) p/x 0x001d800100002469&0x00007ffffffffff8\n(long) $4 = 0x0000000100002468\n(lldb) p/x personClass\n(fy_objc_class *) $5 = 0x0000000100002468//isa 和personclass地址都是0x0000000100002468\n\n//student\n\n(lldb) p/x student->isa\n(Class) $6 = 0x001d8001000024b9 Student\n(lldb) p/x 0x001d8001000024b9&0x00007ffffffffff8\n(long) $7 = 0x00000001000024b8\n(lldb) p/x studentClass\n(fy_objc_class *) $8 = 0x00000001000024b8//studentclass 和isa地址都是0x00000001000024b8\n(lldb) \n```\n从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。\n\n\n\n#### class 对象验证\n接着我们来看`class`对象，同样通过上一篇文章，我们明确`class`对象中存储着`isa`指针，`superclass`指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对`object`源码的分析，我们知道这些信息存储在`class`对象的`class_rw_t`中，我们通过强制转化来窥探其中的内容\n\n```\n//objectClass and objectMetaClass\n\n(lldb) p/x objectClass->isa\n(__NSAtom *) $6 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1&0x00007ffffffffff8\n(long) $7 = 0x00007fff8e3ba0f0\n(lldb) p/x objectMetaClass\n(fy_objc_class *) $8 = 0x00007fff8e3ba0f0\n\n//personClass and personMetaClass\n\n(lldb) p/x personClass->isa\n(__NSAtom *) $9 = 0x001d800100002441\n(lldb) p/x personMetaClass\n(fy_objc_class *) $10 = 0x0000000100002440\n(lldb) p/x 0x001d800100002441&0x00007ffffffffff8\n(long) $11 = 0x0000000100002440\n\n//sutdentClass and studentMetaClass\n\n(lldb) p/x studentClass->isa\n(__NSAtom *) $12 = 0x001d800100002491\n(lldb) p/x 0x001d800100002491&0x00007ffffffffff8\n(long) $13 = 0x0000000100002490\n(lldb) p/x studentMetaClass\n(fy_objc_class *) $14 = 0x0000000100002490\n\n```\n有此结果得知`objectMetaClass==objectClass->isa==0x00007fff8e3ba0f0`,`personClass->isa==personMetaClass==0x0000000100002440`,`studentClass->isa==studentMetaClass==0x0000000100002490`。\n由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。\n\n#### meta-class对象验证\n\n最后我们来看`meta-class`元类对象，上文提到`meta-class`中存储着`isa`指针，`superclass`指针，以及类的类方法信息。同时我们知道`meta-class`元类对象与`class`类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的`isa`指针指向基类的元类对象，基类的元类对象的`isa`指针指向自己。元类对象的`superclass`指针指向其父类的元类对象，基类的元类对象的`superclass`指针指向其类对象。\n与`class`对象相同，我们同样通过模拟对`person`元类对象调用`.data`函数，即对`bits`进行`&FAST_DATA_MASK(0x00007ffffffffff8UL)`运算，并转化为`class_rw_t`。\n\n```\n// objectMetaClass->superclass = 0x00007fff8e3ba140  NSObject\n//objectMetaClass->isa =   0x00007fff8e3ba0f0\n//objectMetaClass = 0x00007fff8e3ba0f0\n\n(lldb) p/x objectMetaClass->superclass\n(Class) $20 = 0x00007fff8e3ba140 NSObject\n(lldb) p/x objectMetaClass->isa\n(__NSAtom *) $21 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1&0x00007ffffffffff8\n(long) $22 = 0x00007fff8e3ba0f0\n(lldb) p/x objectMetaClass\n(fy_objc_class *) $23 = 0x00007fff8e3ba0f0\n\n// personMetaClass->superclas=0x00007fff8e3ba0f0\n//personMetaClass->isa=0x00007fff8e3ba0f0\n//personMetaClass = 0x0000000100002440\n\n(lldb) p/x personMetaClass->superclass\n(Class) $25 = 0x00007fff8e3ba0f0\n(lldb) p/x personMetaClass->isa\n(__NSAtom *) $26 = 0x001dffff8e3ba0f1\n(lldb) p/x personMetaClass\n(fy_objc_class *) $30 = 0x0000000100002440\n\n// studentMetaClass->superclas=0x0000000100002440\n//studentMetaClass->isa=0x00007fff8e3ba0f0\n\n\n(lldb) p/x studentMetaClass->superclass\n(Class) $27 = 0x0000000100002440\n(lldb) p/x studentMetaClass->isa\n(__NSAtom *) $28 = 0x001dffff8e3ba0f1\n(lldb) p/x 0x001dffff8e3ba0f1 & 0x00007ffffffffff8\n(long) $29 = 0x00007fff8e3ba0f0\n```\n\n由上面可以看出，`studentMetaClass->isa`,`personMetaClass->isa`,`objectMetaClass->isa`结果`mask`之后都是`0x00007fff8e3ba0f0`，与`p/x objectMetaClass`结果一致，则验证了13，14，15号线，`studentMetaClass->superclass =0x0000000100002440 `,`personMetaClass = 0x0000000100002440`验证12号线，`personMetaClass->isa=0x00007fff8e3ba0f0\n`和`objectMetaClass = 0x00007fff8e3ba0f0`验证了11号线，`objectMetaClass->superclass = 0x00007fff8e3ba140  NSObject`验证10号线。\n\n#### 总结：\n对象的isa指向哪里？\n- instance对象的isa指向class对象\n- class对象的isa指向meta-class对象\n- meta-class对象的isa指向基类的meta-class对象\n- class和meta-class的内存结构一样的，只是值不一样\n\n\nOC的类信息存放在哪里？\n- 对象方法、属性、成员变量、协议信息存放在class对象中\n- 类方法存放在meta-class对象中\n- 成员变量具体值存放在instance对象中\n\n\n#### 资料下载\n- [学习资料下载](https://github.com/ifgyong/iOSDataFactory)\n- [demo code](https://github.com/ifgyong/demo/tree/master/OC)\n\n---\n最怕一生碌碌无为，还安慰自己平凡可贵。\n\n本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。\n\n\n\n![](../images/0.png)\n\n\n\n\n\n\n\n\n\n","slug":"iOS底层原理 类的本质--(2)","published":1,"updated":"2019-12-03T05:00:43.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2o000s9zsk0fc2m3mm","content":"<h3 id=\"底层原理-类的本质\"><a href=\"#底层原理-类的本质\" class=\"headerlink\" title=\"底层原理 类的本质\"></a>底层原理 类的本质</h3><p>复习一下<a href=\"\">IOS 底层原理 对象的本质–(1)</a>，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Person</div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes</div><div class=\"line\">\tint _level;//4bytes</div><div class=\"line\">\tint _code;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>经过<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后其实<code>Person</code>对象是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Person_IMPL &#123;</div><div class=\"line\">\tstruct NSObject_IMPL NSObject_IVARS;</div><div class=\"line\">\tint _age;</div><div class=\"line\">\tint _level;</div><div class=\"line\">\tint _code;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>NSObject_IMPL</code>结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\">\tClass isa;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>那么<code>NSObject</code>在内存中包括</p>\n<ul>\n<li><code>isa</code>指针</li>\n<li>其他成员变量</li>\n</ul>\n<p><img src=\"../images/2-1.png\" alt=\"\"></p>\n<p><code>isa</code>地址就是<code>instance</code>的地址，其他成员变量排在后边，也就是<code>instance</code>的地址就是<code>isa</code>的地址。</p>\n<p>那么这个<code>isa</code>指向的到底是什么呢？<br>请往下继续看：<br>先看下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSObject *ob1=[[NSObject alloc]init];</div><div class=\"line\">NSObject *ob2=[[NSObject alloc]init];</div><div class=\"line\"></div><div class=\"line\">Class cl1 = object_getClass([ob1 class]);</div><div class=\"line\">Class cl2 = object_getClass([ob2 class]);</div><div class=\"line\"></div><div class=\"line\">Class cl3 = ob1.class;</div><div class=\"line\">Class cl4 = ob2.class;</div><div class=\"line\"></div><div class=\"line\">Class cl5 = NSObject.class;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot; %p %p %p %p %p&quot;,cl1,cl2,cl3,cl4,cl5);</div><div class=\"line\">//0x7fff8e3ba0f0 0x7fff8e3ba0f0 </div><div class=\"line\">//0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140</div></pre></td></tr></table></figure>\n<p>这代码是输出了几个<code>NSObject</code>的对象的类和<code>NSObject</code>的类对象的地址，可以看到<code>cl1==cl2</code>、<code>cl3==cl4==cl5</code>。</p>\n<h4 id=\"Class的本质\"><a href=\"#Class的本质\" class=\"headerlink\" title=\"Class的本质\"></a>Class的本质</h4><p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class objectClass = [NSObject class];        </div><div class=\"line\">Class objectMetaClass = object_getClass([NSObject class]);</div></pre></td></tr></table></figure>\n<p>点击class来到内部，可以发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n<p><code>class</code>对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p>\n<p>来到<code>objc_class</code>内部，在源码中经常看到这段源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;//isa</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class _Nullable super_class                    //父类          OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char * _Nonnull name                              //obj名字 OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                            //版本 OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                               //info OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                      // OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list * _Nullable ivars             //成员变量链表     OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;//方法链表</div><div class=\"line\">    struct objc_cache * _Nonnull cache      //缓存链表                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list * _Nullable protocols         //协议链表 OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div><div class=\"line\">/* Use `Class` instead of `struct objc_class *` */</div></pre></td></tr></table></figure>\n<p>这段代码明显是 已经<code>OBJC2_UNAVAILABLE</code>，说明代码已经不在使用了。那么<code>objc_class</code>结构体内部结构到底是什么呢？通过objc搜寻<code>runtime</code>的内容可以看到<code>objc_class</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class : objc_object &#123;</div><div class=\"line\">    // Class ISA;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             // formerly cache pointer and vtable</div><div class=\"line\">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        return bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">    void setData(class_rw_t *newData) &#123;</div><div class=\"line\">        bits.setData(newData);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void setInfo(uint32_t set) &#123;</div><div class=\"line\">        assert(isFuture()  ||  isRealized());</div><div class=\"line\">        data()-&gt;setFlags(set);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void clearInfo(uint32_t clear) &#123;</div><div class=\"line\">        assert(isFuture()  ||  isRealized());</div><div class=\"line\">        data()-&gt;clearFlags(clear);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //**后边省略</div></pre></td></tr></table></figure>\n<p>我们发现这个结构体继承 <code>objc_object</code> 并且结构体内有一些函数，因为这是<code>c++</code>结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到<code>objc_object</code>内，截取部分代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123;</div><div class=\"line\">private:</div><div class=\"line\">    isa_t isa;</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\"></div><div class=\"line\">    // ISA() assumes this is NOT a tagged pointer object</div><div class=\"line\">    Class ISA();</div><div class=\"line\"></div><div class=\"line\">    // getIsa() allows this to be a tagged pointer object</div><div class=\"line\">    Class getIsa();</div><div class=\"line\"></div><div class=\"line\">    // initIsa() should be used to init the isa of new objects only.</div><div class=\"line\">    // If this object already has an isa, use changeIsa() for correctness.</div><div class=\"line\">    // initInstanceIsa(): objects with no custom RR/AWZ</div><div class=\"line\">    // initClassIsa(): class objects</div><div class=\"line\">    // initProtocolIsa(): protocol objects</div><div class=\"line\">    // initIsa(): other objects</div><div class=\"line\">    void initIsa(Class cls /*nonpointer=false*/);</div><div class=\"line\">    void initClassIsa(Class cls /*nonpointer=maybe*/);</div><div class=\"line\">    void initProtocolIsa(Class cls /*nonpointer=maybe*/);</div><div class=\"line\">    void initInstanceIsa(Class cls, bool hasCxxDtor);</div></pre></td></tr></table></figure>\n<p>那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取<code>class_rw_t</code>内部实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">    // Be warned that Symbolication knows the layout of this structure.</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;//方法列表</div><div class=\"line\">    property_array_t properties;//属性列表</div><div class=\"line\">    protocol_array_t protocols;//协议列表</div><div class=\"line\"></div><div class=\"line\">    Class firstSubclass;</div><div class=\"line\">    Class nextSiblingClass;</div><div class=\"line\">**</div><div class=\"line\">//后边省略</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而<code>class_rw_t</code>是通过<code>bits.data()</code>获取的，截取<code>bits.data()</code>查看内部实现,而仅仅是<code>bits&amp;FAST_DATA_MASK</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_rw_t* data() &#123;</div><div class=\"line\">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而成员变量则是存储在<code>class_ro_t</code>内部中的，我们来到<code>class_ro_t</code>内部查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t instanceStart;</div><div class=\"line\">    uint32_t instanceSize;</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">    uint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    const uint8_t * ivarLayout;</div><div class=\"line\">    </div><div class=\"line\">    const char * name;</div><div class=\"line\">    method_list_t * baseMethodList;//方法列表</div><div class=\"line\">    protocol_list_t * baseProtocols;//协议列表</div><div class=\"line\">    const ivar_list_t * ivars;//成员变量列表</div><div class=\"line\"></div><div class=\"line\">    const uint8_t * weakIvarLayout;</div><div class=\"line\">    property_list_t *baseProperties;//属性列表</div><div class=\"line\"></div><div class=\"line\">    method_list_t *baseMethods() const &#123;</div><div class=\"line\">        return baseMethodList;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>最后通过一张图总结一下：</p>\n<p><img src=\"../images/2-2.png\" alt=\"\"></p>\n<p>那么我们来证明一下：<br>我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。<br>下边代码是我们自定义的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\">//</div><div class=\"line\">//  Header.h</div><div class=\"line\">//  day02-类的本质1</div><div class=\"line\">//</div><div class=\"line\">//  Created by Charlie on 2019/7/2.</div><div class=\"line\">//  Copyright © 2019 www.fgyong.cn. All rights reserved.</div><div class=\"line\">//</div><div class=\"line\"></div><div class=\"line\">#ifndef Header_h</div><div class=\"line\">#define Header_h</div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\"># endif</div><div class=\"line\"></div><div class=\"line\">#if __LP64__</div><div class=\"line\">typedef uint32_t mask_t;</div><div class=\"line\">#else</div><div class=\"line\">typedef uint16_t mask_t;</div><div class=\"line\">#endif</div><div class=\"line\">typedef uintptr_t cache_key_t;</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">\tcache_key_t _key;</div><div class=\"line\">\tIMP _imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">\tbucket_t *_buckets;</div><div class=\"line\">\tmask_t _mask;</div><div class=\"line\">\tmask_t _occupied;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct entsize_list_tt &#123;</div><div class=\"line\">\tuint32_t entsizeAndFlags;</div><div class=\"line\">\tuint32_t count;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">\tSEL name;</div><div class=\"line\">\tconst char *types;</div><div class=\"line\">\tIMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tmethod_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_t &#123;</div><div class=\"line\">\tint32_t *offset;</div><div class=\"line\">\tconst char *name;</div><div class=\"line\">\tconst char *type;</div><div class=\"line\">\tuint32_t alignment_raw;</div><div class=\"line\">\tuint32_t size;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tivar_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_t &#123;</div><div class=\"line\">\tconst char *name;</div><div class=\"line\">\tconst char *attributes;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tproperty_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct chained_property_list &#123;</div><div class=\"line\">\tchained_property_list *next;</div><div class=\"line\">\tuint32_t count;</div><div class=\"line\">\tproperty_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef uintptr_t protocol_ref_t;</div><div class=\"line\">struct protocol_list_t &#123;</div><div class=\"line\">\tuintptr_t count;</div><div class=\"line\">\tprotocol_ref_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t instanceStart;</div><div class=\"line\">\tuint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">\tuint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">\tconst uint8_t * ivarLayout;</div><div class=\"line\">\tconst char * name;  // 类名</div><div class=\"line\">\tmethod_list_t * baseMethodList;</div><div class=\"line\">\tprotocol_list_t * baseProtocols;</div><div class=\"line\">\tconst ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">\tconst uint8_t * weakIvarLayout;</div><div class=\"line\">\tproperty_list_t *baseProperties;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t version;</div><div class=\"line\">\tconst class_ro_t *ro;</div><div class=\"line\">\tmethod_list_t * methods;    // 方法列表</div><div class=\"line\">\tproperty_list_t *properties;    // 属性列表</div><div class=\"line\">\tconst protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">\tClass firstSubclass;</div><div class=\"line\">\tClass nextSiblingClass;</div><div class=\"line\">\tchar *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</div><div class=\"line\">struct class_data_bits_t &#123;</div><div class=\"line\">\tuintptr_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作</div><div class=\"line\">\t\treturn (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* OC对象 */</div><div class=\"line\">struct xx_objc_object &#123;</div><div class=\"line\">\tvoid *isa;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* 类对象 */</div><div class=\"line\">struct fy_objc_class : xx_objc_object &#123;</div><div class=\"line\">\tClass superclass;</div><div class=\"line\">\tcache_t cache;</div><div class=\"line\">\tclass_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123;</div><div class=\"line\">\t\treturn bits.data();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</div><div class=\"line\">\t\t// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</div><div class=\"line\">\t\treturn (fy_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">#endif /* Header_h */</div></pre></td></tr></table></figure>\n<p>这段代码亲测可用，直接复制自己新建<code>.h</code>文件导入’main.m’即可，将<code>main.m</code>改成<code>main.mm</code>或者将其他某一个<code>.m</code>改成<code>.mm</code>运行就可以运行了。</p>\n<p>那么我们再拿出来经典的那张图挨着分析<code>isa</code> 和<code>superclass</code>的指向</p>\n<p><img src=\"../images/2-2.png\" alt=\"\"></p>\n<h4 id=\"instance-对象验证\"><a href=\"#instance-对象验证\" class=\"headerlink\" title=\"instance 对象验证\"></a>instance 对象验证</h4><p>使用 <code>p/x</code>输出<code>obj</code>16进制的地址，然后<strong>isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</strong>。实施之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//object</div><div class=\"line\"></div><div class=\"line\">Printing description of student:</div><div class=\"line\">&lt;Student: 0x1021729c0&gt;</div><div class=\"line\">(lldb) p/x object-&gt;isa //查看isa指针地址</div><div class=\"line\">(Class) $0 = 0x001dffff8e3ba141 NSObject </div><div class=\"line\">(lldb) p/x objectClass//输出 objectClass的地址</div><div class=\"line\">(fy_objc_class *) $1 = 0x00007fff8e3ba140</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba141&amp;0x00007ffffffffff8//计算得出object-&gt;isa真正的地址</div><div class=\"line\">(long) $2 = 0x00007fff8e3ba140 //0x00007fff8e3ba140是 objectClass地址和object-&gt;isa地址一样</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//person</div><div class=\"line\"></div><div class=\"line\">Printing description of person: &lt;Person: 0x102175300&gt;</div><div class=\"line\">(lldb) p/x person-&gt;isa</div><div class=\"line\">(Class) $3 = 0x001d800100002469 Person</div><div class=\"line\">(lldb) p/x 0x001d800100002469&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $4 = 0x0000000100002468</div><div class=\"line\">(lldb) p/x personClass</div><div class=\"line\">(fy_objc_class *) $5 = 0x0000000100002468//isa 和personclass地址都是0x0000000100002468</div><div class=\"line\"></div><div class=\"line\">//student</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x student-&gt;isa</div><div class=\"line\">(Class) $6 = 0x001d8001000024b9 Student</div><div class=\"line\">(lldb) p/x 0x001d8001000024b9&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $7 = 0x00000001000024b8</div><div class=\"line\">(lldb) p/x studentClass</div><div class=\"line\">(fy_objc_class *) $8 = 0x00000001000024b8//studentclass 和isa地址都是0x00000001000024b8</div><div class=\"line\">(lldb)</div></pre></td></tr></table></figure>\n<p>从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。</p>\n<h4 id=\"class-对象验证\"><a href=\"#class-对象验证\" class=\"headerlink\" title=\"class 对象验证\"></a>class 对象验证</h4><p>接着我们来看<code>class</code>对象，同样通过上一篇文章，我们明确<code>class</code>对象中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对<code>object</code>源码的分析，我们知道这些信息存储在<code>class</code>对象的<code>class_rw_t</code>中，我们通过强制转化来窥探其中的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//objectClass and objectMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x objectClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $6 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $7 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x objectMetaClass</div><div class=\"line\">(fy_objc_class *) $8 = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">//personClass and personMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x personClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $9 = 0x001d800100002441</div><div class=\"line\">(lldb) p/x personMetaClass</div><div class=\"line\">(fy_objc_class *) $10 = 0x0000000100002440</div><div class=\"line\">(lldb) p/x 0x001d800100002441&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $11 = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">//sutdentClass and studentMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x studentClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $12 = 0x001d800100002491</div><div class=\"line\">(lldb) p/x 0x001d800100002491&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $13 = 0x0000000100002490</div><div class=\"line\">(lldb) p/x studentMetaClass</div><div class=\"line\">(fy_objc_class *) $14 = 0x0000000100002490</div></pre></td></tr></table></figure>\n<p>有此结果得知<code>objectMetaClass==objectClass-&gt;isa==0x00007fff8e3ba0f0</code>,<code>personClass-&gt;isa==personMetaClass==0x0000000100002440</code>,<code>studentClass-&gt;isa==studentMetaClass==0x0000000100002490</code>。<br>由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。</p>\n<h4 id=\"meta-class对象验证\"><a href=\"#meta-class对象验证\" class=\"headerlink\" title=\"meta-class对象验证\"></a>meta-class对象验证</h4><p>最后我们来看<code>meta-class</code>元类对象，上文提到<code>meta-class</code>中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的类方法信息。同时我们知道<code>meta-class</code>元类对象与<code>class</code>类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的<code>isa</code>指针指向基类的元类对象，基类的元类对象的<code>isa</code>指针指向自己。元类对象的<code>superclass</code>指针指向其父类的元类对象，基类的元类对象的<code>superclass</code>指针指向其类对象。<br>与<code>class</code>对象相同，我们同样通过模拟对<code>person</code>元类对象调用<code>.data</code>函数，即对<code>bits</code>进行<code>&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)</code>运算，并转化为<code>class_rw_t</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">// objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</div><div class=\"line\">//objectMetaClass-&gt;isa =   0x00007fff8e3ba0f0</div><div class=\"line\">//objectMetaClass = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x objectMetaClass-&gt;superclass</div><div class=\"line\">(Class) $20 = 0x00007fff8e3ba140 NSObject</div><div class=\"line\">(lldb) p/x objectMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $21 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $22 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x objectMetaClass</div><div class=\"line\">(fy_objc_class *) $23 = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">// personMetaClass-&gt;superclas=0x00007fff8e3ba0f0</div><div class=\"line\">//personMetaClass-&gt;isa=0x00007fff8e3ba0f0</div><div class=\"line\">//personMetaClass = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x personMetaClass-&gt;superclass</div><div class=\"line\">(Class) $25 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x personMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $26 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x personMetaClass</div><div class=\"line\">(fy_objc_class *) $30 = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">// studentMetaClass-&gt;superclas=0x0000000100002440</div><div class=\"line\">//studentMetaClass-&gt;isa=0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(lldb) p/x studentMetaClass-&gt;superclass</div><div class=\"line\">(Class) $27 = 0x0000000100002440</div><div class=\"line\">(lldb) p/x studentMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $28 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1 &amp; 0x00007ffffffffff8</div><div class=\"line\">(long) $29 = 0x00007fff8e3ba0f0</div></pre></td></tr></table></figure>\n<p>由上面可以看出，<code>studentMetaClass-&gt;isa</code>,<code>personMetaClass-&gt;isa</code>,<code>objectMetaClass-&gt;isa</code>结果<code>mask</code>之后都是<code>0x00007fff8e3ba0f0</code>，与<code>p/x objectMetaClass</code>结果一致，则验证了13，14，15号线，<code>studentMetaClass-&gt;superclass =0x0000000100002440</code>,<code>personMetaClass = 0x0000000100002440</code>验证12号线，<code>personMetaClass-&gt;isa=0x00007fff8e3ba0f0</code>和<code>objectMetaClass = 0x00007fff8e3ba0f0</code>验证了11号线，<code>objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</code>验证10号线。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>对象的isa指向哪里？</p>\n<ul>\n<li>instance对象的isa指向class对象</li>\n<li>class对象的isa指向meta-class对象</li>\n<li>meta-class对象的isa指向基类的meta-class对象</li>\n<li>class和meta-class的内存结构一样的，只是值不一样</li>\n</ul>\n<p>OC的类信息存放在哪里？</p>\n<ul>\n<li>对象方法、属性、成员变量、协议信息存放在class对象中</li>\n<li>类方法存放在meta-class对象中</li>\n<li>成员变量具体值存放在instance对象中</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"底层原理-类的本质\"><a href=\"#底层原理-类的本质\" class=\"headerlink\" title=\"底层原理 类的本质\"></a>底层原理 类的本质</h3><p>复习一下<a href=\"\">IOS 底层原理 对象的本质–(1)</a>，可以看出来实例对象实际是上结构体，那么这个结构体是有类指针和成员变量组成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Person</div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">\t@public</div><div class=\"line\">\tint _age;//4bytes</div><div class=\"line\">\tint _level;//4bytes</div><div class=\"line\">\tint _code;//4bytes</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>经过<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main64.cpp</code>编译之后其实<code>Person</code>对象是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Person_IMPL &#123;</div><div class=\"line\">\tstruct NSObject_IMPL NSObject_IVARS;</div><div class=\"line\">\tint _age;</div><div class=\"line\">\tint _level;</div><div class=\"line\">\tint _code;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>NSObject_IMPL</code>结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct NSObject_IMPL &#123;</div><div class=\"line\">\tClass isa;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>那么<code>NSObject</code>在内存中包括</p>\n<ul>\n<li><code>isa</code>指针</li>\n<li>其他成员变量</li>\n</ul>\n<p><img src=\"../images/2-1.png\" alt=\"\"></p>\n<p><code>isa</code>地址就是<code>instance</code>的地址，其他成员变量排在后边，也就是<code>instance</code>的地址就是<code>isa</code>的地址。</p>\n<p>那么这个<code>isa</code>指向的到底是什么呢？<br>请往下继续看：<br>先看下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSObject *ob1=[[NSObject alloc]init];</div><div class=\"line\">NSObject *ob2=[[NSObject alloc]init];</div><div class=\"line\"></div><div class=\"line\">Class cl1 = object_getClass([ob1 class]);</div><div class=\"line\">Class cl2 = object_getClass([ob2 class]);</div><div class=\"line\"></div><div class=\"line\">Class cl3 = ob1.class;</div><div class=\"line\">Class cl4 = ob2.class;</div><div class=\"line\"></div><div class=\"line\">Class cl5 = NSObject.class;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot; %p %p %p %p %p&quot;,cl1,cl2,cl3,cl4,cl5);</div><div class=\"line\">//0x7fff8e3ba0f0 0x7fff8e3ba0f0 </div><div class=\"line\">//0x7fff8e3ba140 0x7fff8e3ba140 0x7fff8e3ba140</div></pre></td></tr></table></figure>\n<p>这代码是输出了几个<code>NSObject</code>的对象的类和<code>NSObject</code>的类对象的地址，可以看到<code>cl1==cl2</code>、<code>cl3==cl4==cl5</code>。</p>\n<h4 id=\"Class的本质\"><a href=\"#Class的本质\" class=\"headerlink\" title=\"Class的本质\"></a>Class的本质</h4><p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class objectClass = [NSObject class];        </div><div class=\"line\">Class objectMetaClass = object_getClass([NSObject class]);</div></pre></td></tr></table></figure>\n<p>点击class来到内部，可以发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n<p><code>class</code>对象其实是指向objc_class的结构体，因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p>\n<p>来到<code>objc_class</code>内部，在源码中经常看到这段源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;//isa</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class _Nullable super_class                    //父类          OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char * _Nonnull name                              //obj名字 OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                            //版本 OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                               //info OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                      // OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list * _Nullable ivars             //成员变量链表     OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;//方法链表</div><div class=\"line\">    struct objc_cache * _Nonnull cache      //缓存链表                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list * _Nullable protocols         //协议链表 OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div><div class=\"line\">/* Use `Class` instead of `struct objc_class *` */</div></pre></td></tr></table></figure>\n<p>这段代码明显是 已经<code>OBJC2_UNAVAILABLE</code>，说明代码已经不在使用了。那么<code>objc_class</code>结构体内部结构到底是什么呢？通过objc搜寻<code>runtime</code>的内容可以看到<code>objc_class</code>内部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class : objc_object &#123;</div><div class=\"line\">    // Class ISA;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             // formerly cache pointer and vtable</div><div class=\"line\">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        return bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">    void setData(class_rw_t *newData) &#123;</div><div class=\"line\">        bits.setData(newData);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void setInfo(uint32_t set) &#123;</div><div class=\"line\">        assert(isFuture()  ||  isRealized());</div><div class=\"line\">        data()-&gt;setFlags(set);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void clearInfo(uint32_t clear) &#123;</div><div class=\"line\">        assert(isFuture()  ||  isRealized());</div><div class=\"line\">        data()-&gt;clearFlags(clear);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //**后边省略</div></pre></td></tr></table></figure>\n<p>我们发现这个结构体继承 <code>objc_object</code> 并且结构体内有一些函数，因为这是<code>c++</code>结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到<code>objc_object</code>内，截取部分代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123;</div><div class=\"line\">private:</div><div class=\"line\">    isa_t isa;</div><div class=\"line\"></div><div class=\"line\">public:</div><div class=\"line\"></div><div class=\"line\">    // ISA() assumes this is NOT a tagged pointer object</div><div class=\"line\">    Class ISA();</div><div class=\"line\"></div><div class=\"line\">    // getIsa() allows this to be a tagged pointer object</div><div class=\"line\">    Class getIsa();</div><div class=\"line\"></div><div class=\"line\">    // initIsa() should be used to init the isa of new objects only.</div><div class=\"line\">    // If this object already has an isa, use changeIsa() for correctness.</div><div class=\"line\">    // initInstanceIsa(): objects with no custom RR/AWZ</div><div class=\"line\">    // initClassIsa(): class objects</div><div class=\"line\">    // initProtocolIsa(): protocol objects</div><div class=\"line\">    // initIsa(): other objects</div><div class=\"line\">    void initIsa(Class cls /*nonpointer=false*/);</div><div class=\"line\">    void initClassIsa(Class cls /*nonpointer=maybe*/);</div><div class=\"line\">    void initProtocolIsa(Class cls /*nonpointer=maybe*/);</div><div class=\"line\">    void initInstanceIsa(Class cls, bool hasCxxDtor);</div></pre></td></tr></table></figure>\n<p>那么我们之前了解到的，类中存储的类的成员变量信息，方法列表，协议列表，截取<code>class_rw_t</code>内部实现代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">    // Be warned that Symbolication knows the layout of this structure.</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    const class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;//方法列表</div><div class=\"line\">    property_array_t properties;//属性列表</div><div class=\"line\">    protocol_array_t protocols;//协议列表</div><div class=\"line\"></div><div class=\"line\">    Class firstSubclass;</div><div class=\"line\">    Class nextSiblingClass;</div><div class=\"line\">**</div><div class=\"line\">//后边省略</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而<code>class_rw_t</code>是通过<code>bits.data()</code>获取的，截取<code>bits.data()</code>查看内部实现,而仅仅是<code>bits&amp;FAST_DATA_MASK</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_rw_t* data() &#123;</div><div class=\"line\">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而成员变量则是存储在<code>class_ro_t</code>内部中的，我们来到<code>class_ro_t</code>内部查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t instanceStart;</div><div class=\"line\">    uint32_t instanceSize;</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">    uint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">    const uint8_t * ivarLayout;</div><div class=\"line\">    </div><div class=\"line\">    const char * name;</div><div class=\"line\">    method_list_t * baseMethodList;//方法列表</div><div class=\"line\">    protocol_list_t * baseProtocols;//协议列表</div><div class=\"line\">    const ivar_list_t * ivars;//成员变量列表</div><div class=\"line\"></div><div class=\"line\">    const uint8_t * weakIvarLayout;</div><div class=\"line\">    property_list_t *baseProperties;//属性列表</div><div class=\"line\"></div><div class=\"line\">    method_list_t *baseMethods() const &#123;</div><div class=\"line\">        return baseMethodList;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>最后通过一张图总结一下：</p>\n<p><img src=\"../images/2-2.png\" alt=\"\"></p>\n<p>那么我们来证明一下：<br>我们可以自定义一下一个和系统一样的结构体，那么我们当我们强制转化的时候，他们赋值会一一对应，此时我们就可以拿到结构体的内部的值。<br>下边代码是我们自定义的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\">//</div><div class=\"line\">//  Header.h</div><div class=\"line\">//  day02-类的本质1</div><div class=\"line\">//</div><div class=\"line\">//  Created by Charlie on 2019/7/2.</div><div class=\"line\">//  Copyright © 2019 www.fgyong.cn. All rights reserved.</div><div class=\"line\">//</div><div class=\"line\"></div><div class=\"line\">#ifndef Header_h</div><div class=\"line\">#define Header_h</div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\"># if __arm64__</div><div class=\"line\">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class=\"line\"># elif __x86_64__</div><div class=\"line\">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class=\"line\"># endif</div><div class=\"line\"></div><div class=\"line\">#if __LP64__</div><div class=\"line\">typedef uint32_t mask_t;</div><div class=\"line\">#else</div><div class=\"line\">typedef uint16_t mask_t;</div><div class=\"line\">#endif</div><div class=\"line\">typedef uintptr_t cache_key_t;</div><div class=\"line\"></div><div class=\"line\">struct bucket_t &#123;</div><div class=\"line\">\tcache_key_t _key;</div><div class=\"line\">\tIMP _imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct cache_t &#123;</div><div class=\"line\">\tbucket_t *_buckets;</div><div class=\"line\">\tmask_t _mask;</div><div class=\"line\">\tmask_t _occupied;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct entsize_list_tt &#123;</div><div class=\"line\">\tuint32_t entsizeAndFlags;</div><div class=\"line\">\tuint32_t count;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_t &#123;</div><div class=\"line\">\tSEL name;</div><div class=\"line\">\tconst char *types;</div><div class=\"line\">\tIMP imp;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct method_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tmethod_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_t &#123;</div><div class=\"line\">\tint32_t *offset;</div><div class=\"line\">\tconst char *name;</div><div class=\"line\">\tconst char *type;</div><div class=\"line\">\tuint32_t alignment_raw;</div><div class=\"line\">\tuint32_t size;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct ivar_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tivar_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_t &#123;</div><div class=\"line\">\tconst char *name;</div><div class=\"line\">\tconst char *attributes;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct property_list_t : entsize_list_tt &#123;</div><div class=\"line\">\tproperty_t first;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct chained_property_list &#123;</div><div class=\"line\">\tchained_property_list *next;</div><div class=\"line\">\tuint32_t count;</div><div class=\"line\">\tproperty_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef uintptr_t protocol_ref_t;</div><div class=\"line\">struct protocol_list_t &#123;</div><div class=\"line\">\tuintptr_t count;</div><div class=\"line\">\tprotocol_ref_t list[0];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_ro_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t instanceStart;</div><div class=\"line\">\tuint32_t instanceSize;  // instance对象占用的内存空间</div><div class=\"line\">#ifdef __LP64__</div><div class=\"line\">\tuint32_t reserved;</div><div class=\"line\">#endif</div><div class=\"line\">\tconst uint8_t * ivarLayout;</div><div class=\"line\">\tconst char * name;  // 类名</div><div class=\"line\">\tmethod_list_t * baseMethodList;</div><div class=\"line\">\tprotocol_list_t * baseProtocols;</div><div class=\"line\">\tconst ivar_list_t * ivars;  // 成员变量列表</div><div class=\"line\">\tconst uint8_t * weakIvarLayout;</div><div class=\"line\">\tproperty_list_t *baseProperties;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">struct class_rw_t &#123;</div><div class=\"line\">\tuint32_t flags;</div><div class=\"line\">\tuint32_t version;</div><div class=\"line\">\tconst class_ro_t *ro;</div><div class=\"line\">\tmethod_list_t * methods;    // 方法列表</div><div class=\"line\">\tproperty_list_t *properties;    // 属性列表</div><div class=\"line\">\tconst protocol_list_t * protocols;  // 协议列表</div><div class=\"line\">\tClass firstSubclass;</div><div class=\"line\">\tClass nextSiblingClass;</div><div class=\"line\">\tchar *demangledName;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">#define FAST_DATA_MASK          0x00007ffffffffff8UL</div><div class=\"line\">struct class_data_bits_t &#123;</div><div class=\"line\">\tuintptr_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作</div><div class=\"line\">\t\treturn (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* OC对象 */</div><div class=\"line\">struct xx_objc_object &#123;</div><div class=\"line\">\tvoid *isa;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">/* 类对象 */</div><div class=\"line\">struct fy_objc_class : xx_objc_object &#123;</div><div class=\"line\">\tClass superclass;</div><div class=\"line\">\tcache_t cache;</div><div class=\"line\">\tclass_data_bits_t bits;</div><div class=\"line\">public:</div><div class=\"line\">\tclass_rw_t* data() &#123;</div><div class=\"line\">\t\treturn bits.data();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfy_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象</div><div class=\"line\">\t\t// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</div><div class=\"line\">\t\treturn (fy_objc_class *)((long long)isa &amp; ISA_MASK);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">#endif /* Header_h */</div></pre></td></tr></table></figure>\n<p>这段代码亲测可用，直接复制自己新建<code>.h</code>文件导入’main.m’即可，将<code>main.m</code>改成<code>main.mm</code>或者将其他某一个<code>.m</code>改成<code>.mm</code>运行就可以运行了。</p>\n<p>那么我们再拿出来经典的那张图挨着分析<code>isa</code> 和<code>superclass</code>的指向</p>\n<p><img src=\"../images/2-2.png\" alt=\"\"></p>\n<h4 id=\"instance-对象验证\"><a href=\"#instance-对象验证\" class=\"headerlink\" title=\"instance 对象验证\"></a>instance 对象验证</h4><p>使用 <code>p/x</code>输出<code>obj</code>16进制的地址，然后<strong>isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址</strong>。实施之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//object</div><div class=\"line\"></div><div class=\"line\">Printing description of student:</div><div class=\"line\">&lt;Student: 0x1021729c0&gt;</div><div class=\"line\">(lldb) p/x object-&gt;isa //查看isa指针地址</div><div class=\"line\">(Class) $0 = 0x001dffff8e3ba141 NSObject </div><div class=\"line\">(lldb) p/x objectClass//输出 objectClass的地址</div><div class=\"line\">(fy_objc_class *) $1 = 0x00007fff8e3ba140</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba141&amp;0x00007ffffffffff8//计算得出object-&gt;isa真正的地址</div><div class=\"line\">(long) $2 = 0x00007fff8e3ba140 //0x00007fff8e3ba140是 objectClass地址和object-&gt;isa地址一样</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//person</div><div class=\"line\"></div><div class=\"line\">Printing description of person: &lt;Person: 0x102175300&gt;</div><div class=\"line\">(lldb) p/x person-&gt;isa</div><div class=\"line\">(Class) $3 = 0x001d800100002469 Person</div><div class=\"line\">(lldb) p/x 0x001d800100002469&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $4 = 0x0000000100002468</div><div class=\"line\">(lldb) p/x personClass</div><div class=\"line\">(fy_objc_class *) $5 = 0x0000000100002468//isa 和personclass地址都是0x0000000100002468</div><div class=\"line\"></div><div class=\"line\">//student</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x student-&gt;isa</div><div class=\"line\">(Class) $6 = 0x001d8001000024b9 Student</div><div class=\"line\">(lldb) p/x 0x001d8001000024b9&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $7 = 0x00000001000024b8</div><div class=\"line\">(lldb) p/x studentClass</div><div class=\"line\">(fy_objc_class *) $8 = 0x00000001000024b8//studentclass 和isa地址都是0x00000001000024b8</div><div class=\"line\">(lldb)</div></pre></td></tr></table></figure>\n<p>从面的输出结果中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。</p>\n<h4 id=\"class-对象验证\"><a href=\"#class-对象验证\" class=\"headerlink\" title=\"class 对象验证\"></a>class 对象验证</h4><p>接着我们来看<code>class</code>对象，同样通过上一篇文章，我们明确<code>class</code>对象中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对<code>object</code>源码的分析，我们知道这些信息存储在<code>class</code>对象的<code>class_rw_t</code>中，我们通过强制转化来窥探其中的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//objectClass and objectMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x objectClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $6 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $7 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x objectMetaClass</div><div class=\"line\">(fy_objc_class *) $8 = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">//personClass and personMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x personClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $9 = 0x001d800100002441</div><div class=\"line\">(lldb) p/x personMetaClass</div><div class=\"line\">(fy_objc_class *) $10 = 0x0000000100002440</div><div class=\"line\">(lldb) p/x 0x001d800100002441&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $11 = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">//sutdentClass and studentMetaClass</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x studentClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $12 = 0x001d800100002491</div><div class=\"line\">(lldb) p/x 0x001d800100002491&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $13 = 0x0000000100002490</div><div class=\"line\">(lldb) p/x studentMetaClass</div><div class=\"line\">(fy_objc_class *) $14 = 0x0000000100002490</div></pre></td></tr></table></figure>\n<p>有此结果得知<code>objectMetaClass==objectClass-&gt;isa==0x00007fff8e3ba0f0</code>,<code>personClass-&gt;isa==personMetaClass==0x0000000100002440</code>,<code>studentClass-&gt;isa==studentMetaClass==0x0000000100002490</code>。<br>由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的7,8,9号线。</p>\n<h4 id=\"meta-class对象验证\"><a href=\"#meta-class对象验证\" class=\"headerlink\" title=\"meta-class对象验证\"></a>meta-class对象验证</h4><p>最后我们来看<code>meta-class</code>元类对象，上文提到<code>meta-class</code>中存储着<code>isa</code>指针，<code>superclass</code>指针，以及类的类方法信息。同时我们知道<code>meta-class</code>元类对象与<code>class</code>类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的<code>isa</code>指针指向基类的元类对象，基类的元类对象的<code>isa</code>指针指向自己。元类对象的<code>superclass</code>指针指向其父类的元类对象，基类的元类对象的<code>superclass</code>指针指向其类对象。<br>与<code>class</code>对象相同，我们同样通过模拟对<code>person</code>元类对象调用<code>.data</code>函数，即对<code>bits</code>进行<code>&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)</code>运算，并转化为<code>class_rw_t</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">// objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</div><div class=\"line\">//objectMetaClass-&gt;isa =   0x00007fff8e3ba0f0</div><div class=\"line\">//objectMetaClass = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x objectMetaClass-&gt;superclass</div><div class=\"line\">(Class) $20 = 0x00007fff8e3ba140 NSObject</div><div class=\"line\">(lldb) p/x objectMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $21 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1&amp;0x00007ffffffffff8</div><div class=\"line\">(long) $22 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x objectMetaClass</div><div class=\"line\">(fy_objc_class *) $23 = 0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\">// personMetaClass-&gt;superclas=0x00007fff8e3ba0f0</div><div class=\"line\">//personMetaClass-&gt;isa=0x00007fff8e3ba0f0</div><div class=\"line\">//personMetaClass = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">(lldb) p/x personMetaClass-&gt;superclass</div><div class=\"line\">(Class) $25 = 0x00007fff8e3ba0f0</div><div class=\"line\">(lldb) p/x personMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $26 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x personMetaClass</div><div class=\"line\">(fy_objc_class *) $30 = 0x0000000100002440</div><div class=\"line\"></div><div class=\"line\">// studentMetaClass-&gt;superclas=0x0000000100002440</div><div class=\"line\">//studentMetaClass-&gt;isa=0x00007fff8e3ba0f0</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(lldb) p/x studentMetaClass-&gt;superclass</div><div class=\"line\">(Class) $27 = 0x0000000100002440</div><div class=\"line\">(lldb) p/x studentMetaClass-&gt;isa</div><div class=\"line\">(__NSAtom *) $28 = 0x001dffff8e3ba0f1</div><div class=\"line\">(lldb) p/x 0x001dffff8e3ba0f1 &amp; 0x00007ffffffffff8</div><div class=\"line\">(long) $29 = 0x00007fff8e3ba0f0</div></pre></td></tr></table></figure>\n<p>由上面可以看出，<code>studentMetaClass-&gt;isa</code>,<code>personMetaClass-&gt;isa</code>,<code>objectMetaClass-&gt;isa</code>结果<code>mask</code>之后都是<code>0x00007fff8e3ba0f0</code>，与<code>p/x objectMetaClass</code>结果一致，则验证了13，14，15号线，<code>studentMetaClass-&gt;superclass =0x0000000100002440</code>,<code>personMetaClass = 0x0000000100002440</code>验证12号线，<code>personMetaClass-&gt;isa=0x00007fff8e3ba0f0</code>和<code>objectMetaClass = 0x00007fff8e3ba0f0</code>验证了11号线，<code>objectMetaClass-&gt;superclass = 0x00007fff8e3ba140  NSObject</code>验证10号线。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>对象的isa指向哪里？</p>\n<ul>\n<li>instance对象的isa指向class对象</li>\n<li>class对象的isa指向meta-class对象</li>\n<li>meta-class对象的isa指向基类的meta-class对象</li>\n<li>class和meta-class的内存结构一样的，只是值不一样</li>\n</ul>\n<p>OC的类信息存放在哪里？</p>\n<ul>\n<li>对象方法、属性、成员变量、协议信息存放在class对象中</li>\n<li>类方法存放在meta-class对象中</li>\n<li>成员变量具体值存放在instance对象中</li>\n</ul>\n<h4 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h4><ul>\n<li><a href=\"https://github.com/ifgyong/iOSDataFactory\" target=\"_blank\" rel=\"external\">学习资料下载</a></li>\n<li><a href=\"https://github.com/ifgyong/demo/tree/master/OC\" target=\"_blank\" rel=\"external\">demo code</a></li>\n</ul>\n<hr>\n<p>最怕一生碌碌无为，还安慰自己平凡可贵。</p>\n<p>本文章之所以图片比较少，我觉得还是跟着代码敲一遍，印象比较深刻。</p>\n<p><img src=\"../images/0.png\" alt=\"\"></p>\n"},{"title":"iOS线程之NSOperation","date":"2016-03-31T06:47:47.000Z","_content":"\n前篇文章已经讲了GCD了，那么这两者有什么区别？\n### GCD VS   NSOperation \n>\"NSOperationQueue predates Grand Central Dispatch and on iOS it doesn't use GCD to execute operations (this is different on Mac OS X). It uses regular background threads which have a little more overhead than GCD dispatch queues.\nOn the other hand, NSOperationQueue gives you a lot more control over how your operations are executed. You can define dependencies between individual operations for example, which isn't possible with plain GCD queues. It is also possible to cancel operations that have been enqueued in an NSOperationQueue (as far as the operations support it). When you enqueue a block in a GCD dispatch queue, it will definitely be executed at some point.\nTo sum it up, NSOperationQueue can be more suitable for long-running operations that may need to be cancelled or have complex dependencies. GCD dispatch queues are better for short tasks that should have minimum performance and memory overhead.\"\n\n简单来说就是GCD偏底层点，性能好，依赖关系少，并发耗费资源少。\nNSOperation可观察状态，性能也不错，处理事务更简单操作。\n\n对于这两种都熟练运用的人来说，无所谓了，APP大多数事务这两者都能完美解决。至于代码用哪个这个取决于你的兴趣了。\n\n下面详细说一下NSOperation\n\n```\n@interface NSOperation : NSObject {\n\n- (void)start; //开始执行 默认是同步执行的\n- (void)main; //主任务的函数 \n\n@property (readonly, getter=isCancelled) BOOL cancelled; //是否取消\n- (void)cancel; //取消任务\n\n@property (readonly, getter=isExecuting) BOOL executing;//是否正在执行\n@property (readonly, getter=isFinished) BOOL finished; //是否完成\n@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below 是否并行\n@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0); //是否异步\n@property (readonly, getter=isReady) BOOL ready; //是否正在等待\n\n- (void)addDependency:(NSOperation *)op; //添加依赖\n- (void)removeDependency:(NSOperation *)op; //删除依赖关系\n\n@property (readonly, copy) NSArray<NSOperation *> *dependencies; //所有依赖关系的数组\n\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n//队列优先级  优先级高的先执行 一般设置为0 即 NSOperationQueuePriorityNormal。\n NSOperationQueuePriorityVeryLow = -8L,\n NSOperationQueuePriorityLow = -4L,\n NSOperationQueuePriorityNormal = 0,\n NSOperationQueuePriorityHigh = 4,\n NSOperationQueuePriorityVeryHigh = 8\n};\n\n@property NSOperationQueuePriority queuePriority;//队列优先级\n\n@property (nullable, copy) void (^completionBlock)(void)  NS_AVAILABLE(10_6, 4_0);//完成时候执行的代码块\n//等待直到完成\n- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);\n//线程优先级\n@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);\n\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\nNSQualityOfService 的几个枚举值：\n  NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上\n  NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务\n  NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级\n  NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务\n  NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务\n\n\n//名字\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);\n```\n### NSBlockOperation \n```\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{//添加同时执行的task\n        NSLog(@\"1 start\");\n        [self print];\n        sleep(2);\n        \n        NSLog(@\"1 end\");\n    }];\n    [blop addExecutionBlock:^{ //添加同时执行的task\n        NSLog(@\"2 start\");\n        [self print];\n        sleep(4);\n        \n        NSLog(@\"2 end\");\n    }];\n    [blop addExecutionBlock:^{ //添加同时执行的task\n        NSLog(@\"3 start\");\n        [self print];\n        sleep(1);\n        \n        NSLog(@\"3 end\");\n    }];\n    [blop setCompletionBlock:^{ //添加同时执行的task\n        NSLog(@\"blop end\");\n    }];\n    \n    [blop start];\n}\n输出：\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] 1 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] 3 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] 2 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] ****线程****info : <NSThread: 0x7fea68408b30>{number = 1, name = main}**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] ****线程****info : <NSThread: 0x7fea6861fb30>{number = 3, name = (null)}**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] ****线程****info : <NSThread: 0x7fea69300470>{number = 2, name = (null)}**\n**2016-03-29 16:47:45.922 GCD_Demo[17555:562287] 3 end**\n**2016-03-29 16:47:46.858 GCD_Demo[17555:562249] 1 end**\n**2016-03-29 16:47:48.928 GCD_Demo[17555:562288] 2 end**\n**2016-03-29 16:47:48.929 GCD_Demo[17555:562288] blop end**\n```\n可以看出来，NSBlockOperation当任务是1的时候在main线程中执行，任务大于1的时候，其他的个自独自开了线程，而且互不影响。\n\n### 依赖关系\n```\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_1 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop1_1 end\");\n    }];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_2 start\");\n        [self print];\n        sleep(4);\n        NSLog(@\"blop1_2 end\");\n    }];\n    NSLog(@\"blop will start\");\n    [blop start];\n    NSLog(@\"blop did start\");\n    \n    NSBlockOperation * blop2 =[NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"blop2 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop2 end\");\n    }];\n   // [blop2 addDependency:blop];//blop2 依赖blop 就是blopExecutionBlock 执行完之后再执行blop2的任务【blop2 执行task和blop 的CompletionBlock基本是同时执行的】\n    [blop2 start];\n输出：\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop will start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop1_1 start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574455] blop1_2 start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] ****线程****info : <NSThread: 0x7f839a004ff0>{number = 1, name = main}**\n**2016-03-29 17:06:53.218 GCD_Demo[17806:574455] ****线程****info : <NSThread: 0x7f8398416d80>{number = 2, name = (null)}**\n**2016-03-29 17:06:55.219 GCD_Demo[17806:574416] blop1_1 end**\n**2016-03-29 17:06:57.272 GCD_Demo[17806:574455] blop1_2 end**\n**2016-03-29 17:06:57.272 GCD_Demo[17806:574416] blop did start**\n**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] blop2 start**\n**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] ****线程****info : <NSThread: 0x7f839a004ff0>{number = 1, name = main}**\n**2016-03-29 17:06:59.274 GCD_Demo[17806:574416] blop2 end**\n\n```\n从输出的信息可以看出来，block是同步执行的，虽然多任务是多线程，但是主线程还是在阻塞中，只有上一个所有 task 执行完的时候，才会执行下边的task。所以在这里依赖关系不那么重要了，注释掉运行结果也一样的。\n###   NSInvocationOperation\n```\nNSInvocationOperation 是NSOperation的子类，负责实现operation的SEL方法。\n这样子operation就可以start的时候执行一些函数了。\n在swift中已经废弃\n看文档：\nNS_SWIFT_UNAVAILABLE(\"NSInvocation and related APIs not available\")\n```\n\n### NSOperationQueue \n```\n//添加操作\n- (void)addOperation:(NSOperation *)op;\n//添加操作数组 在完成操作的时候\n- (void)addOperations:(NSArray<NSOperation *> *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);\n//添加携带代码块的operation\n- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);\n//所有的操作 组成的数组 可读属性\n@property (readonly, copy) NSArray<__kindof NSOperation *> *operations;\n//操作个数\n@property (readonly) NSUInteger operationCount NS_AVAILABLE(10_6, 4_0);\n//设置最大并行的任务数 ps:operation 其实 一个operation可以同时开启几个线程的。\n@property NSInteger maxConcurrentOperationCount;\n//挂起\n@property (getter=isSuspended) BOOL suspended;\n//队列的名字\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_6, 4_0);\n//优先级\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\n队列\n@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue NS_AVAILABLE(10_10, 8_0);\n//取消所有的操作\n- (void)cancelAllOperations;\n//等到他们的操作结束\n- (void)waitUntilAllOperationsAreFinished;\n//当前的队列\n+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0);\n//主队列\n+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);\n\n \n# 队列的例子\n#队列中添加的operation都是在子线程中执行的。\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)op1{\n     NSLog(@\"op1 开始运行了\");\n     sleep(3);\n     NSLog(@\"op1 结束\");\n}\n\n- (void)test5{\n    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    NSOperationQueue * queue =[[NSOperationQueue alloc]init];\n    [queue addOperation:op1]; //添加操作\n    queue.maxConcurrentOperationCount = 1;//同时允许一个operation运行\n    NSBlockOperation *block = [self test4];//任务块\n    [queue addOperation:block];//添加任务块并运行\n\n// sleep(2);  \n   // [queue cancelAllOperations];\n}\n- (NSBlockOperation *)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_1 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop1_1 end\");\n    }];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_2 start\");\n        [self print];\n        sleep(4);\n        NSLog(@\"blop1_2 end\");\n    }];\n    return blop;\n}\n输出：\n**2016-03-31 11:22:16.663 GCD_Demo[26038:889212] op1 ****开始运行了**\n**2016-03-31 11:22:19.737 GCD_Demo[26038:889212] op1 ****结束**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] blop1_1 start**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] blop1_2 start**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] ****线程****info : <NSThread: 0x7fea3061d110>{number = 2, name = (null)}**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] ****线程****info : <NSThread: 0x7fea31800140>{number = 3, name = (null)}**\n**2016-03-31 11:22:21.808 GCD_Demo[26038:889213] blop1_1 end**\n**2016-03-31 11:22:23.784 GCD_Demo[26038:889226] blop1_2 end**\n# 从输出的信息可以看出来，当设置最大的operation为1的时候，相当于这个队列同步运行了，不过这个同步的单位不是线程，而是operation。\n\n当把这两句代码加到 test5最后边输出结果是：\n**2016-03-31 11:28:59.267 GCD_Demo[26113:892737] op1 ****开始运行了**\n**2016-03-31 11:29:02.341 GCD_Demo[26113:892737] op1 ****结束**\n从输出结果得出：正在执行的Operation无法stop，正在ready的operation直接跳过start，执行complateBlock.状态由ready改为canceld。ps：注意看官方文档\n`Canceling the operations does not automatically remove them from the queue or stop those that are currently executing.`\n正在执行的不会从队列中删除也不会stop。\n`For operations that are queued and waiting execution, the queue must still attempt to execute the operation before recognizing that it is canceled and moving it to the finished state. \nFor operations that are already executing, the operation object itself must check for cancellation and stop what it is doing so that it can move to the finished state. \nIn both cases, a finished (or canceled) operation is still given a chance to execute its completion block before it is removed from the queue.` \n正在队列中等待的operation执行的时候会检测是否被cancenld，如果状态是canceld，那么直接执行completion block 在它被队列删除的时候。\n```\n### 在子线程中耗时的操作完成了，那么该在主线程中更新UI\n```\n#将上面的test5 改成下面的代码\n- (void)test5{\n    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    NSOperationQueue * queue =[[NSOperationQueue alloc]init];\n    [queue addOperation:op1];\n    queue.maxConcurrentOperationCount = 3;//根据需要设置数量\n    NSBlockOperation *block = [self test4];\n    [queue addOperation:block];\n//这句话一定要添加，这句话的意思等到所有的operation都完成了在执行后面的代码，\n其实就是上面的操作执行到这里要等待他们直到他们都完成了。\n#     [queue waitUntilAllOperationsAreFinished]; \n    NSBlockOperation * blockUpdateMainUI=[NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"update UI\");\n    }];\n    [[NSOperationQueue mainQueue] addOperation:blockUpdateMainUI];//在主队列中执行更新UI的操作\n}\n上面的代码 和GCD中的分组有些类似，但是 这个OperationQueue基本单位是operation而不是线程，一定要理解。\noperation和线程的关系是 一个operation可能对应多个线程，也可能对应一个线程。\n```\n关于NSOperationQueue的了解和使用我想到的基本就这么多场景，后期有其他的场景再补充。\n预告：下期节目是NSThread的介绍和使用。\nps:广告时间\n- - -\n有问题可以发我邮箱讨论共同交流技术。\nfgyong@yeah.net","source":"_posts/iOS线程之NSOperation.md","raw":"title: iOS线程之NSOperation\ndate: 2016-03-31 14:47:47\ntags:\n- iOS\n- iOS高级\ncategories: iOS\n---\n\n前篇文章已经讲了GCD了，那么这两者有什么区别？\n### GCD VS   NSOperation \n>\"NSOperationQueue predates Grand Central Dispatch and on iOS it doesn't use GCD to execute operations (this is different on Mac OS X). It uses regular background threads which have a little more overhead than GCD dispatch queues.\nOn the other hand, NSOperationQueue gives you a lot more control over how your operations are executed. You can define dependencies between individual operations for example, which isn't possible with plain GCD queues. It is also possible to cancel operations that have been enqueued in an NSOperationQueue (as far as the operations support it). When you enqueue a block in a GCD dispatch queue, it will definitely be executed at some point.\nTo sum it up, NSOperationQueue can be more suitable for long-running operations that may need to be cancelled or have complex dependencies. GCD dispatch queues are better for short tasks that should have minimum performance and memory overhead.\"\n\n简单来说就是GCD偏底层点，性能好，依赖关系少，并发耗费资源少。\nNSOperation可观察状态，性能也不错，处理事务更简单操作。\n\n对于这两种都熟练运用的人来说，无所谓了，APP大多数事务这两者都能完美解决。至于代码用哪个这个取决于你的兴趣了。\n\n下面详细说一下NSOperation\n\n```\n@interface NSOperation : NSObject {\n\n- (void)start; //开始执行 默认是同步执行的\n- (void)main; //主任务的函数 \n\n@property (readonly, getter=isCancelled) BOOL cancelled; //是否取消\n- (void)cancel; //取消任务\n\n@property (readonly, getter=isExecuting) BOOL executing;//是否正在执行\n@property (readonly, getter=isFinished) BOOL finished; //是否完成\n@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below 是否并行\n@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0); //是否异步\n@property (readonly, getter=isReady) BOOL ready; //是否正在等待\n\n- (void)addDependency:(NSOperation *)op; //添加依赖\n- (void)removeDependency:(NSOperation *)op; //删除依赖关系\n\n@property (readonly, copy) NSArray<NSOperation *> *dependencies; //所有依赖关系的数组\n\ntypedef NS_ENUM(NSInteger, NSOperationQueuePriority) {\n//队列优先级  优先级高的先执行 一般设置为0 即 NSOperationQueuePriorityNormal。\n NSOperationQueuePriorityVeryLow = -8L,\n NSOperationQueuePriorityLow = -4L,\n NSOperationQueuePriorityNormal = 0,\n NSOperationQueuePriorityHigh = 4,\n NSOperationQueuePriorityVeryHigh = 8\n};\n\n@property NSOperationQueuePriority queuePriority;//队列优先级\n\n@property (nullable, copy) void (^completionBlock)(void)  NS_AVAILABLE(10_6, 4_0);//完成时候执行的代码块\n//等待直到完成\n- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);\n//线程优先级\n@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);\n\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\nNSQualityOfService 的几个枚举值：\n  NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上\n  NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务\n  NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级\n  NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务\n  NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务\n\n\n//名字\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);\n```\n### NSBlockOperation \n```\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{//添加同时执行的task\n        NSLog(@\"1 start\");\n        [self print];\n        sleep(2);\n        \n        NSLog(@\"1 end\");\n    }];\n    [blop addExecutionBlock:^{ //添加同时执行的task\n        NSLog(@\"2 start\");\n        [self print];\n        sleep(4);\n        \n        NSLog(@\"2 end\");\n    }];\n    [blop addExecutionBlock:^{ //添加同时执行的task\n        NSLog(@\"3 start\");\n        [self print];\n        sleep(1);\n        \n        NSLog(@\"3 end\");\n    }];\n    [blop setCompletionBlock:^{ //添加同时执行的task\n        NSLog(@\"blop end\");\n    }];\n    \n    [blop start];\n}\n输出：\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] 1 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] 3 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] 2 start**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] ****线程****info : <NSThread: 0x7fea68408b30>{number = 1, name = main}**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] ****线程****info : <NSThread: 0x7fea6861fb30>{number = 3, name = (null)}**\n**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] ****线程****info : <NSThread: 0x7fea69300470>{number = 2, name = (null)}**\n**2016-03-29 16:47:45.922 GCD_Demo[17555:562287] 3 end**\n**2016-03-29 16:47:46.858 GCD_Demo[17555:562249] 1 end**\n**2016-03-29 16:47:48.928 GCD_Demo[17555:562288] 2 end**\n**2016-03-29 16:47:48.929 GCD_Demo[17555:562288] blop end**\n```\n可以看出来，NSBlockOperation当任务是1的时候在main线程中执行，任务大于1的时候，其他的个自独自开了线程，而且互不影响。\n\n### 依赖关系\n```\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_1 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop1_1 end\");\n    }];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_2 start\");\n        [self print];\n        sleep(4);\n        NSLog(@\"blop1_2 end\");\n    }];\n    NSLog(@\"blop will start\");\n    [blop start];\n    NSLog(@\"blop did start\");\n    \n    NSBlockOperation * blop2 =[NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"blop2 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop2 end\");\n    }];\n   // [blop2 addDependency:blop];//blop2 依赖blop 就是blopExecutionBlock 执行完之后再执行blop2的任务【blop2 执行task和blop 的CompletionBlock基本是同时执行的】\n    [blop2 start];\n输出：\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop will start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop1_1 start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574455] blop1_2 start**\n**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] ****线程****info : <NSThread: 0x7f839a004ff0>{number = 1, name = main}**\n**2016-03-29 17:06:53.218 GCD_Demo[17806:574455] ****线程****info : <NSThread: 0x7f8398416d80>{number = 2, name = (null)}**\n**2016-03-29 17:06:55.219 GCD_Demo[17806:574416] blop1_1 end**\n**2016-03-29 17:06:57.272 GCD_Demo[17806:574455] blop1_2 end**\n**2016-03-29 17:06:57.272 GCD_Demo[17806:574416] blop did start**\n**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] blop2 start**\n**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] ****线程****info : <NSThread: 0x7f839a004ff0>{number = 1, name = main}**\n**2016-03-29 17:06:59.274 GCD_Demo[17806:574416] blop2 end**\n\n```\n从输出的信息可以看出来，block是同步执行的，虽然多任务是多线程，但是主线程还是在阻塞中，只有上一个所有 task 执行完的时候，才会执行下边的task。所以在这里依赖关系不那么重要了，注释掉运行结果也一样的。\n###   NSInvocationOperation\n```\nNSInvocationOperation 是NSOperation的子类，负责实现operation的SEL方法。\n这样子operation就可以start的时候执行一些函数了。\n在swift中已经废弃\n看文档：\nNS_SWIFT_UNAVAILABLE(\"NSInvocation and related APIs not available\")\n```\n\n### NSOperationQueue \n```\n//添加操作\n- (void)addOperation:(NSOperation *)op;\n//添加操作数组 在完成操作的时候\n- (void)addOperations:(NSArray<NSOperation *> *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);\n//添加携带代码块的operation\n- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);\n//所有的操作 组成的数组 可读属性\n@property (readonly, copy) NSArray<__kindof NSOperation *> *operations;\n//操作个数\n@property (readonly) NSUInteger operationCount NS_AVAILABLE(10_6, 4_0);\n//设置最大并行的任务数 ps:operation 其实 一个operation可以同时开启几个线程的。\n@property NSInteger maxConcurrentOperationCount;\n//挂起\n@property (getter=isSuspended) BOOL suspended;\n//队列的名字\n@property (nullable, copy) NSString *name NS_AVAILABLE(10_6, 4_0);\n//优先级\n@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);\n队列\n@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue NS_AVAILABLE(10_10, 8_0);\n//取消所有的操作\n- (void)cancelAllOperations;\n//等到他们的操作结束\n- (void)waitUntilAllOperationsAreFinished;\n//当前的队列\n+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0);\n//主队列\n+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);\n\n \n# 队列的例子\n#队列中添加的operation都是在子线程中执行的。\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)op1{\n     NSLog(@\"op1 开始运行了\");\n     sleep(3);\n     NSLog(@\"op1 结束\");\n}\n\n- (void)test5{\n    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    NSOperationQueue * queue =[[NSOperationQueue alloc]init];\n    [queue addOperation:op1]; //添加操作\n    queue.maxConcurrentOperationCount = 1;//同时允许一个operation运行\n    NSBlockOperation *block = [self test4];//任务块\n    [queue addOperation:block];//添加任务块并运行\n\n// sleep(2);  \n   // [queue cancelAllOperations];\n}\n- (NSBlockOperation *)test4{\n    NSBlockOperation * blop = [[NSBlockOperation alloc]init];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_1 start\");\n        [self print];\n        sleep(2);\n        NSLog(@\"blop1_1 end\");\n    }];\n    [blop addExecutionBlock:^{\n        NSLog(@\"blop1_2 start\");\n        [self print];\n        sleep(4);\n        NSLog(@\"blop1_2 end\");\n    }];\n    return blop;\n}\n输出：\n**2016-03-31 11:22:16.663 GCD_Demo[26038:889212] op1 ****开始运行了**\n**2016-03-31 11:22:19.737 GCD_Demo[26038:889212] op1 ****结束**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] blop1_1 start**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] blop1_2 start**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] ****线程****info : <NSThread: 0x7fea3061d110>{number = 2, name = (null)}**\n**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] ****线程****info : <NSThread: 0x7fea31800140>{number = 3, name = (null)}**\n**2016-03-31 11:22:21.808 GCD_Demo[26038:889213] blop1_1 end**\n**2016-03-31 11:22:23.784 GCD_Demo[26038:889226] blop1_2 end**\n# 从输出的信息可以看出来，当设置最大的operation为1的时候，相当于这个队列同步运行了，不过这个同步的单位不是线程，而是operation。\n\n当把这两句代码加到 test5最后边输出结果是：\n**2016-03-31 11:28:59.267 GCD_Demo[26113:892737] op1 ****开始运行了**\n**2016-03-31 11:29:02.341 GCD_Demo[26113:892737] op1 ****结束**\n从输出结果得出：正在执行的Operation无法stop，正在ready的operation直接跳过start，执行complateBlock.状态由ready改为canceld。ps：注意看官方文档\n`Canceling the operations does not automatically remove them from the queue or stop those that are currently executing.`\n正在执行的不会从队列中删除也不会stop。\n`For operations that are queued and waiting execution, the queue must still attempt to execute the operation before recognizing that it is canceled and moving it to the finished state. \nFor operations that are already executing, the operation object itself must check for cancellation and stop what it is doing so that it can move to the finished state. \nIn both cases, a finished (or canceled) operation is still given a chance to execute its completion block before it is removed from the queue.` \n正在队列中等待的operation执行的时候会检测是否被cancenld，如果状态是canceld，那么直接执行completion block 在它被队列删除的时候。\n```\n### 在子线程中耗时的操作完成了，那么该在主线程中更新UI\n```\n#将上面的test5 改成下面的代码\n- (void)test5{\n    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    NSOperationQueue * queue =[[NSOperationQueue alloc]init];\n    [queue addOperation:op1];\n    queue.maxConcurrentOperationCount = 3;//根据需要设置数量\n    NSBlockOperation *block = [self test4];\n    [queue addOperation:block];\n//这句话一定要添加，这句话的意思等到所有的operation都完成了在执行后面的代码，\n其实就是上面的操作执行到这里要等待他们直到他们都完成了。\n#     [queue waitUntilAllOperationsAreFinished]; \n    NSBlockOperation * blockUpdateMainUI=[NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"update UI\");\n    }];\n    [[NSOperationQueue mainQueue] addOperation:blockUpdateMainUI];//在主队列中执行更新UI的操作\n}\n上面的代码 和GCD中的分组有些类似，但是 这个OperationQueue基本单位是operation而不是线程，一定要理解。\noperation和线程的关系是 一个operation可能对应多个线程，也可能对应一个线程。\n```\n关于NSOperationQueue的了解和使用我想到的基本就这么多场景，后期有其他的场景再补充。\n预告：下期节目是NSThread的介绍和使用。\nps:广告时间\n- - -\n有问题可以发我邮箱讨论共同交流技术。\nfgyong@yeah.net","slug":"iOS线程之NSOperation","published":1,"updated":"2019-12-03T04:48:00.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2o000t9zskyhgga9er","content":"<p>前篇文章已经讲了GCD了，那么这两者有什么区别？</p>\n<h3 id=\"GCD-VS-NSOperation\"><a href=\"#GCD-VS-NSOperation\" class=\"headerlink\" title=\"GCD VS   NSOperation\"></a>GCD VS   NSOperation</h3><blockquote>\n<p>“NSOperationQueue predates Grand Central Dispatch and on iOS it doesn’t use GCD to execute operations (this is different on Mac OS X). It uses regular background threads which have a little more overhead than GCD dispatch queues.<br>On the other hand, NSOperationQueue gives you a lot more control over how your operations are executed. You can define dependencies between individual operations for example, which isn’t possible with plain GCD queues. It is also possible to cancel operations that have been enqueued in an NSOperationQueue (as far as the operations support it). When you enqueue a block in a GCD dispatch queue, it will definitely be executed at some point.<br>To sum it up, NSOperationQueue can be more suitable for long-running operations that may need to be cancelled or have complex dependencies. GCD dispatch queues are better for short tasks that should have minimum performance and memory overhead.”</p>\n</blockquote>\n<p>简单来说就是GCD偏底层点，性能好，依赖关系少，并发耗费资源少。<br>NSOperation可观察状态，性能也不错，处理事务更简单操作。</p>\n<p>对于这两种都熟练运用的人来说，无所谓了，APP大多数事务这两者都能完美解决。至于代码用哪个这个取决于你的兴趣了。</p>\n<p>下面详细说一下NSOperation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSOperation : NSObject &#123;</div><div class=\"line\"></div><div class=\"line\">- (void)start; //开始执行 默认是同步执行的</div><div class=\"line\">- (void)main; //主任务的函数 </div><div class=\"line\"></div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled; //是否取消</div><div class=\"line\">- (void)cancel; //取消任务</div><div class=\"line\"></div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing;//是否正在执行</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished; //是否完成</div><div class=\"line\">@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &apos;asynchronous&apos; below 是否并行</div><div class=\"line\">@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0); //是否异步</div><div class=\"line\">@property (readonly, getter=isReady) BOOL ready; //是否正在等待</div><div class=\"line\"></div><div class=\"line\">- (void)addDependency:(NSOperation *)op; //添加依赖</div><div class=\"line\">- (void)removeDependency:(NSOperation *)op; //删除依赖关系</div><div class=\"line\"></div><div class=\"line\">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; //所有依赖关系的数组</div><div class=\"line\"></div><div class=\"line\">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</div><div class=\"line\">//队列优先级  优先级高的先执行 一般设置为0 即 NSOperationQueuePriorityNormal。</div><div class=\"line\"> NSOperationQueuePriorityVeryLow = -8L,</div><div class=\"line\"> NSOperationQueuePriorityLow = -4L,</div><div class=\"line\"> NSOperationQueuePriorityNormal = 0,</div><div class=\"line\"> NSOperationQueuePriorityHigh = 4,</div><div class=\"line\"> NSOperationQueuePriorityVeryHigh = 8</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@property NSOperationQueuePriority queuePriority;//队列优先级</div><div class=\"line\"></div><div class=\"line\">@property (nullable, copy) void (^completionBlock)(void)  NS_AVAILABLE(10_6, 4_0);//完成时候执行的代码块</div><div class=\"line\">//等待直到完成</div><div class=\"line\">- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//线程优先级</div><div class=\"line\">@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);</div><div class=\"line\"></div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">NSQualityOfService 的几个枚举值：</div><div class=\"line\">  NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上</div><div class=\"line\">  NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</div><div class=\"line\">  NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级</div><div class=\"line\">  NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</div><div class=\"line\">  NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//名字</div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);</div></pre></td></tr></table></figure>\n<h3 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;//添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;3 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(1);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;3 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop setCompletionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;blop end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [blop start];</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] 1 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] 3 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] 2 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] ****线程****info : &lt;NSThread: 0x7fea68408b30&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] ****线程****info : &lt;NSThread: 0x7fea6861fb30&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] ****线程****info : &lt;NSThread: 0x7fea69300470&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 16:47:45.922 GCD_Demo[17555:562287] 3 end**</div><div class=\"line\">**2016-03-29 16:47:46.858 GCD_Demo[17555:562249] 1 end**</div><div class=\"line\">**2016-03-29 16:47:48.928 GCD_Demo[17555:562288] 2 end**</div><div class=\"line\">**2016-03-29 16:47:48.929 GCD_Demo[17555:562288] blop end**</div></pre></td></tr></table></figure>\n<p>可以看出来，NSBlockOperation当任务是1的时候在main线程中执行，任务大于1的时候，其他的个自独自开了线程，而且互不影响。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop1_1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        NSLog(@&quot;blop1_2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    NSLog(@&quot;blop will start&quot;);</div><div class=\"line\">    [blop start];</div><div class=\"line\">    NSLog(@&quot;blop did start&quot;);</div><div class=\"line\">    </div><div class=\"line\">    NSBlockOperation * blop2 =[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">   // [blop2 addDependency:blop];//blop2 依赖blop 就是blopExecutionBlock 执行完之后再执行blop2的任务【blop2 执行task和blop 的CompletionBlock基本是同时执行的】</div><div class=\"line\">    [blop2 start];</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop will start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop1_1 start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574455] blop1_2 start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] ****线程****info : &lt;NSThread: 0x7f839a004ff0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 17:06:53.218 GCD_Demo[17806:574455] ****线程****info : &lt;NSThread: 0x7f8398416d80&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 17:06:55.219 GCD_Demo[17806:574416] blop1_1 end**</div><div class=\"line\">**2016-03-29 17:06:57.272 GCD_Demo[17806:574455] blop1_2 end**</div><div class=\"line\">**2016-03-29 17:06:57.272 GCD_Demo[17806:574416] blop did start**</div><div class=\"line\">**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] blop2 start**</div><div class=\"line\">**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] ****线程****info : &lt;NSThread: 0x7f839a004ff0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 17:06:59.274 GCD_Demo[17806:574416] blop2 end**</div></pre></td></tr></table></figure>\n<p>从输出的信息可以看出来，block是同步执行的，虽然多任务是多线程，但是主线程还是在阻塞中，只有上一个所有 task 执行完的时候，才会执行下边的task。所以在这里依赖关系不那么重要了，注释掉运行结果也一样的。</p>\n<h3 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSInvocationOperation 是NSOperation的子类，负责实现operation的SEL方法。</div><div class=\"line\">这样子operation就可以start的时候执行一些函数了。</div><div class=\"line\">在swift中已经废弃</div><div class=\"line\">看文档：</div><div class=\"line\">NS_SWIFT_UNAVAILABLE(&quot;NSInvocation and related APIs not available&quot;)</div></pre></td></tr></table></figure>\n<h3 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">//添加操作</div><div class=\"line\">- (void)addOperation:(NSOperation *)op;</div><div class=\"line\">//添加操作数组 在完成操作的时候</div><div class=\"line\">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//添加携带代码块的operation</div><div class=\"line\">- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//所有的操作 组成的数组 可读属性</div><div class=\"line\">@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;</div><div class=\"line\">//操作个数</div><div class=\"line\">@property (readonly) NSUInteger operationCount NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//设置最大并行的任务数 ps:operation 其实 一个operation可以同时开启几个线程的。</div><div class=\"line\">@property NSInteger maxConcurrentOperationCount;</div><div class=\"line\">//挂起</div><div class=\"line\">@property (getter=isSuspended) BOOL suspended;</div><div class=\"line\">//队列的名字</div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//优先级</div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">队列</div><div class=\"line\">@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">//取消所有的操作</div><div class=\"line\">- (void)cancelAllOperations;</div><div class=\"line\">//等到他们的操作结束</div><div class=\"line\">- (void)waitUntilAllOperationsAreFinished;</div><div class=\"line\">//当前的队列</div><div class=\"line\">+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//主队列</div><div class=\"line\">+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\"># 队列的例子</div><div class=\"line\">#队列中添加的operation都是在子线程中执行的。</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)op1&#123;</div><div class=\"line\">     NSLog(@&quot;op1 开始运行了&quot;);</div><div class=\"line\">     sleep(3);</div><div class=\"line\">     NSLog(@&quot;op1 结束&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)test5&#123;</div><div class=\"line\">    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    NSOperationQueue * queue =[[NSOperationQueue alloc]init];</div><div class=\"line\">    [queue addOperation:op1]; //添加操作</div><div class=\"line\">    queue.maxConcurrentOperationCount = 1;//同时允许一个operation运行</div><div class=\"line\">    NSBlockOperation *block = [self test4];//任务块</div><div class=\"line\">    [queue addOperation:block];//添加任务块并运行</div><div class=\"line\"></div><div class=\"line\">// sleep(2);  </div><div class=\"line\">   // [queue cancelAllOperations];</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSBlockOperation *)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop1_1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        NSLog(@&quot;blop1_2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return blop;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-31 11:22:16.663 GCD_Demo[26038:889212] op1 ****开始运行了**</div><div class=\"line\">**2016-03-31 11:22:19.737 GCD_Demo[26038:889212] op1 ****结束**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] blop1_1 start**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] blop1_2 start**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] ****线程****info : &lt;NSThread: 0x7fea3061d110&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] ****线程****info : &lt;NSThread: 0x7fea31800140&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-31 11:22:21.808 GCD_Demo[26038:889213] blop1_1 end**</div><div class=\"line\">**2016-03-31 11:22:23.784 GCD_Demo[26038:889226] blop1_2 end**</div><div class=\"line\"># 从输出的信息可以看出来，当设置最大的operation为1的时候，相当于这个队列同步运行了，不过这个同步的单位不是线程，而是operation。</div><div class=\"line\"></div><div class=\"line\">当把这两句代码加到 test5最后边输出结果是：</div><div class=\"line\">**2016-03-31 11:28:59.267 GCD_Demo[26113:892737] op1 ****开始运行了**</div><div class=\"line\">**2016-03-31 11:29:02.341 GCD_Demo[26113:892737] op1 ****结束**</div><div class=\"line\">从输出结果得出：正在执行的Operation无法stop，正在ready的operation直接跳过start，执行complateBlock.状态由ready改为canceld。ps：注意看官方文档</div><div class=\"line\">`Canceling the operations does not automatically remove them from the queue or stop those that are currently executing.`</div><div class=\"line\">正在执行的不会从队列中删除也不会stop。</div><div class=\"line\">`For operations that are queued and waiting execution, the queue must still attempt to execute the operation before recognizing that it is canceled and moving it to the finished state. </div><div class=\"line\">For operations that are already executing, the operation object itself must check for cancellation and stop what it is doing so that it can move to the finished state. </div><div class=\"line\">In both cases, a finished (or canceled) operation is still given a chance to execute its completion block before it is removed from the queue.` </div><div class=\"line\">正在队列中等待的operation执行的时候会检测是否被cancenld，如果状态是canceld，那么直接执行completion block 在它被队列删除的时候。</div></pre></td></tr></table></figure>\n<h3 id=\"在子线程中耗时的操作完成了，那么该在主线程中更新UI\"><a href=\"#在子线程中耗时的操作完成了，那么该在主线程中更新UI\" class=\"headerlink\" title=\"在子线程中耗时的操作完成了，那么该在主线程中更新UI\"></a>在子线程中耗时的操作完成了，那么该在主线程中更新UI</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#将上面的test5 改成下面的代码</div><div class=\"line\">- (void)test5&#123;</div><div class=\"line\">    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    NSOperationQueue * queue =[[NSOperationQueue alloc]init];</div><div class=\"line\">    [queue addOperation:op1];</div><div class=\"line\">    queue.maxConcurrentOperationCount = 3;//根据需要设置数量</div><div class=\"line\">    NSBlockOperation *block = [self test4];</div><div class=\"line\">    [queue addOperation:block];</div><div class=\"line\">//这句话一定要添加，这句话的意思等到所有的operation都完成了在执行后面的代码，</div><div class=\"line\">其实就是上面的操作执行到这里要等待他们直到他们都完成了。</div><div class=\"line\">#     [queue waitUntilAllOperationsAreFinished]; </div><div class=\"line\">    NSBlockOperation * blockUpdateMainUI=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;update UI&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [[NSOperationQueue mainQueue] addOperation:blockUpdateMainUI];//在主队列中执行更新UI的操作</div><div class=\"line\">&#125;</div><div class=\"line\">上面的代码 和GCD中的分组有些类似，但是 这个OperationQueue基本单位是operation而不是线程，一定要理解。</div><div class=\"line\">operation和线程的关系是 一个operation可能对应多个线程，也可能对应一个线程。</div></pre></td></tr></table></figure>\n<p>关于NSOperationQueue的了解和使用我想到的基本就这么多场景，后期有其他的场景再补充。<br>预告：下期节目是NSThread的介绍和使用。<br>ps:广告时间</p>\n<hr>\n<p>有问题可以发我邮箱讨论共同交流技术。<br>fgyong@yeah.net</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前篇文章已经讲了GCD了，那么这两者有什么区别？</p>\n<h3 id=\"GCD-VS-NSOperation\"><a href=\"#GCD-VS-NSOperation\" class=\"headerlink\" title=\"GCD VS   NSOperation\"></a>GCD VS   NSOperation</h3><blockquote>\n<p>“NSOperationQueue predates Grand Central Dispatch and on iOS it doesn’t use GCD to execute operations (this is different on Mac OS X). It uses regular background threads which have a little more overhead than GCD dispatch queues.<br>On the other hand, NSOperationQueue gives you a lot more control over how your operations are executed. You can define dependencies between individual operations for example, which isn’t possible with plain GCD queues. It is also possible to cancel operations that have been enqueued in an NSOperationQueue (as far as the operations support it). When you enqueue a block in a GCD dispatch queue, it will definitely be executed at some point.<br>To sum it up, NSOperationQueue can be more suitable for long-running operations that may need to be cancelled or have complex dependencies. GCD dispatch queues are better for short tasks that should have minimum performance and memory overhead.”</p>\n</blockquote>\n<p>简单来说就是GCD偏底层点，性能好，依赖关系少，并发耗费资源少。<br>NSOperation可观察状态，性能也不错，处理事务更简单操作。</p>\n<p>对于这两种都熟练运用的人来说，无所谓了，APP大多数事务这两者都能完美解决。至于代码用哪个这个取决于你的兴趣了。</p>\n<p>下面详细说一下NSOperation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSOperation : NSObject &#123;</div><div class=\"line\"></div><div class=\"line\">- (void)start; //开始执行 默认是同步执行的</div><div class=\"line\">- (void)main; //主任务的函数 </div><div class=\"line\"></div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled; //是否取消</div><div class=\"line\">- (void)cancel; //取消任务</div><div class=\"line\"></div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing;//是否正在执行</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished; //是否完成</div><div class=\"line\">@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override &apos;asynchronous&apos; below 是否并行</div><div class=\"line\">@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0); //是否异步</div><div class=\"line\">@property (readonly, getter=isReady) BOOL ready; //是否正在等待</div><div class=\"line\"></div><div class=\"line\">- (void)addDependency:(NSOperation *)op; //添加依赖</div><div class=\"line\">- (void)removeDependency:(NSOperation *)op; //删除依赖关系</div><div class=\"line\"></div><div class=\"line\">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; //所有依赖关系的数组</div><div class=\"line\"></div><div class=\"line\">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</div><div class=\"line\">//队列优先级  优先级高的先执行 一般设置为0 即 NSOperationQueuePriorityNormal。</div><div class=\"line\"> NSOperationQueuePriorityVeryLow = -8L,</div><div class=\"line\"> NSOperationQueuePriorityLow = -4L,</div><div class=\"line\"> NSOperationQueuePriorityNormal = 0,</div><div class=\"line\"> NSOperationQueuePriorityHigh = 4,</div><div class=\"line\"> NSOperationQueuePriorityVeryHigh = 8</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">@property NSOperationQueuePriority queuePriority;//队列优先级</div><div class=\"line\"></div><div class=\"line\">@property (nullable, copy) void (^completionBlock)(void)  NS_AVAILABLE(10_6, 4_0);//完成时候执行的代码块</div><div class=\"line\">//等待直到完成</div><div class=\"line\">- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//线程优先级</div><div class=\"line\">@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);</div><div class=\"line\"></div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">NSQualityOfService 的几个枚举值：</div><div class=\"line\">  NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上</div><div class=\"line\">  NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务</div><div class=\"line\">  NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级</div><div class=\"line\">  NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务</div><div class=\"line\">  NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//名字</div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);</div></pre></td></tr></table></figure>\n<h3 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;//添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;3 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(1);</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;3 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop setCompletionBlock:^&#123; //添加同时执行的task</div><div class=\"line\">        NSLog(@&quot;blop end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    [blop start];</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] 1 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] 3 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] 2 start**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562249] ****线程****info : &lt;NSThread: 0x7fea68408b30&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562288] ****线程****info : &lt;NSThread: 0x7fea6861fb30&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 16:47:44.857 GCD_Demo[17555:562287] ****线程****info : &lt;NSThread: 0x7fea69300470&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 16:47:45.922 GCD_Demo[17555:562287] 3 end**</div><div class=\"line\">**2016-03-29 16:47:46.858 GCD_Demo[17555:562249] 1 end**</div><div class=\"line\">**2016-03-29 16:47:48.928 GCD_Demo[17555:562288] 2 end**</div><div class=\"line\">**2016-03-29 16:47:48.929 GCD_Demo[17555:562288] blop end**</div></pre></td></tr></table></figure>\n<p>可以看出来，NSBlockOperation当任务是1的时候在main线程中执行，任务大于1的时候，其他的个自独自开了线程，而且互不影响。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop1_1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        NSLog(@&quot;blop1_2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    NSLog(@&quot;blop will start&quot;);</div><div class=\"line\">    [blop start];</div><div class=\"line\">    NSLog(@&quot;blop did start&quot;);</div><div class=\"line\">    </div><div class=\"line\">    NSBlockOperation * blop2 =[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">   // [blop2 addDependency:blop];//blop2 依赖blop 就是blopExecutionBlock 执行完之后再执行blop2的任务【blop2 执行task和blop 的CompletionBlock基本是同时执行的】</div><div class=\"line\">    [blop2 start];</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop will start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] blop1_1 start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574455] blop1_2 start**</div><div class=\"line\">**2016-03-29 17:06:53.217 GCD_Demo[17806:574416] ****线程****info : &lt;NSThread: 0x7f839a004ff0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 17:06:53.218 GCD_Demo[17806:574455] ****线程****info : &lt;NSThread: 0x7f8398416d80&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-29 17:06:55.219 GCD_Demo[17806:574416] blop1_1 end**</div><div class=\"line\">**2016-03-29 17:06:57.272 GCD_Demo[17806:574455] blop1_2 end**</div><div class=\"line\">**2016-03-29 17:06:57.272 GCD_Demo[17806:574416] blop did start**</div><div class=\"line\">**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] blop2 start**</div><div class=\"line\">**2016-03-29 17:06:57.273 GCD_Demo[17806:574416] ****线程****info : &lt;NSThread: 0x7f839a004ff0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-03-29 17:06:59.274 GCD_Demo[17806:574416] blop2 end**</div></pre></td></tr></table></figure>\n<p>从输出的信息可以看出来，block是同步执行的，虽然多任务是多线程，但是主线程还是在阻塞中，只有上一个所有 task 执行完的时候，才会执行下边的task。所以在这里依赖关系不那么重要了，注释掉运行结果也一样的。</p>\n<h3 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSInvocationOperation 是NSOperation的子类，负责实现operation的SEL方法。</div><div class=\"line\">这样子operation就可以start的时候执行一些函数了。</div><div class=\"line\">在swift中已经废弃</div><div class=\"line\">看文档：</div><div class=\"line\">NS_SWIFT_UNAVAILABLE(&quot;NSInvocation and related APIs not available&quot;)</div></pre></td></tr></table></figure>\n<h3 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">//添加操作</div><div class=\"line\">- (void)addOperation:(NSOperation *)op;</div><div class=\"line\">//添加操作数组 在完成操作的时候</div><div class=\"line\">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//添加携带代码块的operation</div><div class=\"line\">- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//所有的操作 组成的数组 可读属性</div><div class=\"line\">@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;</div><div class=\"line\">//操作个数</div><div class=\"line\">@property (readonly) NSUInteger operationCount NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//设置最大并行的任务数 ps:operation 其实 一个operation可以同时开启几个线程的。</div><div class=\"line\">@property NSInteger maxConcurrentOperationCount;</div><div class=\"line\">//挂起</div><div class=\"line\">@property (getter=isSuspended) BOOL suspended;</div><div class=\"line\">//队列的名字</div><div class=\"line\">@property (nullable, copy) NSString *name NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//优先级</div><div class=\"line\">@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">队列</div><div class=\"line\">@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue NS_AVAILABLE(10_10, 8_0);</div><div class=\"line\">//取消所有的操作</div><div class=\"line\">- (void)cancelAllOperations;</div><div class=\"line\">//等到他们的操作结束</div><div class=\"line\">- (void)waitUntilAllOperationsAreFinished;</div><div class=\"line\">//当前的队列</div><div class=\"line\">+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\">//主队列</div><div class=\"line\">+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\"># 队列的例子</div><div class=\"line\">#队列中添加的operation都是在子线程中执行的。</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)op1&#123;</div><div class=\"line\">     NSLog(@&quot;op1 开始运行了&quot;);</div><div class=\"line\">     sleep(3);</div><div class=\"line\">     NSLog(@&quot;op1 结束&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)test5&#123;</div><div class=\"line\">    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    NSOperationQueue * queue =[[NSOperationQueue alloc]init];</div><div class=\"line\">    [queue addOperation:op1]; //添加操作</div><div class=\"line\">    queue.maxConcurrentOperationCount = 1;//同时允许一个operation运行</div><div class=\"line\">    NSBlockOperation *block = [self test4];//任务块</div><div class=\"line\">    [queue addOperation:block];//添加任务块并运行</div><div class=\"line\"></div><div class=\"line\">// sleep(2);  </div><div class=\"line\">   // [queue cancelAllOperations];</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSBlockOperation *)test4&#123;</div><div class=\"line\">    NSBlockOperation * blop = [[NSBlockOperation alloc]init];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_1 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(2);</div><div class=\"line\">        NSLog(@&quot;blop1_1 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [blop addExecutionBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;blop1_2 start&quot;);</div><div class=\"line\">        [self print];</div><div class=\"line\">        sleep(4);</div><div class=\"line\">        NSLog(@&quot;blop1_2 end&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    return blop;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-03-31 11:22:16.663 GCD_Demo[26038:889212] op1 ****开始运行了**</div><div class=\"line\">**2016-03-31 11:22:19.737 GCD_Demo[26038:889212] op1 ****结束**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] blop1_1 start**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] blop1_2 start**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889213] ****线程****info : &lt;NSThread: 0x7fea3061d110&gt;&#123;number = 2, name = (null)&#125;**</div><div class=\"line\">**2016-03-31 11:22:19.738 GCD_Demo[26038:889226] ****线程****info : &lt;NSThread: 0x7fea31800140&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-03-31 11:22:21.808 GCD_Demo[26038:889213] blop1_1 end**</div><div class=\"line\">**2016-03-31 11:22:23.784 GCD_Demo[26038:889226] blop1_2 end**</div><div class=\"line\"># 从输出的信息可以看出来，当设置最大的operation为1的时候，相当于这个队列同步运行了，不过这个同步的单位不是线程，而是operation。</div><div class=\"line\"></div><div class=\"line\">当把这两句代码加到 test5最后边输出结果是：</div><div class=\"line\">**2016-03-31 11:28:59.267 GCD_Demo[26113:892737] op1 ****开始运行了**</div><div class=\"line\">**2016-03-31 11:29:02.341 GCD_Demo[26113:892737] op1 ****结束**</div><div class=\"line\">从输出结果得出：正在执行的Operation无法stop，正在ready的operation直接跳过start，执行complateBlock.状态由ready改为canceld。ps：注意看官方文档</div><div class=\"line\">`Canceling the operations does not automatically remove them from the queue or stop those that are currently executing.`</div><div class=\"line\">正在执行的不会从队列中删除也不会stop。</div><div class=\"line\">`For operations that are queued and waiting execution, the queue must still attempt to execute the operation before recognizing that it is canceled and moving it to the finished state. </div><div class=\"line\">For operations that are already executing, the operation object itself must check for cancellation and stop what it is doing so that it can move to the finished state. </div><div class=\"line\">In both cases, a finished (or canceled) operation is still given a chance to execute its completion block before it is removed from the queue.` </div><div class=\"line\">正在队列中等待的operation执行的时候会检测是否被cancenld，如果状态是canceld，那么直接执行completion block 在它被队列删除的时候。</div></pre></td></tr></table></figure>\n<h3 id=\"在子线程中耗时的操作完成了，那么该在主线程中更新UI\"><a href=\"#在子线程中耗时的操作完成了，那么该在主线程中更新UI\" class=\"headerlink\" title=\"在子线程中耗时的操作完成了，那么该在主线程中更新UI\"></a>在子线程中耗时的操作完成了，那么该在主线程中更新UI</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#将上面的test5 改成下面的代码</div><div class=\"line\">- (void)test5&#123;</div><div class=\"line\">    NSInvocationOperation * op1 =[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    NSOperationQueue * queue =[[NSOperationQueue alloc]init];</div><div class=\"line\">    [queue addOperation:op1];</div><div class=\"line\">    queue.maxConcurrentOperationCount = 3;//根据需要设置数量</div><div class=\"line\">    NSBlockOperation *block = [self test4];</div><div class=\"line\">    [queue addOperation:block];</div><div class=\"line\">//这句话一定要添加，这句话的意思等到所有的operation都完成了在执行后面的代码，</div><div class=\"line\">其实就是上面的操作执行到这里要等待他们直到他们都完成了。</div><div class=\"line\">#     [queue waitUntilAllOperationsAreFinished]; </div><div class=\"line\">    NSBlockOperation * blockUpdateMainUI=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">        NSLog(@&quot;update UI&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [[NSOperationQueue mainQueue] addOperation:blockUpdateMainUI];//在主队列中执行更新UI的操作</div><div class=\"line\">&#125;</div><div class=\"line\">上面的代码 和GCD中的分组有些类似，但是 这个OperationQueue基本单位是operation而不是线程，一定要理解。</div><div class=\"line\">operation和线程的关系是 一个operation可能对应多个线程，也可能对应一个线程。</div></pre></td></tr></table></figure>\n<p>关于NSOperationQueue的了解和使用我想到的基本就这么多场景，后期有其他的场景再补充。<br>预告：下期节目是NSThread的介绍和使用。<br>ps:广告时间</p>\n<hr>\n<p>有问题可以发我邮箱讨论共同交流技术。<br>fgyong@yeah.net</p>\n"},{"title":"iOS线程之NSThread","date":"2016-04-13T03:23:40.000Z","_content":"前两篇文章已经将了现在主流的GCD和NSOperationQueue,现在我们在聊一下NSThread。\n### 创建NSThread \n方法一 类方法\n```\n+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;\n```\n方法二 实例方法\n ```\n- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);\n```\n这两者的区别是 类方法是创建新的线程并且立即启动，而第二个方法是创建线程，但是没有启动，启动需要` [thread start]`。\n### 获取线程的状态\n```\n正在执行\n@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);\n完成\n@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);\n取消\n@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);\n```\n### 更改线程状态\n```\n取消\n- (void)cancel NS_AVAILABLE(10_5, 2_0);\n开始\n- (void)start NS_AVAILABLE(10_5, 2_0);\n线程的主函数\n- (void)main NS_AVAILABLE(10_5, 2_0);\n```\n在子线程中想要更新UI怎么办，这里官方直接提供了在子线程执行方法的函数，很实用的。\n```\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray<NSString *> *)array;\n在主线程执行\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;\n\n // equivalent to the first method with kCFRunLoopCommonModes\n- (void)performSelector:(SEL)aSelector \n                        onThread:(NSThread *)thr \n                      withObject:(nullable id)arg \n                waitUntilDone:(BOOL)wait \n                              modes:(nullable NSArray<NSString *> *)array NS_AVAILABLE(10_5, 2_0);\n- (void)performSelector:(SEL)aSelector \n                          onThread:(NSThread *)thr\n                       withObject:(nullable id)arg \n                waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);\n // equivalent to the first method with kCFRunLoopCommonModes\n- (void)performSelectorInBackground:(SEL)aSelector\n                                                  withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);\n```\n### 代码\n```\n- (void)test6{\n    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    thread.name = @\"test6\";\n    [thread start];\n    [self performSelectorInBackground:@selector(print) withObject:nil];\n}\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)op1{\n    \n     NSLog(@\"op1 开始运行了\");\n     sleep(3);\n\n     NSLog(@\"op1 结束\");\n}\n输出：\n**2016-04-13 10:34:23.515 GCD_Demo[33904:647479] op1 ****开始运行了**\n**2016-04-13 10:34:23.515 GCD_Demo[33904:647480] ****线程****info : <NSThread: 0x7fcc81a1abe0>{number = 3, name = (null)}**\n**2016-04-13 10:34:26.521 GCD_Demo[33904:647479] op1 ****结束**\n```\n从输出结果看出来`[self performSelectorInBackground:@selector(print) withObject:nil];`又自动生成了子线程并且在子线程执行`print`函数。\n\n把test6函数改成下面的情况\n```\n//当waitUntilDone 是yes的时候，是同步执行\n [self performSelectorOnMainThread:@selector(print) withObject:nil waitUntilDone:NO];\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    _thread.name = @\"test6\";\n    [_thread start];\n    [self performSelectorInBackground:@selector(print) withObject:nil];\n```\n输出：\n```\n**2016-04-13 10:41:32.534 GCD_Demo[34026:652753] test6 ****开始运行了**\n**2016-04-13 10:41:32.534 GCD_Demo[34026:652754] ****线程****info : <NSThread: 0x7fb7320a1bf0>{number = 3, name = (null)}**\n**2016-04-13 10:41:32.537 GCD_Demo[34026:652708] ****线程****info : <NSThread: 0x7fb730c05a20>{number = 1, name = main}**\n**2016-04-13 10:41:35.539 GCD_Demo[34026:652753] test6 ****结束**\n```\n`[self performSelectorOnMainThread:@selector(print) \n                                                withObject:nil\n                                         waitUntilDone:NO];`\nwaitUntilDone为YES的时候是同步执行代码，为NO的时候异步执行代码。\n`[self performSelectorInBackground:@selector(print) withObject:nil];`开启子线程执行print函数。\n### cancel thread\n```\n- (void)test6{\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    _thread.name = @\"test6\";\n    [_thread start];\n    sleep(2);\n    [_thread cancel];\n    if (_thread.cancelled) {\n        NSLog(@\"%@ canceld\",_thread.name);\n    } else if(_thread.executing){\n        NSLog(@\"%@ execuitng\",_thread.name);\n    }\n}\n```\n输出：\n```\n**2016-04-13 10:50:46.685 GCD_Demo[34128:657263] test6 ****开始运行了**\n**2016-04-13 10:50:48.686 GCD_Demo[34128:657214] test6 canceld**\n**2016-04-13 10:50:48.692 GCD_Demo[34128:657214] ****线程****info : <NSThread: 0x7ffb34004fb0>{number = 1, name = main}**\n**2016-04-13 10:51:16.689 GCD_Demo[34128:657263] test6 ****结束**\n```\n其实thread取消也是在执行中的线程是没办法直接取消的，`[thread cancel]`紧紧是改了状态，却没有终止线程。和`[NSOperation cancel]`类似，当你cancel之后，如果线程在执行，那么他会执行完毕，如果线程还没执行，那么他会终止执行。\n\n关于thread的通知\n```\n//将要变成多线程 在有新的线程启动的时候会发送此通知\nFOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;\n//将要变成单独线程  官方标注: Not implemented.【没有实现】\nFOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;\n//线程退出\nFOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;\n\n通过这三个通知可以监测线程的启动和现成的退出。\n//监测线程启动，启动的线程是未知的所以object是nil\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(becomeMultiNsthread) name:NSWillBecomeMultiThreadedNotification object:nil];\n\n//监测线程退出\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(exit:) name:NSThreadWillExitNotification object:nil];\n```\n线程的讨论暂时就这么多，有问题我们一起讨论，欢迎留言。。","source":"_posts/iOS线程之NSThread.md","raw":"title: iOS线程之NSThread\ndate: 2016-04-13 11:23:40\ntags:\n- iOS\n- iOS高级\ncategories: iOS\n---\n前两篇文章已经将了现在主流的GCD和NSOperationQueue,现在我们在聊一下NSThread。\n### 创建NSThread \n方法一 类方法\n```\n+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;\n```\n方法二 实例方法\n ```\n- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);\n```\n这两者的区别是 类方法是创建新的线程并且立即启动，而第二个方法是创建线程，但是没有启动，启动需要` [thread start]`。\n### 获取线程的状态\n```\n正在执行\n@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);\n完成\n@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);\n取消\n@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);\n```\n### 更改线程状态\n```\n取消\n- (void)cancel NS_AVAILABLE(10_5, 2_0);\n开始\n- (void)start NS_AVAILABLE(10_5, 2_0);\n线程的主函数\n- (void)main NS_AVAILABLE(10_5, 2_0);\n```\n在子线程中想要更新UI怎么办，这里官方直接提供了在子线程执行方法的函数，很实用的。\n```\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray<NSString *> *)array;\n在主线程执行\n- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;\n\n // equivalent to the first method with kCFRunLoopCommonModes\n- (void)performSelector:(SEL)aSelector \n                        onThread:(NSThread *)thr \n                      withObject:(nullable id)arg \n                waitUntilDone:(BOOL)wait \n                              modes:(nullable NSArray<NSString *> *)array NS_AVAILABLE(10_5, 2_0);\n- (void)performSelector:(SEL)aSelector \n                          onThread:(NSThread *)thr\n                       withObject:(nullable id)arg \n                waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);\n // equivalent to the first method with kCFRunLoopCommonModes\n- (void)performSelectorInBackground:(SEL)aSelector\n                                                  withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);\n```\n### 代码\n```\n- (void)test6{\n    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    thread.name = @\"test6\";\n    [thread start];\n    [self performSelectorInBackground:@selector(print) withObject:nil];\n}\n- (void)print{\n    NSLog(@\"线程info : %@\",[NSThread currentThread]);\n}\n- (void)op1{\n    \n     NSLog(@\"op1 开始运行了\");\n     sleep(3);\n\n     NSLog(@\"op1 结束\");\n}\n输出：\n**2016-04-13 10:34:23.515 GCD_Demo[33904:647479] op1 ****开始运行了**\n**2016-04-13 10:34:23.515 GCD_Demo[33904:647480] ****线程****info : <NSThread: 0x7fcc81a1abe0>{number = 3, name = (null)}**\n**2016-04-13 10:34:26.521 GCD_Demo[33904:647479] op1 ****结束**\n```\n从输出结果看出来`[self performSelectorInBackground:@selector(print) withObject:nil];`又自动生成了子线程并且在子线程执行`print`函数。\n\n把test6函数改成下面的情况\n```\n//当waitUntilDone 是yes的时候，是同步执行\n [self performSelectorOnMainThread:@selector(print) withObject:nil waitUntilDone:NO];\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    _thread.name = @\"test6\";\n    [_thread start];\n    [self performSelectorInBackground:@selector(print) withObject:nil];\n```\n输出：\n```\n**2016-04-13 10:41:32.534 GCD_Demo[34026:652753] test6 ****开始运行了**\n**2016-04-13 10:41:32.534 GCD_Demo[34026:652754] ****线程****info : <NSThread: 0x7fb7320a1bf0>{number = 3, name = (null)}**\n**2016-04-13 10:41:32.537 GCD_Demo[34026:652708] ****线程****info : <NSThread: 0x7fb730c05a20>{number = 1, name = main}**\n**2016-04-13 10:41:35.539 GCD_Demo[34026:652753] test6 ****结束**\n```\n`[self performSelectorOnMainThread:@selector(print) \n                                                withObject:nil\n                                         waitUntilDone:NO];`\nwaitUntilDone为YES的时候是同步执行代码，为NO的时候异步执行代码。\n`[self performSelectorInBackground:@selector(print) withObject:nil];`开启子线程执行print函数。\n### cancel thread\n```\n- (void)test6{\n    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];\n    _thread.name = @\"test6\";\n    [_thread start];\n    sleep(2);\n    [_thread cancel];\n    if (_thread.cancelled) {\n        NSLog(@\"%@ canceld\",_thread.name);\n    } else if(_thread.executing){\n        NSLog(@\"%@ execuitng\",_thread.name);\n    }\n}\n```\n输出：\n```\n**2016-04-13 10:50:46.685 GCD_Demo[34128:657263] test6 ****开始运行了**\n**2016-04-13 10:50:48.686 GCD_Demo[34128:657214] test6 canceld**\n**2016-04-13 10:50:48.692 GCD_Demo[34128:657214] ****线程****info : <NSThread: 0x7ffb34004fb0>{number = 1, name = main}**\n**2016-04-13 10:51:16.689 GCD_Demo[34128:657263] test6 ****结束**\n```\n其实thread取消也是在执行中的线程是没办法直接取消的，`[thread cancel]`紧紧是改了状态，却没有终止线程。和`[NSOperation cancel]`类似，当你cancel之后，如果线程在执行，那么他会执行完毕，如果线程还没执行，那么他会终止执行。\n\n关于thread的通知\n```\n//将要变成多线程 在有新的线程启动的时候会发送此通知\nFOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;\n//将要变成单独线程  官方标注: Not implemented.【没有实现】\nFOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;\n//线程退出\nFOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;\n\n通过这三个通知可以监测线程的启动和现成的退出。\n//监测线程启动，启动的线程是未知的所以object是nil\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(becomeMultiNsthread) name:NSWillBecomeMultiThreadedNotification object:nil];\n\n//监测线程退出\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(exit:) name:NSThreadWillExitNotification object:nil];\n```\n线程的讨论暂时就这么多，有问题我们一起讨论，欢迎留言。。","slug":"iOS线程之NSThread","published":1,"updated":"2019-12-03T04:48:00.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2p000u9zskxi0ki3jo","content":"<p>前两篇文章已经将了现在主流的GCD和NSOperationQueue,现在我们在聊一下NSThread。</p>\n<h3 id=\"创建NSThread\"><a href=\"#创建NSThread\" class=\"headerlink\" title=\"创建NSThread\"></a>创建NSThread</h3><p>方法一 类方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</div></pre></td></tr></table></figure></p>\n<p>方法二 实例方法<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p>\n<p>这两者的区别是 类方法是创建新的线程并且立即启动，而第二个方法是创建线程，但是没有启动，启动需要<code>[thread start]</code>。</p>\n<h3 id=\"获取线程的状态\"><a href=\"#获取线程的状态\" class=\"headerlink\" title=\"获取线程的状态\"></a>获取线程的状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">正在执行</div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">完成</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">取消</div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure>\n<h3 id=\"更改线程状态\"><a href=\"#更改线程状态\" class=\"headerlink\" title=\"更改线程状态\"></a>更改线程状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">取消</div><div class=\"line\">- (void)cancel NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">开始</div><div class=\"line\">- (void)start NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">线程的主函数</div><div class=\"line\">- (void)main NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure>\n<p>在子线程中想要更新UI怎么办，这里官方直接提供了在子线程执行方法的函数，很实用的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div><div class=\"line\">在主线程执行</div><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class=\"line\"></div><div class=\"line\"> // equivalent to the first method with kCFRunLoopCommonModes</div><div class=\"line\">- (void)performSelector:(SEL)aSelector </div><div class=\"line\">                        onThread:(NSThread *)thr </div><div class=\"line\">                      withObject:(nullable id)arg </div><div class=\"line\">                waitUntilDone:(BOOL)wait </div><div class=\"line\">                              modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">- (void)performSelector:(SEL)aSelector </div><div class=\"line\">                          onThread:(NSThread *)thr</div><div class=\"line\">                       withObject:(nullable id)arg </div><div class=\"line\">                waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\"> // equivalent to the first method with kCFRunLoopCommonModes</div><div class=\"line\">- (void)performSelectorInBackground:(SEL)aSelector</div><div class=\"line\">                                                  withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test6&#123;</div><div class=\"line\">    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [thread start];</div><div class=\"line\">    [self performSelectorInBackground:@selector(print) withObject:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)op1&#123;</div><div class=\"line\">    </div><div class=\"line\">     NSLog(@&quot;op1 开始运行了&quot;);</div><div class=\"line\">     sleep(3);</div><div class=\"line\"></div><div class=\"line\">     NSLog(@&quot;op1 结束&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-04-13 10:34:23.515 GCD_Demo[33904:647479] op1 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:34:23.515 GCD_Demo[33904:647480] ****线程****info : &lt;NSThread: 0x7fcc81a1abe0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-04-13 10:34:26.521 GCD_Demo[33904:647479] op1 ****结束**</div></pre></td></tr></table></figure>\n<p>从输出结果看出来<code>[self performSelectorInBackground:@selector(print) withObject:nil];</code>又自动生成了子线程并且在子线程执行<code>print</code>函数。</p>\n<p>把test6函数改成下面的情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当waitUntilDone 是yes的时候，是同步执行</div><div class=\"line\"> [self performSelectorOnMainThread:@selector(print) withObject:nil waitUntilDone:NO];</div><div class=\"line\">    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    _thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [_thread start];</div><div class=\"line\">    [self performSelectorInBackground:@selector(print) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">**2016-04-13 10:41:32.534 GCD_Demo[34026:652753] test6 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:41:32.534 GCD_Demo[34026:652754] ****线程****info : &lt;NSThread: 0x7fb7320a1bf0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-04-13 10:41:32.537 GCD_Demo[34026:652708] ****线程****info : &lt;NSThread: 0x7fb730c05a20&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-04-13 10:41:35.539 GCD_Demo[34026:652753] test6 ****结束**</div></pre></td></tr></table></figure></p>\n<p><code>[self performSelectorOnMainThread:@selector(print) \n                                                withObject:nil\n                                         waitUntilDone:NO];</code><br>waitUntilDone为YES的时候是同步执行代码，为NO的时候异步执行代码。<br><code>[self performSelectorInBackground:@selector(print) withObject:nil];</code>开启子线程执行print函数。</p>\n<h3 id=\"cancel-thread\"><a href=\"#cancel-thread\" class=\"headerlink\" title=\"cancel thread\"></a>cancel thread</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test6&#123;</div><div class=\"line\">    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    _thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [_thread start];</div><div class=\"line\">    sleep(2);</div><div class=\"line\">    [_thread cancel];</div><div class=\"line\">    if (_thread.cancelled) &#123;</div><div class=\"line\">        NSLog(@&quot;%@ canceld&quot;,_thread.name);</div><div class=\"line\">    &#125; else if(_thread.executing)&#123;</div><div class=\"line\">        NSLog(@&quot;%@ execuitng&quot;,_thread.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">**2016-04-13 10:50:46.685 GCD_Demo[34128:657263] test6 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:50:48.686 GCD_Demo[34128:657214] test6 canceld**</div><div class=\"line\">**2016-04-13 10:50:48.692 GCD_Demo[34128:657214] ****线程****info : &lt;NSThread: 0x7ffb34004fb0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-04-13 10:51:16.689 GCD_Demo[34128:657263] test6 ****结束**</div></pre></td></tr></table></figure></p>\n<p>其实thread取消也是在执行中的线程是没办法直接取消的，<code>[thread cancel]</code>紧紧是改了状态，却没有终止线程。和<code>[NSOperation cancel]</code>类似，当你cancel之后，如果线程在执行，那么他会执行完毕，如果线程还没执行，那么他会终止执行。</p>\n<p>关于thread的通知<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将要变成多线程 在有新的线程启动的时候会发送此通知</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;</div><div class=\"line\">//将要变成单独线程  官方标注: Not implemented.【没有实现】</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;</div><div class=\"line\">//线程退出</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;</div><div class=\"line\"></div><div class=\"line\">通过这三个通知可以监测线程的启动和现成的退出。</div><div class=\"line\">//监测线程启动，启动的线程是未知的所以object是nil</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(becomeMultiNsthread) name:NSWillBecomeMultiThreadedNotification object:nil];</div><div class=\"line\"></div><div class=\"line\">//监测线程退出</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(exit:) name:NSThreadWillExitNotification object:nil];</div></pre></td></tr></table></figure></p>\n<p>线程的讨论暂时就这么多，有问题我们一起讨论，欢迎留言。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前两篇文章已经将了现在主流的GCD和NSOperationQueue,现在我们在聊一下NSThread。</p>\n<h3 id=\"创建NSThread\"><a href=\"#创建NSThread\" class=\"headerlink\" title=\"创建NSThread\"></a>创建NSThread</h3><p>方法一 类方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</div></pre></td></tr></table></figure></p>\n<p>方法二 实例方法<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p>\n<p>这两者的区别是 类方法是创建新的线程并且立即启动，而第二个方法是创建线程，但是没有启动，启动需要<code>[thread start]</code>。</p>\n<h3 id=\"获取线程的状态\"><a href=\"#获取线程的状态\" class=\"headerlink\" title=\"获取线程的状态\"></a>获取线程的状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">正在执行</div><div class=\"line\">@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">完成</div><div class=\"line\">@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">取消</div><div class=\"line\">@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure>\n<h3 id=\"更改线程状态\"><a href=\"#更改线程状态\" class=\"headerlink\" title=\"更改线程状态\"></a>更改线程状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">取消</div><div class=\"line\">- (void)cancel NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">开始</div><div class=\"line\">- (void)start NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">线程的主函数</div><div class=\"line\">- (void)main NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure>\n<p>在子线程中想要更新UI怎么办，这里官方直接提供了在子线程执行方法的函数，很实用的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div><div class=\"line\">在主线程执行</div><div class=\"line\">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class=\"line\"></div><div class=\"line\"> // equivalent to the first method with kCFRunLoopCommonModes</div><div class=\"line\">- (void)performSelector:(SEL)aSelector </div><div class=\"line\">                        onThread:(NSThread *)thr </div><div class=\"line\">                      withObject:(nullable id)arg </div><div class=\"line\">                waitUntilDone:(BOOL)wait </div><div class=\"line\">                              modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\">- (void)performSelector:(SEL)aSelector </div><div class=\"line\">                          onThread:(NSThread *)thr</div><div class=\"line\">                       withObject:(nullable id)arg </div><div class=\"line\">                waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</div><div class=\"line\"> // equivalent to the first method with kCFRunLoopCommonModes</div><div class=\"line\">- (void)performSelectorInBackground:(SEL)aSelector</div><div class=\"line\">                                                  withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);</div></pre></td></tr></table></figure></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test6&#123;</div><div class=\"line\">    NSThread * thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [thread start];</div><div class=\"line\">    [self performSelectorInBackground:@selector(print) withObject:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)print&#123;</div><div class=\"line\">    NSLog(@&quot;线程info : %@&quot;,[NSThread currentThread]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)op1&#123;</div><div class=\"line\">    </div><div class=\"line\">     NSLog(@&quot;op1 开始运行了&quot;);</div><div class=\"line\">     sleep(3);</div><div class=\"line\"></div><div class=\"line\">     NSLog(@&quot;op1 结束&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">**2016-04-13 10:34:23.515 GCD_Demo[33904:647479] op1 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:34:23.515 GCD_Demo[33904:647480] ****线程****info : &lt;NSThread: 0x7fcc81a1abe0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-04-13 10:34:26.521 GCD_Demo[33904:647479] op1 ****结束**</div></pre></td></tr></table></figure>\n<p>从输出结果看出来<code>[self performSelectorInBackground:@selector(print) withObject:nil];</code>又自动生成了子线程并且在子线程执行<code>print</code>函数。</p>\n<p>把test6函数改成下面的情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当waitUntilDone 是yes的时候，是同步执行</div><div class=\"line\"> [self performSelectorOnMainThread:@selector(print) withObject:nil waitUntilDone:NO];</div><div class=\"line\">    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    _thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [_thread start];</div><div class=\"line\">    [self performSelectorInBackground:@selector(print) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">**2016-04-13 10:41:32.534 GCD_Demo[34026:652753] test6 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:41:32.534 GCD_Demo[34026:652754] ****线程****info : &lt;NSThread: 0x7fb7320a1bf0&gt;&#123;number = 3, name = (null)&#125;**</div><div class=\"line\">**2016-04-13 10:41:32.537 GCD_Demo[34026:652708] ****线程****info : &lt;NSThread: 0x7fb730c05a20&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-04-13 10:41:35.539 GCD_Demo[34026:652753] test6 ****结束**</div></pre></td></tr></table></figure></p>\n<p><code>[self performSelectorOnMainThread:@selector(print) \n                                                withObject:nil\n                                         waitUntilDone:NO];</code><br>waitUntilDone为YES的时候是同步执行代码，为NO的时候异步执行代码。<br><code>[self performSelectorInBackground:@selector(print) withObject:nil];</code>开启子线程执行print函数。</p>\n<h3 id=\"cancel-thread\"><a href=\"#cancel-thread\" class=\"headerlink\" title=\"cancel thread\"></a>cancel thread</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)test6&#123;</div><div class=\"line\">    _thread = [[NSThread alloc]initWithTarget:self selector:@selector(op1) object:nil];</div><div class=\"line\">    _thread.name = @&quot;test6&quot;;</div><div class=\"line\">    [_thread start];</div><div class=\"line\">    sleep(2);</div><div class=\"line\">    [_thread cancel];</div><div class=\"line\">    if (_thread.cancelled) &#123;</div><div class=\"line\">        NSLog(@&quot;%@ canceld&quot;,_thread.name);</div><div class=\"line\">    &#125; else if(_thread.executing)&#123;</div><div class=\"line\">        NSLog(@&quot;%@ execuitng&quot;,_thread.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">**2016-04-13 10:50:46.685 GCD_Demo[34128:657263] test6 ****开始运行了**</div><div class=\"line\">**2016-04-13 10:50:48.686 GCD_Demo[34128:657214] test6 canceld**</div><div class=\"line\">**2016-04-13 10:50:48.692 GCD_Demo[34128:657214] ****线程****info : &lt;NSThread: 0x7ffb34004fb0&gt;&#123;number = 1, name = main&#125;**</div><div class=\"line\">**2016-04-13 10:51:16.689 GCD_Demo[34128:657263] test6 ****结束**</div></pre></td></tr></table></figure></p>\n<p>其实thread取消也是在执行中的线程是没办法直接取消的，<code>[thread cancel]</code>紧紧是改了状态，却没有终止线程。和<code>[NSOperation cancel]</code>类似，当你cancel之后，如果线程在执行，那么他会执行完毕，如果线程还没执行，那么他会终止执行。</p>\n<p>关于thread的通知<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将要变成多线程 在有新的线程启动的时候会发送此通知</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;</div><div class=\"line\">//将要变成单独线程  官方标注: Not implemented.【没有实现】</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;</div><div class=\"line\">//线程退出</div><div class=\"line\">FOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;</div><div class=\"line\"></div><div class=\"line\">通过这三个通知可以监测线程的启动和现成的退出。</div><div class=\"line\">//监测线程启动，启动的线程是未知的所以object是nil</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(becomeMultiNsthread) name:NSWillBecomeMultiThreadedNotification object:nil];</div><div class=\"line\"></div><div class=\"line\">//监测线程退出</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(exit:) name:NSThreadWillExitNotification object:nil];</div></pre></td></tr></table></figure></p>\n<p>线程的讨论暂时就这么多，有问题我们一起讨论，欢迎留言。。</p>\n"},{"title":"iOS自动化打包第一步","date":"2016-01-28T09:32:06.000Z","_content":"## shell入门初探\niOS打包有点烦人，现在就是想做个脚本一条命令执行之后打包然后上传到测试环境脚本。这是第一步在上传的基础上又写了一层上传只需要一条命令即可\n\n``` \n #!/bin/bash \n if [ $# != 1 ] //判断输入参数\n    then\n     echo \"请输入版本号\"//没有参数直接报错\n     exit             //退出\n else\n     version=${1}    //获取输入的版本号\n     shorder=\"./debug-publish.sh ${version} ios debug-${version}.ipa\"//将要执行的shell脚本和命令\n\n\n      $shorder //执行字符串脚本\n      echo \"正在执行命令。。。\"\n      if [ $? -eq 0 ]//判断执行命令的结果是否成功 0是成功\n       then\n       echo \"push successed\"\n       else\n            echo \"push faild\"\n         fi\n\nfi\n                                                                                                 ```\n                                                                                                 完成之后就可以使用了记得给这个脚本权限哦\n                                                                                                 ```\n                                                                                                 chmod +x yourShellFile //给执行权限\n\n                                                                                                 ./yourShellFile 1.1.1 //执行脚本在本目录下面\n                                                                                                 ```\n\n\n                                                                                                 这是我的第一个脚本哦欢迎大虾指教。\n\n\n","source":"_posts/iOS自动化打包第一步.md","raw":"title: iOS自动化打包第一步\ndate: 2016-01-28 17:32:06\ntags:\n- iOS\n- Shell\n- iOS自动化打包\ncategories: iOS\n---\n## shell入门初探\niOS打包有点烦人，现在就是想做个脚本一条命令执行之后打包然后上传到测试环境脚本。这是第一步在上传的基础上又写了一层上传只需要一条命令即可\n\n``` \n #!/bin/bash \n if [ $# != 1 ] //判断输入参数\n    then\n     echo \"请输入版本号\"//没有参数直接报错\n     exit             //退出\n else\n     version=${1}    //获取输入的版本号\n     shorder=\"./debug-publish.sh ${version} ios debug-${version}.ipa\"//将要执行的shell脚本和命令\n\n\n      $shorder //执行字符串脚本\n      echo \"正在执行命令。。。\"\n      if [ $? -eq 0 ]//判断执行命令的结果是否成功 0是成功\n       then\n       echo \"push successed\"\n       else\n            echo \"push faild\"\n         fi\n\nfi\n                                                                                                 ```\n                                                                                                 完成之后就可以使用了记得给这个脚本权限哦\n                                                                                                 ```\n                                                                                                 chmod +x yourShellFile //给执行权限\n\n                                                                                                 ./yourShellFile 1.1.1 //执行脚本在本目录下面\n                                                                                                 ```\n\n\n                                                                                                 这是我的第一个脚本哦欢迎大虾指教。\n\n\n","slug":"iOS自动化打包第一步","published":1,"updated":"2019-12-03T04:48:00.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2p000v9zskdgy24emp","content":"<h2 id=\"shell入门初探\"><a href=\"#shell入门初探\" class=\"headerlink\" title=\"shell入门初探\"></a>shell入门初探</h2><p>iOS打包有点烦人，现在就是想做个脚本一条命令执行之后打包然后上传到测试环境脚本。这是第一步在上传的基础上又写了一层上传只需要一条命令即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> #!/bin/bash </div><div class=\"line\"> if [ $# != 1 ] //判断输入参数</div><div class=\"line\">    then</div><div class=\"line\">     echo &quot;请输入版本号&quot;//没有参数直接报错</div><div class=\"line\">     exit             //退出</div><div class=\"line\"> else</div><div class=\"line\">     version=$&#123;1&#125;    //获取输入的版本号</div><div class=\"line\">     shorder=&quot;./debug-publish.sh $&#123;version&#125; ios debug-$&#123;version&#125;.ipa&quot;//将要执行的shell脚本和命令</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      $shorder //执行字符串脚本</div><div class=\"line\">      echo &quot;正在执行命令。。。&quot;</div><div class=\"line\">      if [ $? -eq 0 ]//判断执行命令的结果是否成功 0是成功</div><div class=\"line\">       then</div><div class=\"line\">       echo &quot;push successed&quot;</div><div class=\"line\">       else</div><div class=\"line\">            echo &quot;push faild&quot;</div><div class=\"line\">         fi</div><div class=\"line\"></div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<pre><code>完成之后就可以使用了记得给这个脚本权限哦\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x yourShellFile //给执行权限</div><div class=\"line\"></div><div class=\"line\">./yourShellFile 1.1.1 //执行脚本在本目录下面</div></pre></td></tr></table></figure>\n\n这是我的第一个脚本哦欢迎大虾指教。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"shell入门初探\"><a href=\"#shell入门初探\" class=\"headerlink\" title=\"shell入门初探\"></a>shell入门初探</h2><p>iOS打包有点烦人，现在就是想做个脚本一条命令执行之后打包然后上传到测试环境脚本。这是第一步在上传的基础上又写了一层上传只需要一条命令即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> #!/bin/bash </div><div class=\"line\"> if [ $# != 1 ] //判断输入参数</div><div class=\"line\">    then</div><div class=\"line\">     echo &quot;请输入版本号&quot;//没有参数直接报错</div><div class=\"line\">     exit             //退出</div><div class=\"line\"> else</div><div class=\"line\">     version=$&#123;1&#125;    //获取输入的版本号</div><div class=\"line\">     shorder=&quot;./debug-publish.sh $&#123;version&#125; ios debug-$&#123;version&#125;.ipa&quot;//将要执行的shell脚本和命令</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">      $shorder //执行字符串脚本</div><div class=\"line\">      echo &quot;正在执行命令。。。&quot;</div><div class=\"line\">      if [ $? -eq 0 ]//判断执行命令的结果是否成功 0是成功</div><div class=\"line\">       then</div><div class=\"line\">       echo &quot;push successed&quot;</div><div class=\"line\">       else</div><div class=\"line\">            echo &quot;push faild&quot;</div><div class=\"line\">         fi</div><div class=\"line\"></div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<pre><code>完成之后就可以使用了记得给这个脚本权限哦\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x yourShellFile //给执行权限</div><div class=\"line\"></div><div class=\"line\">./yourShellFile 1.1.1 //执行脚本在本目录下面</div></pre></td></tr></table></figure>\n\n这是我的第一个脚本哦欢迎大虾指教。\n</code></pre>"},{"title":"iOS证书过期解决方案","date":"2016-01-28T02:36:27.000Z","_content":"关于证书过期还有描述文件不匹配的问题见解：\n\n## 平时问题下列步骤都能解决\n大牛（ps英语好的）[请去苹果开发文档中心](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html)\n证书过期一般都是先去开发者中心重新创建证书，不过现在的证书过期之后直接被官方删除了，倒是省事了。创建证书不懂的可以自行百度。\n删除配置文件【删除哪些？】那些有关过期证书的描述文件都删了\n重新生成配置文件【ps怎么生成？ 去这里】\n删除Xcode【我用的7.2】本地的描述文件【ps怎么删？去哪里删？】\n去目录 `/Users/用户名/Library/MobileDevice/Provisioning Profiles`文件夹下边删除所有的描述文件\n然后 下载刚才新生成的描述文件，然后双击下载好的描述文件装到电脑和资料库---------------------------------看到这里如果还不行的话，看我放大招--------------------\n\n## 假如你用的是Xcode 7.2的话\n大牛[是去这里](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html)\n上面的步骤你测试了都不行，然后给你大招解决问题去app工程文件用编辑器打开搜索关键字`PROVISIONING_PROFILE`、`command` +` F` 搜搜有关这关键字的都删除了，然后重启Xcode，重新编译即可\n## 问题还没解决怎么办？\n看看国际友人怎么处理的\n```\nI've also the same problem, in Xcode 7.2\n\nIt solved by followings steps: 1) Open Xcode preference, 2) Select the appropriate team, 3) Click the \"View Details..\". 4) In section \"Signing Identities\": click on \"Reset\" for each of them.\n\n5) In section \"Provisioning Profiles\". Click on \"Download All\".\n\n6) Click on \"Done.\"\n\n7) Go in Xcode, build settings, select it. In General tab, the issues should get removed.\n\n8) Restart the Xcode.\n\n9) Do the Final build.\n\nThat's all.\n```\n我是翻译：\n\n打开Xcode的preference，选择你的账号，点击账号下边的view detail。。然后选择你们的开发证书 reset按钮，之后下载全部的描述文件，点击done按钮。重启和编译Xcode之后，这个问题应该没有了。\n\n--------------------------------------邪恶的分割线----------------------------------------------\n\n这是我对于这个问题的一些总结，希望可以帮到一些人，不懂的可以评论问我。\n\n\n\n\n\n\n\n","source":"_posts/iOS证书过期解决方案.md","raw":"title: iOS证书过期解决方案\ndate: 2016-01-28 10:36:27\ntags: \n- iOS\n- 疑难杂症\ncategories: iOS\n---\n关于证书过期还有描述文件不匹配的问题见解：\n\n## 平时问题下列步骤都能解决\n大牛（ps英语好的）[请去苹果开发文档中心](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html)\n证书过期一般都是先去开发者中心重新创建证书，不过现在的证书过期之后直接被官方删除了，倒是省事了。创建证书不懂的可以自行百度。\n删除配置文件【删除哪些？】那些有关过期证书的描述文件都删了\n重新生成配置文件【ps怎么生成？ 去这里】\n删除Xcode【我用的7.2】本地的描述文件【ps怎么删？去哪里删？】\n去目录 `/Users/用户名/Library/MobileDevice/Provisioning Profiles`文件夹下边删除所有的描述文件\n然后 下载刚才新生成的描述文件，然后双击下载好的描述文件装到电脑和资料库---------------------------------看到这里如果还不行的话，看我放大招--------------------\n\n## 假如你用的是Xcode 7.2的话\n大牛[是去这里](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html)\n上面的步骤你测试了都不行，然后给你大招解决问题去app工程文件用编辑器打开搜索关键字`PROVISIONING_PROFILE`、`command` +` F` 搜搜有关这关键字的都删除了，然后重启Xcode，重新编译即可\n## 问题还没解决怎么办？\n看看国际友人怎么处理的\n```\nI've also the same problem, in Xcode 7.2\n\nIt solved by followings steps: 1) Open Xcode preference, 2) Select the appropriate team, 3) Click the \"View Details..\". 4) In section \"Signing Identities\": click on \"Reset\" for each of them.\n\n5) In section \"Provisioning Profiles\". Click on \"Download All\".\n\n6) Click on \"Done.\"\n\n7) Go in Xcode, build settings, select it. In General tab, the issues should get removed.\n\n8) Restart the Xcode.\n\n9) Do the Final build.\n\nThat's all.\n```\n我是翻译：\n\n打开Xcode的preference，选择你的账号，点击账号下边的view detail。。然后选择你们的开发证书 reset按钮，之后下载全部的描述文件，点击done按钮。重启和编译Xcode之后，这个问题应该没有了。\n\n--------------------------------------邪恶的分割线----------------------------------------------\n\n这是我对于这个问题的一些总结，希望可以帮到一些人，不懂的可以评论问我。\n\n\n\n\n\n\n\n","slug":"iOS证书过期解决方案","published":1,"updated":"2019-12-03T04:48:00.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi2q000w9zsk62t4hcpn","content":"<p>关于证书过期还有描述文件不匹配的问题见解：</p>\n<h2 id=\"平时问题下列步骤都能解决\"><a href=\"#平时问题下列步骤都能解决\" class=\"headerlink\" title=\"平时问题下列步骤都能解决\"></a>平时问题下列步骤都能解决</h2><p>大牛（ps英语好的）<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html\" target=\"_blank\" rel=\"external\">请去苹果开发文档中心</a><br>证书过期一般都是先去开发者中心重新创建证书，不过现在的证书过期之后直接被官方删除了，倒是省事了。创建证书不懂的可以自行百度。<br>删除配置文件【删除哪些？】那些有关过期证书的描述文件都删了<br>重新生成配置文件【ps怎么生成？ 去这里】<br>删除Xcode【我用的7.2】本地的描述文件【ps怎么删？去哪里删？】<br>去目录 <code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>文件夹下边删除所有的描述文件<br>然后 下载刚才新生成的描述文件，然后双击下载好的描述文件装到电脑和资料库———————————看到这里如果还不行的话，看我放大招——————–</p>\n<h2 id=\"假如你用的是Xcode-7-2的话\"><a href=\"#假如你用的是Xcode-7-2的话\" class=\"headerlink\" title=\"假如你用的是Xcode 7.2的话\"></a>假如你用的是Xcode 7.2的话</h2><p>大牛<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html\" target=\"_blank\" rel=\"external\">是去这里</a><br>上面的步骤你测试了都不行，然后给你大招解决问题去app工程文件用编辑器打开搜索关键字<code>PROVISIONING_PROFILE</code>、<code>command</code> +<code>F</code> 搜搜有关这关键字的都删除了，然后重启Xcode，重新编译即可</p>\n<h2 id=\"问题还没解决怎么办？\"><a href=\"#问题还没解决怎么办？\" class=\"headerlink\" title=\"问题还没解决怎么办？\"></a>问题还没解决怎么办？</h2><p>看看国际友人怎么处理的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">I&apos;ve also the same problem, in Xcode 7.2</div><div class=\"line\"></div><div class=\"line\">It solved by followings steps: 1) Open Xcode preference, 2) Select the appropriate team, 3) Click the &quot;View Details..&quot;. 4) In section &quot;Signing Identities&quot;: click on &quot;Reset&quot; for each of them.</div><div class=\"line\"></div><div class=\"line\">5) In section &quot;Provisioning Profiles&quot;. Click on &quot;Download All&quot;.</div><div class=\"line\"></div><div class=\"line\">6) Click on &quot;Done.&quot;</div><div class=\"line\"></div><div class=\"line\">7) Go in Xcode, build settings, select it. In General tab, the issues should get removed.</div><div class=\"line\"></div><div class=\"line\">8) Restart the Xcode.</div><div class=\"line\"></div><div class=\"line\">9) Do the Final build.</div><div class=\"line\"></div><div class=\"line\">That&apos;s all.</div></pre></td></tr></table></figure></p>\n<p>我是翻译：</p>\n<p>打开Xcode的preference，选择你的账号，点击账号下边的view detail。。然后选择你们的开发证书 reset按钮，之后下载全部的描述文件，点击done按钮。重启和编译Xcode之后，这个问题应该没有了。</p>\n<p>————————————–邪恶的分割线———————————————-</p>\n<p>这是我对于这个问题的一些总结，希望可以帮到一些人，不懂的可以评论问我。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于证书过期还有描述文件不匹配的问题见解：</p>\n<h2 id=\"平时问题下列步骤都能解决\"><a href=\"#平时问题下列步骤都能解决\" class=\"headerlink\" title=\"平时问题下列步骤都能解决\"></a>平时问题下列步骤都能解决</h2><p>大牛（ps英语好的）<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html\" target=\"_blank\" rel=\"external\">请去苹果开发文档中心</a><br>证书过期一般都是先去开发者中心重新创建证书，不过现在的证书过期之后直接被官方删除了，倒是省事了。创建证书不懂的可以自行百度。<br>删除配置文件【删除哪些？】那些有关过期证书的描述文件都删了<br>重新生成配置文件【ps怎么生成？ 去这里】<br>删除Xcode【我用的7.2】本地的描述文件【ps怎么删？去哪里删？】<br>去目录 <code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>文件夹下边删除所有的描述文件<br>然后 下载刚才新生成的描述文件，然后双击下载好的描述文件装到电脑和资料库———————————看到这里如果还不行的话，看我放大招——————–</p>\n<h2 id=\"假如你用的是Xcode-7-2的话\"><a href=\"#假如你用的是Xcode-7-2的话\" class=\"headerlink\" title=\"假如你用的是Xcode 7.2的话\"></a>假如你用的是Xcode 7.2的话</h2><p>大牛<a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Troubleshooting/Troubleshooting.html\" target=\"_blank\" rel=\"external\">是去这里</a><br>上面的步骤你测试了都不行，然后给你大招解决问题去app工程文件用编辑器打开搜索关键字<code>PROVISIONING_PROFILE</code>、<code>command</code> +<code>F</code> 搜搜有关这关键字的都删除了，然后重启Xcode，重新编译即可</p>\n<h2 id=\"问题还没解决怎么办？\"><a href=\"#问题还没解决怎么办？\" class=\"headerlink\" title=\"问题还没解决怎么办？\"></a>问题还没解决怎么办？</h2><p>看看国际友人怎么处理的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">I&apos;ve also the same problem, in Xcode 7.2</div><div class=\"line\"></div><div class=\"line\">It solved by followings steps: 1) Open Xcode preference, 2) Select the appropriate team, 3) Click the &quot;View Details..&quot;. 4) In section &quot;Signing Identities&quot;: click on &quot;Reset&quot; for each of them.</div><div class=\"line\"></div><div class=\"line\">5) In section &quot;Provisioning Profiles&quot;. Click on &quot;Download All&quot;.</div><div class=\"line\"></div><div class=\"line\">6) Click on &quot;Done.&quot;</div><div class=\"line\"></div><div class=\"line\">7) Go in Xcode, build settings, select it. In General tab, the issues should get removed.</div><div class=\"line\"></div><div class=\"line\">8) Restart the Xcode.</div><div class=\"line\"></div><div class=\"line\">9) Do the Final build.</div><div class=\"line\"></div><div class=\"line\">That&apos;s all.</div></pre></td></tr></table></figure></p>\n<p>我是翻译：</p>\n<p>打开Xcode的preference，选择你的账号，点击账号下边的view detail。。然后选择你们的开发证书 reset按钮，之后下载全部的描述文件，点击done按钮。重启和编译Xcode之后，这个问题应该没有了。</p>\n<p>————————————–邪恶的分割线———————————————-</p>\n<p>这是我对于这个问题的一些总结，希望可以帮到一些人，不懂的可以评论问我。</p>\n"},{"title":"iOS高级开发runtime那点事实战（1）","date":"2016-03-24T02:36:14.000Z","_content":"\n## runtime 给类别添加属性浅析\n很多时候因为需求想着给一个类添加属性，就是给一个类添加成员变量了，这样子方便了用这个类的时候，有了自己添加的属性，做什么事都是 信手捏来了。\n## 源码\n```\n \n\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h> //千万别忘记添加哦\n@interfaceNSObject(FY)\n@property(nonatomic,copy)NSString* name;//像平时一样的添加属性\n@end\n```\n下面是在.m中实现的\n```\nstaticvoid* FYKeyName = (void*)\"FYKeyName\";//声明这个变量要存储的key的名字\n@implementationNSObject(FY)\n- (void)setName:(NSString*)name{\nobjc_setAssociatedObject(self, FYKeyName, name, OBJC_ASSOCIATION_COPY);//把这个值存储起来类型是copy，值是name，存储的键值是\"FYKeyName\",存储到self的属性里面\n}\n- (NSString*)name{\nreturnobjc_getAssociatedObject(self, FYKeyName);//获取self的key为FYKeyName的值\n}\n@end\n```\n到此为止这个属性已经添加完成了。\n其实为毛添加属性啊，我们公司的按钮不能连续点击，是所有按钮。。。没错是all not some。我问Google大神了，搜到了消息是runtime解决问题，但是没找到如何解决。在我努力寻找。。。。一万字。。\n终于知道runtime是运行时，什么是运行时呢？就是我们写的OC代码会让runtime翻译并且执行，runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。\n在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者。\n所以给类添加属性就派上用场了，我解决思路是这样子的，给按钮添加类别就是点击事件间隔，执行点击事件的时候判断一下是否时间到了，如果时间不到，那么拦截点击事件。\n怎么拦截点击事件呢？\n其实点击事件在runtime里面是obj发送消息，我们可以把要发送的消息的SEL 和自己写的SEL交换一下，然后在自己写的SEL里面判断是否执行点击事件。【有点绕】\n代码：\n```\n#import\n#import\n@interfaceUIControl(FY)\n@property(nonatomic,assign)NSTimeIntervalacceptEventInterval;\n@property(nonatomic)BOOLignoreEvent;\n@end\n@implementationUIControl(FYControl)\nstaticconstchar*UIControl_acceptEventInterval=\"UIControl_acceptEventInterval\";\nstaticconstchar*UIControl_ignoreEvent=\"UIControl_ignoreEvent\";\n@end\n@implementationUIControl(FY)\n- (void)setAcceptEventInterval:(NSTimeInterval)acceptEventInterval\n{\nobjc_setAssociatedObject(self,UIControl_acceptEventInterval, @(acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n-(NSTimeInterval)acceptEventInterval {\nreturn[objc_getAssociatedObject(self,UIControl_acceptEventInterval) doubleValue];\n}\n-(void)setIgnoreEvent:(BOOL)ignoreEvent{\nobjc_setAssociatedObject(self,UIControl_ignoreEvent, @(ignoreEvent), OBJC_ASSOCIATION_ASSIGN);\n}\n-(BOOL)ignoreEvent{\nreturn[objc_getAssociatedObject(self,UIControl_ignoreEvent) boolValue];\n}\n+(void)load {\nMethod a = class_getInstanceMethod(self,@selector(sendAction:to:forEvent:));\nMethod b = class_getInstanceMethod(self,@selector(_sendAction:to:forEvent:));\nmethod_exchangeImplementations(a, b);//交换方法\n}\n- (void)_sendAction:(SEL)action to:(id)target forEvent:(UIEvent*)event\n{\nif(self.ignoreEvent)return;\nif(self.acceptEventInterval>0)\n{\nself.ignoreEvent=YES;\n[selfperformSelector:@selector(setIgnoreEventWithNo)  withObject:nilafterDelay:self.acceptEventInterval];\n}\n[self_sendAction:action to:target forEvent:event];\n}\n-(void)setIgnoreEventWithNo{\nself.ignoreEvent=NO;\n}\n@end\n```\n用的时候很好用的\n\n```\n-(void)click{\nbtn =[[UIButton alloc]initWithFrame:CGRectMake(100,100,100,40)];\n[btnsetTitle:@\"btn\"forState:UIControlStateNormal];\n[btnsetTitleColor:[UIColor redColor]forState:UIControlStateNormal];\nbtn.touchTimeValue =3;\n[self.viewaddSubview:btn];\n[btnaddTarget:selfaction:@selector(objcName)forControlEvents:UIControlEventTouchUpInside];\n}\n\n\n输出：2016-03-1713:14:20.365runTimeObj[9297:2669428] 测试\n2016-03-1713:14:23.717runTimeObj[9297:2669428] 测试\n2016-03-1713:14:26.876runTimeObj[9297:2669428] 测试\n```\n这个例子是利用了两个参数，一个参数Bool判断是否往下执行，一个时间用来修改Bool的值，最后就是执行方法b。有些同学纳闷，这执行方法b，不是执行自身方法吗？难道不是递归？其实不是，在load函数里面已经把a，b方法交换了。\n这样子就可以操作一些系统方法了。后续还会出runtime在项目中的实际应用。\n","source":"_posts/iOS高级开发runtime那点事实战（1）.md","raw":"title: iOS高级开发runtime那点事实战（1）\ndate: 2016-03-24 10:36:14\ntags:\n- iOS\n- iOS高级开发\ncategories: iOS\n---\n\n## runtime 给类别添加属性浅析\n很多时候因为需求想着给一个类添加属性，就是给一个类添加成员变量了，这样子方便了用这个类的时候，有了自己添加的属性，做什么事都是 信手捏来了。\n## 源码\n```\n \n\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h> //千万别忘记添加哦\n@interfaceNSObject(FY)\n@property(nonatomic,copy)NSString* name;//像平时一样的添加属性\n@end\n```\n下面是在.m中实现的\n```\nstaticvoid* FYKeyName = (void*)\"FYKeyName\";//声明这个变量要存储的key的名字\n@implementationNSObject(FY)\n- (void)setName:(NSString*)name{\nobjc_setAssociatedObject(self, FYKeyName, name, OBJC_ASSOCIATION_COPY);//把这个值存储起来类型是copy，值是name，存储的键值是\"FYKeyName\",存储到self的属性里面\n}\n- (NSString*)name{\nreturnobjc_getAssociatedObject(self, FYKeyName);//获取self的key为FYKeyName的值\n}\n@end\n```\n到此为止这个属性已经添加完成了。\n其实为毛添加属性啊，我们公司的按钮不能连续点击，是所有按钮。。。没错是all not some。我问Google大神了，搜到了消息是runtime解决问题，但是没找到如何解决。在我努力寻找。。。。一万字。。\n终于知道runtime是运行时，什么是运行时呢？就是我们写的OC代码会让runtime翻译并且执行，runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。\n在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者。\n所以给类添加属性就派上用场了，我解决思路是这样子的，给按钮添加类别就是点击事件间隔，执行点击事件的时候判断一下是否时间到了，如果时间不到，那么拦截点击事件。\n怎么拦截点击事件呢？\n其实点击事件在runtime里面是obj发送消息，我们可以把要发送的消息的SEL 和自己写的SEL交换一下，然后在自己写的SEL里面判断是否执行点击事件。【有点绕】\n代码：\n```\n#import\n#import\n@interfaceUIControl(FY)\n@property(nonatomic,assign)NSTimeIntervalacceptEventInterval;\n@property(nonatomic)BOOLignoreEvent;\n@end\n@implementationUIControl(FYControl)\nstaticconstchar*UIControl_acceptEventInterval=\"UIControl_acceptEventInterval\";\nstaticconstchar*UIControl_ignoreEvent=\"UIControl_ignoreEvent\";\n@end\n@implementationUIControl(FY)\n- (void)setAcceptEventInterval:(NSTimeInterval)acceptEventInterval\n{\nobjc_setAssociatedObject(self,UIControl_acceptEventInterval, @(acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n-(NSTimeInterval)acceptEventInterval {\nreturn[objc_getAssociatedObject(self,UIControl_acceptEventInterval) doubleValue];\n}\n-(void)setIgnoreEvent:(BOOL)ignoreEvent{\nobjc_setAssociatedObject(self,UIControl_ignoreEvent, @(ignoreEvent), OBJC_ASSOCIATION_ASSIGN);\n}\n-(BOOL)ignoreEvent{\nreturn[objc_getAssociatedObject(self,UIControl_ignoreEvent) boolValue];\n}\n+(void)load {\nMethod a = class_getInstanceMethod(self,@selector(sendAction:to:forEvent:));\nMethod b = class_getInstanceMethod(self,@selector(_sendAction:to:forEvent:));\nmethod_exchangeImplementations(a, b);//交换方法\n}\n- (void)_sendAction:(SEL)action to:(id)target forEvent:(UIEvent*)event\n{\nif(self.ignoreEvent)return;\nif(self.acceptEventInterval>0)\n{\nself.ignoreEvent=YES;\n[selfperformSelector:@selector(setIgnoreEventWithNo)  withObject:nilafterDelay:self.acceptEventInterval];\n}\n[self_sendAction:action to:target forEvent:event];\n}\n-(void)setIgnoreEventWithNo{\nself.ignoreEvent=NO;\n}\n@end\n```\n用的时候很好用的\n\n```\n-(void)click{\nbtn =[[UIButton alloc]initWithFrame:CGRectMake(100,100,100,40)];\n[btnsetTitle:@\"btn\"forState:UIControlStateNormal];\n[btnsetTitleColor:[UIColor redColor]forState:UIControlStateNormal];\nbtn.touchTimeValue =3;\n[self.viewaddSubview:btn];\n[btnaddTarget:selfaction:@selector(objcName)forControlEvents:UIControlEventTouchUpInside];\n}\n\n\n输出：2016-03-1713:14:20.365runTimeObj[9297:2669428] 测试\n2016-03-1713:14:23.717runTimeObj[9297:2669428] 测试\n2016-03-1713:14:26.876runTimeObj[9297:2669428] 测试\n```\n这个例子是利用了两个参数，一个参数Bool判断是否往下执行，一个时间用来修改Bool的值，最后就是执行方法b。有些同学纳闷，这执行方法b，不是执行自身方法吗？难道不是递归？其实不是，在load函数里面已经把a，b方法交换了。\n这样子就可以操作一些系统方法了。后续还会出runtime在项目中的实际应用。\n","slug":"iOS高级开发runtime那点事实战（1）","published":1,"updated":"2019-12-03T04:48:00.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi6w00109zskumbbvg27","content":"<h2 id=\"runtime-给类别添加属性浅析\"><a href=\"#runtime-给类别添加属性浅析\" class=\"headerlink\" title=\"runtime 给类别添加属性浅析\"></a>runtime 给类别添加属性浅析</h2><p>很多时候因为需求想着给一个类添加属性，就是给一个类添加成员变量了，这样子方便了用这个类的时候，有了自己添加的属性，做什么事都是 信手捏来了。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">#import &lt;objc/runtime.h&gt; //千万别忘记添加哦</div><div class=\"line\">@interfaceNSObject(FY)</div><div class=\"line\">@property(nonatomic,copy)NSString* name;//像平时一样的添加属性</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>下面是在.m中实现的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">staticvoid* FYKeyName = (void*)&quot;FYKeyName&quot;;//声明这个变量要存储的key的名字</div><div class=\"line\">@implementationNSObject(FY)</div><div class=\"line\">- (void)setName:(NSString*)name&#123;</div><div class=\"line\">objc_setAssociatedObject(self, FYKeyName, name, OBJC_ASSOCIATION_COPY);//把这个值存储起来类型是copy，值是name，存储的键值是&quot;FYKeyName&quot;,存储到self的属性里面</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString*)name&#123;</div><div class=\"line\">returnobjc_getAssociatedObject(self, FYKeyName);//获取self的key为FYKeyName的值</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>到此为止这个属性已经添加完成了。<br>其实为毛添加属性啊，我们公司的按钮不能连续点击，是所有按钮。。。没错是all not some。我问Google大神了，搜到了消息是runtime解决问题，但是没找到如何解决。在我努力寻找。。。。一万字。。<br>终于知道runtime是运行时，什么是运行时呢？就是我们写的OC代码会让runtime翻译并且执行，runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。<br>在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者。<br>所以给类添加属性就派上用场了，我解决思路是这样子的，给按钮添加类别就是点击事件间隔，执行点击事件的时候判断一下是否时间到了，如果时间不到，那么拦截点击事件。<br>怎么拦截点击事件呢？<br>其实点击事件在runtime里面是obj发送消息，我们可以把要发送的消息的SEL 和自己写的SEL交换一下，然后在自己写的SEL里面判断是否执行点击事件。【有点绕】<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import</div><div class=\"line\">#import</div><div class=\"line\">@interfaceUIControl(FY)</div><div class=\"line\">@property(nonatomic,assign)NSTimeIntervalacceptEventInterval;</div><div class=\"line\">@property(nonatomic)BOOLignoreEvent;</div><div class=\"line\">@end</div><div class=\"line\">@implementationUIControl(FYControl)</div><div class=\"line\">staticconstchar*UIControl_acceptEventInterval=&quot;UIControl_acceptEventInterval&quot;;</div><div class=\"line\">staticconstchar*UIControl_ignoreEvent=&quot;UIControl_ignoreEvent&quot;;</div><div class=\"line\">@end</div><div class=\"line\">@implementationUIControl(FY)</div><div class=\"line\">- (void)setAcceptEventInterval:(NSTimeInterval)acceptEventInterval</div><div class=\"line\">&#123;</div><div class=\"line\">objc_setAssociatedObject(self,UIControl_acceptEventInterval, @(acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSTimeInterval)acceptEventInterval &#123;</div><div class=\"line\">return[objc_getAssociatedObject(self,UIControl_acceptEventInterval) doubleValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setIgnoreEvent:(BOOL)ignoreEvent&#123;</div><div class=\"line\">objc_setAssociatedObject(self,UIControl_ignoreEvent, @(ignoreEvent), OBJC_ASSOCIATION_ASSIGN);</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)ignoreEvent&#123;</div><div class=\"line\">return[objc_getAssociatedObject(self,UIControl_ignoreEvent) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load &#123;</div><div class=\"line\">Method a = class_getInstanceMethod(self,@selector(sendAction:to:forEvent:));</div><div class=\"line\">Method b = class_getInstanceMethod(self,@selector(_sendAction:to:forEvent:));</div><div class=\"line\">method_exchangeImplementations(a, b);//交换方法</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)_sendAction:(SEL)action to:(id)target forEvent:(UIEvent*)event</div><div class=\"line\">&#123;</div><div class=\"line\">if(self.ignoreEvent)return;</div><div class=\"line\">if(self.acceptEventInterval&gt;0)</div><div class=\"line\">&#123;</div><div class=\"line\">self.ignoreEvent=YES;</div><div class=\"line\">[selfperformSelector:@selector(setIgnoreEventWithNo)  withObject:nilafterDelay:self.acceptEventInterval];</div><div class=\"line\">&#125;</div><div class=\"line\">[self_sendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setIgnoreEventWithNo&#123;</div><div class=\"line\">self.ignoreEvent=NO;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>用的时候很好用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)click&#123;</div><div class=\"line\">btn =[[UIButton alloc]initWithFrame:CGRectMake(100,100,100,40)];</div><div class=\"line\">[btnsetTitle:@&quot;btn&quot;forState:UIControlStateNormal];</div><div class=\"line\">[btnsetTitleColor:[UIColor redColor]forState:UIControlStateNormal];</div><div class=\"line\">btn.touchTimeValue =3;</div><div class=\"line\">[self.viewaddSubview:btn];</div><div class=\"line\">[btnaddTarget:selfaction:@selector(objcName)forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">输出：2016-03-1713:14:20.365runTimeObj[9297:2669428] 测试</div><div class=\"line\">2016-03-1713:14:23.717runTimeObj[9297:2669428] 测试</div><div class=\"line\">2016-03-1713:14:26.876runTimeObj[9297:2669428] 测试</div></pre></td></tr></table></figure>\n<p>这个例子是利用了两个参数，一个参数Bool判断是否往下执行，一个时间用来修改Bool的值，最后就是执行方法b。有些同学纳闷，这执行方法b，不是执行自身方法吗？难道不是递归？其实不是，在load函数里面已经把a，b方法交换了。<br>这样子就可以操作一些系统方法了。后续还会出runtime在项目中的实际应用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"runtime-给类别添加属性浅析\"><a href=\"#runtime-给类别添加属性浅析\" class=\"headerlink\" title=\"runtime 给类别添加属性浅析\"></a>runtime 给类别添加属性浅析</h2><p>很多时候因为需求想着给一个类添加属性，就是给一个类添加成员变量了，这样子方便了用这个类的时候，有了自己添加的属性，做什么事都是 信手捏来了。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">#import &lt;objc/runtime.h&gt; //千万别忘记添加哦</div><div class=\"line\">@interfaceNSObject(FY)</div><div class=\"line\">@property(nonatomic,copy)NSString* name;//像平时一样的添加属性</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>下面是在.m中实现的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">staticvoid* FYKeyName = (void*)&quot;FYKeyName&quot;;//声明这个变量要存储的key的名字</div><div class=\"line\">@implementationNSObject(FY)</div><div class=\"line\">- (void)setName:(NSString*)name&#123;</div><div class=\"line\">objc_setAssociatedObject(self, FYKeyName, name, OBJC_ASSOCIATION_COPY);//把这个值存储起来类型是copy，值是name，存储的键值是&quot;FYKeyName&quot;,存储到self的属性里面</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSString*)name&#123;</div><div class=\"line\">returnobjc_getAssociatedObject(self, FYKeyName);//获取self的key为FYKeyName的值</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>到此为止这个属性已经添加完成了。<br>其实为毛添加属性啊，我们公司的按钮不能连续点击，是所有按钮。。。没错是all not some。我问Google大神了，搜到了消息是runtime解决问题，但是没找到如何解决。在我努力寻找。。。。一万字。。<br>终于知道runtime是运行时，什么是运行时呢？就是我们写的OC代码会让runtime翻译并且执行，runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。<br>在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者。<br>所以给类添加属性就派上用场了，我解决思路是这样子的，给按钮添加类别就是点击事件间隔，执行点击事件的时候判断一下是否时间到了，如果时间不到，那么拦截点击事件。<br>怎么拦截点击事件呢？<br>其实点击事件在runtime里面是obj发送消息，我们可以把要发送的消息的SEL 和自己写的SEL交换一下，然后在自己写的SEL里面判断是否执行点击事件。【有点绕】<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import</div><div class=\"line\">#import</div><div class=\"line\">@interfaceUIControl(FY)</div><div class=\"line\">@property(nonatomic,assign)NSTimeIntervalacceptEventInterval;</div><div class=\"line\">@property(nonatomic)BOOLignoreEvent;</div><div class=\"line\">@end</div><div class=\"line\">@implementationUIControl(FYControl)</div><div class=\"line\">staticconstchar*UIControl_acceptEventInterval=&quot;UIControl_acceptEventInterval&quot;;</div><div class=\"line\">staticconstchar*UIControl_ignoreEvent=&quot;UIControl_ignoreEvent&quot;;</div><div class=\"line\">@end</div><div class=\"line\">@implementationUIControl(FY)</div><div class=\"line\">- (void)setAcceptEventInterval:(NSTimeInterval)acceptEventInterval</div><div class=\"line\">&#123;</div><div class=\"line\">objc_setAssociatedObject(self,UIControl_acceptEventInterval, @(acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">-(NSTimeInterval)acceptEventInterval &#123;</div><div class=\"line\">return[objc_getAssociatedObject(self,UIControl_acceptEventInterval) doubleValue];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setIgnoreEvent:(BOOL)ignoreEvent&#123;</div><div class=\"line\">objc_setAssociatedObject(self,UIControl_ignoreEvent, @(ignoreEvent), OBJC_ASSOCIATION_ASSIGN);</div><div class=\"line\">&#125;</div><div class=\"line\">-(BOOL)ignoreEvent&#123;</div><div class=\"line\">return[objc_getAssociatedObject(self,UIControl_ignoreEvent) boolValue];</div><div class=\"line\">&#125;</div><div class=\"line\">+(void)load &#123;</div><div class=\"line\">Method a = class_getInstanceMethod(self,@selector(sendAction:to:forEvent:));</div><div class=\"line\">Method b = class_getInstanceMethod(self,@selector(_sendAction:to:forEvent:));</div><div class=\"line\">method_exchangeImplementations(a, b);//交换方法</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)_sendAction:(SEL)action to:(id)target forEvent:(UIEvent*)event</div><div class=\"line\">&#123;</div><div class=\"line\">if(self.ignoreEvent)return;</div><div class=\"line\">if(self.acceptEventInterval&gt;0)</div><div class=\"line\">&#123;</div><div class=\"line\">self.ignoreEvent=YES;</div><div class=\"line\">[selfperformSelector:@selector(setIgnoreEventWithNo)  withObject:nilafterDelay:self.acceptEventInterval];</div><div class=\"line\">&#125;</div><div class=\"line\">[self_sendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)setIgnoreEventWithNo&#123;</div><div class=\"line\">self.ignoreEvent=NO;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>用的时候很好用的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)click&#123;</div><div class=\"line\">btn =[[UIButton alloc]initWithFrame:CGRectMake(100,100,100,40)];</div><div class=\"line\">[btnsetTitle:@&quot;btn&quot;forState:UIControlStateNormal];</div><div class=\"line\">[btnsetTitleColor:[UIColor redColor]forState:UIControlStateNormal];</div><div class=\"line\">btn.touchTimeValue =3;</div><div class=\"line\">[self.viewaddSubview:btn];</div><div class=\"line\">[btnaddTarget:selfaction:@selector(objcName)forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">输出：2016-03-1713:14:20.365runTimeObj[9297:2669428] 测试</div><div class=\"line\">2016-03-1713:14:23.717runTimeObj[9297:2669428] 测试</div><div class=\"line\">2016-03-1713:14:26.876runTimeObj[9297:2669428] 测试</div></pre></td></tr></table></figure>\n<p>这个例子是利用了两个参数，一个参数Bool判断是否往下执行，一个时间用来修改Bool的值，最后就是执行方法b。有些同学纳闷，这执行方法b，不是执行自身方法吗？难道不是递归？其实不是，在load函数里面已经把a，b方法交换了。<br>这样子就可以操作一些系统方法了。后续还会出runtime在项目中的实际应用。</p>\n"},{"title":"iOS高级开发runtime那点事实战（2）","date":"2016-03-24T03:01:56.000Z","_content":"### 获取class的property属性List\n```\n-(void)printPropertyList{\n    unsigned int count ;//存储属性的数量的\n    objc_property_t * methodsVar = class_copyPropertyList([UINavigationController class], &count) ;\n    for (int i = 0; i < count; i ++) {\n        objc_property_t var = methodsVar[i] ;\n        NSString * strName =[NSString stringWithUTF8String:property_getName(var)];\n        NSString * str =[NSString stringWithUTF8String:property_getAttributes(var)];\n        NSLog(@\"属性 %@   名字  %@\",str,strName);\n    }\n    free(methodsVar);\n}\n```\n### 获取class的的名字\n```\n-(void)printfClassName{\n    Class clas = NSClassFromString(@\"NSString\");\n   printf(\"%s\", class_getName(clas)); //当clas为空的话 return value 是nil\n}\n\n输出：NSString\n```\n### 获取类的父类并输出\n```\n-(void)printfClassName:(Class )clas{\n   printf(\"%s\", class_getName(clas));\n}\n-(Class)getSuperClass:(Class)clas{\n    return class_getSuperclass(clas);\n}\n\n[self printfClassName:[self getSuperClass:NSClassFromString(@\"UIView\")]];\n输出：UIResponder\n```\n### 设置类的父类\n```\n/** \n * Sets the superclass of a given class.\n * \n * @param cls The class whose superclass you want to set.\n * @param newSuper The new superclass for cls.\n * \n * @return The old superclass for cls.\n * \n * @warning You should not use this function. 警告不要用\n */\nOBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper) \n     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);\n     \n    [self printfClassName:[self getSuperClass:NSClassFromString(@\"FY\")]];第一次输出NSObjec\n    [self setClass:NSClassFromString(@\"FY\") newSuperClass:NSClassFromString(@\"UIImageView\")];//设置新的父类\n    [self printfClassName:[self getSuperClass:NSClassFromString(@\"FY\")]];//再次输出是UIImageView 说明设置新的父类是可用的\n    \n\n-(void)printfClassName:(Class )clas{\n   printf(\"%s\\n\", class_getName(clas));\n}\n-(Class)getSuperClass:(Class)clas{\n    return class_getSuperclass(clas);\n}\n-(Class)setClass:(Class)clas newSuperClass:(Class)superClas{\n   return   class_setSuperclass(clas, superClas);\n}\n\n```\n### 对象和类的区分\n```\n-(void)isMetaClass{\n    NSMutableArray *arr = [[NSMutableArray alloc] init];\n    \n    [arr addObject:[NSObject class]];\n    [arr addObject:[NSValue class]];\n    [arr addObject:[NSNumber class]];\n    [arr addObject:[NSPredicate class]];\n    [arr addObject:@\"not a class object\"];\n    \n    for (int i; i<[arr count]; i++) {\n        id obj = [arr objectAtIndex:i];\n        \n        if(class_isMetaClass(object_getClass(obj)))\n        {\n            //do sth\n            NSLog(@\"Class: %@\", obj);\n        }\n        else\n        {\n            NSLog(@\"Instance: %@\", obj);\n        }\n    }\n}\n输出：2016-03-18 15:46:56.235 runTimeObj[18396:2997316] Class: NSObject\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSValue\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSNumber\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSPredicate\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Instance: not a class object\n```\n### 获得类所占字节的大小\n```\nsize_t size = class_getInstanceSize(NSClassFromString(@\"UIView\"));\n    printf(\"%zu\",size);\n```\n### 获得类的属性及其属性的类型\n```\n-(void)ivarList{\n    unsigned int count;\n    Ivar * vars = class_copyIvarList(NSClassFromString(@\"UIViewController\"), &count)//ivar 是结构体 包含 name,offset,type三个可读属性的结构体。\n    ;\n    for (int i = 0; i < count; i ++) {\n        Ivar  var = vars[i];\n        [self printIvar:var];\n    }\n    free(vars);\n}\n-(void)printIvar:(Ivar)var{//输出结构体\n    const  char * name = ivar_getName(var);\n    long  offset = ivar_getOffset(var);\n    const  char * type = ivar_getTypeEncoding(var);\n    printf(\"%s %ld %s\\n\",name,offset,type);\n}\n输出：\n_storyboard 152 @\"UIStoryboard\"\n_externalObjectsTableForViewLoading 160 @\"NSDictionary\"\n_topLevelObjectsToKeepAliveFromStoryboard 168 @\"NSArray\"\n_savedHeaderSuperview 176 @\"UIView\"\n_savedFooterSuperview 184 @\"UIView\"\n\n```\n这些是apple [Objectice-C Runtime Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/objc_msgSend),具体的更多的在这个网址可见。\n\n上一篇说了一个方法 名字是`void method_exchangeImplementations(Method m1, Method m2)`\n因为这个交换方法只能执行一次，所以解决了交换两次，就相当于没有交换了。具体代码：\n```\nstatic dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        void (^__method_swizzling)(Class, SEL, SEL) = ^(Class cls, SEL sel, SEL _sel) {\n            Method  method = class_getInstanceMethod(cls, sel);\n            Method _method = class_getInstanceMethod(cls, _sel);\n            method_exchangeImplementations(method, _method);\n        };\n      }\n``` \n在这里是把这个方法封装了一个c函数，保证了只会执行一次，最好把这个`dispatch`放在`+ load`函数里面，保证加载次数的减少。\n更多博客在www.fgyong.cn可见。\n","source":"_posts/iOS高级开发runtime那点事实战（2）.md","raw":"title: iOS高级开发runtime那点事实战（2）\ndate: 2016-03-24 11:01:56\ntags:\n- iOS\n- iOS高级开发\ncategories: iOS\n---\n### 获取class的property属性List\n```\n-(void)printPropertyList{\n    unsigned int count ;//存储属性的数量的\n    objc_property_t * methodsVar = class_copyPropertyList([UINavigationController class], &count) ;\n    for (int i = 0; i < count; i ++) {\n        objc_property_t var = methodsVar[i] ;\n        NSString * strName =[NSString stringWithUTF8String:property_getName(var)];\n        NSString * str =[NSString stringWithUTF8String:property_getAttributes(var)];\n        NSLog(@\"属性 %@   名字  %@\",str,strName);\n    }\n    free(methodsVar);\n}\n```\n### 获取class的的名字\n```\n-(void)printfClassName{\n    Class clas = NSClassFromString(@\"NSString\");\n   printf(\"%s\", class_getName(clas)); //当clas为空的话 return value 是nil\n}\n\n输出：NSString\n```\n### 获取类的父类并输出\n```\n-(void)printfClassName:(Class )clas{\n   printf(\"%s\", class_getName(clas));\n}\n-(Class)getSuperClass:(Class)clas{\n    return class_getSuperclass(clas);\n}\n\n[self printfClassName:[self getSuperClass:NSClassFromString(@\"UIView\")]];\n输出：UIResponder\n```\n### 设置类的父类\n```\n/** \n * Sets the superclass of a given class.\n * \n * @param cls The class whose superclass you want to set.\n * @param newSuper The new superclass for cls.\n * \n * @return The old superclass for cls.\n * \n * @warning You should not use this function. 警告不要用\n */\nOBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper) \n     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);\n     \n    [self printfClassName:[self getSuperClass:NSClassFromString(@\"FY\")]];第一次输出NSObjec\n    [self setClass:NSClassFromString(@\"FY\") newSuperClass:NSClassFromString(@\"UIImageView\")];//设置新的父类\n    [self printfClassName:[self getSuperClass:NSClassFromString(@\"FY\")]];//再次输出是UIImageView 说明设置新的父类是可用的\n    \n\n-(void)printfClassName:(Class )clas{\n   printf(\"%s\\n\", class_getName(clas));\n}\n-(Class)getSuperClass:(Class)clas{\n    return class_getSuperclass(clas);\n}\n-(Class)setClass:(Class)clas newSuperClass:(Class)superClas{\n   return   class_setSuperclass(clas, superClas);\n}\n\n```\n### 对象和类的区分\n```\n-(void)isMetaClass{\n    NSMutableArray *arr = [[NSMutableArray alloc] init];\n    \n    [arr addObject:[NSObject class]];\n    [arr addObject:[NSValue class]];\n    [arr addObject:[NSNumber class]];\n    [arr addObject:[NSPredicate class]];\n    [arr addObject:@\"not a class object\"];\n    \n    for (int i; i<[arr count]; i++) {\n        id obj = [arr objectAtIndex:i];\n        \n        if(class_isMetaClass(object_getClass(obj)))\n        {\n            //do sth\n            NSLog(@\"Class: %@\", obj);\n        }\n        else\n        {\n            NSLog(@\"Instance: %@\", obj);\n        }\n    }\n}\n输出：2016-03-18 15:46:56.235 runTimeObj[18396:2997316] Class: NSObject\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSValue\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSNumber\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSPredicate\n2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Instance: not a class object\n```\n### 获得类所占字节的大小\n```\nsize_t size = class_getInstanceSize(NSClassFromString(@\"UIView\"));\n    printf(\"%zu\",size);\n```\n### 获得类的属性及其属性的类型\n```\n-(void)ivarList{\n    unsigned int count;\n    Ivar * vars = class_copyIvarList(NSClassFromString(@\"UIViewController\"), &count)//ivar 是结构体 包含 name,offset,type三个可读属性的结构体。\n    ;\n    for (int i = 0; i < count; i ++) {\n        Ivar  var = vars[i];\n        [self printIvar:var];\n    }\n    free(vars);\n}\n-(void)printIvar:(Ivar)var{//输出结构体\n    const  char * name = ivar_getName(var);\n    long  offset = ivar_getOffset(var);\n    const  char * type = ivar_getTypeEncoding(var);\n    printf(\"%s %ld %s\\n\",name,offset,type);\n}\n输出：\n_storyboard 152 @\"UIStoryboard\"\n_externalObjectsTableForViewLoading 160 @\"NSDictionary\"\n_topLevelObjectsToKeepAliveFromStoryboard 168 @\"NSArray\"\n_savedHeaderSuperview 176 @\"UIView\"\n_savedFooterSuperview 184 @\"UIView\"\n\n```\n这些是apple [Objectice-C Runtime Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/objc_msgSend),具体的更多的在这个网址可见。\n\n上一篇说了一个方法 名字是`void method_exchangeImplementations(Method m1, Method m2)`\n因为这个交换方法只能执行一次，所以解决了交换两次，就相当于没有交换了。具体代码：\n```\nstatic dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        void (^__method_swizzling)(Class, SEL, SEL) = ^(Class cls, SEL sel, SEL _sel) {\n            Method  method = class_getInstanceMethod(cls, sel);\n            Method _method = class_getInstanceMethod(cls, _sel);\n            method_exchangeImplementations(method, _method);\n        };\n      }\n``` \n在这里是把这个方法封装了一个c函数，保证了只会执行一次，最好把这个`dispatch`放在`+ load`函数里面，保证加载次数的减少。\n更多博客在www.fgyong.cn可见。\n","slug":"iOS高级开发runtime那点事实战（2）","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi6y00129zskrq93b2mf","content":"<h3 id=\"获取class的property属性List\"><a href=\"#获取class的property属性List\" class=\"headerlink\" title=\"获取class的property属性List\"></a>获取class的property属性List</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printPropertyList&#123;</div><div class=\"line\">    unsigned int count ;//存储属性的数量的</div><div class=\"line\">    objc_property_t * methodsVar = class_copyPropertyList([UINavigationController class], &amp;count) ;</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        objc_property_t var = methodsVar[i] ;</div><div class=\"line\">        NSString * strName =[NSString stringWithUTF8String:property_getName(var)];</div><div class=\"line\">        NSString * str =[NSString stringWithUTF8String:property_getAttributes(var)];</div><div class=\"line\">        NSLog(@&quot;属性 %@   名字  %@&quot;,str,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(methodsVar);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"获取class的的名字\"><a href=\"#获取class的的名字\" class=\"headerlink\" title=\"获取class的的名字\"></a>获取class的的名字</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printfClassName&#123;</div><div class=\"line\">    Class clas = NSClassFromString(@&quot;NSString&quot;);</div><div class=\"line\">   printf(&quot;%s&quot;, class_getName(clas)); //当clas为空的话 return value 是nil</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输出：NSString</div></pre></td></tr></table></figure>\n<h3 id=\"获取类的父类并输出\"><a href=\"#获取类的父类并输出\" class=\"headerlink\" title=\"获取类的父类并输出\"></a>获取类的父类并输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printfClassName:(Class )clas&#123;</div><div class=\"line\">   printf(&quot;%s&quot;, class_getName(clas));</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)getSuperClass:(Class)clas&#123;</div><div class=\"line\">    return class_getSuperclass(clas);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self printfClassName:[self getSuperClass:NSClassFromString(@&quot;UIView&quot;)]];</div><div class=\"line\">输出：UIResponder</div></pre></td></tr></table></figure>\n<h3 id=\"设置类的父类\"><a href=\"#设置类的父类\" class=\"headerlink\" title=\"设置类的父类\"></a>设置类的父类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\"> * Sets the superclass of a given class.</div><div class=\"line\"> * </div><div class=\"line\"> * @param cls The class whose superclass you want to set.</div><div class=\"line\"> * @param newSuper The new superclass for cls.</div><div class=\"line\"> * </div><div class=\"line\"> * @return The old superclass for cls.</div><div class=\"line\"> * </div><div class=\"line\"> * @warning You should not use this function. 警告不要用</div><div class=\"line\"> */</div><div class=\"line\">OBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper) </div><div class=\"line\">     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);</div><div class=\"line\">     </div><div class=\"line\">    [self printfClassName:[self getSuperClass:NSClassFromString(@&quot;FY&quot;)]];第一次输出NSObjec</div><div class=\"line\">    [self setClass:NSClassFromString(@&quot;FY&quot;) newSuperClass:NSClassFromString(@&quot;UIImageView&quot;)];//设置新的父类</div><div class=\"line\">    [self printfClassName:[self getSuperClass:NSClassFromString(@&quot;FY&quot;)]];//再次输出是UIImageView 说明设置新的父类是可用的</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">-(void)printfClassName:(Class )clas&#123;</div><div class=\"line\">   printf(&quot;%s\\n&quot;, class_getName(clas));</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)getSuperClass:(Class)clas&#123;</div><div class=\"line\">    return class_getSuperclass(clas);</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)setClass:(Class)clas newSuperClass:(Class)superClas&#123;</div><div class=\"line\">   return   class_setSuperclass(clas, superClas);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和类的区分\"><a href=\"#对象和类的区分\" class=\"headerlink\" title=\"对象和类的区分\"></a>对象和类的区分</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)isMetaClass&#123;</div><div class=\"line\">    NSMutableArray *arr = [[NSMutableArray alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    [arr addObject:[NSObject class]];</div><div class=\"line\">    [arr addObject:[NSValue class]];</div><div class=\"line\">    [arr addObject:[NSNumber class]];</div><div class=\"line\">    [arr addObject:[NSPredicate class]];</div><div class=\"line\">    [arr addObject:@&quot;not a class object&quot;];</div><div class=\"line\">    </div><div class=\"line\">    for (int i; i&lt;[arr count]; i++) &#123;</div><div class=\"line\">        id obj = [arr objectAtIndex:i];</div><div class=\"line\">        </div><div class=\"line\">        if(class_isMetaClass(object_getClass(obj)))</div><div class=\"line\">        &#123;</div><div class=\"line\">            //do sth</div><div class=\"line\">            NSLog(@&quot;Class: %@&quot;, obj);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            NSLog(@&quot;Instance: %@&quot;, obj);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：2016-03-18 15:46:56.235 runTimeObj[18396:2997316] Class: NSObject</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSValue</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSNumber</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSPredicate</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Instance: not a class object</div></pre></td></tr></table></figure>\n<h3 id=\"获得类所占字节的大小\"><a href=\"#获得类所占字节的大小\" class=\"headerlink\" title=\"获得类所占字节的大小\"></a>获得类所占字节的大小</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">size_t size = class_getInstanceSize(NSClassFromString(@&quot;UIView&quot;));</div><div class=\"line\">    printf(&quot;%zu&quot;,size);</div></pre></td></tr></table></figure>\n<h3 id=\"获得类的属性及其属性的类型\"><a href=\"#获得类的属性及其属性的类型\" class=\"headerlink\" title=\"获得类的属性及其属性的类型\"></a>获得类的属性及其属性的类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)ivarList&#123;</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">    Ivar * vars = class_copyIvarList(NSClassFromString(@&quot;UIViewController&quot;), &amp;count)//ivar 是结构体 包含 name,offset,type三个可读属性的结构体。</div><div class=\"line\">    ;</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        Ivar  var = vars[i];</div><div class=\"line\">        [self printIvar:var];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)printIvar:(Ivar)var&#123;//输出结构体</div><div class=\"line\">    const  char * name = ivar_getName(var);</div><div class=\"line\">    long  offset = ivar_getOffset(var);</div><div class=\"line\">    const  char * type = ivar_getTypeEncoding(var);</div><div class=\"line\">    printf(&quot;%s %ld %s\\n&quot;,name,offset,type);</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">_storyboard 152 @&quot;UIStoryboard&quot;</div><div class=\"line\">_externalObjectsTableForViewLoading 160 @&quot;NSDictionary&quot;</div><div class=\"line\">_topLevelObjectsToKeepAliveFromStoryboard 168 @&quot;NSArray&quot;</div><div class=\"line\">_savedHeaderSuperview 176 @&quot;UIView&quot;</div><div class=\"line\">_savedFooterSuperview 184 @&quot;UIView&quot;</div></pre></td></tr></table></figure>\n<p>这些是apple <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/objc_msgSend\" target=\"_blank\" rel=\"external\">Objectice-C Runtime Reference</a>,具体的更多的在这个网址可见。</p>\n<p>上一篇说了一个方法 名字是<code>void method_exchangeImplementations(Method m1, Method m2)</code><br>因为这个交换方法只能执行一次，所以解决了交换两次，就相当于没有交换了。具体代码：</p>\n<pre><code>static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n\n        void (^__method_swizzling)(Class, SEL, SEL) = ^(Class cls, SEL sel, SEL _sel) {\n            Method  method = class_getInstanceMethod(cls, sel);\n            Method _method = class_getInstanceMethod(cls, _sel);\n            method_exchangeImplementations(method, _method);\n        };\n      }\n</code></pre><p>在这里是把这个方法封装了一个c函数，保证了只会执行一次，最好把这个<code>dispatch</code>放在<code>+ load</code>函数里面，保证加载次数的减少。<br>更多博客在www.fgyong.cn可见。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"获取class的property属性List\"><a href=\"#获取class的property属性List\" class=\"headerlink\" title=\"获取class的property属性List\"></a>获取class的property属性List</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printPropertyList&#123;</div><div class=\"line\">    unsigned int count ;//存储属性的数量的</div><div class=\"line\">    objc_property_t * methodsVar = class_copyPropertyList([UINavigationController class], &amp;count) ;</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        objc_property_t var = methodsVar[i] ;</div><div class=\"line\">        NSString * strName =[NSString stringWithUTF8String:property_getName(var)];</div><div class=\"line\">        NSString * str =[NSString stringWithUTF8String:property_getAttributes(var)];</div><div class=\"line\">        NSLog(@&quot;属性 %@   名字  %@&quot;,str,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(methodsVar);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"获取class的的名字\"><a href=\"#获取class的的名字\" class=\"headerlink\" title=\"获取class的的名字\"></a>获取class的的名字</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printfClassName&#123;</div><div class=\"line\">    Class clas = NSClassFromString(@&quot;NSString&quot;);</div><div class=\"line\">   printf(&quot;%s&quot;, class_getName(clas)); //当clas为空的话 return value 是nil</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输出：NSString</div></pre></td></tr></table></figure>\n<h3 id=\"获取类的父类并输出\"><a href=\"#获取类的父类并输出\" class=\"headerlink\" title=\"获取类的父类并输出\"></a>获取类的父类并输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)printfClassName:(Class )clas&#123;</div><div class=\"line\">   printf(&quot;%s&quot;, class_getName(clas));</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)getSuperClass:(Class)clas&#123;</div><div class=\"line\">    return class_getSuperclass(clas);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">[self printfClassName:[self getSuperClass:NSClassFromString(@&quot;UIView&quot;)]];</div><div class=\"line\">输出：UIResponder</div></pre></td></tr></table></figure>\n<h3 id=\"设置类的父类\"><a href=\"#设置类的父类\" class=\"headerlink\" title=\"设置类的父类\"></a>设置类的父类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\"> * Sets the superclass of a given class.</div><div class=\"line\"> * </div><div class=\"line\"> * @param cls The class whose superclass you want to set.</div><div class=\"line\"> * @param newSuper The new superclass for cls.</div><div class=\"line\"> * </div><div class=\"line\"> * @return The old superclass for cls.</div><div class=\"line\"> * </div><div class=\"line\"> * @warning You should not use this function. 警告不要用</div><div class=\"line\"> */</div><div class=\"line\">OBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper) </div><div class=\"line\">     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_5, __IPHONE_2_0,__IPHONE_2_0);</div><div class=\"line\">     </div><div class=\"line\">    [self printfClassName:[self getSuperClass:NSClassFromString(@&quot;FY&quot;)]];第一次输出NSObjec</div><div class=\"line\">    [self setClass:NSClassFromString(@&quot;FY&quot;) newSuperClass:NSClassFromString(@&quot;UIImageView&quot;)];//设置新的父类</div><div class=\"line\">    [self printfClassName:[self getSuperClass:NSClassFromString(@&quot;FY&quot;)]];//再次输出是UIImageView 说明设置新的父类是可用的</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">-(void)printfClassName:(Class )clas&#123;</div><div class=\"line\">   printf(&quot;%s\\n&quot;, class_getName(clas));</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)getSuperClass:(Class)clas&#123;</div><div class=\"line\">    return class_getSuperclass(clas);</div><div class=\"line\">&#125;</div><div class=\"line\">-(Class)setClass:(Class)clas newSuperClass:(Class)superClas&#123;</div><div class=\"line\">   return   class_setSuperclass(clas, superClas);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和类的区分\"><a href=\"#对象和类的区分\" class=\"headerlink\" title=\"对象和类的区分\"></a>对象和类的区分</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)isMetaClass&#123;</div><div class=\"line\">    NSMutableArray *arr = [[NSMutableArray alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    [arr addObject:[NSObject class]];</div><div class=\"line\">    [arr addObject:[NSValue class]];</div><div class=\"line\">    [arr addObject:[NSNumber class]];</div><div class=\"line\">    [arr addObject:[NSPredicate class]];</div><div class=\"line\">    [arr addObject:@&quot;not a class object&quot;];</div><div class=\"line\">    </div><div class=\"line\">    for (int i; i&lt;[arr count]; i++) &#123;</div><div class=\"line\">        id obj = [arr objectAtIndex:i];</div><div class=\"line\">        </div><div class=\"line\">        if(class_isMetaClass(object_getClass(obj)))</div><div class=\"line\">        &#123;</div><div class=\"line\">            //do sth</div><div class=\"line\">            NSLog(@&quot;Class: %@&quot;, obj);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">            NSLog(@&quot;Instance: %@&quot;, obj);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">输出：2016-03-18 15:46:56.235 runTimeObj[18396:2997316] Class: NSObject</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSValue</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSNumber</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Class: NSPredicate</div><div class=\"line\">2016-03-18 15:46:56.236 runTimeObj[18396:2997316] Instance: not a class object</div></pre></td></tr></table></figure>\n<h3 id=\"获得类所占字节的大小\"><a href=\"#获得类所占字节的大小\" class=\"headerlink\" title=\"获得类所占字节的大小\"></a>获得类所占字节的大小</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">size_t size = class_getInstanceSize(NSClassFromString(@&quot;UIView&quot;));</div><div class=\"line\">    printf(&quot;%zu&quot;,size);</div></pre></td></tr></table></figure>\n<h3 id=\"获得类的属性及其属性的类型\"><a href=\"#获得类的属性及其属性的类型\" class=\"headerlink\" title=\"获得类的属性及其属性的类型\"></a>获得类的属性及其属性的类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)ivarList&#123;</div><div class=\"line\">    unsigned int count;</div><div class=\"line\">    Ivar * vars = class_copyIvarList(NSClassFromString(@&quot;UIViewController&quot;), &amp;count)//ivar 是结构体 包含 name,offset,type三个可读属性的结构体。</div><div class=\"line\">    ;</div><div class=\"line\">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class=\"line\">        Ivar  var = vars[i];</div><div class=\"line\">        [self printIvar:var];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)printIvar:(Ivar)var&#123;//输出结构体</div><div class=\"line\">    const  char * name = ivar_getName(var);</div><div class=\"line\">    long  offset = ivar_getOffset(var);</div><div class=\"line\">    const  char * type = ivar_getTypeEncoding(var);</div><div class=\"line\">    printf(&quot;%s %ld %s\\n&quot;,name,offset,type);</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">_storyboard 152 @&quot;UIStoryboard&quot;</div><div class=\"line\">_externalObjectsTableForViewLoading 160 @&quot;NSDictionary&quot;</div><div class=\"line\">_topLevelObjectsToKeepAliveFromStoryboard 168 @&quot;NSArray&quot;</div><div class=\"line\">_savedHeaderSuperview 176 @&quot;UIView&quot;</div><div class=\"line\">_savedFooterSuperview 184 @&quot;UIView&quot;</div></pre></td></tr></table></figure>\n<p>这些是apple <a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/func/objc_msgSend\" target=\"_blank\" rel=\"external\">Objectice-C Runtime Reference</a>,具体的更多的在这个网址可见。</p>\n<p>上一篇说了一个方法 名字是<code>void method_exchangeImplementations(Method m1, Method m2)</code><br>因为这个交换方法只能执行一次，所以解决了交换两次，就相当于没有交换了。具体代码：</p>\n<pre><code>static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n\n        void (^__method_swizzling)(Class, SEL, SEL) = ^(Class cls, SEL sel, SEL _sel) {\n            Method  method = class_getInstanceMethod(cls, sel);\n            Method _method = class_getInstanceMethod(cls, _sel);\n            method_exchangeImplementations(method, _method);\n        };\n      }\n</code></pre><p>在这里是把这个方法封装了一个c函数，保证了只会执行一次，最好把这个<code>dispatch</code>放在<code>+ load</code>函数里面，保证加载次数的减少。<br>更多博客在www.fgyong.cn可见。</p>\n"},{"title":"iOS高级开发runtime那点事实战（3）","date":"2016-03-24T03:15:48.000Z","_content":"###  添加类\n```\nobjc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)\n添加类 superclass 类是父类   name 类的名字  size_t 类占的空间\n\nvoid objc_disposeClassPair(Class cls) 销毁类\n\n\nvoid objc_registerClassPair(Class cls) 注册类\n\n\nobjc_duplicateClass\n Used by Foundation's Key-Value Observing.官方说法是不让自己调用\nDo not call this function yourself. \n```\n具体代码：\n```\n- (void)allocClass{\n    Class clas = objc_allocateClassPair(NSClassFromString(@\"FY\"), \"FYss\", 0);\n   \n    objc_property_attribute_t type = {\"T\", \"@\\\"NSString\\\"\"};\n    objc_property_attribute_t ownership = { \"C\", \"\" };\n    objc_property_attribute_t backingivar = { \"V\", \"_ivar1\"};\n    objc_property_attribute_t attrs[] = {type, ownership, backingivar};\n \n bool success =    class_addProperty(clas, \"nameIvar\", attrs, 3);\n    if (success) {\n        NSLog(@\"addIvar success\");\n        if (class_isMetaClass(clas)) {\n            NSLog(@\"是一个类\");\n        }\n    }\n     objc_registerClassPair(clas);\n    [self printPropreListClass:clas];\n}\n```\n###  实例化类\n```\n// 创建类实例\n\nid class_createInstance ( Class cls, size_t extraBytes );\n\n\n\n// 在指定位置创建类实例\n\nid objc_constructInstance ( Class cls, void *bytes );\n\n\n\n// 销毁类实例\n\nvoid * objc_destructInstance ( id obj );\n```\n\n###  实例\n```\nid object_copy(id obj, size_t size) //拷贝obj\n\nid object_dispose(id obj)   //释放obj\n\nIvar object_setInstanceVariable(id obj, const char *name, void *value) //修改实例的值\n\nIvar object_getInstanceVariable(id obj, const char *name, void **outValue) //获取实例\n\nOBJC_EXPORT void *object_getIndexedIvars(id obj) //获取obj的index\n\nid object_getIvar(id object, Ivar ivar) //获取obj的ivar\n\nvoid object_setIvar(id object, Ivar ivar, id value) //赋值ivar给obj默认值是value\n\nconst char *object_getClassName(id obj) //获取类的名字\n\nClass object_getClass(id object) //获得 类\n\nClass object_setClass(id object, Class cls)  //把obj 改到cls的类下\n\nint objc_getClassList(Class *buffer, int bufferLen) //获取class列表\n\nClass *objc_copyClassList(unsigned int *outCount) //拷贝类数组\n\nid objc_lookUpClass(const char *name) // 看看是否 注册了类\n\nid objc_getClass(const char *name) //获取类\n\nid objc_getRequiredClass(const char *name) //要是没有这个类就kill 这个类 \n\nconst char * ivar_getName( Ivar ivar) //获取var的名字\n\nconst char * ivar_getTypeEncoding( Ivar ivar) //获取ivar 的 type\n\nptrdiff_t ivar_getOffset( Ivar ivar) //\n\nvoid objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //给类别添加 属性\n\nid objc_getAssociatedObject(id object, void *key) //获取属性\n\nvoid objc_removeAssociatedObjects(id object) //删除属性\n\n```\n###  发送消息\n```\nid objc_msgSend(id self, SEL op, ...)// id 发送消息给SEL op\n\ndouble objc_msgSend_fpret(id self, SEL op, ...)// 和上边的一样这个用i386平台，PPC和PPC64不能用。\n\nvoid objc_msgSend_stret(void * stretAddr, id theReceiver, SEL theSelector, ...)// 有返回值的消息  stretAddr 是返回值 theReceiver接收消息的id SEL 是方法名\n\nid objc_msgSendSuper(struct objc_super *super, SEL op, ...)//给父类方法发送消息\n\nvoid objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)//给父类添加消息 \n```\n当我们用OC调用方法的时候，其实底层是obj发送消息的过程，就够obj发送消息给SEL，然后objruntime中会在objSELList中寻找，当然不是每次都去遍历所有的方法的，而是在methodCache，它会先去常用的方法cache在中查找，要是cache中没有这个方法，再去遍历所有的方法。参考：[Runtime源码点这里](http://www.opensource.apple.com/tarballs/objc4/)\n\n###  具体测试\n```\n    objc_msgSend(self,@selector(msgTest));\n\n-(void)msgTest{\n    NSLog(@\"调用了我 objc_msgSend\");\n}\n\n输出：2016-03-23 15:06:18.011 runTimeObj[46084:3861049] 调用了我 objc_msgSend\n```\n\n```\nid method_invoke(id receiver, Method m, ...) 调用receiver的方法 id 不能是nil\n\nvoid method_invoke_stret(id receiver, Method m, ...) //Using this function to call the implementation of a method is faster than calling method_getImplementation and method_getName. 官方描述就是比method_getName和method_getImplementation块\n\nIMP method_getImplementation( Method method) //指向IMP的方法指针\nIMP是什么？本质上是一个指针，指向方法的指针，俗名就是函数指针。\n\nconst char * method_getTypeEncoding( Method method) //方法type 返回一个c字符串\n\nchar * method_copyReturnType( Method method) 方法返回的类型 一个c字符串 用完要free(char *)的\n\nunsigned method_getNumberOfArguments( Method method) //方法的元素数量\n\nvoid method_getArgumentType( Method method, unsigned int index, char *dst, size_t dst_len) 获取method 索引是index的参数 值赋给dst 要是dst = nil；系统自动调用strncpy(dst, \"\", dst_len)\n\nIMP method_setImplementation( Method method, IMP imp) 把imp赋给method \n\nvoid method_exchangeImplementations( Method m1, Method m2) 交换两个方法\n例如：IMP imp1 = method_getImplementation(m1);\n     IMP imp2 = method_getImplementation(m2);\n         method_setImplementation(m1, imp2);\n         method_setImplementation(m2, imp1);\nconst char * * objc_copyImageNames(unsigned int *outCount)//返回所有加载的Objective-C框架和动态库的名字。\n\nconst char *class_getImageName(Class cls)//获取class的动态库的名字\n\nconst char * *objc_copyClassNamesForImage(const char *image, unsigned int *outCount) //拷贝动态库\n\nconst char* sel_getName(SEL aSelector) //获取SEL的字符串名字\n\nSEL sel_registerName(const char *str) //注册SEL 名字是str 返回注册成功的SEL\n\nSEL sel_getUid(const char *str) //获取str的方法SEL指针\n\nBOOL sel_isEqual(SEL lhs, SEL rhs) //判断两个SEL是否是同一个SEL \n\n\n```\n今天就到这吧，明天吧协议和属性看了。更多文章在www.fgyong.cn\n","source":"_posts/iOS高级开发runtime那点事实战（3）.md","raw":"title: iOS高级开发runtime那点事实战（3）\ndate: 2016-03-24 11:15:48\ntags:\n- iOS\n- iOS高级开发\ncategories: iOS\n---\n###  添加类\n```\nobjc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)\n添加类 superclass 类是父类   name 类的名字  size_t 类占的空间\n\nvoid objc_disposeClassPair(Class cls) 销毁类\n\n\nvoid objc_registerClassPair(Class cls) 注册类\n\n\nobjc_duplicateClass\n Used by Foundation's Key-Value Observing.官方说法是不让自己调用\nDo not call this function yourself. \n```\n具体代码：\n```\n- (void)allocClass{\n    Class clas = objc_allocateClassPair(NSClassFromString(@\"FY\"), \"FYss\", 0);\n   \n    objc_property_attribute_t type = {\"T\", \"@\\\"NSString\\\"\"};\n    objc_property_attribute_t ownership = { \"C\", \"\" };\n    objc_property_attribute_t backingivar = { \"V\", \"_ivar1\"};\n    objc_property_attribute_t attrs[] = {type, ownership, backingivar};\n \n bool success =    class_addProperty(clas, \"nameIvar\", attrs, 3);\n    if (success) {\n        NSLog(@\"addIvar success\");\n        if (class_isMetaClass(clas)) {\n            NSLog(@\"是一个类\");\n        }\n    }\n     objc_registerClassPair(clas);\n    [self printPropreListClass:clas];\n}\n```\n###  实例化类\n```\n// 创建类实例\n\nid class_createInstance ( Class cls, size_t extraBytes );\n\n\n\n// 在指定位置创建类实例\n\nid objc_constructInstance ( Class cls, void *bytes );\n\n\n\n// 销毁类实例\n\nvoid * objc_destructInstance ( id obj );\n```\n\n###  实例\n```\nid object_copy(id obj, size_t size) //拷贝obj\n\nid object_dispose(id obj)   //释放obj\n\nIvar object_setInstanceVariable(id obj, const char *name, void *value) //修改实例的值\n\nIvar object_getInstanceVariable(id obj, const char *name, void **outValue) //获取实例\n\nOBJC_EXPORT void *object_getIndexedIvars(id obj) //获取obj的index\n\nid object_getIvar(id object, Ivar ivar) //获取obj的ivar\n\nvoid object_setIvar(id object, Ivar ivar, id value) //赋值ivar给obj默认值是value\n\nconst char *object_getClassName(id obj) //获取类的名字\n\nClass object_getClass(id object) //获得 类\n\nClass object_setClass(id object, Class cls)  //把obj 改到cls的类下\n\nint objc_getClassList(Class *buffer, int bufferLen) //获取class列表\n\nClass *objc_copyClassList(unsigned int *outCount) //拷贝类数组\n\nid objc_lookUpClass(const char *name) // 看看是否 注册了类\n\nid objc_getClass(const char *name) //获取类\n\nid objc_getRequiredClass(const char *name) //要是没有这个类就kill 这个类 \n\nconst char * ivar_getName( Ivar ivar) //获取var的名字\n\nconst char * ivar_getTypeEncoding( Ivar ivar) //获取ivar 的 type\n\nptrdiff_t ivar_getOffset( Ivar ivar) //\n\nvoid objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //给类别添加 属性\n\nid objc_getAssociatedObject(id object, void *key) //获取属性\n\nvoid objc_removeAssociatedObjects(id object) //删除属性\n\n```\n###  发送消息\n```\nid objc_msgSend(id self, SEL op, ...)// id 发送消息给SEL op\n\ndouble objc_msgSend_fpret(id self, SEL op, ...)// 和上边的一样这个用i386平台，PPC和PPC64不能用。\n\nvoid objc_msgSend_stret(void * stretAddr, id theReceiver, SEL theSelector, ...)// 有返回值的消息  stretAddr 是返回值 theReceiver接收消息的id SEL 是方法名\n\nid objc_msgSendSuper(struct objc_super *super, SEL op, ...)//给父类方法发送消息\n\nvoid objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)//给父类添加消息 \n```\n当我们用OC调用方法的时候，其实底层是obj发送消息的过程，就够obj发送消息给SEL，然后objruntime中会在objSELList中寻找，当然不是每次都去遍历所有的方法的，而是在methodCache，它会先去常用的方法cache在中查找，要是cache中没有这个方法，再去遍历所有的方法。参考：[Runtime源码点这里](http://www.opensource.apple.com/tarballs/objc4/)\n\n###  具体测试\n```\n    objc_msgSend(self,@selector(msgTest));\n\n-(void)msgTest{\n    NSLog(@\"调用了我 objc_msgSend\");\n}\n\n输出：2016-03-23 15:06:18.011 runTimeObj[46084:3861049] 调用了我 objc_msgSend\n```\n\n```\nid method_invoke(id receiver, Method m, ...) 调用receiver的方法 id 不能是nil\n\nvoid method_invoke_stret(id receiver, Method m, ...) //Using this function to call the implementation of a method is faster than calling method_getImplementation and method_getName. 官方描述就是比method_getName和method_getImplementation块\n\nIMP method_getImplementation( Method method) //指向IMP的方法指针\nIMP是什么？本质上是一个指针，指向方法的指针，俗名就是函数指针。\n\nconst char * method_getTypeEncoding( Method method) //方法type 返回一个c字符串\n\nchar * method_copyReturnType( Method method) 方法返回的类型 一个c字符串 用完要free(char *)的\n\nunsigned method_getNumberOfArguments( Method method) //方法的元素数量\n\nvoid method_getArgumentType( Method method, unsigned int index, char *dst, size_t dst_len) 获取method 索引是index的参数 值赋给dst 要是dst = nil；系统自动调用strncpy(dst, \"\", dst_len)\n\nIMP method_setImplementation( Method method, IMP imp) 把imp赋给method \n\nvoid method_exchangeImplementations( Method m1, Method m2) 交换两个方法\n例如：IMP imp1 = method_getImplementation(m1);\n     IMP imp2 = method_getImplementation(m2);\n         method_setImplementation(m1, imp2);\n         method_setImplementation(m2, imp1);\nconst char * * objc_copyImageNames(unsigned int *outCount)//返回所有加载的Objective-C框架和动态库的名字。\n\nconst char *class_getImageName(Class cls)//获取class的动态库的名字\n\nconst char * *objc_copyClassNamesForImage(const char *image, unsigned int *outCount) //拷贝动态库\n\nconst char* sel_getName(SEL aSelector) //获取SEL的字符串名字\n\nSEL sel_registerName(const char *str) //注册SEL 名字是str 返回注册成功的SEL\n\nSEL sel_getUid(const char *str) //获取str的方法SEL指针\n\nBOOL sel_isEqual(SEL lhs, SEL rhs) //判断两个SEL是否是同一个SEL \n\n\n```\n今天就到这吧，明天吧协议和属性看了。更多文章在www.fgyong.cn\n","slug":"iOS高级开发runtime那点事实战（3）","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi6z00149zskixomncuj","content":"<h3 id=\"添加类\"><a href=\"#添加类\" class=\"headerlink\" title=\"添加类\"></a>添加类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</div><div class=\"line\">添加类 superclass 类是父类   name 类的名字  size_t 类占的空间</div><div class=\"line\"></div><div class=\"line\">void objc_disposeClassPair(Class cls) 销毁类</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">void objc_registerClassPair(Class cls) 注册类</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc_duplicateClass</div><div class=\"line\"> Used by Foundation&apos;s Key-Value Observing.官方说法是不让自己调用</div><div class=\"line\">Do not call this function yourself.</div></pre></td></tr></table></figure>\n<p>具体代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)allocClass&#123;</div><div class=\"line\">    Class clas = objc_allocateClassPair(NSClassFromString(@&quot;FY&quot;), &quot;FYss&quot;, 0);</div><div class=\"line\">   </div><div class=\"line\">    objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;&#125;;</div><div class=\"line\">    objc_property_attribute_t ownership = &#123; &quot;C&quot;, &quot;&quot; &#125;;</div><div class=\"line\">    objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_ivar1&quot;&#125;;</div><div class=\"line\">    objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class=\"line\"> </div><div class=\"line\"> bool success =    class_addProperty(clas, &quot;nameIvar&quot;, attrs, 3);</div><div class=\"line\">    if (success) &#123;</div><div class=\"line\">        NSLog(@&quot;addIvar success&quot;);</div><div class=\"line\">        if (class_isMetaClass(clas)) &#123;</div><div class=\"line\">            NSLog(@&quot;是一个类&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">     objc_registerClassPair(clas);</div><div class=\"line\">    [self printPropreListClass:clas];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"实例化类\"><a href=\"#实例化类\" class=\"headerlink\" title=\"实例化类\"></a>实例化类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建类实例</div><div class=\"line\"></div><div class=\"line\">id class_createInstance ( Class cls, size_t extraBytes );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 在指定位置创建类实例</div><div class=\"line\"></div><div class=\"line\">id objc_constructInstance ( Class cls, void *bytes );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 销毁类实例</div><div class=\"line\"></div><div class=\"line\">void * objc_destructInstance ( id obj );</div></pre></td></tr></table></figure>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">id object_copy(id obj, size_t size) //拷贝obj</div><div class=\"line\"></div><div class=\"line\">id object_dispose(id obj)   //释放obj</div><div class=\"line\"></div><div class=\"line\">Ivar object_setInstanceVariable(id obj, const char *name, void *value) //修改实例的值</div><div class=\"line\"></div><div class=\"line\">Ivar object_getInstanceVariable(id obj, const char *name, void **outValue) //获取实例</div><div class=\"line\"></div><div class=\"line\">OBJC_EXPORT void *object_getIndexedIvars(id obj) //获取obj的index</div><div class=\"line\"></div><div class=\"line\">id object_getIvar(id object, Ivar ivar) //获取obj的ivar</div><div class=\"line\"></div><div class=\"line\">void object_setIvar(id object, Ivar ivar, id value) //赋值ivar给obj默认值是value</div><div class=\"line\"></div><div class=\"line\">const char *object_getClassName(id obj) //获取类的名字</div><div class=\"line\"></div><div class=\"line\">Class object_getClass(id object) //获得 类</div><div class=\"line\"></div><div class=\"line\">Class object_setClass(id object, Class cls)  //把obj 改到cls的类下</div><div class=\"line\"></div><div class=\"line\">int objc_getClassList(Class *buffer, int bufferLen) //获取class列表</div><div class=\"line\"></div><div class=\"line\">Class *objc_copyClassList(unsigned int *outCount) //拷贝类数组</div><div class=\"line\"></div><div class=\"line\">id objc_lookUpClass(const char *name) // 看看是否 注册了类</div><div class=\"line\"></div><div class=\"line\">id objc_getClass(const char *name) //获取类</div><div class=\"line\"></div><div class=\"line\">id objc_getRequiredClass(const char *name) //要是没有这个类就kill 这个类 </div><div class=\"line\"></div><div class=\"line\">const char * ivar_getName( Ivar ivar) //获取var的名字</div><div class=\"line\"></div><div class=\"line\">const char * ivar_getTypeEncoding( Ivar ivar) //获取ivar 的 type</div><div class=\"line\"></div><div class=\"line\">ptrdiff_t ivar_getOffset( Ivar ivar) //</div><div class=\"line\"></div><div class=\"line\">void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //给类别添加 属性</div><div class=\"line\"></div><div class=\"line\">id objc_getAssociatedObject(id object, void *key) //获取属性</div><div class=\"line\"></div><div class=\"line\">void objc_removeAssociatedObjects(id object) //删除属性</div></pre></td></tr></table></figure>\n<h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">id objc_msgSend(id self, SEL op, ...)// id 发送消息给SEL op</div><div class=\"line\"></div><div class=\"line\">double objc_msgSend_fpret(id self, SEL op, ...)// 和上边的一样这个用i386平台，PPC和PPC64不能用。</div><div class=\"line\"></div><div class=\"line\">void objc_msgSend_stret(void * stretAddr, id theReceiver, SEL theSelector, ...)// 有返回值的消息  stretAddr 是返回值 theReceiver接收消息的id SEL 是方法名</div><div class=\"line\"></div><div class=\"line\">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)//给父类方法发送消息</div><div class=\"line\"></div><div class=\"line\">void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)//给父类添加消息</div></pre></td></tr></table></figure>\n<p>当我们用OC调用方法的时候，其实底层是obj发送消息的过程，就够obj发送消息给SEL，然后objruntime中会在objSELList中寻找，当然不是每次都去遍历所有的方法的，而是在methodCache，它会先去常用的方法cache在中查找，要是cache中没有这个方法，再去遍历所有的方法。参考：<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">Runtime源码点这里</a></p>\n<h3 id=\"具体测试\"><a href=\"#具体测试\" class=\"headerlink\" title=\"具体测试\"></a>具体测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    objc_msgSend(self,@selector(msgTest));</div><div class=\"line\"></div><div class=\"line\">-(void)msgTest&#123;</div><div class=\"line\">    NSLog(@&quot;调用了我 objc_msgSend&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输出：2016-03-23 15:06:18.011 runTimeObj[46084:3861049] 调用了我 objc_msgSend</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">id method_invoke(id receiver, Method m, ...) 调用receiver的方法 id 不能是nil</div><div class=\"line\"></div><div class=\"line\">void method_invoke_stret(id receiver, Method m, ...) //Using this function to call the implementation of a method is faster than calling method_getImplementation and method_getName. 官方描述就是比method_getName和method_getImplementation块</div><div class=\"line\"></div><div class=\"line\">IMP method_getImplementation( Method method) //指向IMP的方法指针</div><div class=\"line\">IMP是什么？本质上是一个指针，指向方法的指针，俗名就是函数指针。</div><div class=\"line\"></div><div class=\"line\">const char * method_getTypeEncoding( Method method) //方法type 返回一个c字符串</div><div class=\"line\"></div><div class=\"line\">char * method_copyReturnType( Method method) 方法返回的类型 一个c字符串 用完要free(char *)的</div><div class=\"line\"></div><div class=\"line\">unsigned method_getNumberOfArguments( Method method) //方法的元素数量</div><div class=\"line\"></div><div class=\"line\">void method_getArgumentType( Method method, unsigned int index, char *dst, size_t dst_len) 获取method 索引是index的参数 值赋给dst 要是dst = nil；系统自动调用strncpy(dst, &quot;&quot;, dst_len)</div><div class=\"line\"></div><div class=\"line\">IMP method_setImplementation( Method method, IMP imp) 把imp赋给method </div><div class=\"line\"></div><div class=\"line\">void method_exchangeImplementations( Method m1, Method m2) 交换两个方法</div><div class=\"line\">例如：IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">     IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">         method_setImplementation(m1, imp2);</div><div class=\"line\">         method_setImplementation(m2, imp1);</div><div class=\"line\">const char * * objc_copyImageNames(unsigned int *outCount)//返回所有加载的Objective-C框架和动态库的名字。</div><div class=\"line\"></div><div class=\"line\">const char *class_getImageName(Class cls)//获取class的动态库的名字</div><div class=\"line\"></div><div class=\"line\">const char * *objc_copyClassNamesForImage(const char *image, unsigned int *outCount) //拷贝动态库</div><div class=\"line\"></div><div class=\"line\">const char* sel_getName(SEL aSelector) //获取SEL的字符串名字</div><div class=\"line\"></div><div class=\"line\">SEL sel_registerName(const char *str) //注册SEL 名字是str 返回注册成功的SEL</div><div class=\"line\"></div><div class=\"line\">SEL sel_getUid(const char *str) //获取str的方法SEL指针</div><div class=\"line\"></div><div class=\"line\">BOOL sel_isEqual(SEL lhs, SEL rhs) //判断两个SEL是否是同一个SEL</div></pre></td></tr></table></figure>\n<p>今天就到这吧，明天吧协议和属性看了。更多文章在www.fgyong.cn</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"添加类\"><a href=\"#添加类\" class=\"headerlink\" title=\"添加类\"></a>添加类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</div><div class=\"line\">添加类 superclass 类是父类   name 类的名字  size_t 类占的空间</div><div class=\"line\"></div><div class=\"line\">void objc_disposeClassPair(Class cls) 销毁类</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">void objc_registerClassPair(Class cls) 注册类</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">objc_duplicateClass</div><div class=\"line\"> Used by Foundation&apos;s Key-Value Observing.官方说法是不让自己调用</div><div class=\"line\">Do not call this function yourself.</div></pre></td></tr></table></figure>\n<p>具体代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)allocClass&#123;</div><div class=\"line\">    Class clas = objc_allocateClassPair(NSClassFromString(@&quot;FY&quot;), &quot;FYss&quot;, 0);</div><div class=\"line\">   </div><div class=\"line\">    objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;&#125;;</div><div class=\"line\">    objc_property_attribute_t ownership = &#123; &quot;C&quot;, &quot;&quot; &#125;;</div><div class=\"line\">    objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_ivar1&quot;&#125;;</div><div class=\"line\">    objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class=\"line\"> </div><div class=\"line\"> bool success =    class_addProperty(clas, &quot;nameIvar&quot;, attrs, 3);</div><div class=\"line\">    if (success) &#123;</div><div class=\"line\">        NSLog(@&quot;addIvar success&quot;);</div><div class=\"line\">        if (class_isMetaClass(clas)) &#123;</div><div class=\"line\">            NSLog(@&quot;是一个类&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">     objc_registerClassPair(clas);</div><div class=\"line\">    [self printPropreListClass:clas];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"实例化类\"><a href=\"#实例化类\" class=\"headerlink\" title=\"实例化类\"></a>实例化类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建类实例</div><div class=\"line\"></div><div class=\"line\">id class_createInstance ( Class cls, size_t extraBytes );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 在指定位置创建类实例</div><div class=\"line\"></div><div class=\"line\">id objc_constructInstance ( Class cls, void *bytes );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 销毁类实例</div><div class=\"line\"></div><div class=\"line\">void * objc_destructInstance ( id obj );</div></pre></td></tr></table></figure>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">id object_copy(id obj, size_t size) //拷贝obj</div><div class=\"line\"></div><div class=\"line\">id object_dispose(id obj)   //释放obj</div><div class=\"line\"></div><div class=\"line\">Ivar object_setInstanceVariable(id obj, const char *name, void *value) //修改实例的值</div><div class=\"line\"></div><div class=\"line\">Ivar object_getInstanceVariable(id obj, const char *name, void **outValue) //获取实例</div><div class=\"line\"></div><div class=\"line\">OBJC_EXPORT void *object_getIndexedIvars(id obj) //获取obj的index</div><div class=\"line\"></div><div class=\"line\">id object_getIvar(id object, Ivar ivar) //获取obj的ivar</div><div class=\"line\"></div><div class=\"line\">void object_setIvar(id object, Ivar ivar, id value) //赋值ivar给obj默认值是value</div><div class=\"line\"></div><div class=\"line\">const char *object_getClassName(id obj) //获取类的名字</div><div class=\"line\"></div><div class=\"line\">Class object_getClass(id object) //获得 类</div><div class=\"line\"></div><div class=\"line\">Class object_setClass(id object, Class cls)  //把obj 改到cls的类下</div><div class=\"line\"></div><div class=\"line\">int objc_getClassList(Class *buffer, int bufferLen) //获取class列表</div><div class=\"line\"></div><div class=\"line\">Class *objc_copyClassList(unsigned int *outCount) //拷贝类数组</div><div class=\"line\"></div><div class=\"line\">id objc_lookUpClass(const char *name) // 看看是否 注册了类</div><div class=\"line\"></div><div class=\"line\">id objc_getClass(const char *name) //获取类</div><div class=\"line\"></div><div class=\"line\">id objc_getRequiredClass(const char *name) //要是没有这个类就kill 这个类 </div><div class=\"line\"></div><div class=\"line\">const char * ivar_getName( Ivar ivar) //获取var的名字</div><div class=\"line\"></div><div class=\"line\">const char * ivar_getTypeEncoding( Ivar ivar) //获取ivar 的 type</div><div class=\"line\"></div><div class=\"line\">ptrdiff_t ivar_getOffset( Ivar ivar) //</div><div class=\"line\"></div><div class=\"line\">void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) //给类别添加 属性</div><div class=\"line\"></div><div class=\"line\">id objc_getAssociatedObject(id object, void *key) //获取属性</div><div class=\"line\"></div><div class=\"line\">void objc_removeAssociatedObjects(id object) //删除属性</div></pre></td></tr></table></figure>\n<h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">id objc_msgSend(id self, SEL op, ...)// id 发送消息给SEL op</div><div class=\"line\"></div><div class=\"line\">double objc_msgSend_fpret(id self, SEL op, ...)// 和上边的一样这个用i386平台，PPC和PPC64不能用。</div><div class=\"line\"></div><div class=\"line\">void objc_msgSend_stret(void * stretAddr, id theReceiver, SEL theSelector, ...)// 有返回值的消息  stretAddr 是返回值 theReceiver接收消息的id SEL 是方法名</div><div class=\"line\"></div><div class=\"line\">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)//给父类方法发送消息</div><div class=\"line\"></div><div class=\"line\">void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)//给父类添加消息</div></pre></td></tr></table></figure>\n<p>当我们用OC调用方法的时候，其实底层是obj发送消息的过程，就够obj发送消息给SEL，然后objruntime中会在objSELList中寻找，当然不是每次都去遍历所有的方法的，而是在methodCache，它会先去常用的方法cache在中查找，要是cache中没有这个方法，再去遍历所有的方法。参考：<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">Runtime源码点这里</a></p>\n<h3 id=\"具体测试\"><a href=\"#具体测试\" class=\"headerlink\" title=\"具体测试\"></a>具体测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    objc_msgSend(self,@selector(msgTest));</div><div class=\"line\"></div><div class=\"line\">-(void)msgTest&#123;</div><div class=\"line\">    NSLog(@&quot;调用了我 objc_msgSend&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">输出：2016-03-23 15:06:18.011 runTimeObj[46084:3861049] 调用了我 objc_msgSend</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">id method_invoke(id receiver, Method m, ...) 调用receiver的方法 id 不能是nil</div><div class=\"line\"></div><div class=\"line\">void method_invoke_stret(id receiver, Method m, ...) //Using this function to call the implementation of a method is faster than calling method_getImplementation and method_getName. 官方描述就是比method_getName和method_getImplementation块</div><div class=\"line\"></div><div class=\"line\">IMP method_getImplementation( Method method) //指向IMP的方法指针</div><div class=\"line\">IMP是什么？本质上是一个指针，指向方法的指针，俗名就是函数指针。</div><div class=\"line\"></div><div class=\"line\">const char * method_getTypeEncoding( Method method) //方法type 返回一个c字符串</div><div class=\"line\"></div><div class=\"line\">char * method_copyReturnType( Method method) 方法返回的类型 一个c字符串 用完要free(char *)的</div><div class=\"line\"></div><div class=\"line\">unsigned method_getNumberOfArguments( Method method) //方法的元素数量</div><div class=\"line\"></div><div class=\"line\">void method_getArgumentType( Method method, unsigned int index, char *dst, size_t dst_len) 获取method 索引是index的参数 值赋给dst 要是dst = nil；系统自动调用strncpy(dst, &quot;&quot;, dst_len)</div><div class=\"line\"></div><div class=\"line\">IMP method_setImplementation( Method method, IMP imp) 把imp赋给method </div><div class=\"line\"></div><div class=\"line\">void method_exchangeImplementations( Method m1, Method m2) 交换两个方法</div><div class=\"line\">例如：IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">     IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">         method_setImplementation(m1, imp2);</div><div class=\"line\">         method_setImplementation(m2, imp1);</div><div class=\"line\">const char * * objc_copyImageNames(unsigned int *outCount)//返回所有加载的Objective-C框架和动态库的名字。</div><div class=\"line\"></div><div class=\"line\">const char *class_getImageName(Class cls)//获取class的动态库的名字</div><div class=\"line\"></div><div class=\"line\">const char * *objc_copyClassNamesForImage(const char *image, unsigned int *outCount) //拷贝动态库</div><div class=\"line\"></div><div class=\"line\">const char* sel_getName(SEL aSelector) //获取SEL的字符串名字</div><div class=\"line\"></div><div class=\"line\">SEL sel_registerName(const char *str) //注册SEL 名字是str 返回注册成功的SEL</div><div class=\"line\"></div><div class=\"line\">SEL sel_getUid(const char *str) //获取str的方法SEL指针</div><div class=\"line\"></div><div class=\"line\">BOOL sel_isEqual(SEL lhs, SEL rhs) //判断两个SEL是否是同一个SEL</div></pre></td></tr></table></figure>\n<p>今天就到这吧，明天吧协议和属性看了。更多文章在www.fgyong.cn</p>\n"},{"title":"PHP5.6+YII+MongoDB环境搭建","date":"2018-04-16T07:39:24.000Z","_content":"### 1.安装php5.6\n##### 1.先安装brew，要是不确定是否已经安装了brew，可以先运行`brew -v`查看版本，有版本号的话直接下一步，报错的话安装brew。\n安装命令是`/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n`有其他问题可以查看[brew官方安装方法](https://brew.sh/index_zh-cn)。\n##### 2.搜索PHP\n```\nbrew search php\n```\n![brew search php](https://upload-images.jianshu.io/upload_images/783986-58be6a637b83983b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 3.安装PHP\n```\nbrew install php@5.6\n```\nOK，安装完成。\n### 2.安装MongoDB\n```\nsudo brew install mongodb #安装MongoDB\n\nsudo mongod #启动\n\n# 如果没有创建全局路径 PATH，需要进入以下目录\ncd /usr/local/mongodb/bin\nsudo ./mongod\n\n\n$ cd /usr/local/mongodb/bin \n$ ./mongo\nMongoDB shell version v3.4.2\nconnecting to: mongodb://127.0.0.1:27017\nMongoDB server version: 3.4.2\nWelcome to the MongoDB shell.\n……\n> 1 + 1\n2\n> \n```\n### 3.配置Apache\n不知道mac的Apache目录的可以使用命令`which apache`，一般的配置文件目录是`/etc/apache2`，Apahce启动的时候读的文件是http.conf，现在我们配置http.conf\n```\n因为我配置了两个web，所以监听 80 和 81\n  Listen 80\n  Listen 81\n#加载PHP动态库的配置，如果是用的PHP7.1或者其他版本，路径改为相对应版本的路径。加入是使用brew安装的PHP5.6的话，路径应该是我的路径。\n#PHP7.1的路径\nLoadModule php7_module libexec/apache2/libphp7.so\n#php5.6的路径\n LoadModule php5_module /usr/local/opt/php@5.6/lib/httpd/modules/libphp5.so\n\n<VirtualHost *:81>    #ServerAdmin demo@demo.com    \n DocumentRoot \"/Users/Jerry/Desktop/s/api/web\"    \n ServerName demo.com         \n<Directory \"/Users/Jerry/Desktop/s/api/web\">   \n      Options +Indexes +Includes +FollowSymLinks +MultiViews     \n    AllowOverride All         Require local         Require all granted       \n  IndexIgnore */*         RewriteEngine on         RewriteCond %\n{REQUEST_FILENAME} !-f         RewriteCond %\n{REQUEST_FILENAME} !-d         RewriteRule . index.php       \n</Directory>    \n ErrorLog \"/private/var/log/apache2/demo.com-\nerror_log\"    \n CustomLog \"/private/var/log/apache2/demo.com-\naccess_log\" common\n </VirtualHost>\n            AllowOverride None         Require all granted    \n     IndexIgnore */*         RewriteEngine on         RewriteCond %\n{REQUEST_FILENAME} !-f         RewriteCond %\n{REQUEST_FILENAME} !-d         RewriteRule . index.php     \n</Directory>  \n   ErrorLog \"/private/var/log/apache2/demo2.com-error_log\"  \n   CustomLog \"/private/var/log/apache2/demo2.com-access_log\" \ncommon </VirtualHost>\n```\n配置好Apache需要重新启动，\n```\nsudo /usr/sbin/apachectl restart #重新启动\nsudo /usr/sbin/apachectl start#启动\nsudo /usr/sbin/apachectl stop#停止\n```\n在\n`/Users/Jerry/Desktop/s/api/web`新建index.html，内容是\n```\n<?php\nphpinfo();\n>\n```\n添加url到hosts\n```\nvi  /etc/hosts\n#添加 \n127.0.0.7 demo.com\n#保存退出\n:wq\n#刷新hosts立即生效\nsource /etc/hosts\n```\n在浏览器中输入http://demo.com/,回车，出来的界面是\n![PHPinfo](https://upload-images.jianshu.io/upload_images/783986-e1b5fda1f7385967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这就代表运行成功了，其实这个界面包含很多配置信息，左边是参数，右边是值，例如：\nServer API 值是Apache 2.0Handler。\n\n已经有项目的，可以\n```\ngit clone git地址 dirName #克隆仓库\ncd ./dicNme #进入工程文件\ncomposer install #安装 composer\n```\n\n有什么疑问的小伙伴可以留言哦。\n更多博客在www.fgyong.cn可见。\n\n\n\n","source":"_posts/mac-php5-6+mongdb+Apache环境配置.md","raw":"title: PHP5.6+YII+MongoDB环境搭建\ndate: 2018-4-16 15:39:24\ntags:  \n- PHP环境配置\n- YII\n- MongoDB\ncategories: 数据结构 \n---\n### 1.安装php5.6\n##### 1.先安装brew，要是不确定是否已经安装了brew，可以先运行`brew -v`查看版本，有版本号的话直接下一步，报错的话安装brew。\n安装命令是`/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n`有其他问题可以查看[brew官方安装方法](https://brew.sh/index_zh-cn)。\n##### 2.搜索PHP\n```\nbrew search php\n```\n![brew search php](https://upload-images.jianshu.io/upload_images/783986-58be6a637b83983b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 3.安装PHP\n```\nbrew install php@5.6\n```\nOK，安装完成。\n### 2.安装MongoDB\n```\nsudo brew install mongodb #安装MongoDB\n\nsudo mongod #启动\n\n# 如果没有创建全局路径 PATH，需要进入以下目录\ncd /usr/local/mongodb/bin\nsudo ./mongod\n\n\n$ cd /usr/local/mongodb/bin \n$ ./mongo\nMongoDB shell version v3.4.2\nconnecting to: mongodb://127.0.0.1:27017\nMongoDB server version: 3.4.2\nWelcome to the MongoDB shell.\n……\n> 1 + 1\n2\n> \n```\n### 3.配置Apache\n不知道mac的Apache目录的可以使用命令`which apache`，一般的配置文件目录是`/etc/apache2`，Apahce启动的时候读的文件是http.conf，现在我们配置http.conf\n```\n因为我配置了两个web，所以监听 80 和 81\n  Listen 80\n  Listen 81\n#加载PHP动态库的配置，如果是用的PHP7.1或者其他版本，路径改为相对应版本的路径。加入是使用brew安装的PHP5.6的话，路径应该是我的路径。\n#PHP7.1的路径\nLoadModule php7_module libexec/apache2/libphp7.so\n#php5.6的路径\n LoadModule php5_module /usr/local/opt/php@5.6/lib/httpd/modules/libphp5.so\n\n<VirtualHost *:81>    #ServerAdmin demo@demo.com    \n DocumentRoot \"/Users/Jerry/Desktop/s/api/web\"    \n ServerName demo.com         \n<Directory \"/Users/Jerry/Desktop/s/api/web\">   \n      Options +Indexes +Includes +FollowSymLinks +MultiViews     \n    AllowOverride All         Require local         Require all granted       \n  IndexIgnore */*         RewriteEngine on         RewriteCond %\n{REQUEST_FILENAME} !-f         RewriteCond %\n{REQUEST_FILENAME} !-d         RewriteRule . index.php       \n</Directory>    \n ErrorLog \"/private/var/log/apache2/demo.com-\nerror_log\"    \n CustomLog \"/private/var/log/apache2/demo.com-\naccess_log\" common\n </VirtualHost>\n            AllowOverride None         Require all granted    \n     IndexIgnore */*         RewriteEngine on         RewriteCond %\n{REQUEST_FILENAME} !-f         RewriteCond %\n{REQUEST_FILENAME} !-d         RewriteRule . index.php     \n</Directory>  \n   ErrorLog \"/private/var/log/apache2/demo2.com-error_log\"  \n   CustomLog \"/private/var/log/apache2/demo2.com-access_log\" \ncommon </VirtualHost>\n```\n配置好Apache需要重新启动，\n```\nsudo /usr/sbin/apachectl restart #重新启动\nsudo /usr/sbin/apachectl start#启动\nsudo /usr/sbin/apachectl stop#停止\n```\n在\n`/Users/Jerry/Desktop/s/api/web`新建index.html，内容是\n```\n<?php\nphpinfo();\n>\n```\n添加url到hosts\n```\nvi  /etc/hosts\n#添加 \n127.0.0.7 demo.com\n#保存退出\n:wq\n#刷新hosts立即生效\nsource /etc/hosts\n```\n在浏览器中输入http://demo.com/,回车，出来的界面是\n![PHPinfo](https://upload-images.jianshu.io/upload_images/783986-e1b5fda1f7385967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这就代表运行成功了，其实这个界面包含很多配置信息，左边是参数，右边是值，例如：\nServer API 值是Apache 2.0Handler。\n\n已经有项目的，可以\n```\ngit clone git地址 dirName #克隆仓库\ncd ./dicNme #进入工程文件\ncomposer install #安装 composer\n```\n\n有什么疑问的小伙伴可以留言哦。\n更多博客在www.fgyong.cn可见。\n\n\n\n","slug":"mac-php5-6+mongdb+Apache环境配置","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi7000179zsk9p3wvklw","content":"<h3 id=\"1-安装php5-6\"><a href=\"#1-安装php5-6\" class=\"headerlink\" title=\"1.安装php5.6\"></a>1.安装php5.6</h3><h5 id=\"1-先安装brew，要是不确定是否已经安装了brew，可以先运行brew-v查看版本，有版本号的话直接下一步，报错的话安装brew。\"><a href=\"#1-先安装brew，要是不确定是否已经安装了brew，可以先运行brew-v查看版本，有版本号的话直接下一步，报错的话安装brew。\" class=\"headerlink\" title=\"1.先安装brew，要是不确定是否已经安装了brew，可以先运行brew -v查看版本，有版本号的话直接下一步，报错的话安装brew。\"></a>1.先安装brew，要是不确定是否已经安装了brew，可以先运行<code>brew -v</code>查看版本，有版本号的话直接下一步，报错的话安装brew。</h5><p>安装命令是<code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>有其他问题可以查看<a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"external\">brew官方安装方法</a>。</p>\n<h5 id=\"2-搜索PHP\"><a href=\"#2-搜索PHP\" class=\"headerlink\" title=\"2.搜索PHP\"></a>2.搜索PHP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew search php</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/783986-58be6a637b83983b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"brew search php\"></p>\n<h3 id=\"3-安装PHP\"><a href=\"#3-安装PHP\" class=\"headerlink\" title=\"3.安装PHP\"></a>3.安装PHP</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install php@5.6</div></pre></td></tr></table></figure>\n<p>OK，安装完成。</p>\n<h3 id=\"2-安装MongoDB\"><a href=\"#2-安装MongoDB\" class=\"headerlink\" title=\"2.安装MongoDB\"></a>2.安装MongoDB</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo brew install mongodb #安装MongoDB</div><div class=\"line\"></div><div class=\"line\">sudo mongod #启动</div><div class=\"line\"></div><div class=\"line\"># 如果没有创建全局路径 PATH，需要进入以下目录</div><div class=\"line\">cd /usr/local/mongodb/bin</div><div class=\"line\">sudo ./mongod</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ cd /usr/local/mongodb/bin </div><div class=\"line\">$ ./mongo</div><div class=\"line\">MongoDB shell version v3.4.2</div><div class=\"line\">connecting to: mongodb://127.0.0.1:27017</div><div class=\"line\">MongoDB server version: 3.4.2</div><div class=\"line\">Welcome to the MongoDB shell.</div><div class=\"line\">……</div><div class=\"line\">&gt; 1 + 1</div><div class=\"line\">2</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"3-配置Apache\"><a href=\"#3-配置Apache\" class=\"headerlink\" title=\"3.配置Apache\"></a>3.配置Apache</h3><p>不知道mac的Apache目录的可以使用命令<code>which apache</code>，一般的配置文件目录是<code>/etc/apache2</code>，Apahce启动的时候读的文件是http.conf，现在我们配置http.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">因为我配置了两个web，所以监听 80 和 81</div><div class=\"line\">  Listen 80</div><div class=\"line\">  Listen 81</div><div class=\"line\">#加载PHP动态库的配置，如果是用的PHP7.1或者其他版本，路径改为相对应版本的路径。加入是使用brew安装的PHP5.6的话，路径应该是我的路径。</div><div class=\"line\">#PHP7.1的路径</div><div class=\"line\">LoadModule php7_module libexec/apache2/libphp7.so</div><div class=\"line\">#php5.6的路径</div><div class=\"line\"> LoadModule php5_module /usr/local/opt/php@5.6/lib/httpd/modules/libphp5.so</div><div class=\"line\"></div><div class=\"line\">&lt;VirtualHost *:81&gt;    #ServerAdmin demo@demo.com    </div><div class=\"line\"> DocumentRoot &quot;/Users/Jerry/Desktop/s/api/web&quot;    </div><div class=\"line\"> ServerName demo.com         </div><div class=\"line\">&lt;Directory &quot;/Users/Jerry/Desktop/s/api/web&quot;&gt;   </div><div class=\"line\">      Options +Indexes +Includes +FollowSymLinks +MultiViews     </div><div class=\"line\">    AllowOverride All         Require local         Require all granted       </div><div class=\"line\">  IndexIgnore */*         RewriteEngine on         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-f         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-d         RewriteRule . index.php       </div><div class=\"line\">&lt;/Directory&gt;    </div><div class=\"line\"> ErrorLog &quot;/private/var/log/apache2/demo.com-</div><div class=\"line\">error_log&quot;    </div><div class=\"line\"> CustomLog &quot;/private/var/log/apache2/demo.com-</div><div class=\"line\">access_log&quot; common</div><div class=\"line\"> &lt;/VirtualHost&gt;</div><div class=\"line\">            AllowOverride None         Require all granted    </div><div class=\"line\">     IndexIgnore */*         RewriteEngine on         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-f         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-d         RewriteRule . index.php     </div><div class=\"line\">&lt;/Directory&gt;  </div><div class=\"line\">   ErrorLog &quot;/private/var/log/apache2/demo2.com-error_log&quot;  </div><div class=\"line\">   CustomLog &quot;/private/var/log/apache2/demo2.com-access_log&quot; </div><div class=\"line\">common &lt;/VirtualHost&gt;</div></pre></td></tr></table></figure></p>\n<p>配置好Apache需要重新启动，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/sbin/apachectl restart #重新启动</div><div class=\"line\">sudo /usr/sbin/apachectl start#启动</div><div class=\"line\">sudo /usr/sbin/apachectl stop#停止</div></pre></td></tr></table></figure></p>\n<p>在<br><code>/Users/Jerry/Desktop/s/api/web</code>新建index.html，内容是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">phpinfo();</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>添加url到hosts<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi  /etc/hosts</div><div class=\"line\">#添加 </div><div class=\"line\">127.0.0.7 demo.com</div><div class=\"line\">#保存退出</div><div class=\"line\">:wq</div><div class=\"line\">#刷新hosts立即生效</div><div class=\"line\">source /etc/hosts</div></pre></td></tr></table></figure></p>\n<p>在浏览器中输入<a href=\"http://demo.com/,回车，出来的界面是\" target=\"_blank\" rel=\"external\">http://demo.com/,回车，出来的界面是</a><br><img src=\"https://upload-images.jianshu.io/upload_images/783986-e1b5fda1f7385967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PHPinfo\"><br>这就代表运行成功了，其实这个界面包含很多配置信息，左边是参数，右边是值，例如：<br>Server API 值是Apache 2.0Handler。</p>\n<p>已经有项目的，可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git地址 dirName #克隆仓库</div><div class=\"line\">cd ./dicNme #进入工程文件</div><div class=\"line\">composer install #安装 composer</div></pre></td></tr></table></figure></p>\n<p>有什么疑问的小伙伴可以留言哦。<br>更多博客在www.fgyong.cn可见。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-安装php5-6\"><a href=\"#1-安装php5-6\" class=\"headerlink\" title=\"1.安装php5.6\"></a>1.安装php5.6</h3><h5 id=\"1-先安装brew，要是不确定是否已经安装了brew，可以先运行brew-v查看版本，有版本号的话直接下一步，报错的话安装brew。\"><a href=\"#1-先安装brew，要是不确定是否已经安装了brew，可以先运行brew-v查看版本，有版本号的话直接下一步，报错的话安装brew。\" class=\"headerlink\" title=\"1.先安装brew，要是不确定是否已经安装了brew，可以先运行brew -v查看版本，有版本号的话直接下一步，报错的话安装brew。\"></a>1.先安装brew，要是不确定是否已经安装了brew，可以先运行<code>brew -v</code>查看版本，有版本号的话直接下一步，报错的话安装brew。</h5><p>安装命令是<code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>有其他问题可以查看<a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"external\">brew官方安装方法</a>。</p>\n<h5 id=\"2-搜索PHP\"><a href=\"#2-搜索PHP\" class=\"headerlink\" title=\"2.搜索PHP\"></a>2.搜索PHP</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew search php</div></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/783986-58be6a637b83983b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"brew search php\"></p>\n<h3 id=\"3-安装PHP\"><a href=\"#3-安装PHP\" class=\"headerlink\" title=\"3.安装PHP\"></a>3.安装PHP</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install php@5.6</div></pre></td></tr></table></figure>\n<p>OK，安装完成。</p>\n<h3 id=\"2-安装MongoDB\"><a href=\"#2-安装MongoDB\" class=\"headerlink\" title=\"2.安装MongoDB\"></a>2.安装MongoDB</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo brew install mongodb #安装MongoDB</div><div class=\"line\"></div><div class=\"line\">sudo mongod #启动</div><div class=\"line\"></div><div class=\"line\"># 如果没有创建全局路径 PATH，需要进入以下目录</div><div class=\"line\">cd /usr/local/mongodb/bin</div><div class=\"line\">sudo ./mongod</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ cd /usr/local/mongodb/bin </div><div class=\"line\">$ ./mongo</div><div class=\"line\">MongoDB shell version v3.4.2</div><div class=\"line\">connecting to: mongodb://127.0.0.1:27017</div><div class=\"line\">MongoDB server version: 3.4.2</div><div class=\"line\">Welcome to the MongoDB shell.</div><div class=\"line\">……</div><div class=\"line\">&gt; 1 + 1</div><div class=\"line\">2</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"3-配置Apache\"><a href=\"#3-配置Apache\" class=\"headerlink\" title=\"3.配置Apache\"></a>3.配置Apache</h3><p>不知道mac的Apache目录的可以使用命令<code>which apache</code>，一般的配置文件目录是<code>/etc/apache2</code>，Apahce启动的时候读的文件是http.conf，现在我们配置http.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">因为我配置了两个web，所以监听 80 和 81</div><div class=\"line\">  Listen 80</div><div class=\"line\">  Listen 81</div><div class=\"line\">#加载PHP动态库的配置，如果是用的PHP7.1或者其他版本，路径改为相对应版本的路径。加入是使用brew安装的PHP5.6的话，路径应该是我的路径。</div><div class=\"line\">#PHP7.1的路径</div><div class=\"line\">LoadModule php7_module libexec/apache2/libphp7.so</div><div class=\"line\">#php5.6的路径</div><div class=\"line\"> LoadModule php5_module /usr/local/opt/php@5.6/lib/httpd/modules/libphp5.so</div><div class=\"line\"></div><div class=\"line\">&lt;VirtualHost *:81&gt;    #ServerAdmin demo@demo.com    </div><div class=\"line\"> DocumentRoot &quot;/Users/Jerry/Desktop/s/api/web&quot;    </div><div class=\"line\"> ServerName demo.com         </div><div class=\"line\">&lt;Directory &quot;/Users/Jerry/Desktop/s/api/web&quot;&gt;   </div><div class=\"line\">      Options +Indexes +Includes +FollowSymLinks +MultiViews     </div><div class=\"line\">    AllowOverride All         Require local         Require all granted       </div><div class=\"line\">  IndexIgnore */*         RewriteEngine on         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-f         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-d         RewriteRule . index.php       </div><div class=\"line\">&lt;/Directory&gt;    </div><div class=\"line\"> ErrorLog &quot;/private/var/log/apache2/demo.com-</div><div class=\"line\">error_log&quot;    </div><div class=\"line\"> CustomLog &quot;/private/var/log/apache2/demo.com-</div><div class=\"line\">access_log&quot; common</div><div class=\"line\"> &lt;/VirtualHost&gt;</div><div class=\"line\">            AllowOverride None         Require all granted    </div><div class=\"line\">     IndexIgnore */*         RewriteEngine on         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-f         RewriteCond %</div><div class=\"line\">&#123;REQUEST_FILENAME&#125; !-d         RewriteRule . index.php     </div><div class=\"line\">&lt;/Directory&gt;  </div><div class=\"line\">   ErrorLog &quot;/private/var/log/apache2/demo2.com-error_log&quot;  </div><div class=\"line\">   CustomLog &quot;/private/var/log/apache2/demo2.com-access_log&quot; </div><div class=\"line\">common &lt;/VirtualHost&gt;</div></pre></td></tr></table></figure></p>\n<p>配置好Apache需要重新启动，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /usr/sbin/apachectl restart #重新启动</div><div class=\"line\">sudo /usr/sbin/apachectl start#启动</div><div class=\"line\">sudo /usr/sbin/apachectl stop#停止</div></pre></td></tr></table></figure></p>\n<p>在<br><code>/Users/Jerry/Desktop/s/api/web</code>新建index.html，内容是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">phpinfo();</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>添加url到hosts<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi  /etc/hosts</div><div class=\"line\">#添加 </div><div class=\"line\">127.0.0.7 demo.com</div><div class=\"line\">#保存退出</div><div class=\"line\">:wq</div><div class=\"line\">#刷新hosts立即生效</div><div class=\"line\">source /etc/hosts</div></pre></td></tr></table></figure></p>\n<p>在浏览器中输入<a href=\"http://demo.com/,回车，出来的界面是\" target=\"_blank\" rel=\"external\">http://demo.com/,回车，出来的界面是</a><br><img src=\"https://upload-images.jianshu.io/upload_images/783986-e1b5fda1f7385967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PHPinfo\"><br>这就代表运行成功了，其实这个界面包含很多配置信息，左边是参数，右边是值，例如：<br>Server API 值是Apache 2.0Handler。</p>\n<p>已经有项目的，可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git地址 dirName #克隆仓库</div><div class=\"line\">cd ./dicNme #进入工程文件</div><div class=\"line\">composer install #安装 composer</div></pre></td></tr></table></figure></p>\n<p>有什么疑问的小伙伴可以留言哦。<br>更多博客在www.fgyong.cn可见。</p>\n"},{"title":"iOS高级开发runtime那点事实战（4）","date":"2016-03-28T06:19:20.000Z","_content":"### Category\nCategory是表示一个指向分类的结构体的指针，其定义如下：\n```\ntypedef struct objc_category *Category;\n\n\n\nstruct objc_category {\n\n    char *category_name                          OBJC2_UNAVAILABLE; // 分类名\n\n    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名\n\n    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表\n\n    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表\n\n    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n} \n```\n\n### Protocol\nProtocol定义：\n\n```\ntypedef struct objc_object Protocol;\n\n// 返回指定的协议\n\nProtocol * objc_getProtocol ( const char *name );\n\n\n\n// 获取运行时所知道的所有协议的数组\n\nProtocol ** objc_copyProtocolList ( unsigned int *outCount );\n\n\n\n// 创建新的协议实例\n\nProtocol * objc_allocateProtocol ( const char *name );\n\n\n\n// 在运行时中注册新创建的协议\n\nvoid objc_registerProtocol ( Protocol *proto );\n\n\n\n// 为协议添加方法\n\nvoid protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n\n\n// 添加一个已注册的协议到协议中\n\nvoid protocol_addProtocol ( Protocol *proto, Protocol *addition );\n\n\n\n// 为协议添加属性\n\nvoid protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n\n\n// 返回协议名\n\nconst char * protocol_getName ( Protocol *p );\n\n\n\n// 测试两个协议是否相等\n\nBOOL protocol_isEqual ( Protocol *proto, Protocol *other );\n\n\n\n// 获取协议中指定条件的方法的方法描述数组\n\nstruct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );\n\n\n\n// 获取协议中指定方法的方法描述\n\nstruct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n\n\n// 获取协议中的属性列表\n\nobjc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );\n\n\n\n// 获取协议的指定属性\n\nobjc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n\n\n// 获取协议采用的协议\n\nProtocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );\n\n\n\n// 查看协议是否采用了另一个协议\n\nBOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );\n```\n### 属性\n\n```\n\nconst char *property_getName(objc_property_t property) 获得property的name\n\nconst char *property_getAttributes(objc_property_t property) //获得property的atttibutes\n\nchar *property_copyAttributeValue(objc_property_t property, const char *attributeName) 拷贝 property的attributeName的值\n\nobjc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int*outCount) 拷贝property的数组 个数是outCount\n\n```\n其实runtime的很多函数在平时我们是用不到的，但是还是要了解一点的，以便于有时候出现的问题，自己却不知道原理，那样解决问题，有时解决了但是还不知道为什么。[至于runtime的源码在这里](http://www.opensource.apple.com/tarballs/objc4/),要下载就下载版本最高的，感兴趣的可以看一下。\n","source":"_posts/iOS高级开发runtime那点事实战（4）.md","raw":"title: iOS高级开发runtime那点事实战（4）\ndate: 2016-03-28 14:19:20\ntags:\n- iOS\n- iOS高级开发\ncategories: iOS\n---\n### Category\nCategory是表示一个指向分类的结构体的指针，其定义如下：\n```\ntypedef struct objc_category *Category;\n\n\n\nstruct objc_category {\n\n    char *category_name                          OBJC2_UNAVAILABLE; // 分类名\n\n    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名\n\n    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表\n\n    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表\n\n    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n} \n```\n\n### Protocol\nProtocol定义：\n\n```\ntypedef struct objc_object Protocol;\n\n// 返回指定的协议\n\nProtocol * objc_getProtocol ( const char *name );\n\n\n\n// 获取运行时所知道的所有协议的数组\n\nProtocol ** objc_copyProtocolList ( unsigned int *outCount );\n\n\n\n// 创建新的协议实例\n\nProtocol * objc_allocateProtocol ( const char *name );\n\n\n\n// 在运行时中注册新创建的协议\n\nvoid objc_registerProtocol ( Protocol *proto );\n\n\n\n// 为协议添加方法\n\nvoid protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n\n\n// 添加一个已注册的协议到协议中\n\nvoid protocol_addProtocol ( Protocol *proto, Protocol *addition );\n\n\n\n// 为协议添加属性\n\nvoid protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n\n\n// 返回协议名\n\nconst char * protocol_getName ( Protocol *p );\n\n\n\n// 测试两个协议是否相等\n\nBOOL protocol_isEqual ( Protocol *proto, Protocol *other );\n\n\n\n// 获取协议中指定条件的方法的方法描述数组\n\nstruct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );\n\n\n\n// 获取协议中指定方法的方法描述\n\nstruct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n\n\n// 获取协议中的属性列表\n\nobjc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );\n\n\n\n// 获取协议的指定属性\n\nobjc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n\n\n// 获取协议采用的协议\n\nProtocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );\n\n\n\n// 查看协议是否采用了另一个协议\n\nBOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );\n```\n### 属性\n\n```\n\nconst char *property_getName(objc_property_t property) 获得property的name\n\nconst char *property_getAttributes(objc_property_t property) //获得property的atttibutes\n\nchar *property_copyAttributeValue(objc_property_t property, const char *attributeName) 拷贝 property的attributeName的值\n\nobjc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int*outCount) 拷贝property的数组 个数是outCount\n\n```\n其实runtime的很多函数在平时我们是用不到的，但是还是要了解一点的，以便于有时候出现的问题，自己却不知道原理，那样解决问题，有时解决了但是还不知道为什么。[至于runtime的源码在这里](http://www.opensource.apple.com/tarballs/objc4/),要下载就下载版本最高的，感兴趣的可以看一下。\n","slug":"iOS高级开发runtime那点事实战（4）","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi7100189zskk45a7xg1","content":"<h3 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h3><p>Category是表示一个指向分类的结构体的指针，其定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_category *Category;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct objc_category &#123;</div><div class=\"line\"></div><div class=\"line\">    char *category_name                          OBJC2_UNAVAILABLE; // 分类名</div><div class=\"line\"></div><div class=\"line\">    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名</div><div class=\"line\"></div><div class=\"line\">    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表</div><div class=\"line\"></div><div class=\"line\">    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表</div><div class=\"line\"></div><div class=\"line\">    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h3><p>Protocol定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_object Protocol;</div><div class=\"line\"></div><div class=\"line\">// 返回指定的协议</div><div class=\"line\"></div><div class=\"line\">Protocol * objc_getProtocol ( const char *name );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取运行时所知道的所有协议的数组</div><div class=\"line\"></div><div class=\"line\">Protocol ** objc_copyProtocolList ( unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 创建新的协议实例</div><div class=\"line\"></div><div class=\"line\">Protocol * objc_allocateProtocol ( const char *name );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 在运行时中注册新创建的协议</div><div class=\"line\"></div><div class=\"line\">void objc_registerProtocol ( Protocol *proto );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 为协议添加方法</div><div class=\"line\"></div><div class=\"line\">void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 添加一个已注册的协议到协议中</div><div class=\"line\"></div><div class=\"line\">void protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 为协议添加属性</div><div class=\"line\"></div><div class=\"line\">void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 返回协议名</div><div class=\"line\"></div><div class=\"line\">const char * protocol_getName ( Protocol *p );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 测试两个协议是否相等</div><div class=\"line\"></div><div class=\"line\">BOOL protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中指定条件的方法的方法描述数组</div><div class=\"line\"></div><div class=\"line\">struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中指定方法的方法描述</div><div class=\"line\"></div><div class=\"line\">struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中的属性列表</div><div class=\"line\"></div><div class=\"line\">objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议的指定属性</div><div class=\"line\"></div><div class=\"line\">objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议采用的协议</div><div class=\"line\"></div><div class=\"line\">Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 查看协议是否采用了另一个协议</div><div class=\"line\"></div><div class=\"line\">BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">const char *property_getName(objc_property_t property) 获得property的name</div><div class=\"line\"></div><div class=\"line\">const char *property_getAttributes(objc_property_t property) //获得property的atttibutes</div><div class=\"line\"></div><div class=\"line\">char *property_copyAttributeValue(objc_property_t property, const char *attributeName) 拷贝 property的attributeName的值</div><div class=\"line\"></div><div class=\"line\">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int*outCount) 拷贝property的数组 个数是outCount</div></pre></td></tr></table></figure>\n<p>其实runtime的很多函数在平时我们是用不到的，但是还是要了解一点的，以便于有时候出现的问题，自己却不知道原理，那样解决问题，有时解决了但是还不知道为什么。<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">至于runtime的源码在这里</a>,要下载就下载版本最高的，感兴趣的可以看一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h3><p>Category是表示一个指向分类的结构体的指针，其定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_category *Category;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">struct objc_category &#123;</div><div class=\"line\"></div><div class=\"line\">    char *category_name                          OBJC2_UNAVAILABLE; // 分类名</div><div class=\"line\"></div><div class=\"line\">    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名</div><div class=\"line\"></div><div class=\"line\">    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表</div><div class=\"line\"></div><div class=\"line\">    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表</div><div class=\"line\"></div><div class=\"line\">    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h3><p>Protocol定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_object Protocol;</div><div class=\"line\"></div><div class=\"line\">// 返回指定的协议</div><div class=\"line\"></div><div class=\"line\">Protocol * objc_getProtocol ( const char *name );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取运行时所知道的所有协议的数组</div><div class=\"line\"></div><div class=\"line\">Protocol ** objc_copyProtocolList ( unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 创建新的协议实例</div><div class=\"line\"></div><div class=\"line\">Protocol * objc_allocateProtocol ( const char *name );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 在运行时中注册新创建的协议</div><div class=\"line\"></div><div class=\"line\">void objc_registerProtocol ( Protocol *proto );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 为协议添加方法</div><div class=\"line\"></div><div class=\"line\">void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 添加一个已注册的协议到协议中</div><div class=\"line\"></div><div class=\"line\">void protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 为协议添加属性</div><div class=\"line\"></div><div class=\"line\">void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 返回协议名</div><div class=\"line\"></div><div class=\"line\">const char * protocol_getName ( Protocol *p );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 测试两个协议是否相等</div><div class=\"line\"></div><div class=\"line\">BOOL protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中指定条件的方法的方法描述数组</div><div class=\"line\"></div><div class=\"line\">struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中指定方法的方法描述</div><div class=\"line\"></div><div class=\"line\">struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议中的属性列表</div><div class=\"line\"></div><div class=\"line\">objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议的指定属性</div><div class=\"line\"></div><div class=\"line\">objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 获取协议采用的协议</div><div class=\"line\"></div><div class=\"line\">Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 查看协议是否采用了另一个协议</div><div class=\"line\"></div><div class=\"line\">BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">const char *property_getName(objc_property_t property) 获得property的name</div><div class=\"line\"></div><div class=\"line\">const char *property_getAttributes(objc_property_t property) //获得property的atttibutes</div><div class=\"line\"></div><div class=\"line\">char *property_copyAttributeValue(objc_property_t property, const char *attributeName) 拷贝 property的attributeName的值</div><div class=\"line\"></div><div class=\"line\">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int*outCount) 拷贝property的数组 个数是outCount</div></pre></td></tr></table></figure>\n<p>其实runtime的很多函数在平时我们是用不到的，但是还是要了解一点的，以便于有时候出现的问题，自己却不知道原理，那样解决问题，有时解决了但是还不知道为什么。<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\">至于runtime的源码在这里</a>,要下载就下载版本最高的，感兴趣的可以看一下。</p>\n"},{"title":"二叉树的4种遍历","date":"2017-05-07T08:39:24.000Z","_content":"## 树\n> 定义:二叉树是n（n>0）个节点的有限集合，该集合或者为空集（空二叉树）,或者由一个根节点和两棵互不相交分别称为根节点的左子树和右子树的二叉树组成。\n\n*** 注意：***\n- n>0 时节点是唯一的，不可能存在多个节点，别和现实中的树木混在一起。\n- m>0 时，子树的个数没有限制，但是一定是不交互的。\n\n## 树的四种遍历\n> 遍历：二叉树的遍历是指从根节点出发,按照某种次序依次访问二叉树中所有节点,使得每个节点被访问依次且被访问依次。\n\n- 前序遍历\n- 中序遍历\n- 后序遍历\n- 层序遍历\n\n### 前序遍历\n>定义：规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。优先级：根->左->右\n\n### 中序遍历\n>定义：规则是树若为空，操作返回，否则从根节点开始，中序遍历(注意并不是访问根节点)根节点的左子树，然后访问根节点，最后中序遍历右子树。优先级：左->根->右\n\n### 后序遍历\n>定义：规则是若树空,操作返回，否则是从左到右先叶子后节点的方式遍历访问左右子树，最后是访问跟节点。优先级：左->右->根\n\n### 层序遍历\n>定义：规则是若树空,操作返回，否则是从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，从左到右的顺序对节点逐个访问。优先级：左->右->根\n\n## 代码示例4中遍历\n\n```\n\n\n这四种遍历示例：   \n\n             A\n          /    \\\n        B        C\n      /  \\      /  \\ \n     D    E     F   G  \n 层序遍历结果是:  ABCDEFG\n 前序遍历结果是:  ABDECFG\n 中序遍历结果是:  DBEAFCG\n 后序遍历结果是:  DEBFGCA\n\n\n\n//节点对象\n@interface Node : NSObject\n\n@property (nonatomic) NSInteger data;//存储的数据\n\n@property (nonatomic) Node * leftNode; //左节点\n\n@property (nonatomic) Node * rightNode; //右节点\n\n@end\n\n@implementation Node\n\n@end\n```\n每一种遍历其实都是递归，只是递归的时候，处理数据的代码时机不一样。\n```\n\n//前序 遍历\n/*\n 规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。跟->左->右\n \n */\n-(void)printNode:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    NSLog(@\"%ld\",node.data);\n    [self printNode:node.leftNode];\n    [self printNode:node.rightNode];\n}\n// 中序遍历   从 左子树【左->跟->右】\n-(void)printCenterNode:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    [self printCenterNode:node.leftNode];\n     NSLog(@\"%ld\",node.data);\n    [self printCenterNode:node.rightNode];\n}\n\n// 后序遍历   从 左子树【左->右->跟】\n-(void)print2Node:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    [self print2Node:node.leftNode];\n    [self print2Node:node.rightNode];\n    NSLog(@\"%ld\",node.data);//节点数据可以进行其他操作\n}\n\n/*\n 层序遍历暂时没有代码示例。\n */\n\n//构造节点\n-(Node *)randNode{\n    Node * node =[Node new];\n    node.data = rand()%20 + 1;\n    return node;\n}\n\n```\n","source":"_posts/二叉树的4种遍历.md","raw":"title: 二叉树的4种遍历\ndate: 2017-5-7 16:39:24\ntags: \n- 数据结构 \n- 二叉树\ncategories: 数据结构 \n---\n## 树\n> 定义:二叉树是n（n>0）个节点的有限集合，该集合或者为空集（空二叉树）,或者由一个根节点和两棵互不相交分别称为根节点的左子树和右子树的二叉树组成。\n\n*** 注意：***\n- n>0 时节点是唯一的，不可能存在多个节点，别和现实中的树木混在一起。\n- m>0 时，子树的个数没有限制，但是一定是不交互的。\n\n## 树的四种遍历\n> 遍历：二叉树的遍历是指从根节点出发,按照某种次序依次访问二叉树中所有节点,使得每个节点被访问依次且被访问依次。\n\n- 前序遍历\n- 中序遍历\n- 后序遍历\n- 层序遍历\n\n### 前序遍历\n>定义：规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。优先级：根->左->右\n\n### 中序遍历\n>定义：规则是树若为空，操作返回，否则从根节点开始，中序遍历(注意并不是访问根节点)根节点的左子树，然后访问根节点，最后中序遍历右子树。优先级：左->根->右\n\n### 后序遍历\n>定义：规则是若树空,操作返回，否则是从左到右先叶子后节点的方式遍历访问左右子树，最后是访问跟节点。优先级：左->右->根\n\n### 层序遍历\n>定义：规则是若树空,操作返回，否则是从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，从左到右的顺序对节点逐个访问。优先级：左->右->根\n\n## 代码示例4中遍历\n\n```\n\n\n这四种遍历示例：   \n\n             A\n          /    \\\n        B        C\n      /  \\      /  \\ \n     D    E     F   G  \n 层序遍历结果是:  ABCDEFG\n 前序遍历结果是:  ABDECFG\n 中序遍历结果是:  DBEAFCG\n 后序遍历结果是:  DEBFGCA\n\n\n\n//节点对象\n@interface Node : NSObject\n\n@property (nonatomic) NSInteger data;//存储的数据\n\n@property (nonatomic) Node * leftNode; //左节点\n\n@property (nonatomic) Node * rightNode; //右节点\n\n@end\n\n@implementation Node\n\n@end\n```\n每一种遍历其实都是递归，只是递归的时候，处理数据的代码时机不一样。\n```\n\n//前序 遍历\n/*\n 规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。跟->左->右\n \n */\n-(void)printNode:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    NSLog(@\"%ld\",node.data);\n    [self printNode:node.leftNode];\n    [self printNode:node.rightNode];\n}\n// 中序遍历   从 左子树【左->跟->右】\n-(void)printCenterNode:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    [self printCenterNode:node.leftNode];\n     NSLog(@\"%ld\",node.data);\n    [self printCenterNode:node.rightNode];\n}\n\n// 后序遍历   从 左子树【左->右->跟】\n-(void)print2Node:(Node *)node{\n    if (node == nil) {\n        return;\n    }\n    [self print2Node:node.leftNode];\n    [self print2Node:node.rightNode];\n    NSLog(@\"%ld\",node.data);//节点数据可以进行其他操作\n}\n\n/*\n 层序遍历暂时没有代码示例。\n */\n\n//构造节点\n-(Node *)randNode{\n    Node * node =[Node new];\n    node.data = rand()%20 + 1;\n    return node;\n}\n\n```\n","slug":"二叉树的4种遍历","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi72001b9zskmkd24elg","content":"<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><blockquote>\n<p>定义:二叉树是n（n&gt;0）个节点的有限集合，该集合或者为空集（空二叉树）,或者由一个根节点和两棵互不相交分别称为根节点的左子树和右子树的二叉树组成。</p>\n</blockquote>\n<p><strong><em> 注意：</em></strong></p>\n<ul>\n<li>n&gt;0 时节点是唯一的，不可能存在多个节点，别和现实中的树木混在一起。</li>\n<li>m&gt;0 时，子树的个数没有限制，但是一定是不交互的。</li>\n</ul>\n<h2 id=\"树的四种遍历\"><a href=\"#树的四种遍历\" class=\"headerlink\" title=\"树的四种遍历\"></a>树的四种遍历</h2><blockquote>\n<p>遍历：二叉树的遍历是指从根节点出发,按照某种次序依次访问二叉树中所有节点,使得每个节点被访问依次且被访问依次。</p>\n</blockquote>\n<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n<h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><blockquote>\n<p>定义：规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。优先级：根-&gt;左-&gt;右</p>\n</blockquote>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><blockquote>\n<p>定义：规则是树若为空，操作返回，否则从根节点开始，中序遍历(注意并不是访问根节点)根节点的左子树，然后访问根节点，最后中序遍历右子树。优先级：左-&gt;根-&gt;右</p>\n</blockquote>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><blockquote>\n<p>定义：规则是若树空,操作返回，否则是从左到右先叶子后节点的方式遍历访问左右子树，最后是访问跟节点。优先级：左-&gt;右-&gt;根</p>\n</blockquote>\n<h3 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h3><blockquote>\n<p>定义：规则是若树空,操作返回，否则是从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，从左到右的顺序对节点逐个访问。优先级：左-&gt;右-&gt;根</p>\n</blockquote>\n<h2 id=\"代码示例4中遍历\"><a href=\"#代码示例4中遍历\" class=\"headerlink\" title=\"代码示例4中遍历\"></a>代码示例4中遍历</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">这四种遍历示例：   </div><div class=\"line\"></div><div class=\"line\">             A</div><div class=\"line\">          /    \\</div><div class=\"line\">        B        C</div><div class=\"line\">      /  \\      /  \\ </div><div class=\"line\">     D    E     F   G  </div><div class=\"line\"> 层序遍历结果是:  ABCDEFG</div><div class=\"line\"> 前序遍历结果是:  ABDECFG</div><div class=\"line\"> 中序遍历结果是:  DBEAFCG</div><div class=\"line\"> 后序遍历结果是:  DEBFGCA</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//节点对象</div><div class=\"line\">@interface Node : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) NSInteger data;//存储的数据</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) Node * leftNode; //左节点</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) Node * rightNode; //右节点</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Node</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>每一种遍历其实都是递归，只是递归的时候，处理数据的代码时机不一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//前序 遍历</div><div class=\"line\">/*</div><div class=\"line\"> 规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。跟-&gt;左-&gt;右</div><div class=\"line\"> </div><div class=\"line\"> */</div><div class=\"line\">-(void)printNode:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,node.data);</div><div class=\"line\">    [self printNode:node.leftNode];</div><div class=\"line\">    [self printNode:node.rightNode];</div><div class=\"line\">&#125;</div><div class=\"line\">// 中序遍历   从 左子树【左-&gt;跟-&gt;右】</div><div class=\"line\">-(void)printCenterNode:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self printCenterNode:node.leftNode];</div><div class=\"line\">     NSLog(@&quot;%ld&quot;,node.data);</div><div class=\"line\">    [self printCenterNode:node.rightNode];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 后序遍历   从 左子树【左-&gt;右-&gt;跟】</div><div class=\"line\">-(void)print2Node:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self print2Node:node.leftNode];</div><div class=\"line\">    [self print2Node:node.rightNode];</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,node.data);//节点数据可以进行其他操作</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"> 层序遍历暂时没有代码示例。</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">//构造节点</div><div class=\"line\">-(Node *)randNode&#123;</div><div class=\"line\">    Node * node =[Node new];</div><div class=\"line\">    node.data = rand()%20 + 1;</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><blockquote>\n<p>定义:二叉树是n（n&gt;0）个节点的有限集合，该集合或者为空集（空二叉树）,或者由一个根节点和两棵互不相交分别称为根节点的左子树和右子树的二叉树组成。</p>\n</blockquote>\n<p><strong><em> 注意：</em></strong></p>\n<ul>\n<li>n&gt;0 时节点是唯一的，不可能存在多个节点，别和现实中的树木混在一起。</li>\n<li>m&gt;0 时，子树的个数没有限制，但是一定是不交互的。</li>\n</ul>\n<h2 id=\"树的四种遍历\"><a href=\"#树的四种遍历\" class=\"headerlink\" title=\"树的四种遍历\"></a>树的四种遍历</h2><blockquote>\n<p>遍历：二叉树的遍历是指从根节点出发,按照某种次序依次访问二叉树中所有节点,使得每个节点被访问依次且被访问依次。</p>\n</blockquote>\n<ul>\n<li>前序遍历</li>\n<li>中序遍历</li>\n<li>后序遍历</li>\n<li>层序遍历</li>\n</ul>\n<h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><blockquote>\n<p>定义：规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。优先级：根-&gt;左-&gt;右</p>\n</blockquote>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><blockquote>\n<p>定义：规则是树若为空，操作返回，否则从根节点开始，中序遍历(注意并不是访问根节点)根节点的左子树，然后访问根节点，最后中序遍历右子树。优先级：左-&gt;根-&gt;右</p>\n</blockquote>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><blockquote>\n<p>定义：规则是若树空,操作返回，否则是从左到右先叶子后节点的方式遍历访问左右子树，最后是访问跟节点。优先级：左-&gt;右-&gt;根</p>\n</blockquote>\n<h3 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h3><blockquote>\n<p>定义：规则是若树空,操作返回，否则是从树的第一层，也就是从根节点开始访问，从上而下逐层遍历，在同一层中，从左到右的顺序对节点逐个访问。优先级：左-&gt;右-&gt;根</p>\n</blockquote>\n<h2 id=\"代码示例4中遍历\"><a href=\"#代码示例4中遍历\" class=\"headerlink\" title=\"代码示例4中遍历\"></a>代码示例4中遍历</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">这四种遍历示例：   </div><div class=\"line\"></div><div class=\"line\">             A</div><div class=\"line\">          /    \\</div><div class=\"line\">        B        C</div><div class=\"line\">      /  \\      /  \\ </div><div class=\"line\">     D    E     F   G  </div><div class=\"line\"> 层序遍历结果是:  ABCDEFG</div><div class=\"line\"> 前序遍历结果是:  ABDECFG</div><div class=\"line\"> 中序遍历结果是:  DBEAFCG</div><div class=\"line\"> 后序遍历结果是:  DEBFGCA</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//节点对象</div><div class=\"line\">@interface Node : NSObject</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) NSInteger data;//存储的数据</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) Node * leftNode; //左节点</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic) Node * rightNode; //右节点</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Node</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>每一种遍历其实都是递归，只是递归的时候，处理数据的代码时机不一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//前序 遍历</div><div class=\"line\">/*</div><div class=\"line\"> 规则是若二叉树为空，则空操作返回。 否则先访问跟节点，然后前序遍历左子树，再遍历右子树。跟-&gt;左-&gt;右</div><div class=\"line\"> </div><div class=\"line\"> */</div><div class=\"line\">-(void)printNode:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,node.data);</div><div class=\"line\">    [self printNode:node.leftNode];</div><div class=\"line\">    [self printNode:node.rightNode];</div><div class=\"line\">&#125;</div><div class=\"line\">// 中序遍历   从 左子树【左-&gt;跟-&gt;右】</div><div class=\"line\">-(void)printCenterNode:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self printCenterNode:node.leftNode];</div><div class=\"line\">     NSLog(@&quot;%ld&quot;,node.data);</div><div class=\"line\">    [self printCenterNode:node.rightNode];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 后序遍历   从 左子树【左-&gt;右-&gt;跟】</div><div class=\"line\">-(void)print2Node:(Node *)node&#123;</div><div class=\"line\">    if (node == nil) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self print2Node:node.leftNode];</div><div class=\"line\">    [self print2Node:node.rightNode];</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,node.data);//节点数据可以进行其他操作</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"> 层序遍历暂时没有代码示例。</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">//构造节点</div><div class=\"line\">-(Node *)randNode&#123;</div><div class=\"line\">    Node * node =[Node new];</div><div class=\"line\">    node.data = rand()%20 + 1;</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"微信小程序_2","date":"2016-11-05T08:39:24.000Z","_content":"## 1.swiper的使用\n这个类似iOS的滚动视图，里边也可以放一下其他的东西。\n先讲一下属性：\n\n\n|属性名\t            |                      类型 |       \t        默认值\t|                  说明|\n| --------------- | :-----------------: |----------------------|-----------------|\n|indicator-dots|\t  Boolean\t  |       false\t        |是否显示面板指示点|\n|autoplay\t             |     Boolean\t   |     false\t      |是否自动切换|\n|current\t|Number|\t0|\t当前所在页面的 index|\n|interval|\tNumber|\t5000|\t自动切换时间间隔|\n|duration|\tNumber\t|1000\t|滑动动画时长|\n|bindchange|\tEventHandle|\t\t|current 改变时会触发 change 事件，event.detail = {current: current}\n### swiper.js文件\n```\nvar app = getApp();\nPage({\n  data:{\n    indicatordos:true,\n    autoplay:true,\n/*图片数组*/\n    imgUrls: [\n      'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg',\n      'http://imgsrc.baidu.com/forum/pic/item/1080fc8b87d6277f026c80b428381f30e824fc46.jpg',\n      'http://imgsrc.baidu.com/forum/pic/item/2eadcbef76094b366ac0bf0da3cc7cd98c109d84.jpg',\n      'http://img1.tgbusdata.cn/v2/thumb/jpg/MGNlNiw3MzAsNzMwLDQsMSwxLC0xLDAscms1MA==/u/olpic.tgbusdata.cn/uploads/allimg/130124/62-130124160054.jpg'\n    ],\n    vertical:true,\n  },\n  \n  displaychange:function(event){\n      console.log(event.detail.current);//输出来当前swiper-item的index\n   },\n\n  changeautodisplay:function(){\n    this.setData({\n      autoplay:!this.data.autoplay//设置是否自动播放\n  })\n  },\n  changeindicator:function(){\n    this.setData({\n  indicatordos:!this.data.indicatordos//隐藏图片那个点\n})\n  },\n  changevertical:function(){\n    this.setData({//设置水平方向\n      vertical:!this.data.vertical\n    })\n  }\n\n})\n```\n#### swiper.xml文件\n```\n<view class=\"container\">\n    <view class=\"swiperview\">\n        <swiper class=\"swiperitem\" indicator-dots=\"{{indicatordos}}\" autoplay=\"{{autoplay}}\"\n          bindchange=\"displaychange\" duration=\"1000\" interval=\"2000\"\n          vertical=\"{{vertical}}\"\n        >\n        <block wx:for=\"{{imgUrls}}\">\n            <swiper-item>\n                <image src=\"{{item}}\"></image>\n            </swiper-item>\n        </block>\n        </swiper>\n    </view>\n    <view vlass=\"bottomview\">\n        <button type=\"default\" bindtap=\"changeautodisplay\" class=\"bottomButton\">autodisplay:{{autoplay?\"YES\":\"NO\"}}</button>\n        <button type=\"default\" bindtap=\"changeindicator\" class=\"bottomButton\">indicatordots:{{autoplay?\"YES\":\"NO\"}}</button>\n        <button type=\"default\" bindtap=\"changevertical\" class=\"bottomButton\">水平:{{autoplay?\"YES\":\"NO\"}}</button>\n//这里边用了一个简单的判断语句 :{{autoplay?\"YES\":\"NO\"\n    </view>\n</view>\n```\n效果如下:\n\n![2016-11-07 17_27_56.gif](http://upload-images.jianshu.io/upload_images/783986-f75545234a080c18.gif?imageMogr2/auto-orient/strip)\n\n\n\n\n## 2.checkbox的使用\n其实就是复选框：\n\n![E935B5E6-0FC3-4A00-813C-9A259C2582AE.png](http://upload-images.jianshu.io/upload_images/783986-26e5a47de1bf531a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n下边用了text显示了当前选中的name。\n**js文件**\n```\n首先要设置data的list\nPage({\n  data:{\n     items: [\n      {name: 'USA', value: '美国'},\n      {name: 'CHN', value: '中国', checked: 'true'},\n      {name: 'BRA', value: '巴西'},\n      {name: 'JPN', value: '日本'},\n      {name: 'ENG', value: '英国'},\n      {name: 'TUR', value: '法国'},\n    ],\n    text:'',//用来显示选中的box\n  },\n  \n  onShow:function(){\n    // 页面显示 第一次进入页面统计选中的box 调用函数。\n    this.check();\n  },\n  \n  change:function(e){\n      console.log(e.detail.value);\n      var te=\"暂时没选中\";\n      if(e.detail.value.length == 0)\n        { \n        } else {\n         te = e.detail.value;\n        }\n         this.setData({\n        text:te\n      })\n      \n  },\n********遍历是否有选中的***********\n  check:function(){\n    var te=\"\";//遍历是否有选中的\n    for(var i = 0;i < this.data.items.length;i ++){\n      var item = this.data.items[i];\n      if(item.checked){ //如果选中 加到字符串中\n        te += item.value;\n      }\n    }\n      if(te.length == 0)\n        { \n         te = \"暂时没选中\" ;\n        }\n         this.setData({\n        text:te\n      })\n    }\n})\n```\n\n\n**xml文件**\n```\n<view class = \"contain\">\n    <view class=\"bd\">\n        <checkbox-group bindchange=\"change\"> //绑定事件\n            <label class=\"checkbox\" wx:for=\"{{items}}\">//循环绑定到item\n                <checkbox value=\"{{item.value}}\" checked=\"{{item.checked}}\"\n                > \n                {{item.value}}\n                </checkbox>\n            </label>\n        </checkbox-group>\n    </view>\n\n    <view class=\"checkfooter\">\n    <text >{{text}}</text>//显示选中的数据的name\n    </view>\n</view>\n```\n\n**css文件**\n```\n.bd{\n    width: 800rpx;\n    height: 500rpx;\n    margin-left: 50rpx;\n}\n.checkbox{\n   display: block;//这个要一定写的 暂时没搞懂意思  应该是一种布局方式。\n   margin: 20;\n}\n.checklabel{\n    width: 500rpx;\n    height: 200rpx;\n}\n.checkfooter{\n    margin-left: 50rpx;\n}\n```\n效果如下：\n\n![2016-11-07 17_13_36.gif](http://upload-images.jianshu.io/upload_images/783986-274e66a04bdd68da.gif?imageMogr2/auto-orient/strip)\n\n很多代码的地方都写了注释，有什么不懂或者疑问，欢迎来吐槽！\n[demo地址](https://github.com/ifgyong/WeChatDemo)\n[微信小程序_01](http://fgyong.cn/2016/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_01/)\n","source":"_posts/微信小程序_02.md","raw":"title: 微信小程序_2\ndate: 2016-11-05 16:39:24\ntags: 微信小程序\ncategories: 微信小程序\n---\n## 1.swiper的使用\n这个类似iOS的滚动视图，里边也可以放一下其他的东西。\n先讲一下属性：\n\n\n|属性名\t            |                      类型 |       \t        默认值\t|                  说明|\n| --------------- | :-----------------: |----------------------|-----------------|\n|indicator-dots|\t  Boolean\t  |       false\t        |是否显示面板指示点|\n|autoplay\t             |     Boolean\t   |     false\t      |是否自动切换|\n|current\t|Number|\t0|\t当前所在页面的 index|\n|interval|\tNumber|\t5000|\t自动切换时间间隔|\n|duration|\tNumber\t|1000\t|滑动动画时长|\n|bindchange|\tEventHandle|\t\t|current 改变时会触发 change 事件，event.detail = {current: current}\n### swiper.js文件\n```\nvar app = getApp();\nPage({\n  data:{\n    indicatordos:true,\n    autoplay:true,\n/*图片数组*/\n    imgUrls: [\n      'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg',\n      'http://imgsrc.baidu.com/forum/pic/item/1080fc8b87d6277f026c80b428381f30e824fc46.jpg',\n      'http://imgsrc.baidu.com/forum/pic/item/2eadcbef76094b366ac0bf0da3cc7cd98c109d84.jpg',\n      'http://img1.tgbusdata.cn/v2/thumb/jpg/MGNlNiw3MzAsNzMwLDQsMSwxLC0xLDAscms1MA==/u/olpic.tgbusdata.cn/uploads/allimg/130124/62-130124160054.jpg'\n    ],\n    vertical:true,\n  },\n  \n  displaychange:function(event){\n      console.log(event.detail.current);//输出来当前swiper-item的index\n   },\n\n  changeautodisplay:function(){\n    this.setData({\n      autoplay:!this.data.autoplay//设置是否自动播放\n  })\n  },\n  changeindicator:function(){\n    this.setData({\n  indicatordos:!this.data.indicatordos//隐藏图片那个点\n})\n  },\n  changevertical:function(){\n    this.setData({//设置水平方向\n      vertical:!this.data.vertical\n    })\n  }\n\n})\n```\n#### swiper.xml文件\n```\n<view class=\"container\">\n    <view class=\"swiperview\">\n        <swiper class=\"swiperitem\" indicator-dots=\"{{indicatordos}}\" autoplay=\"{{autoplay}}\"\n          bindchange=\"displaychange\" duration=\"1000\" interval=\"2000\"\n          vertical=\"{{vertical}}\"\n        >\n        <block wx:for=\"{{imgUrls}}\">\n            <swiper-item>\n                <image src=\"{{item}}\"></image>\n            </swiper-item>\n        </block>\n        </swiper>\n    </view>\n    <view vlass=\"bottomview\">\n        <button type=\"default\" bindtap=\"changeautodisplay\" class=\"bottomButton\">autodisplay:{{autoplay?\"YES\":\"NO\"}}</button>\n        <button type=\"default\" bindtap=\"changeindicator\" class=\"bottomButton\">indicatordots:{{autoplay?\"YES\":\"NO\"}}</button>\n        <button type=\"default\" bindtap=\"changevertical\" class=\"bottomButton\">水平:{{autoplay?\"YES\":\"NO\"}}</button>\n//这里边用了一个简单的判断语句 :{{autoplay?\"YES\":\"NO\"\n    </view>\n</view>\n```\n效果如下:\n\n![2016-11-07 17_27_56.gif](http://upload-images.jianshu.io/upload_images/783986-f75545234a080c18.gif?imageMogr2/auto-orient/strip)\n\n\n\n\n## 2.checkbox的使用\n其实就是复选框：\n\n![E935B5E6-0FC3-4A00-813C-9A259C2582AE.png](http://upload-images.jianshu.io/upload_images/783986-26e5a47de1bf531a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n下边用了text显示了当前选中的name。\n**js文件**\n```\n首先要设置data的list\nPage({\n  data:{\n     items: [\n      {name: 'USA', value: '美国'},\n      {name: 'CHN', value: '中国', checked: 'true'},\n      {name: 'BRA', value: '巴西'},\n      {name: 'JPN', value: '日本'},\n      {name: 'ENG', value: '英国'},\n      {name: 'TUR', value: '法国'},\n    ],\n    text:'',//用来显示选中的box\n  },\n  \n  onShow:function(){\n    // 页面显示 第一次进入页面统计选中的box 调用函数。\n    this.check();\n  },\n  \n  change:function(e){\n      console.log(e.detail.value);\n      var te=\"暂时没选中\";\n      if(e.detail.value.length == 0)\n        { \n        } else {\n         te = e.detail.value;\n        }\n         this.setData({\n        text:te\n      })\n      \n  },\n********遍历是否有选中的***********\n  check:function(){\n    var te=\"\";//遍历是否有选中的\n    for(var i = 0;i < this.data.items.length;i ++){\n      var item = this.data.items[i];\n      if(item.checked){ //如果选中 加到字符串中\n        te += item.value;\n      }\n    }\n      if(te.length == 0)\n        { \n         te = \"暂时没选中\" ;\n        }\n         this.setData({\n        text:te\n      })\n    }\n})\n```\n\n\n**xml文件**\n```\n<view class = \"contain\">\n    <view class=\"bd\">\n        <checkbox-group bindchange=\"change\"> //绑定事件\n            <label class=\"checkbox\" wx:for=\"{{items}}\">//循环绑定到item\n                <checkbox value=\"{{item.value}}\" checked=\"{{item.checked}}\"\n                > \n                {{item.value}}\n                </checkbox>\n            </label>\n        </checkbox-group>\n    </view>\n\n    <view class=\"checkfooter\">\n    <text >{{text}}</text>//显示选中的数据的name\n    </view>\n</view>\n```\n\n**css文件**\n```\n.bd{\n    width: 800rpx;\n    height: 500rpx;\n    margin-left: 50rpx;\n}\n.checkbox{\n   display: block;//这个要一定写的 暂时没搞懂意思  应该是一种布局方式。\n   margin: 20;\n}\n.checklabel{\n    width: 500rpx;\n    height: 200rpx;\n}\n.checkfooter{\n    margin-left: 50rpx;\n}\n```\n效果如下：\n\n![2016-11-07 17_13_36.gif](http://upload-images.jianshu.io/upload_images/783986-274e66a04bdd68da.gif?imageMogr2/auto-orient/strip)\n\n很多代码的地方都写了注释，有什么不懂或者疑问，欢迎来吐槽！\n[demo地址](https://github.com/ifgyong/WeChatDemo)\n[微信小程序_01](http://fgyong.cn/2016/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_01/)\n","slug":"微信小程序_02","published":1,"updated":"2019-12-03T04:48:00.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi73001c9zskn196hy2n","content":"<h2 id=\"1-swiper的使用\"><a href=\"#1-swiper的使用\" class=\"headerlink\" title=\"1.swiper的使用\"></a>1.swiper的使用</h2><p>这个类似iOS的滚动视图，里边也可以放一下其他的东西。<br>先讲一下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th style=\"text-align:center\">类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>indicator-dots</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>false</td>\n<td>是否显示面板指示点</td>\n</tr>\n<tr>\n<td>autoplay</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>false</td>\n<td>是否自动切换</td>\n</tr>\n<tr>\n<td>current</td>\n<td style=\"text-align:center\">Number</td>\n<td>0</td>\n<td>当前所在页面的 index</td>\n</tr>\n<tr>\n<td>interval</td>\n<td style=\"text-align:center\">Number</td>\n<td>5000</td>\n<td>自动切换时间间隔</td>\n</tr>\n<tr>\n<td>duration</td>\n<td style=\"text-align:center\">Number</td>\n<td>1000</td>\n<td>滑动动画时长</td>\n</tr>\n<tr>\n<td>bindchange</td>\n<td style=\"text-align:center\">EventHandle</td>\n<td></td>\n<td>current 改变时会触发 change 事件，event.detail = {current: current}</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"swiper-js文件\"><a href=\"#swiper-js文件\" class=\"headerlink\" title=\"swiper.js文件\"></a>swiper.js文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = getApp();</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    indicatordos:true,</div><div class=\"line\">    autoplay:true,</div><div class=\"line\">/*图片数组*/</div><div class=\"line\">    imgUrls: [</div><div class=\"line\">      &apos;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&apos;,</div><div class=\"line\">      &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg&apos;,</div><div class=\"line\">      &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&apos;,</div><div class=\"line\">      &apos;http://imgsrc.baidu.com/forum/pic/item/1080fc8b87d6277f026c80b428381f30e824fc46.jpg&apos;,</div><div class=\"line\">      &apos;http://imgsrc.baidu.com/forum/pic/item/2eadcbef76094b366ac0bf0da3cc7cd98c109d84.jpg&apos;,</div><div class=\"line\">      &apos;http://img1.tgbusdata.cn/v2/thumb/jpg/MGNlNiw3MzAsNzMwLDQsMSwxLC0xLDAscms1MA==/u/olpic.tgbusdata.cn/uploads/allimg/130124/62-130124160054.jpg&apos;</div><div class=\"line\">    ],</div><div class=\"line\">    vertical:true,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  displaychange:function(event)&#123;</div><div class=\"line\">      console.log(event.detail.current);//输出来当前swiper-item的index</div><div class=\"line\">   &#125;,</div><div class=\"line\"></div><div class=\"line\">  changeautodisplay:function()&#123;</div><div class=\"line\">    this.setData(&#123;</div><div class=\"line\">      autoplay:!this.data.autoplay//设置是否自动播放</div><div class=\"line\">  &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  changeindicator:function()&#123;</div><div class=\"line\">    this.setData(&#123;</div><div class=\"line\">  indicatordos:!this.data.indicatordos//隐藏图片那个点</div><div class=\"line\">&#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  changevertical:function()&#123;</div><div class=\"line\">    this.setData(&#123;//设置水平方向</div><div class=\"line\">      vertical:!this.data.vertical</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"swiper-xml文件\"><a href=\"#swiper-xml文件\" class=\"headerlink\" title=\"swiper.xml文件\"></a>swiper.xml文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view class=&quot;container&quot;&gt;</div><div class=\"line\">    &lt;view class=&quot;swiperview&quot;&gt;</div><div class=\"line\">        &lt;swiper class=&quot;swiperitem&quot; indicator-dots=&quot;&#123;&#123;indicatordos&#125;&#125;&quot; autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot;</div><div class=\"line\">          bindchange=&quot;displaychange&quot; duration=&quot;1000&quot; interval=&quot;2000&quot;</div><div class=\"line\">          vertical=&quot;&#123;&#123;vertical&#125;&#125;&quot;</div><div class=\"line\">        &gt;</div><div class=\"line\">        &lt;block wx:for=&quot;&#123;&#123;imgUrls&#125;&#125;&quot;&gt;</div><div class=\"line\">            &lt;swiper-item&gt;</div><div class=\"line\">                &lt;image src=&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;/image&gt;</div><div class=\"line\">            &lt;/swiper-item&gt;</div><div class=\"line\">        &lt;/block&gt;</div><div class=\"line\">        &lt;/swiper&gt;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">    &lt;view vlass=&quot;bottomview&quot;&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changeautodisplay&quot; class=&quot;bottomButton&quot;&gt;autodisplay:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changeindicator&quot; class=&quot;bottomButton&quot;&gt;indicatordots:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changevertical&quot; class=&quot;bottomButton&quot;&gt;水平:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">//这里边用了一个简单的判断语句 :&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure>\n<p>效果如下:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-f75545234a080c18.gif?imageMogr2/auto-orient/strip\" alt=\"2016-11-07 17_27_56.gif\"></p>\n<h2 id=\"2-checkbox的使用\"><a href=\"#2-checkbox的使用\" class=\"headerlink\" title=\"2.checkbox的使用\"></a>2.checkbox的使用</h2><p>其实就是复选框：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-26e5a47de1bf531a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"E935B5E6-0FC3-4A00-813C-9A259C2582AE.png\"><br>下边用了text显示了当前选中的name。<br><strong>js文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">首先要设置data的list</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">     items: [</div><div class=\"line\">      &#123;name: &apos;USA&apos;, value: &apos;美国&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;CHN&apos;, value: &apos;中国&apos;, checked: &apos;true&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;BRA&apos;, value: &apos;巴西&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;JPN&apos;, value: &apos;日本&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;ENG&apos;, value: &apos;英国&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;TUR&apos;, value: &apos;法国&apos;&#125;,</div><div class=\"line\">    ],</div><div class=\"line\">    text:&apos;&apos;,//用来显示选中的box</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  onShow:function()&#123;</div><div class=\"line\">    // 页面显示 第一次进入页面统计选中的box 调用函数。</div><div class=\"line\">    this.check();</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  change:function(e)&#123;</div><div class=\"line\">      console.log(e.detail.value);</div><div class=\"line\">      var te=&quot;暂时没选中&quot;;</div><div class=\"line\">      if(e.detail.value.length == 0)</div><div class=\"line\">        &#123; </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">         te = e.detail.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">         this.setData(&#123;</div><div class=\"line\">        text:te</div><div class=\"line\">      &#125;)</div><div class=\"line\">      </div><div class=\"line\">  &#125;,</div><div class=\"line\">********遍历是否有选中的***********</div><div class=\"line\">  check:function()&#123;</div><div class=\"line\">    var te=&quot;&quot;;//遍历是否有选中的</div><div class=\"line\">    for(var i = 0;i &lt; this.data.items.length;i ++)&#123;</div><div class=\"line\">      var item = this.data.items[i];</div><div class=\"line\">      if(item.checked)&#123; //如果选中 加到字符串中</div><div class=\"line\">        te += item.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">      if(te.length == 0)</div><div class=\"line\">        &#123; </div><div class=\"line\">         te = &quot;暂时没选中&quot; ;</div><div class=\"line\">        &#125;</div><div class=\"line\">         this.setData(&#123;</div><div class=\"line\">        text:te</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong>xml文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view class = &quot;contain&quot;&gt;</div><div class=\"line\">    &lt;view class=&quot;bd&quot;&gt;</div><div class=\"line\">        &lt;checkbox-group bindchange=&quot;change&quot;&gt; //绑定事件</div><div class=\"line\">            &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;//循环绑定到item</div><div class=\"line\">                &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot; checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot;</div><div class=\"line\">                &gt; </div><div class=\"line\">                &#123;&#123;item.value&#125;&#125;</div><div class=\"line\">                &lt;/checkbox&gt;</div><div class=\"line\">            &lt;/label&gt;</div><div class=\"line\">        &lt;/checkbox-group&gt;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;view class=&quot;checkfooter&quot;&gt;</div><div class=\"line\">    &lt;text &gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;//显示选中的数据的name</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>css文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.bd&#123;</div><div class=\"line\">    width: 800rpx;</div><div class=\"line\">    height: 500rpx;</div><div class=\"line\">    margin-left: 50rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.checkbox&#123;</div><div class=\"line\">   display: block;//这个要一定写的 暂时没搞懂意思  应该是一种布局方式。</div><div class=\"line\">   margin: 20;</div><div class=\"line\">&#125;</div><div class=\"line\">.checklabel&#123;</div><div class=\"line\">    width: 500rpx;</div><div class=\"line\">    height: 200rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.checkfooter&#123;</div><div class=\"line\">    margin-left: 50rpx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-274e66a04bdd68da.gif?imageMogr2/auto-orient/strip\" alt=\"2016-11-07 17_13_36.gif\"></p>\n<p>很多代码的地方都写了注释，有什么不懂或者疑问，欢迎来吐槽！<br><a href=\"https://github.com/ifgyong/WeChatDemo\" target=\"_blank\" rel=\"external\">demo地址</a><br><a href=\"http://fgyong.cn/2016/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_01/\">微信小程序_01</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-swiper的使用\"><a href=\"#1-swiper的使用\" class=\"headerlink\" title=\"1.swiper的使用\"></a>1.swiper的使用</h2><p>这个类似iOS的滚动视图，里边也可以放一下其他的东西。<br>先讲一下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th style=\"text-align:center\">类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>indicator-dots</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>false</td>\n<td>是否显示面板指示点</td>\n</tr>\n<tr>\n<td>autoplay</td>\n<td style=\"text-align:center\">Boolean</td>\n<td>false</td>\n<td>是否自动切换</td>\n</tr>\n<tr>\n<td>current</td>\n<td style=\"text-align:center\">Number</td>\n<td>0</td>\n<td>当前所在页面的 index</td>\n</tr>\n<tr>\n<td>interval</td>\n<td style=\"text-align:center\">Number</td>\n<td>5000</td>\n<td>自动切换时间间隔</td>\n</tr>\n<tr>\n<td>duration</td>\n<td style=\"text-align:center\">Number</td>\n<td>1000</td>\n<td>滑动动画时长</td>\n</tr>\n<tr>\n<td>bindchange</td>\n<td style=\"text-align:center\">EventHandle</td>\n<td></td>\n<td>current 改变时会触发 change 事件，event.detail = {current: current}</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"swiper-js文件\"><a href=\"#swiper-js文件\" class=\"headerlink\" title=\"swiper.js文件\"></a>swiper.js文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = getApp();</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    indicatordos:true,</div><div class=\"line\">    autoplay:true,</div><div class=\"line\">/*图片数组*/</div><div class=\"line\">    imgUrls: [</div><div class=\"line\">      &apos;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&apos;,</div><div class=\"line\">      &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg&apos;,</div><div class=\"line\">      &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&apos;,</div><div class=\"line\">      &apos;http://imgsrc.baidu.com/forum/pic/item/1080fc8b87d6277f026c80b428381f30e824fc46.jpg&apos;,</div><div class=\"line\">      &apos;http://imgsrc.baidu.com/forum/pic/item/2eadcbef76094b366ac0bf0da3cc7cd98c109d84.jpg&apos;,</div><div class=\"line\">      &apos;http://img1.tgbusdata.cn/v2/thumb/jpg/MGNlNiw3MzAsNzMwLDQsMSwxLC0xLDAscms1MA==/u/olpic.tgbusdata.cn/uploads/allimg/130124/62-130124160054.jpg&apos;</div><div class=\"line\">    ],</div><div class=\"line\">    vertical:true,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  displaychange:function(event)&#123;</div><div class=\"line\">      console.log(event.detail.current);//输出来当前swiper-item的index</div><div class=\"line\">   &#125;,</div><div class=\"line\"></div><div class=\"line\">  changeautodisplay:function()&#123;</div><div class=\"line\">    this.setData(&#123;</div><div class=\"line\">      autoplay:!this.data.autoplay//设置是否自动播放</div><div class=\"line\">  &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  changeindicator:function()&#123;</div><div class=\"line\">    this.setData(&#123;</div><div class=\"line\">  indicatordos:!this.data.indicatordos//隐藏图片那个点</div><div class=\"line\">&#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  changevertical:function()&#123;</div><div class=\"line\">    this.setData(&#123;//设置水平方向</div><div class=\"line\">      vertical:!this.data.vertical</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"swiper-xml文件\"><a href=\"#swiper-xml文件\" class=\"headerlink\" title=\"swiper.xml文件\"></a>swiper.xml文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view class=&quot;container&quot;&gt;</div><div class=\"line\">    &lt;view class=&quot;swiperview&quot;&gt;</div><div class=\"line\">        &lt;swiper class=&quot;swiperitem&quot; indicator-dots=&quot;&#123;&#123;indicatordos&#125;&#125;&quot; autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot;</div><div class=\"line\">          bindchange=&quot;displaychange&quot; duration=&quot;1000&quot; interval=&quot;2000&quot;</div><div class=\"line\">          vertical=&quot;&#123;&#123;vertical&#125;&#125;&quot;</div><div class=\"line\">        &gt;</div><div class=\"line\">        &lt;block wx:for=&quot;&#123;&#123;imgUrls&#125;&#125;&quot;&gt;</div><div class=\"line\">            &lt;swiper-item&gt;</div><div class=\"line\">                &lt;image src=&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;/image&gt;</div><div class=\"line\">            &lt;/swiper-item&gt;</div><div class=\"line\">        &lt;/block&gt;</div><div class=\"line\">        &lt;/swiper&gt;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">    &lt;view vlass=&quot;bottomview&quot;&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changeautodisplay&quot; class=&quot;bottomButton&quot;&gt;autodisplay:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changeindicator&quot; class=&quot;bottomButton&quot;&gt;indicatordots:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">        &lt;button type=&quot;default&quot; bindtap=&quot;changevertical&quot; class=&quot;bottomButton&quot;&gt;水平:&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;&#125;&#125;&lt;/button&gt;</div><div class=\"line\">//这里边用了一个简单的判断语句 :&#123;&#123;autoplay?&quot;YES&quot;:&quot;NO&quot;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure>\n<p>效果如下:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-f75545234a080c18.gif?imageMogr2/auto-orient/strip\" alt=\"2016-11-07 17_27_56.gif\"></p>\n<h2 id=\"2-checkbox的使用\"><a href=\"#2-checkbox的使用\" class=\"headerlink\" title=\"2.checkbox的使用\"></a>2.checkbox的使用</h2><p>其实就是复选框：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-26e5a47de1bf531a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"E935B5E6-0FC3-4A00-813C-9A259C2582AE.png\"><br>下边用了text显示了当前选中的name。<br><strong>js文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">首先要设置data的list</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">     items: [</div><div class=\"line\">      &#123;name: &apos;USA&apos;, value: &apos;美国&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;CHN&apos;, value: &apos;中国&apos;, checked: &apos;true&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;BRA&apos;, value: &apos;巴西&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;JPN&apos;, value: &apos;日本&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;ENG&apos;, value: &apos;英国&apos;&#125;,</div><div class=\"line\">      &#123;name: &apos;TUR&apos;, value: &apos;法国&apos;&#125;,</div><div class=\"line\">    ],</div><div class=\"line\">    text:&apos;&apos;,//用来显示选中的box</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  onShow:function()&#123;</div><div class=\"line\">    // 页面显示 第一次进入页面统计选中的box 调用函数。</div><div class=\"line\">    this.check();</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  change:function(e)&#123;</div><div class=\"line\">      console.log(e.detail.value);</div><div class=\"line\">      var te=&quot;暂时没选中&quot;;</div><div class=\"line\">      if(e.detail.value.length == 0)</div><div class=\"line\">        &#123; </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">         te = e.detail.value;</div><div class=\"line\">        &#125;</div><div class=\"line\">         this.setData(&#123;</div><div class=\"line\">        text:te</div><div class=\"line\">      &#125;)</div><div class=\"line\">      </div><div class=\"line\">  &#125;,</div><div class=\"line\">********遍历是否有选中的***********</div><div class=\"line\">  check:function()&#123;</div><div class=\"line\">    var te=&quot;&quot;;//遍历是否有选中的</div><div class=\"line\">    for(var i = 0;i &lt; this.data.items.length;i ++)&#123;</div><div class=\"line\">      var item = this.data.items[i];</div><div class=\"line\">      if(item.checked)&#123; //如果选中 加到字符串中</div><div class=\"line\">        te += item.value;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">      if(te.length == 0)</div><div class=\"line\">        &#123; </div><div class=\"line\">         te = &quot;暂时没选中&quot; ;</div><div class=\"line\">        &#125;</div><div class=\"line\">         this.setData(&#123;</div><div class=\"line\">        text:te</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong>xml文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;view class = &quot;contain&quot;&gt;</div><div class=\"line\">    &lt;view class=&quot;bd&quot;&gt;</div><div class=\"line\">        &lt;checkbox-group bindchange=&quot;change&quot;&gt; //绑定事件</div><div class=\"line\">            &lt;label class=&quot;checkbox&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot;&gt;//循环绑定到item</div><div class=\"line\">                &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot; checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot;</div><div class=\"line\">                &gt; </div><div class=\"line\">                &#123;&#123;item.value&#125;&#125;</div><div class=\"line\">                &lt;/checkbox&gt;</div><div class=\"line\">            &lt;/label&gt;</div><div class=\"line\">        &lt;/checkbox-group&gt;</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;view class=&quot;checkfooter&quot;&gt;</div><div class=\"line\">    &lt;text &gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;//显示选中的数据的name</div><div class=\"line\">    &lt;/view&gt;</div><div class=\"line\">&lt;/view&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>css文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.bd&#123;</div><div class=\"line\">    width: 800rpx;</div><div class=\"line\">    height: 500rpx;</div><div class=\"line\">    margin-left: 50rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.checkbox&#123;</div><div class=\"line\">   display: block;//这个要一定写的 暂时没搞懂意思  应该是一种布局方式。</div><div class=\"line\">   margin: 20;</div><div class=\"line\">&#125;</div><div class=\"line\">.checklabel&#123;</div><div class=\"line\">    width: 500rpx;</div><div class=\"line\">    height: 200rpx;</div><div class=\"line\">&#125;</div><div class=\"line\">.checkfooter&#123;</div><div class=\"line\">    margin-left: 50rpx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-274e66a04bdd68da.gif?imageMogr2/auto-orient/strip\" alt=\"2016-11-07 17_13_36.gif\"></p>\n<p>很多代码的地方都写了注释，有什么不懂或者疑问，欢迎来吐槽！<br><a href=\"https://github.com/ifgyong/WeChatDemo\" target=\"_blank\" rel=\"external\">demo地址</a><br><a href=\"http://fgyong.cn/2016/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_01/\">微信小程序_01</a></p>\n"},{"title":"微信小程序_1","date":"2016-11-04T08:39:24.000Z","_content":"1.下载微信小程序编辑器：[下载微信小程序编辑器](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161102)\n\n2.创建小程序应用：打开刚才下载的dmg，用微信扫面二维码登陆。点击本地小程序项目，就可以开始开发了。\n\n3.先介绍下目录结构：\n\n![F6B51227-E9DB-433B-86E3-336916B6E88B.png](http://upload-images.jianshu.io/upload_images/783986-d6c985cf217cfe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\npages文件夹中放的都是页面，app.js相当于iOS的appdelegate,app.json就是app的配置,app.wxss就是css样式文件。\n每一个页面都单独有一个js，json，wxss文件。\n4.app.json文件分析\n```\n{//所有的页面都在这里列出来\n  \"pages\":[\n    \"pages/index/index\",\n    \"pages/logs/logs\",\n    \"pages/button/button\"\n  ],\n  \"window\":{ //app的样式\n    \"backgroundTextStyle\":\"light\",\n    \"navigationBarBackgroundColor\": \"#fff\",\n    \"navigationBarTitleText\": \"WeChat\",\n    \"navigationBarTextStyle\":\"black\"\n  }\n}\n```\n5.先做一个小demo(js，json，wxml，wxss都是新建的)\n代码：\n```\n//获取应用实例\nvar app = getApp()\nPage({\n  data:{\n    count:0,\n    text: '加载了了0次',\n    loadingstatus: false,\n  },\n  onLoad:function(options){\n    // 页面初始化 options为页面跳转所带来的参数\n    console.log(\"onLoad\");\n    \n  },\n  onReady:function(){\n    // 页面渲染完成\n    console.log(\"onReady\");\n  },\n  onShow:function(){\n    // 页面显示\n    console.log(\"onShow\");\n  },\n  onHide:function(){\n    // 页面隐藏\n    console.log(\"onHide\");\n  },\n  onUnload:function(){\n    // 页面关闭\n    console.log(\"onUnload\");\n  },\n  button1click: function(){\n   var that = this;\n   that.data.count++;\n   that.setData({ //更改属性的值\n       text:'加载了'+that.data.count+'次',\n       loadingstatus:that.data.count%2 == 0 ? true:false,\n   })\n  },\n})\n\n//这里的data就是页面的数据和函数，\nonShow,onHide,onReady,onUnload都是生命周期函数，\nbutton1Click是button的click函数\n这框架是data和页面的绑定起来的，只要改变data的值，页面就会随着变化，这点和iOS有点不同。\n\nbutton.json 文件\n{\n     \"navigationBarTitleText\": \"ButtonDemo\" 这是页面的title\n}\n\nbutton.wxml文件\n\n<view class=\"container\"> \n    <view class=\"button-wrapper\">\n    <button type=\"default\" bindtap=\"button1click\"  size=\"default\"  \n    loading=\"{{loadingstatus}}\" > 点我\n    </button>\n     </view>\n<text class=\"countClick\" id=\"text1\">{{text}}\n</text>\n</view>\n\nbutton.wxss\n\n.countClick{\n    margin-top: 100rpx;\n    width: 200rpx;\n    height: 50rpx;\n    text-align: center;\n    font-size: 1em;\n    background-color: cadetblue;\n}\n\n bindtap=\"button1click\"  绑定点击事件到buttonclick函数\n{{text}}   {{data中的属性}}\n```\n今天还看到一段比较好玩的代码：\n```\nfor (var i = 0; i < types.length; ++i) {\n  (function(type) {\n    pageObject[type] = function(e) {\n      var key = type + 'Size'\n      var changedData = {}\n      changedData[key] =\n        this.data[key] === 'default' ? 'mini' : 'default'\n      this.setData(changedData)\n    }\n  })(types[i])\n```\n可能做iOS的没看过js的人这点看不太懂，我也是新手，哪里说的不对，欢迎前端大神指正。\n大概意思是：\n```\nfor (var i = 0; i < types.length; ++i) { 循环数组\n  (function(type) { //写法js(function)(item)\n    pageObject[type] = function(e) { //添加属性函数 就是增加了几个函数。\n      var key = type + 'Size' //拼接字符串\n      var changedData = {} //字典\n      changedData[key] = //字典赋值\n        this.data[key] === 'default' ? 'mini' : 'default'\n      this.setData(changedData) //相当于iOS的kvo用hash值的方式给自己的属性赋值\n    }\n  })(types[i]) //执行函数\n```\n这一个系列的Demo都会在这个仓库哦，欢迎大神吐槽。\n**[demo地址](https://github.com/ifgyong/WeChatDemo)**\n","source":"_posts/微信小程序_01.md","raw":"title: 微信小程序_1\ndate: 2016-11-04 16:39:24\ntags: 微信小程序\ncategories: 微信小程序\n---\n1.下载微信小程序编辑器：[下载微信小程序编辑器](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161102)\n\n2.创建小程序应用：打开刚才下载的dmg，用微信扫面二维码登陆。点击本地小程序项目，就可以开始开发了。\n\n3.先介绍下目录结构：\n\n![F6B51227-E9DB-433B-86E3-336916B6E88B.png](http://upload-images.jianshu.io/upload_images/783986-d6c985cf217cfe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\npages文件夹中放的都是页面，app.js相当于iOS的appdelegate,app.json就是app的配置,app.wxss就是css样式文件。\n每一个页面都单独有一个js，json，wxss文件。\n4.app.json文件分析\n```\n{//所有的页面都在这里列出来\n  \"pages\":[\n    \"pages/index/index\",\n    \"pages/logs/logs\",\n    \"pages/button/button\"\n  ],\n  \"window\":{ //app的样式\n    \"backgroundTextStyle\":\"light\",\n    \"navigationBarBackgroundColor\": \"#fff\",\n    \"navigationBarTitleText\": \"WeChat\",\n    \"navigationBarTextStyle\":\"black\"\n  }\n}\n```\n5.先做一个小demo(js，json，wxml，wxss都是新建的)\n代码：\n```\n//获取应用实例\nvar app = getApp()\nPage({\n  data:{\n    count:0,\n    text: '加载了了0次',\n    loadingstatus: false,\n  },\n  onLoad:function(options){\n    // 页面初始化 options为页面跳转所带来的参数\n    console.log(\"onLoad\");\n    \n  },\n  onReady:function(){\n    // 页面渲染完成\n    console.log(\"onReady\");\n  },\n  onShow:function(){\n    // 页面显示\n    console.log(\"onShow\");\n  },\n  onHide:function(){\n    // 页面隐藏\n    console.log(\"onHide\");\n  },\n  onUnload:function(){\n    // 页面关闭\n    console.log(\"onUnload\");\n  },\n  button1click: function(){\n   var that = this;\n   that.data.count++;\n   that.setData({ //更改属性的值\n       text:'加载了'+that.data.count+'次',\n       loadingstatus:that.data.count%2 == 0 ? true:false,\n   })\n  },\n})\n\n//这里的data就是页面的数据和函数，\nonShow,onHide,onReady,onUnload都是生命周期函数，\nbutton1Click是button的click函数\n这框架是data和页面的绑定起来的，只要改变data的值，页面就会随着变化，这点和iOS有点不同。\n\nbutton.json 文件\n{\n     \"navigationBarTitleText\": \"ButtonDemo\" 这是页面的title\n}\n\nbutton.wxml文件\n\n<view class=\"container\"> \n    <view class=\"button-wrapper\">\n    <button type=\"default\" bindtap=\"button1click\"  size=\"default\"  \n    loading=\"{{loadingstatus}}\" > 点我\n    </button>\n     </view>\n<text class=\"countClick\" id=\"text1\">{{text}}\n</text>\n</view>\n\nbutton.wxss\n\n.countClick{\n    margin-top: 100rpx;\n    width: 200rpx;\n    height: 50rpx;\n    text-align: center;\n    font-size: 1em;\n    background-color: cadetblue;\n}\n\n bindtap=\"button1click\"  绑定点击事件到buttonclick函数\n{{text}}   {{data中的属性}}\n```\n今天还看到一段比较好玩的代码：\n```\nfor (var i = 0; i < types.length; ++i) {\n  (function(type) {\n    pageObject[type] = function(e) {\n      var key = type + 'Size'\n      var changedData = {}\n      changedData[key] =\n        this.data[key] === 'default' ? 'mini' : 'default'\n      this.setData(changedData)\n    }\n  })(types[i])\n```\n可能做iOS的没看过js的人这点看不太懂，我也是新手，哪里说的不对，欢迎前端大神指正。\n大概意思是：\n```\nfor (var i = 0; i < types.length; ++i) { 循环数组\n  (function(type) { //写法js(function)(item)\n    pageObject[type] = function(e) { //添加属性函数 就是增加了几个函数。\n      var key = type + 'Size' //拼接字符串\n      var changedData = {} //字典\n      changedData[key] = //字典赋值\n        this.data[key] === 'default' ? 'mini' : 'default'\n      this.setData(changedData) //相当于iOS的kvo用hash值的方式给自己的属性赋值\n    }\n  })(types[i]) //执行函数\n```\n这一个系列的Demo都会在这个仓库哦，欢迎大神吐槽。\n**[demo地址](https://github.com/ifgyong/WeChatDemo)**\n","slug":"微信小程序_01","published":1,"updated":"2019-12-03T04:48:00.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi74001f9zskh6z8udfi","content":"<p>1.下载微信小程序编辑器：<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161102\" target=\"_blank\" rel=\"external\">下载微信小程序编辑器</a></p>\n<p>2.创建小程序应用：打开刚才下载的dmg，用微信扫面二维码登陆。点击本地小程序项目，就可以开始开发了。</p>\n<p>3.先介绍下目录结构：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-d6c985cf217cfe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"F6B51227-E9DB-433B-86E3-336916B6E88B.png\"><br>pages文件夹中放的都是页面，app.js相当于iOS的appdelegate,app.json就是app的配置,app.wxss就是css样式文件。<br>每一个页面都单独有一个js，json，wxss文件。<br>4.app.json文件分析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;//所有的页面都在这里列出来</div><div class=\"line\">  &quot;pages&quot;:[</div><div class=\"line\">    &quot;pages/index/index&quot;,</div><div class=\"line\">    &quot;pages/logs/logs&quot;,</div><div class=\"line\">    &quot;pages/button/button&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;window&quot;:&#123; //app的样式</div><div class=\"line\">    &quot;backgroundTextStyle&quot;:&quot;light&quot;,</div><div class=\"line\">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</div><div class=\"line\">    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,</div><div class=\"line\">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>5.先做一个小demo(js，json，wxml，wxss都是新建的)<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取应用实例</div><div class=\"line\">var app = getApp()</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    count:0,</div><div class=\"line\">    text: &apos;加载了了0次&apos;,</div><div class=\"line\">    loadingstatus: false,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onLoad:function(options)&#123;</div><div class=\"line\">    // 页面初始化 options为页面跳转所带来的参数</div><div class=\"line\">    console.log(&quot;onLoad&quot;);</div><div class=\"line\">    </div><div class=\"line\">  &#125;,</div><div class=\"line\">  onReady:function()&#123;</div><div class=\"line\">    // 页面渲染完成</div><div class=\"line\">    console.log(&quot;onReady&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onShow:function()&#123;</div><div class=\"line\">    // 页面显示</div><div class=\"line\">    console.log(&quot;onShow&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onHide:function()&#123;</div><div class=\"line\">    // 页面隐藏</div><div class=\"line\">    console.log(&quot;onHide&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onUnload:function()&#123;</div><div class=\"line\">    // 页面关闭</div><div class=\"line\">    console.log(&quot;onUnload&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  button1click: function()&#123;</div><div class=\"line\">   var that = this;</div><div class=\"line\">   that.data.count++;</div><div class=\"line\">   that.setData(&#123; //更改属性的值</div><div class=\"line\">       text:&apos;加载了&apos;+that.data.count+&apos;次&apos;,</div><div class=\"line\">       loadingstatus:that.data.count%2 == 0 ? true:false,</div><div class=\"line\">   &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">//这里的data就是页面的数据和函数，</div><div class=\"line\">onShow,onHide,onReady,onUnload都是生命周期函数，</div><div class=\"line\">button1Click是button的click函数</div><div class=\"line\">这框架是data和页面的绑定起来的，只要改变data的值，页面就会随着变化，这点和iOS有点不同。</div><div class=\"line\"></div><div class=\"line\">button.json 文件</div><div class=\"line\">&#123;</div><div class=\"line\">     &quot;navigationBarTitleText&quot;: &quot;ButtonDemo&quot; 这是页面的title</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">button.wxml文件</div><div class=\"line\"></div><div class=\"line\">&lt;view class=&quot;container&quot;&gt; </div><div class=\"line\">    &lt;view class=&quot;button-wrapper&quot;&gt;</div><div class=\"line\">    &lt;button type=&quot;default&quot; bindtap=&quot;button1click&quot;  size=&quot;default&quot;  </div><div class=\"line\">    loading=&quot;&#123;&#123;loadingstatus&#125;&#125;&quot; &gt; 点我</div><div class=\"line\">    &lt;/button&gt;</div><div class=\"line\">     &lt;/view&gt;</div><div class=\"line\">&lt;text class=&quot;countClick&quot; id=&quot;text1&quot;&gt;&#123;&#123;text&#125;&#125;</div><div class=\"line\">&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\"></div><div class=\"line\">button.wxss</div><div class=\"line\"></div><div class=\"line\">.countClick&#123;</div><div class=\"line\">    margin-top: 100rpx;</div><div class=\"line\">    width: 200rpx;</div><div class=\"line\">    height: 50rpx;</div><div class=\"line\">    text-align: center;</div><div class=\"line\">    font-size: 1em;</div><div class=\"line\">    background-color: cadetblue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> bindtap=&quot;button1click&quot;  绑定点击事件到buttonclick函数</div><div class=\"line\">&#123;&#123;text&#125;&#125;   &#123;&#123;data中的属性&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>今天还看到一段比较好玩的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; types.length; ++i) &#123;</div><div class=\"line\">  (function(type) &#123;</div><div class=\"line\">    pageObject[type] = function(e) &#123;</div><div class=\"line\">      var key = type + &apos;Size&apos;</div><div class=\"line\">      var changedData = &#123;&#125;</div><div class=\"line\">      changedData[key] =</div><div class=\"line\">        this.data[key] === &apos;default&apos; ? &apos;mini&apos; : &apos;default&apos;</div><div class=\"line\">      this.setData(changedData)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)(types[i])</div></pre></td></tr></table></figure></p>\n<p>可能做iOS的没看过js的人这点看不太懂，我也是新手，哪里说的不对，欢迎前端大神指正。<br>大概意思是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; types.length; ++i) &#123; 循环数组</div><div class=\"line\">  (function(type) &#123; //写法js(function)(item)</div><div class=\"line\">    pageObject[type] = function(e) &#123; //添加属性函数 就是增加了几个函数。</div><div class=\"line\">      var key = type + &apos;Size&apos; //拼接字符串</div><div class=\"line\">      var changedData = &#123;&#125; //字典</div><div class=\"line\">      changedData[key] = //字典赋值</div><div class=\"line\">        this.data[key] === &apos;default&apos; ? &apos;mini&apos; : &apos;default&apos;</div><div class=\"line\">      this.setData(changedData) //相当于iOS的kvo用hash值的方式给自己的属性赋值</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)(types[i]) //执行函数</div></pre></td></tr></table></figure></p>\n<p>这一个系列的Demo都会在这个仓库哦，欢迎大神吐槽。<br><strong><a href=\"https://github.com/ifgyong/WeChatDemo\" target=\"_blank\" rel=\"external\">demo地址</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.下载微信小程序编辑器：<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161102\" target=\"_blank\" rel=\"external\">下载微信小程序编辑器</a></p>\n<p>2.创建小程序应用：打开刚才下载的dmg，用微信扫面二维码登陆。点击本地小程序项目，就可以开始开发了。</p>\n<p>3.先介绍下目录结构：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/783986-d6c985cf217cfe83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"F6B51227-E9DB-433B-86E3-336916B6E88B.png\"><br>pages文件夹中放的都是页面，app.js相当于iOS的appdelegate,app.json就是app的配置,app.wxss就是css样式文件。<br>每一个页面都单独有一个js，json，wxss文件。<br>4.app.json文件分析<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;//所有的页面都在这里列出来</div><div class=\"line\">  &quot;pages&quot;:[</div><div class=\"line\">    &quot;pages/index/index&quot;,</div><div class=\"line\">    &quot;pages/logs/logs&quot;,</div><div class=\"line\">    &quot;pages/button/button&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;window&quot;:&#123; //app的样式</div><div class=\"line\">    &quot;backgroundTextStyle&quot;:&quot;light&quot;,</div><div class=\"line\">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</div><div class=\"line\">    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,</div><div class=\"line\">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>5.先做一个小demo(js，json，wxml，wxss都是新建的)<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">//获取应用实例</div><div class=\"line\">var app = getApp()</div><div class=\"line\">Page(&#123;</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    count:0,</div><div class=\"line\">    text: &apos;加载了了0次&apos;,</div><div class=\"line\">    loadingstatus: false,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onLoad:function(options)&#123;</div><div class=\"line\">    // 页面初始化 options为页面跳转所带来的参数</div><div class=\"line\">    console.log(&quot;onLoad&quot;);</div><div class=\"line\">    </div><div class=\"line\">  &#125;,</div><div class=\"line\">  onReady:function()&#123;</div><div class=\"line\">    // 页面渲染完成</div><div class=\"line\">    console.log(&quot;onReady&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onShow:function()&#123;</div><div class=\"line\">    // 页面显示</div><div class=\"line\">    console.log(&quot;onShow&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onHide:function()&#123;</div><div class=\"line\">    // 页面隐藏</div><div class=\"line\">    console.log(&quot;onHide&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  onUnload:function()&#123;</div><div class=\"line\">    // 页面关闭</div><div class=\"line\">    console.log(&quot;onUnload&quot;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  button1click: function()&#123;</div><div class=\"line\">   var that = this;</div><div class=\"line\">   that.data.count++;</div><div class=\"line\">   that.setData(&#123; //更改属性的值</div><div class=\"line\">       text:&apos;加载了&apos;+that.data.count+&apos;次&apos;,</div><div class=\"line\">       loadingstatus:that.data.count%2 == 0 ? true:false,</div><div class=\"line\">   &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">//这里的data就是页面的数据和函数，</div><div class=\"line\">onShow,onHide,onReady,onUnload都是生命周期函数，</div><div class=\"line\">button1Click是button的click函数</div><div class=\"line\">这框架是data和页面的绑定起来的，只要改变data的值，页面就会随着变化，这点和iOS有点不同。</div><div class=\"line\"></div><div class=\"line\">button.json 文件</div><div class=\"line\">&#123;</div><div class=\"line\">     &quot;navigationBarTitleText&quot;: &quot;ButtonDemo&quot; 这是页面的title</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">button.wxml文件</div><div class=\"line\"></div><div class=\"line\">&lt;view class=&quot;container&quot;&gt; </div><div class=\"line\">    &lt;view class=&quot;button-wrapper&quot;&gt;</div><div class=\"line\">    &lt;button type=&quot;default&quot; bindtap=&quot;button1click&quot;  size=&quot;default&quot;  </div><div class=\"line\">    loading=&quot;&#123;&#123;loadingstatus&#125;&#125;&quot; &gt; 点我</div><div class=\"line\">    &lt;/button&gt;</div><div class=\"line\">     &lt;/view&gt;</div><div class=\"line\">&lt;text class=&quot;countClick&quot; id=&quot;text1&quot;&gt;&#123;&#123;text&#125;&#125;</div><div class=\"line\">&lt;/text&gt;</div><div class=\"line\">&lt;/view&gt;</div><div class=\"line\"></div><div class=\"line\">button.wxss</div><div class=\"line\"></div><div class=\"line\">.countClick&#123;</div><div class=\"line\">    margin-top: 100rpx;</div><div class=\"line\">    width: 200rpx;</div><div class=\"line\">    height: 50rpx;</div><div class=\"line\">    text-align: center;</div><div class=\"line\">    font-size: 1em;</div><div class=\"line\">    background-color: cadetblue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> bindtap=&quot;button1click&quot;  绑定点击事件到buttonclick函数</div><div class=\"line\">&#123;&#123;text&#125;&#125;   &#123;&#123;data中的属性&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>今天还看到一段比较好玩的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; types.length; ++i) &#123;</div><div class=\"line\">  (function(type) &#123;</div><div class=\"line\">    pageObject[type] = function(e) &#123;</div><div class=\"line\">      var key = type + &apos;Size&apos;</div><div class=\"line\">      var changedData = &#123;&#125;</div><div class=\"line\">      changedData[key] =</div><div class=\"line\">        this.data[key] === &apos;default&apos; ? &apos;mini&apos; : &apos;default&apos;</div><div class=\"line\">      this.setData(changedData)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)(types[i])</div></pre></td></tr></table></figure></p>\n<p>可能做iOS的没看过js的人这点看不太懂，我也是新手，哪里说的不对，欢迎前端大神指正。<br>大概意思是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; types.length; ++i) &#123; 循环数组</div><div class=\"line\">  (function(type) &#123; //写法js(function)(item)</div><div class=\"line\">    pageObject[type] = function(e) &#123; //添加属性函数 就是增加了几个函数。</div><div class=\"line\">      var key = type + &apos;Size&apos; //拼接字符串</div><div class=\"line\">      var changedData = &#123;&#125; //字典</div><div class=\"line\">      changedData[key] = //字典赋值</div><div class=\"line\">        this.data[key] === &apos;default&apos; ? &apos;mini&apos; : &apos;default&apos;</div><div class=\"line\">      this.setData(changedData) //相当于iOS的kvo用hash值的方式给自己的属性赋值</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)(types[i]) //执行函数</div></pre></td></tr></table></figure></p>\n<p>这一个系列的Demo都会在这个仓库哦，欢迎大神吐槽。<br><strong><a href=\"https://github.com/ifgyong/WeChatDemo\" target=\"_blank\" rel=\"external\">demo地址</a></strong></p>\n"},{"title":"排序算法","date":"2017-05-08T08:39:24.000Z","_content":"## 排序算法\n- 冒泡排序\n- 选择排序\n- 直接插入排序\n- 希尔排序\n- 快速排序\n\n\n\n### 冒泡排序\n\n>冒泡排序是一种交换排序，基本思想是两两相邻的记录的关键字，如果反序则交换，知道没有反序为止。\n\n冒泡排序的复杂度是n(n-1)/2,就是o(n²)。\n\n```\n/*对顺序列表排序*/\n-(void)sort:(NSMutableArray *)list{\n    NSInteger i , j;\n    for (i = 0; i < list.count; i ++) {\n        for (j = list.count-1; j>=i; j --) {\n            if (list[j] > list[i]) {\n                /*\n                 交换obj\n                 */\n                [list exchangeObjectAtIndex:i withObjectAtIndex:j];\n            }\n        }\n    }\n}\n\n```\n### 选择排序\n>简单选择排序法是通过n-i次关键字间的比较，从n-i+1个记录选出关键字最小的记录，并和第i（1=《i《=n）交换之。\n\n选择排序复杂度是n（n-1）/2,就是o（n²），性能略优于冒泡。\n\n```\n-(void)sort:(NSMutableArray *)list{\n    NSInteger i , j , min;\n    for (i = 1; i < list.count; i ++) {\n        min = i; //默认最小值是第一个\n        for (j = i + 1; j <= list.count; j ++) {\n            if (list[min]  >  list[j] ) {\n                min = j; //记录最小值的索引\n                \n            }\n        }\n        if (min != i) {// 出现最小的值的时候 和上个最小的值交换位置\n            /*\n             交换obj\n             */\n            [list exchangeObjectAtIndex:i withObjectAtIndex:j];\n        }\n        \n    }\n}\n\n```\n###直接插入排序算法\n>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的，记录增加1的有序表。\n\n\n直接插入排序时间复杂度是（n+4）（n-1）/2，就是o（n²）。\n性能略优于选择排序。\n```\n-(void)sort2:(NSMutableArray *)list{\n    NSInteger i , j ;\n    for (i = 1; i < list.count; i ++) {\n       \n        if (list[i-1] < list[i]) {// i-1 小于 i\n             NSInteger data = [list[i] integerValue];//设置哨兵\n            for (j = i - 1; j >= 0 && [list[j] integerValue] < data  ; j --) {\n                list[j+1] = list[j];//向后移动一位\n            }\n            if (data) {\n                 list[j+1] =@(data);//哨兵赋值\n            }\n        }\n    }\n}\n```\n### 希尔排序\n>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n```\n//希尔排序算法\n-(void)shellSort:(NSMutableArray *)list{\n    NSInteger i , j ;\n    NSInteger inrement = list.count;\n    do {\n        inrement = inrement/3 + 1;//增量序列\n        for (i = inrement+1; i < list.count; i ++) {\n            if (list[i]<list[i-inrement]) {\n                //需将list[i] 插入有序增量字表\n                NSNumber  * data = list[i];\n                for (j = i - inrement; j >0 && data < list[j]; j-= inrement) {\n                    list[j+inrement] = list[j];//记录后移\n                }\n                list[j+inrement] = data;//插入\n            }\n        }\n    }while (inrement > 1);\n}\n```\n希尔排序和直接插入排序有异曲同工之妙，都是记录后移，都是插入排序。不过希尔用的条件是步长，步长越来越短，直到是1，而直接插入排序是直接是1，循环次数多。\n时间复杂度是o(n的二分之三次方)，优于o（n²）。\n\n###  快速排序\n>基本思想是:通过一趟排序将带排序记录分割成独立的两部分，其中一部分记录的关键字均比另外一部分的关键字小，则可分别对着两部分重新排序，以达到整个序列的有序的目的。\n\n```\n// 快速排序\n-(void)quickSort:(NSMutableArray *)list{\n    [self qsort:list low:0 hight:list.count-1];\n}\n-(void)qsort:(NSMutableArray *)list low:(NSInteger)low hight:(NSInteger ) hight{\n    NSInteger pt;\n    if (low < hight) {\n        pt =[self partition:list low:low high:hight];//将整个序列一分为二\n        [self qsort:list low:low hight:pt -1];//对低子表递归排序\n        [self qsort:list low:pt + 1 hight:hight];//对高字表递归排序\n    }\n}\n//返回在他前后记录均不大（小）与他。\n-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high{\n    NSNumber * data = list[low];\n    while (low < high) {\n        while (low < high && list[high] >= data)// 倒叙 找出比data小的 并交换位置\n            high --;\n            [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n        \n        while (low < high && list[low] <= data)//正序 找出比data大的 并交换位置\n            low ++;\n         [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n        \n    }\n    return low;\n}\n\n```\n时间复杂度是o（n²）空间复杂度是o（log n）。\n\n优化选择枢轴\n三数取中发，就是取三个关键字排序，将中间的数作为枢轴，一般是取左，右，中间三个数。\n```\n  data = list[low];\n\n将上面的一行改成下边的：\n\nNSNumber * data;\n    NSInteger m = low + (high + low)/2;\n    if (list[low] > list[high]) {\n        [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n    }\n    if (list[m] > list[high]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:high];\n    }\n    if (list[m] > list[low]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:low];\n    }\n    data = list[low];\n\n```\n优化不必要的交换\n```\n//返回在他前后记录均不大（小）与他。\n-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high{\n    NSNumber * data;\n    NSInteger m = low + (high - low)/2;\n    if (list[low] > list[high]) {\n        [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n    }\n    if (list[m] > list[high]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:high];\n    }\n    if (list[m] > list[low]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:low];\n    }\n    data = list[low];//取出来适当的关键字\n    while (low < high) {\n        while (low < high && list[high] >= data)// 倒叙 找出比data小的 并交换位置\n            high --;\n        list[low] = list[high];  //将 上面的交换改成直接赋值\n        \n        while (low < high && list[low] <= data)//正序 找出比data大的 并交换位置\n            low ++;\n         list[high ] = list[low];   //将 上面的交换改成直接赋值\n        \n    }\n    list[low] = data; //最后 将关键字 赋值给low的位置\n    return low;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/排序算法.md","raw":"title: 排序算法\ndate: 2017-5-8 16:39:24\ntags:\n- 排序\n- 数据结构\ncategories: 数据结构\n-------------\n## 排序算法\n- 冒泡排序\n- 选择排序\n- 直接插入排序\n- 希尔排序\n- 快速排序\n\n\n\n### 冒泡排序\n\n>冒泡排序是一种交换排序，基本思想是两两相邻的记录的关键字，如果反序则交换，知道没有反序为止。\n\n冒泡排序的复杂度是n(n-1)/2,就是o(n²)。\n\n```\n/*对顺序列表排序*/\n-(void)sort:(NSMutableArray *)list{\n    NSInteger i , j;\n    for (i = 0; i < list.count; i ++) {\n        for (j = list.count-1; j>=i; j --) {\n            if (list[j] > list[i]) {\n                /*\n                 交换obj\n                 */\n                [list exchangeObjectAtIndex:i withObjectAtIndex:j];\n            }\n        }\n    }\n}\n\n```\n### 选择排序\n>简单选择排序法是通过n-i次关键字间的比较，从n-i+1个记录选出关键字最小的记录，并和第i（1=《i《=n）交换之。\n\n选择排序复杂度是n（n-1）/2,就是o（n²），性能略优于冒泡。\n\n```\n-(void)sort:(NSMutableArray *)list{\n    NSInteger i , j , min;\n    for (i = 1; i < list.count; i ++) {\n        min = i; //默认最小值是第一个\n        for (j = i + 1; j <= list.count; j ++) {\n            if (list[min]  >  list[j] ) {\n                min = j; //记录最小值的索引\n                \n            }\n        }\n        if (min != i) {// 出现最小的值的时候 和上个最小的值交换位置\n            /*\n             交换obj\n             */\n            [list exchangeObjectAtIndex:i withObjectAtIndex:j];\n        }\n        \n    }\n}\n\n```\n###直接插入排序算法\n>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的，记录增加1的有序表。\n\n\n直接插入排序时间复杂度是（n+4）（n-1）/2，就是o（n²）。\n性能略优于选择排序。\n```\n-(void)sort2:(NSMutableArray *)list{\n    NSInteger i , j ;\n    for (i = 1; i < list.count; i ++) {\n       \n        if (list[i-1] < list[i]) {// i-1 小于 i\n             NSInteger data = [list[i] integerValue];//设置哨兵\n            for (j = i - 1; j >= 0 && [list[j] integerValue] < data  ; j --) {\n                list[j+1] = list[j];//向后移动一位\n            }\n            if (data) {\n                 list[j+1] =@(data);//哨兵赋值\n            }\n        }\n    }\n}\n```\n### 希尔排序\n>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n```\n//希尔排序算法\n-(void)shellSort:(NSMutableArray *)list{\n    NSInteger i , j ;\n    NSInteger inrement = list.count;\n    do {\n        inrement = inrement/3 + 1;//增量序列\n        for (i = inrement+1; i < list.count; i ++) {\n            if (list[i]<list[i-inrement]) {\n                //需将list[i] 插入有序增量字表\n                NSNumber  * data = list[i];\n                for (j = i - inrement; j >0 && data < list[j]; j-= inrement) {\n                    list[j+inrement] = list[j];//记录后移\n                }\n                list[j+inrement] = data;//插入\n            }\n        }\n    }while (inrement > 1);\n}\n```\n希尔排序和直接插入排序有异曲同工之妙，都是记录后移，都是插入排序。不过希尔用的条件是步长，步长越来越短，直到是1，而直接插入排序是直接是1，循环次数多。\n时间复杂度是o(n的二分之三次方)，优于o（n²）。\n\n###  快速排序\n>基本思想是:通过一趟排序将带排序记录分割成独立的两部分，其中一部分记录的关键字均比另外一部分的关键字小，则可分别对着两部分重新排序，以达到整个序列的有序的目的。\n\n```\n// 快速排序\n-(void)quickSort:(NSMutableArray *)list{\n    [self qsort:list low:0 hight:list.count-1];\n}\n-(void)qsort:(NSMutableArray *)list low:(NSInteger)low hight:(NSInteger ) hight{\n    NSInteger pt;\n    if (low < hight) {\n        pt =[self partition:list low:low high:hight];//将整个序列一分为二\n        [self qsort:list low:low hight:pt -1];//对低子表递归排序\n        [self qsort:list low:pt + 1 hight:hight];//对高字表递归排序\n    }\n}\n//返回在他前后记录均不大（小）与他。\n-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high{\n    NSNumber * data = list[low];\n    while (low < high) {\n        while (low < high && list[high] >= data)// 倒叙 找出比data小的 并交换位置\n            high --;\n            [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n        \n        while (low < high && list[low] <= data)//正序 找出比data大的 并交换位置\n            low ++;\n         [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n        \n    }\n    return low;\n}\n\n```\n时间复杂度是o（n²）空间复杂度是o（log n）。\n\n优化选择枢轴\n三数取中发，就是取三个关键字排序，将中间的数作为枢轴，一般是取左，右，中间三个数。\n```\n  data = list[low];\n\n将上面的一行改成下边的：\n\nNSNumber * data;\n    NSInteger m = low + (high + low)/2;\n    if (list[low] > list[high]) {\n        [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n    }\n    if (list[m] > list[high]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:high];\n    }\n    if (list[m] > list[low]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:low];\n    }\n    data = list[low];\n\n```\n优化不必要的交换\n```\n//返回在他前后记录均不大（小）与他。\n-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high{\n    NSNumber * data;\n    NSInteger m = low + (high - low)/2;\n    if (list[low] > list[high]) {\n        [list exchangeObjectAtIndex:low withObjectAtIndex:high];\n    }\n    if (list[m] > list[high]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:high];\n    }\n    if (list[m] > list[low]) {\n        [list exchangeObjectAtIndex:m withObjectAtIndex:low];\n    }\n    data = list[low];//取出来适当的关键字\n    while (low < high) {\n        while (low < high && list[high] >= data)// 倒叙 找出比data小的 并交换位置\n            high --;\n        list[low] = list[high];  //将 上面的交换改成直接赋值\n        \n        while (low < high && list[low] <= data)//正序 找出比data大的 并交换位置\n            low ++;\n         list[high ] = list[low];   //将 上面的交换改成直接赋值\n        \n    }\n    list[low] = data; //最后 将关键字 赋值给low的位置\n    return low;\n}\n```\n\n\n\n\n\n\n\n","slug":"排序算法","published":1,"updated":"2019-12-03T04:48:00.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3qqhi75001g9zskrj7k03jj","content":"<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><ul>\n<li>冒泡排序</li>\n<li>选择排序</li>\n<li>直接插入排序</li>\n<li>希尔排序</li>\n<li>快速排序</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>冒泡排序是一种交换排序，基本思想是两两相邻的记录的关键字，如果反序则交换，知道没有反序为止。</p>\n</blockquote>\n<p>冒泡排序的复杂度是n(n-1)/2,就是o(n²)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*对顺序列表排序*/</div><div class=\"line\">-(void)sort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j;</div><div class=\"line\">    for (i = 0; i &lt; list.count; i ++) &#123;</div><div class=\"line\">        for (j = list.count-1; j&gt;=i; j --) &#123;</div><div class=\"line\">            if (list[j] &gt; list[i]) &#123;</div><div class=\"line\">                /*</div><div class=\"line\">                 交换obj</div><div class=\"line\">                 */</div><div class=\"line\">                [list exchangeObjectAtIndex:i withObjectAtIndex:j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>简单选择排序法是通过n-i次关键字间的比较，从n-i+1个记录选出关键字最小的记录，并和第i（1=《i《=n）交换之。</p>\n</blockquote>\n<p>选择排序复杂度是n（n-1）/2,就是o（n²），性能略优于冒泡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j , min;</div><div class=\"line\">    for (i = 1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">        min = i; //默认最小值是第一个</div><div class=\"line\">        for (j = i + 1; j &lt;= list.count; j ++) &#123;</div><div class=\"line\">            if (list[min]  &gt;  list[j] ) &#123;</div><div class=\"line\">                min = j; //记录最小值的索引</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (min != i) &#123;// 出现最小的值的时候 和上个最小的值交换位置</div><div class=\"line\">            /*</div><div class=\"line\">             交换obj</div><div class=\"line\">             */</div><div class=\"line\">            [list exchangeObjectAtIndex:i withObjectAtIndex:j];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###直接插入排序算法</p>\n<blockquote>\n<p>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的，记录增加1的有序表。</p>\n</blockquote>\n<p>直接插入排序时间复杂度是（n+4）（n-1）/2，就是o（n²）。<br>性能略优于选择排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sort2:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j ;</div><div class=\"line\">    for (i = 1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">       </div><div class=\"line\">        if (list[i-1] &lt; list[i]) &#123;// i-1 小于 i</div><div class=\"line\">             NSInteger data = [list[i] integerValue];//设置哨兵</div><div class=\"line\">            for (j = i - 1; j &gt;= 0 &amp;&amp; [list[j] integerValue] &lt; data  ; j --) &#123;</div><div class=\"line\">                list[j+1] = list[j];//向后移动一位</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (data) &#123;</div><div class=\"line\">                 list[j+1] =@(data);//哨兵赋值</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><blockquote>\n<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//希尔排序算法</div><div class=\"line\">-(void)shellSort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j ;</div><div class=\"line\">    NSInteger inrement = list.count;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        inrement = inrement/3 + 1;//增量序列</div><div class=\"line\">        for (i = inrement+1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">            if (list[i]&lt;list[i-inrement]) &#123;</div><div class=\"line\">                //需将list[i] 插入有序增量字表</div><div class=\"line\">                NSNumber  * data = list[i];</div><div class=\"line\">                for (j = i - inrement; j &gt;0 &amp;&amp; data &lt; list[j]; j-= inrement) &#123;</div><div class=\"line\">                    list[j+inrement] = list[j];//记录后移</div><div class=\"line\">                &#125;</div><div class=\"line\">                list[j+inrement] = data;//插入</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;while (inrement &gt; 1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>希尔排序和直接插入排序有异曲同工之妙，都是记录后移，都是插入排序。不过希尔用的条件是步长，步长越来越短，直到是1，而直接插入排序是直接是1，循环次数多。<br>时间复杂度是o(n的二分之三次方)，优于o（n²）。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><blockquote>\n<p>基本思想是:通过一趟排序将带排序记录分割成独立的两部分，其中一部分记录的关键字均比另外一部分的关键字小，则可分别对着两部分重新排序，以达到整个序列的有序的目的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 快速排序</div><div class=\"line\">-(void)quickSort:(NSMutableArray *)list&#123;</div><div class=\"line\">    [self qsort:list low:0 hight:list.count-1];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)qsort:(NSMutableArray *)list low:(NSInteger)low hight:(NSInteger ) hight&#123;</div><div class=\"line\">    NSInteger pt;</div><div class=\"line\">    if (low &lt; hight) &#123;</div><div class=\"line\">        pt =[self partition:list low:low high:hight];//将整个序列一分为二</div><div class=\"line\">        [self qsort:list low:low hight:pt -1];//对低子表递归排序</div><div class=\"line\">        [self qsort:list low:pt + 1 hight:hight];//对高字表递归排序</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//返回在他前后记录均不大（小）与他。</div><div class=\"line\">-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high&#123;</div><div class=\"line\">    NSNumber * data = list[low];</div><div class=\"line\">    while (low &lt; high) &#123;</div><div class=\"line\">        while (low &lt; high &amp;&amp; list[high] &gt;= data)// 倒叙 找出比data小的 并交换位置</div><div class=\"line\">            high --;</div><div class=\"line\">            [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">        </div><div class=\"line\">        while (low &lt; high &amp;&amp; list[low] &lt;= data)//正序 找出比data大的 并交换位置</div><div class=\"line\">            low ++;</div><div class=\"line\">         [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    return low;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>时间复杂度是o（n²）空间复杂度是o（log n）。</p>\n<p>优化选择枢轴<br>三数取中发，就是取三个关键字排序，将中间的数作为枢轴，一般是取左，右，中间三个数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">  data = list[low];</div><div class=\"line\"></div><div class=\"line\">将上面的一行改成下边的：</div><div class=\"line\"></div><div class=\"line\">NSNumber * data;</div><div class=\"line\">    NSInteger m = low + (high + low)/2;</div><div class=\"line\">    if (list[low] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[low]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:low];</div><div class=\"line\">    &#125;</div><div class=\"line\">    data = list[low];</div></pre></td></tr></table></figure></p>\n<p>优化不必要的交换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//返回在他前后记录均不大（小）与他。</div><div class=\"line\">-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high&#123;</div><div class=\"line\">    NSNumber * data;</div><div class=\"line\">    NSInteger m = low + (high - low)/2;</div><div class=\"line\">    if (list[low] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[low]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:low];</div><div class=\"line\">    &#125;</div><div class=\"line\">    data = list[low];//取出来适当的关键字</div><div class=\"line\">    while (low &lt; high) &#123;</div><div class=\"line\">        while (low &lt; high &amp;&amp; list[high] &gt;= data)// 倒叙 找出比data小的 并交换位置</div><div class=\"line\">            high --;</div><div class=\"line\">        list[low] = list[high];  //将 上面的交换改成直接赋值</div><div class=\"line\">        </div><div class=\"line\">        while (low &lt; high &amp;&amp; list[low] &lt;= data)//正序 找出比data大的 并交换位置</div><div class=\"line\">            low ++;</div><div class=\"line\">         list[high ] = list[low];   //将 上面的交换改成直接赋值</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    list[low] = data; //最后 将关键字 赋值给low的位置</div><div class=\"line\">    return low;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><ul>\n<li>冒泡排序</li>\n<li>选择排序</li>\n<li>直接插入排序</li>\n<li>希尔排序</li>\n<li>快速排序</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>冒泡排序是一种交换排序，基本思想是两两相邻的记录的关键字，如果反序则交换，知道没有反序为止。</p>\n</blockquote>\n<p>冒泡排序的复杂度是n(n-1)/2,就是o(n²)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*对顺序列表排序*/</div><div class=\"line\">-(void)sort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j;</div><div class=\"line\">    for (i = 0; i &lt; list.count; i ++) &#123;</div><div class=\"line\">        for (j = list.count-1; j&gt;=i; j --) &#123;</div><div class=\"line\">            if (list[j] &gt; list[i]) &#123;</div><div class=\"line\">                /*</div><div class=\"line\">                 交换obj</div><div class=\"line\">                 */</div><div class=\"line\">                [list exchangeObjectAtIndex:i withObjectAtIndex:j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>简单选择排序法是通过n-i次关键字间的比较，从n-i+1个记录选出关键字最小的记录，并和第i（1=《i《=n）交换之。</p>\n</blockquote>\n<p>选择排序复杂度是n（n-1）/2,就是o（n²），性能略优于冒泡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j , min;</div><div class=\"line\">    for (i = 1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">        min = i; //默认最小值是第一个</div><div class=\"line\">        for (j = i + 1; j &lt;= list.count; j ++) &#123;</div><div class=\"line\">            if (list[min]  &gt;  list[j] ) &#123;</div><div class=\"line\">                min = j; //记录最小值的索引</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (min != i) &#123;// 出现最小的值的时候 和上个最小的值交换位置</div><div class=\"line\">            /*</div><div class=\"line\">             交换obj</div><div class=\"line\">             */</div><div class=\"line\">            [list exchangeObjectAtIndex:i withObjectAtIndex:j];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###直接插入排序算法</p>\n<blockquote>\n<p>直接插入排序的基本操作是将一个记录插入到已经排好的有序表中，从而得到一个新的，记录增加1的有序表。</p>\n</blockquote>\n<p>直接插入排序时间复杂度是（n+4）（n-1）/2，就是o（n²）。<br>性能略优于选择排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)sort2:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j ;</div><div class=\"line\">    for (i = 1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">       </div><div class=\"line\">        if (list[i-1] &lt; list[i]) &#123;// i-1 小于 i</div><div class=\"line\">             NSInteger data = [list[i] integerValue];//设置哨兵</div><div class=\"line\">            for (j = i - 1; j &gt;= 0 &amp;&amp; [list[j] integerValue] &lt; data  ; j --) &#123;</div><div class=\"line\">                list[j+1] = list[j];//向后移动一位</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (data) &#123;</div><div class=\"line\">                 list[j+1] =@(data);//哨兵赋值</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><blockquote>\n<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//希尔排序算法</div><div class=\"line\">-(void)shellSort:(NSMutableArray *)list&#123;</div><div class=\"line\">    NSInteger i , j ;</div><div class=\"line\">    NSInteger inrement = list.count;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        inrement = inrement/3 + 1;//增量序列</div><div class=\"line\">        for (i = inrement+1; i &lt; list.count; i ++) &#123;</div><div class=\"line\">            if (list[i]&lt;list[i-inrement]) &#123;</div><div class=\"line\">                //需将list[i] 插入有序增量字表</div><div class=\"line\">                NSNumber  * data = list[i];</div><div class=\"line\">                for (j = i - inrement; j &gt;0 &amp;&amp; data &lt; list[j]; j-= inrement) &#123;</div><div class=\"line\">                    list[j+inrement] = list[j];//记录后移</div><div class=\"line\">                &#125;</div><div class=\"line\">                list[j+inrement] = data;//插入</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;while (inrement &gt; 1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>希尔排序和直接插入排序有异曲同工之妙，都是记录后移，都是插入排序。不过希尔用的条件是步长，步长越来越短，直到是1，而直接插入排序是直接是1，循环次数多。<br>时间复杂度是o(n的二分之三次方)，优于o（n²）。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><blockquote>\n<p>基本思想是:通过一趟排序将带排序记录分割成独立的两部分，其中一部分记录的关键字均比另外一部分的关键字小，则可分别对着两部分重新排序，以达到整个序列的有序的目的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 快速排序</div><div class=\"line\">-(void)quickSort:(NSMutableArray *)list&#123;</div><div class=\"line\">    [self qsort:list low:0 hight:list.count-1];</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)qsort:(NSMutableArray *)list low:(NSInteger)low hight:(NSInteger ) hight&#123;</div><div class=\"line\">    NSInteger pt;</div><div class=\"line\">    if (low &lt; hight) &#123;</div><div class=\"line\">        pt =[self partition:list low:low high:hight];//将整个序列一分为二</div><div class=\"line\">        [self qsort:list low:low hight:pt -1];//对低子表递归排序</div><div class=\"line\">        [self qsort:list low:pt + 1 hight:hight];//对高字表递归排序</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//返回在他前后记录均不大（小）与他。</div><div class=\"line\">-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high&#123;</div><div class=\"line\">    NSNumber * data = list[low];</div><div class=\"line\">    while (low &lt; high) &#123;</div><div class=\"line\">        while (low &lt; high &amp;&amp; list[high] &gt;= data)// 倒叙 找出比data小的 并交换位置</div><div class=\"line\">            high --;</div><div class=\"line\">            [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">        </div><div class=\"line\">        while (low &lt; high &amp;&amp; list[low] &lt;= data)//正序 找出比data大的 并交换位置</div><div class=\"line\">            low ++;</div><div class=\"line\">         [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    return low;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>时间复杂度是o（n²）空间复杂度是o（log n）。</p>\n<p>优化选择枢轴<br>三数取中发，就是取三个关键字排序，将中间的数作为枢轴，一般是取左，右，中间三个数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">  data = list[low];</div><div class=\"line\"></div><div class=\"line\">将上面的一行改成下边的：</div><div class=\"line\"></div><div class=\"line\">NSNumber * data;</div><div class=\"line\">    NSInteger m = low + (high + low)/2;</div><div class=\"line\">    if (list[low] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[low]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:low];</div><div class=\"line\">    &#125;</div><div class=\"line\">    data = list[low];</div></pre></td></tr></table></figure></p>\n<p>优化不必要的交换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//返回在他前后记录均不大（小）与他。</div><div class=\"line\">-(NSInteger)partition:(NSMutableArray *)list low:(NSInteger)low high:(NSInteger)high&#123;</div><div class=\"line\">    NSNumber * data;</div><div class=\"line\">    NSInteger m = low + (high - low)/2;</div><div class=\"line\">    if (list[low] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:low withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[high]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:high];</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (list[m] &gt; list[low]) &#123;</div><div class=\"line\">        [list exchangeObjectAtIndex:m withObjectAtIndex:low];</div><div class=\"line\">    &#125;</div><div class=\"line\">    data = list[low];//取出来适当的关键字</div><div class=\"line\">    while (low &lt; high) &#123;</div><div class=\"line\">        while (low &lt; high &amp;&amp; list[high] &gt;= data)// 倒叙 找出比data小的 并交换位置</div><div class=\"line\">            high --;</div><div class=\"line\">        list[low] = list[high];  //将 上面的交换改成直接赋值</div><div class=\"line\">        </div><div class=\"line\">        while (low &lt; high &amp;&amp; list[low] &lt;= data)//正序 找出比data大的 并交换位置</div><div class=\"line\">            low ++;</div><div class=\"line\">         list[high ] = list[low];   //将 上面的交换改成直接赋值</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    list[low] = data; //最后 将关键字 赋值给low的位置</div><div class=\"line\">    return low;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck3qqhi2200009zsktithshbb","category_id":"ck3qqhi6l000x9zskxw88u5tk","_id":"ck3qqhi8y003k9zskih7mq47o"},{"post_id":"ck3qqhi2500019zsk6vqjvvbu","category_id":"ck3qqhi6z00159zsk48run40m","_id":"ck3qqhi8z003m9zskvlf08pus"},{"post_id":"ck3qqhi2600029zskakxu7mt1","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi8z003o9zskj6lwrca2"},{"post_id":"ck3qqhi2700039zskaxhyg3je","category_id":"ck3qqhi74001d9zskurohe737","_id":"ck3qqhi90003s9zskb5hw11oa"},{"post_id":"ck3qqhi2800049zske1xnz2tl","category_id":"ck3qqhi74001d9zskurohe737","_id":"ck3qqhi90003u9zskxf2z4x5m"},{"post_id":"ck3qqhi2900059zskd6ld3p9c","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi90003y9zsk93mg1v37"},{"post_id":"ck3qqhi2900069zskc1qnesir","category_id":"ck3qqhi78001l9zsktldjcmno","_id":"ck3qqhi9100409zskgr56cfcv"},{"post_id":"ck3qqhi2a00079zskp88fb7sd","category_id":"ck3qqhi6z00159zsk48run40m","_id":"ck3qqhi9200449zskk5js4n9t"},{"post_id":"ck3qqhi2b00089zskw5rukims","category_id":"ck3qqhi74001d9zskurohe737","_id":"ck3qqhi9200469zsk4qmmcm67"},{"post_id":"ck3qqhi2b00099zsk4b44qr0g","category_id":"ck3qqhi6z00159zsk48run40m","_id":"ck3qqhi93004a9zskxk54wlv8"},{"post_id":"ck3qqhi2c000a9zsk4t1hzyxn","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi93004c9zskejr6aarh"},{"post_id":"ck3qqhi2d000b9zsko2w5ftgw","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi93004e9zsk15biczhe"},{"post_id":"ck3qqhi2e000d9zsk0h0yo8q3","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi93004h9zskfapw8j97"},{"post_id":"ck3qqhi2e000e9zsk4yf977qk","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi94004j9zsk3u44vsuj"},{"post_id":"ck3qqhi2f000f9zskdh2j61sb","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi94004m9zsk25ayf9tl"},{"post_id":"ck3qqhi2g000g9zsksrops5wt","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi94004o9zskqu88cu8s"},{"post_id":"ck3qqhi2g000h9zskdzpj6sih","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi95004r9zskm1y3q95f"},{"post_id":"ck3qqhi2h000i9zskqk03vx1p","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi95004t9zsk4dyv6c6n"},{"post_id":"ck3qqhi2i000j9zskv3miql05","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi95004w9zsk1cor4zgl"},{"post_id":"ck3qqhi2i000k9zsksug5xpm7","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi95004y9zskm2weakey"},{"post_id":"ck3qqhi2j000l9zsktshqec1g","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi9500509zsk081dmt2t"},{"post_id":"ck3qqhi2j000m9zskskxcfog6","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi9600529zskjbpwobg8"},{"post_id":"ck3qqhi2k000n9zsk1swy0kdy","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi9600549zskww6rl1g3"},{"post_id":"ck3qqhi2k000o9zsklew7nap1","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi9600569zsk6pda60wa"},{"post_id":"ck3qqhi2m000p9zskdz8jqwjl","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi9600589zskq4d0y17q"},{"post_id":"ck3qqhi2m000q9zskzddqeqqg","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi96005a9zskl3rp3rmq"},{"post_id":"ck3qqhi2n000r9zsk2ebt2nd1","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi96005c9zsktp5kbxn1"},{"post_id":"ck3qqhi2o000s9zsk0fc2m3mm","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi96005e9zskoybl06p5"},{"post_id":"ck3qqhi2o000t9zskyhgga9er","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005g9zskahjfpla0"},{"post_id":"ck3qqhi2p000u9zskxi0ki3jo","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005i9zskabskbz6n"},{"post_id":"ck3qqhi2p000v9zskdgy24emp","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005k9zsk906d66c3"},{"post_id":"ck3qqhi2q000w9zsk62t4hcpn","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005m9zsk6vas7ema"},{"post_id":"ck3qqhi6w00109zskumbbvg27","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005o9zskmd35kr8c"},{"post_id":"ck3qqhi6y00129zskrq93b2mf","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005q9zskdcs2n15f"},{"post_id":"ck3qqhi6z00149zskixomncuj","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi97005s9zsksgaqwsp1"},{"post_id":"ck3qqhi7100189zskk45a7xg1","category_id":"ck3qqhi7100199zskhah5wkny","_id":"ck3qqhi98005u9zsktwwdmy64"},{"post_id":"ck3qqhi7000179zsk9p3wvklw","category_id":"ck3qqhi8y003i9zsksrhr84ks","_id":"ck3qqhiad006g9zsk3goxpchc"},{"post_id":"ck3qqhi72001b9zskmkd24elg","category_id":"ck3qqhi8y003i9zsksrhr84ks","_id":"ck3qqhiad006i9zsk1dgqu60d"},{"post_id":"ck3qqhi73001c9zskn196hy2n","category_id":"ck3qqhi90003v9zsk82msfha9","_id":"ck3qqhiad006k9zsk8sy3oqa6"},{"post_id":"ck3qqhi74001f9zskh6z8udfi","category_id":"ck3qqhi90003v9zsk82msfha9","_id":"ck3qqhiae006m9zskitohswkv"},{"post_id":"ck3qqhi75001g9zskrj7k03jj","category_id":"ck3qqhi8y003i9zsksrhr84ks","_id":"ck3qqhiae006o9zskyv8dhast"}],"PostTag":[{"post_id":"ck3qqhi2200009zsktithshbb","tag_id":"ck3qqhi6v000y9zsknsxh1a91","_id":"ck3qqhi8x003h9zskn1azpaz4"},{"post_id":"ck3qqhi2500019zsk6vqjvvbu","tag_id":"ck3qqhi7000169zsk8auut9wo","_id":"ck3qqhi8y003l9zsk5lop684r"},{"post_id":"ck3qqhi2500019zsk6vqjvvbu","tag_id":"ck3qqhi72001a9zskn76aprzv","_id":"ck3qqhi8z003n9zskvcljxfo5"},{"post_id":"ck3qqhi2600029zskakxu7mt1","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi8z003r9zskocpsswn8"},{"post_id":"ck3qqhi2700039zskaxhyg3je","tag_id":"ck3qqhi76001i9zsk4cpjfw3g","_id":"ck3qqhi90003t9zsk8eh3bghl"},{"post_id":"ck3qqhi2700039zskaxhyg3je","tag_id":"ck3qqhi78001k9zsk4g8w8bsk","_id":"ck3qqhi90003x9zsksgpu3iw2"},{"post_id":"ck3qqhi2800049zske1xnz2tl","tag_id":"ck3qqhi76001i9zsk4cpjfw3g","_id":"ck3qqhi91003z9zskruueltuz"},{"post_id":"ck3qqhi2800049zske1xnz2tl","tag_id":"ck3qqhi78001k9zsk4g8w8bsk","_id":"ck3qqhi9200439zskfd7a5fsq"},{"post_id":"ck3qqhi2900059zskd6ld3p9c","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9200459zskjs554gk8"},{"post_id":"ck3qqhi2900069zskc1qnesir","tag_id":"ck3qqhi78001k9zsk4g8w8bsk","_id":"ck3qqhi9200489zsk5ztbyfzi"},{"post_id":"ck3qqhi2900069zskc1qnesir","tag_id":"ck3qqhi7h001u9zskhg5c8q5s","_id":"ck3qqhi93004b9zskpzfa34is"},{"post_id":"ck3qqhi2a00079zskp88fb7sd","tag_id":"ck3qqhi7000169zsk8auut9wo","_id":"ck3qqhi93004d9zska3hvhryk"},{"post_id":"ck3qqhi2a00079zskp88fb7sd","tag_id":"ck3qqhi72001a9zskn76aprzv","_id":"ck3qqhi93004g9zskeqn18xd2"},{"post_id":"ck3qqhi2b00089zskw5rukims","tag_id":"ck3qqhi78001k9zsk4g8w8bsk","_id":"ck3qqhi93004i9zskcvqepkhb"},{"post_id":"ck3qqhi2b00089zskw5rukims","tag_id":"ck3qqhi7l00229zskuktvfejy","_id":"ck3qqhi94004l9zskybubqxn5"},{"post_id":"ck3qqhi2b00089zskw5rukims","tag_id":"ck3qqhi7000169zsk8auut9wo","_id":"ck3qqhi94004n9zskbgr9h0su"},{"post_id":"ck3qqhi2b00099zsk4b44qr0g","tag_id":"ck3qqhi7000169zsk8auut9wo","_id":"ck3qqhi94004q9zskoa5luqvb"},{"post_id":"ck3qqhi2c000a9zsk4t1hzyxn","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi95004s9zskbqhvdj10"},{"post_id":"ck3qqhi2d000b9zsko2w5ftgw","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi95004v9zskhac60l1b"},{"post_id":"ck3qqhi2d000b9zsko2w5ftgw","tag_id":"ck3qqhi7p002c9zskb8mmmu26","_id":"ck3qqhi95004x9zskhc6dfipf"},{"post_id":"ck3qqhi2d000c9zskjllvdgx8","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi95004z9zskq6ux9jkx"},{"post_id":"ck3qqhi2e000d9zsk0h0yo8q3","tag_id":"ck3qqhi7r002g9zskud4gja9g","_id":"ck3qqhi9600519zsks2ratted"},{"post_id":"ck3qqhi2e000e9zsk4yf977qk","tag_id":"ck3qqhi7s002i9zsk0kryoiyb","_id":"ck3qqhi9600539zskyqkp7ioq"},{"post_id":"ck3qqhi2e000e9zsk4yf977qk","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9600559zsk8ilq9jux"},{"post_id":"ck3qqhi2f000f9zskdh2j61sb","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9600579zsk8avzs3rn"},{"post_id":"ck3qqhi2g000g9zsksrops5wt","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9600599zskf2e3fqff"},{"post_id":"ck3qqhi2g000h9zskdzpj6sih","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi96005b9zskz7jamx1t"},{"post_id":"ck3qqhi2h000i9zskqk03vx1p","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi96005d9zskwt0f49av"},{"post_id":"ck3qqhi2i000j9zskv3miql05","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005f9zskgvnszmuj"},{"post_id":"ck3qqhi2i000k9zsksug5xpm7","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005h9zsk3aux1pyk"},{"post_id":"ck3qqhi2j000l9zsktshqec1g","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005j9zsktghdgn2x"},{"post_id":"ck3qqhi2j000m9zskskxcfog6","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005l9zsk79qx89hb"},{"post_id":"ck3qqhi2k000n9zsk1swy0kdy","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005n9zsktj0qzgep"},{"post_id":"ck3qqhi2k000o9zsklew7nap1","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005p9zsktdnonuiz"},{"post_id":"ck3qqhi2m000p9zskdz8jqwjl","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi97005r9zskq48sjvf3"},{"post_id":"ck3qqhi2m000p9zskdz8jqwjl","tag_id":"ck3qqhi8300349zskxf2uesqd","_id":"ck3qqhi98005t9zsk1ybp9jst"},{"post_id":"ck3qqhi2m000q9zskzddqeqqg","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi98005v9zsko6pd9s3m"},{"post_id":"ck3qqhi2n000r9zsk2ebt2nd1","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi98005w9zsknqe45oww"},{"post_id":"ck3qqhi2o000s9zsk0fc2m3mm","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi98005x9zskxytpi5od"},{"post_id":"ck3qqhi2o000t9zskyhgga9er","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi98005y9zsk0v0pgsjp"},{"post_id":"ck3qqhi2o000t9zskyhgga9er","tag_id":"ck3qqhi8300349zskxf2uesqd","_id":"ck3qqhi98005z9zskfa5bmkms"},{"post_id":"ck3qqhi2p000u9zskxi0ki3jo","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9800609zsk1f72a4j5"},{"post_id":"ck3qqhi2p000u9zskxi0ki3jo","tag_id":"ck3qqhi8300349zskxf2uesqd","_id":"ck3qqhi9800619zsko7d3gaqd"},{"post_id":"ck3qqhi2p000v9zskdgy24emp","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9800629zskmy441ari"},{"post_id":"ck3qqhi2p000v9zskdgy24emp","tag_id":"ck3qqhi87003d9zskutztos8f","_id":"ck3qqhi9800639zskgn0rmh1d"},{"post_id":"ck3qqhi2p000v9zskdgy24emp","tag_id":"ck3qqhi87003e9zsk5jzpjese","_id":"ck3qqhi9800649zskymsmj8v2"},{"post_id":"ck3qqhi2q000w9zsk62t4hcpn","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9900659zskjuiv3v4c"},{"post_id":"ck3qqhi2q000w9zsk62t4hcpn","tag_id":"ck3qqhi88003g9zskd928eyi8","_id":"ck3qqhi9900669zskwx84st4o"},{"post_id":"ck3qqhi6w00109zskumbbvg27","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9900679zskhj7up03j"},{"post_id":"ck3qqhi6w00109zskumbbvg27","tag_id":"ck3qqhi7r002g9zskud4gja9g","_id":"ck3qqhi9900689zsk7uldiisy"},{"post_id":"ck3qqhi6y00129zskrq93b2mf","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9900699zskvk18eiwu"},{"post_id":"ck3qqhi6y00129zskrq93b2mf","tag_id":"ck3qqhi7r002g9zskud4gja9g","_id":"ck3qqhi99006a9zskkccz4sqw"},{"post_id":"ck3qqhi6z00149zskixomncuj","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi99006b9zsksr03g3nc"},{"post_id":"ck3qqhi6z00149zskixomncuj","tag_id":"ck3qqhi7r002g9zskud4gja9g","_id":"ck3qqhi99006c9zskedubttbs"},{"post_id":"ck3qqhi7100189zskk45a7xg1","tag_id":"ck3qqhi74001e9zsk8p0bzxpl","_id":"ck3qqhi9a006d9zskxe27jglz"},{"post_id":"ck3qqhi7100189zskk45a7xg1","tag_id":"ck3qqhi7r002g9zskud4gja9g","_id":"ck3qqhi9a006e9zskjx00fr63"},{"post_id":"ck3qqhi7000179zsk9p3wvklw","tag_id":"ck3qqhi8y003j9zskxba1a8oa","_id":"ck3qqhiad006f9zsks27kv2it"},{"post_id":"ck3qqhi7000179zsk9p3wvklw","tag_id":"ck3qqhi8z003q9zskpkdv8rw0","_id":"ck3qqhiad006h9zsky1eut26l"},{"post_id":"ck3qqhi7000179zsk9p3wvklw","tag_id":"ck3qqhi90003w9zskbx97pbpg","_id":"ck3qqhiad006j9zsk5lkl7bzc"},{"post_id":"ck3qqhi72001b9zskmkd24elg","tag_id":"ck3qqhi9100429zskgpglmpfw","_id":"ck3qqhiae006l9zskxsfuje91"},{"post_id":"ck3qqhi72001b9zskmkd24elg","tag_id":"ck3qqhi9200499zskcb4oau8z","_id":"ck3qqhiae006n9zskwujpoivk"},{"post_id":"ck3qqhi73001c9zskn196hy2n","tag_id":"ck3qqhi93004f9zski8vv0837","_id":"ck3qqhiae006p9zskm5c49ihf"},{"post_id":"ck3qqhi74001f9zskh6z8udfi","tag_id":"ck3qqhi93004f9zski8vv0837","_id":"ck3qqhiae006q9zsku3ddapd7"},{"post_id":"ck3qqhi75001g9zskrj7k03jj","tag_id":"ck3qqhi94004p9zskyu6bla7w","_id":"ck3qqhiae006r9zsknt5oxlt2"},{"post_id":"ck3qqhi75001g9zskrj7k03jj","tag_id":"ck3qqhi9100429zskgpglmpfw","_id":"ck3qqhiae006s9zskktd157bw"}],"Tag":[{"name":"Git","_id":"ck3qqhi6v000y9zsknsxh1a91"},{"name":"建站","_id":"ck3qqhi7000169zsk8auut9wo"},{"name":"hexo","_id":"ck3qqhi72001a9zskn76aprzv"},{"name":"iOS","_id":"ck3qqhi74001e9zsk8p0bzxpl"},{"name":"Flask","_id":"ck3qqhi76001i9zsk4cpjfw3g"},{"name":"Python3","_id":"ck3qqhi78001k9zsk4g8w8bsk"},{"name":"PyQt5","_id":"ck3qqhi7h001u9zskhg5c8q5s"},{"name":"开发","_id":"ck3qqhi7l00229zskuktvfejy"},{"name":"自动打包","_id":"ck3qqhi7p002c9zskb8mmmu26"},{"name":"iOS高级开发","_id":"ck3qqhi7r002g9zskud4gja9g"},{"name":"指针","_id":"ck3qqhi7s002i9zsk0kryoiyb"},{"name":"iOS高级","_id":"ck3qqhi8300349zskxf2uesqd"},{"name":"Shell","_id":"ck3qqhi87003d9zskutztos8f"},{"name":"iOS自动化打包","_id":"ck3qqhi87003e9zsk5jzpjese"},{"name":"疑难杂症","_id":"ck3qqhi88003g9zskd928eyi8"},{"name":"PHP环境配置","_id":"ck3qqhi8y003j9zskxba1a8oa"},{"name":"YII","_id":"ck3qqhi8z003q9zskpkdv8rw0"},{"name":"MongoDB","_id":"ck3qqhi90003w9zskbx97pbpg"},{"name":"数据结构","_id":"ck3qqhi9100429zskgpglmpfw"},{"name":"二叉树","_id":"ck3qqhi9200499zskcb4oau8z"},{"name":"微信小程序","_id":"ck3qqhi93004f9zski8vv0837"},{"name":"排序","_id":"ck3qqhi94004p9zskyu6bla7w"}]}}